<?php
/**
 * @file
 * Book navigation defaults and overrides.
 */

/**
 * Implements hook_page_build().
 */
function mooc_helper_book_nav_page_build(&$page) {
  // add jwerty navigation via keyboard
  if ($node = menu_get_object('node')) {
    if (arg(2) == NULL && !empty($node->book)) {
      drupal_add_js(drupal_get_path('module', 'mooc_helper_book_nav') . '/js/mooc_helper_book_nav.js');
    }
  }
}

/**
 * Implements hook_node_view().
 */
function mooc_helper_book_nav_node_view($node, $view_mode, $langcode) {
  // ensure this only happens for node's viewed in books
  if (arg(0) == 'node' && $view_mode == 'full' && isset($node->book) && isset($node->body) && empty($node->body['und'][0]['value'])) {
    $next = book_next($node->book);
    // ensure we have a next item and it's in this one
    if ($next && $node->book['mlid'] == $next['plid']) {
      if (entity_access('update', 'node', $node)) {
        drupal_set_message(t('This page is empty, so students will automatically be taken to the next page. You have not been since you can edit this content.'), 'status', FALSE);
      }
      else {
        drupal_goto($next['link_path']);
      }
    }
  }
}

/**
 * Implements hook_menu_link_insert().
 */
function mooc_helper_book_nav_menu_link_insert($link) {
  // make sure this is a book or in a book
  if (!empty($link['bid'])) {
    _mooc_helper_book_nav_cache_clear('nav:' . $link['bid'], TRUE);
  }
}

/**
 * Implements hook_menu_link_update().
 */
function mooc_helper_book_nav_menu_link_update($link) {
  // make sure this is a book or in a book
  if (!empty($link['bid'])) {
    _mooc_helper_book_nav_cache_clear('nav:' . $link['bid'], TRUE);
  }
}

/**
 * Implements hook_menu_link_delete().
 */
function mooc_helper_book_nav_menu_link_delete($link) {
  // make sure this is a book or in a book
  if (!empty($link['bid'])) {
    _mooc_helper_book_nav_cache_clear('nav:' . $link['bid'], TRUE);
  }
}

/**
 * Implements hook_block_info().
 */
function mooc_helper_book_nav_block_info() {
  // provide block for rendering siblings in a line of the current page
  $blocks['book_sibling_nav'] = array(
    'info' => t('Book breadcrumb navigation'),
    'cache' => DRUPAL_CACHE_PER_USER,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function mooc_helper_book_nav_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    // build out the top navigational element with all the drop downs
    case 'book_sibling_nav':
      $block['subject'] = '';
      $block['content'] = '<a href="#block-mooc-helper-mooc-helper-toc-nav-modal" class="mooc-helper-toc elmsln-outline-button elmsln-modal-trigger black-text waves-effect cis-lmsless-waves" aria-controls="toc-drop" aria-expanded="false" title="Table of Contents" data-jwerty-key="o" data-voicecommand="open outline">
          <i class="material-icons">explore</i>' . t('Outline') .'</a>';
      $next_title = t('>');
      $prev_title = t('<');
      // load the node in scope globally at the moment and ensure we have one
      $globalnode = menu_get_object();
      $active_book = _mooc_helper_active_outline();
      // ensure we are in the active outline before bothering to render anything
      if ($globalnode && !empty($globalnode->book) && $globalnode->book['plid'] != 0 && $globalnode->book['bid'] == $active_book->nid) {
        $breadcrumbs = array();
        $count = 0;
        $nav_count = 0;
        // loop through and generate a per level listing of all items
        $children = array();
        $parents = array();
        // get the parent of the current page
        $tmp = $globalnode->book;
        // lob off the authenticated role and mash user roles into string
        $tmproles = $GLOBALS['user']->roles;
        $rolecid = '';
        unset($tmproles[2]);
        if (!empty($tmproles)) {
          $rolecid = ':' . implode('-', array_keys($tmproles));
        }
        // edge case; user 1 doesn't have admin role
        // just to be safe let's account for this
        elseif ($GLOBALS['user']->uid == 1) {
          $rolecid = ':30037204';
        }
        if ($tmp['has_children'] && $globalnode->type != 'mooc_container') {
          // form cache bin id as these have to be per mlid and then per role combo
          // to make sure we account for publish / unpublish, hidden nodes, etc
          $cid = 'nav:' . $globalnode->book['bid'] . ':' . $globalnode->book['mlid'] . ':top-level' . $rolecid;
          // if this has children, load 1 so we have that data for below
          $data = &drupal_static(__FUNCTION__ . $cid);
          // check static cache
          if ($data) {
            $tmp2 = $data['tmp2'];
            $parents = $data['parents'];
            $children = $data['children'];
          }
          // @ignore druplart_conditional_assignment
          elseif (!$data && $cache = cache_get($cid, 'cache_mooc_helper_book_nav')) {
            $data = $cache->data;
            $tmp2 = $data['tmp2'];
            $parents = $data['parents'];
            $children = $data['children'];
          }
          else {
            $tmp2 = array();
            // load all items that share the same parent as the current item
            $results = db_select('menu_links', 'ml')
              ->fields('ml')
              ->condition('plid', $tmp['mlid'], '=')
              ->orderBy('weight', 'ASC')
              ->execute()
              ->fetchAll();
            // associate the items that are siblings of the same parent
            $nids = array();
            $tmpary = array();
            foreach ($results as $item) {
              $tmpary[$item->mlid] = (array)$item;
              $nids[str_replace('node/', '', $item->link_path)] = $item->mlid;
            }
            // ensure we have nids, there is a possibility of corruption in
            // the menu_links table where an item that once had children no longer does
            // but that isn't reflected in the items as updated. It's rare but possible
            if (!empty($nids)) {
              // node access check
              $select = db_select('node', 'n');
              $select->addField('n', 'nid');
              $select->condition('n.status', 1);
              $select->condition('n.nid', array_keys($nids), 'IN');
              $select->addTag('node_access');
              $nidslist = $select->execute()->fetchCol();
              // compare against what we are ALLOWED to show so order is maintained
              foreach ($nids as $nid => $mid) {
                // this suggests an item was removed bc of access rights
                // the pulled list doesn't have an item from the original
                if (!in_array($nid, $nidslist)) {
                  unset($tmpary[$nids[$nid]]);
                }
              }
              $children[-1] = $tmpary;
              foreach ($nidslist as $nid) {
                $children[-1][$nids[$nid]] = $tmpary[$nids[$nid]];
              }
              $tmp2 = $tmp;
              $bid = explode('-', $tmp2['menu_name']);
              $tmp2['bid'] = $bid[2];
              $tmp2['mlid'] = -1;
              $tmp2['link_path'] = '';
              $tmp2['link_title'] = t('...');
              $tmp2['_class'] = 'book-parent-tree';
              $parents[-1] = $tmp2;
            }
            // store these so we can get here faster in the future
            $data = array(
              'tmp2' => $tmp2,
              'parents' => $parents,
              'children' => $children,
            );
            cache_set($cid, $data, 'cache_mooc_helper_book_nav');
          }
        }
        // keep tapping parents up the tree til we hit the end
        while ($tmp['plid'] != 0) {
          // check cached result at each level
          $cid = 'nav:' . $tmp['bid'] . ':' . $tmp['mlid'] . $rolecid;
          $cache = cache_get($cid, 'cache_mooc_helper_book_nav');
          if ($cache) {
            $data = $cache->data;
            $nids = $data['nids'];
            $nidslist = $data['nidslist'];
            $tmpary = $data['tmpary'];
          }
          else {
            // load all items that share the same parent as the current item
            $results = db_select('menu_links', 'ml')
              ->fields('ml')
              ->condition('plid', $tmp['plid'], '=')
              ->orderBy('weight', 'ASC')
              ->execute()
              ->fetchAll();
            // associate the items that are siblings of the same parent
            $nids = array();
            $tmpary = array();
            foreach ($results as $item) {
              $tmpary[$item->mlid] = (array)$item;
              $nids[str_replace('node/', '', $item->link_path)] = $item->mlid;
            }
            // node access check
            $select = db_select('node', 'n');
            $select->addField('n', 'nid');
            $select->condition('n.status', 1);
            $select->condition('n.nid', array_keys($nids), 'IN');
            $select->addTag('node_access');
            $nidslist = $select->execute()->fetchCol();
            // compare against what we are ALLOWED to show so order is maintained
            foreach ($nids as $nid => $mid) {
              // this suggests an item was removed bc of access rights
              // the pulled list doesn't have an item from the original
              if (!in_array($nid, $nidslist)) {
                unset($tmpary[$nids[$nid]]);
              }
            }
            $data = array(
              'nids' => $nids,
              'nidslist' => $nidslist,
              'tmpary' => $tmpary,
            );
            cache_set($cid, $data, 'cache_mooc_helper_book_nav');
          }
          $children[$tmp['plid']]  = $tmpary;
          foreach ($nidslist as $nid) {
            $children[$tmp['plid']][$nids[$nid]] = $tmpary[$nids[$nid]];
          }
          // load the parent of the current item
          $cache = _book_cache_get_associations($tmp);
          // set next / prev relative to the globalnode
          if (!isset($next_url)) {
            $next_url = url($cache['next']['link_path']);
            $prev_url = url($cache['prev']['link_path']);
          }
          $parents[$tmp['plid']] = $tmp;
          $tmp = $cache['parent'];
        }
        // ensure we have results to style
        if (!empty($children)) {
          $firstlevel = TRUE;
          $icons = TRUE;
          // loop through the menu items associated to each menu parent
          foreach($children as $mlid => $menu_items) {
            $items = array();
            // loop through each menu item and build the menu item out
            foreach ($menu_items as $menu_item) {
              // default is a page icon
              $icon = NULL;
              // allow for modification of the book item icon to match mooc / FA
              $ml = $menu_item;
              // support for token replacement
              if (module_exists('token')) {
                $ml['link_path'] = token_replace($ml['link_path']);
              }
              // only perform icon look up for lowest level
              if ($firstlevel && $ml['has_children']) {
                $icons = FALSE;
              }
              // see if current item is the parent item, set to same compiled result if it is
              if (isset($parents[$menu_item['plid']]) && $parents[$menu_item['plid']]['mlid'] == $menu_item['mlid']) {
                $parents[$menu_item['plid']] = $ml;
                $parents[$menu_item['plid']]['_class'] = 'book-parent-tree';
                // see if the active global is this parent item
                if ($menu_item['mlid'] == $globalnode->book['mlid']) {
                  $parents[$menu_item['plid']]['_class'] .= ' active-trail';
                }
              }
              // send compiled menu link off to theme engine for rendering
              $items[] = $ml;
            }
            // need to dump icons because something had children at this level
            if ($firstlevel && $icons) {
              foreach ($items as &$item) {
                $icon = 'page';
                // support for foundation access icon
                if (isset($item['options'])) {
                  $tmp = unserialize($item['options']);
                  if (isset($tmp['fa_icon'])) {
                    $icon = $tmp['fa_icon'];
                  }
                }
                $count++;
                $item['_count'] = $count;
                $item['_icon'] = $icon;
                if (isset($parents[$item['plid']]) && $parents[$item['plid']]['mlid'] == $item['mlid']) {
                  $parents[$item['plid']] = $item;
                  $parents[$item['plid']]['_class'] = 'book-parent-tree';
                  // see if the active global is this parent item
                  if ($item['mlid'] == $globalnode->book['mlid']) {
                    $parents[$item['plid']]['_class'] .= ' active-trail';
                  }
                }
              }
            }
            $nav_count++;
            $firstlevel = FALSE;
            $breadcrumbs[] = theme('book_sibling_nav', array('parent' => $parents[$mlid] ,'items' => $items, 'count' => $nav_count));
          }
          $breadcrumbs = array_reverse($breadcrumbs);
          // support for mooc_containers
          if ($globalnode->type == 'mooc_container' && isset($globalnode->field_mooc_container_type['und'][0]['value'])) {
            if ($globalnode->field_mooc_container_type['und'][0]['value'] == 'index') {
              $next_title = '';
              $next_url = '';
              $prev_title = '';
              $prev_url = '';
            }
          }
          $vars = array(
            'breadcrumbs' => $breadcrumbs,
            'next_url' => $next_url,
            'next_title' => $next_title,
            'prev_url' => $prev_url,
            'prev_title' => $prev_title,
            'count' => $nav_count,
          );
          // output contents by passing through the wrapper theme function
          $block['content'] = theme('book_sibling_nav_wrapper', $vars);
        }
      }
    break;
  }
  return $block;
}

/**
 * Implements hook_preprocess_HOOK().
 */
function mooc_helper_book_nav_preprocess_book_sibling_nav_wrapper(&$variables) {
}

/**
 * Implements hook_theme().
 */
function mooc_helper_book_nav_theme() {
  return array(
    'book_sibling_nav' => array(
      'variables' => array(
        'parent' => array(),
        'items' => array(),
        'count' => 1,
      ),
      'render element' => 'element',
      'template' => 'templates/book-sibling-nav',
    ),
    'book_sibling_nav_wrapper' => array(
      'variables' => array(
        'breadcrumbs' => array(),
        'next_url' => NULL,
        'next_title' => t('Next'),
        'prev_url' => NULL,
        'prev_title' => t('Previous'),
        'count' => 1,
      ),
      'render element' => 'element',
      'template' => 'templates/book-sibling-nav-wrapper',
    ),
  );
}

/**
 * Implements hook_fa_a11y().
 * Provides keyboard shortcut buttons
 */
function mooc_helper_book_nav_fa_a11y_alter(&$a11y) {
  if ($node = menu_get_object('node')) {
    if (arg(2) == NULL && !empty($node->book)) {
    $a11y['keyboard']['keys']['#markup'] .=
      '<div class="keyboard-short">
        <div class="keyboard-short__group">
          <span>' . t('Previous page') . '</span>
          <div class="keyboard-short__key">←</div>
          <div class="keyboard-short__key">←</div>
        </div>
        <div class="keyboard-short__group">
          <span>' . t('Next page') . '</span>
          <div class="keyboard-short__key">→</div>
          <div class="keyboard-short__key">→</div>
        </div>
        <div class="keyboard-short__group">
          <span>' . t('Open content outline') . '</span>
          <div class="keyboard-short__key">Alt</div>
          <div class="keyboard-short__key">Shift</div>
          <div class="keyboard-short__key">o</div>
        </div>
      </div>';
    }
  }
}

/**
 * Invalidates cached data relating to cache_mooc_helper_book_nav.
 *
 * @param $cid
 *   (optional) Cache ID of the record to clear from the private update module
 *   cache. If empty, all records will be cleared from the table except fetch
 *   tasks. Defaults to NULL.
 * @param $wildcard
 *   (optional) If TRUE, cache IDs starting with $cid are deleted in addition to
 *   the exact cache ID specified by $cid. Defaults to FALSE.
 */
function _mooc_helper_book_nav_cache_clear($cid = NULL, $wildcard = FALSE) {
  if (empty($cid)) {
    cache_clear_all('*', 'cache_mooc_helper_book_nav', TRUE);
  }
  else {
    cache_clear_all($cid, 'cache_mooc_helper_book_nav', $wildcard);
  }
}

/**
 * Implements hook_flush_caches().
 */
function mooc_helper_book_nav_flush_caches() {
  _mooc_helper_book_nav_cache_clear();
  return array();
}

/**
 * Implements hook_admin_menu_cache_info().
 */
function mooc_helper_book_nav_admin_menu_cache_info() {
  $caches['cache_mooc_helper_book_nav'] = array(
    'title' => t('MOOC book nav data'),
    'callback' => '_mooc_helper_book_nav_cache_clear',
  );
  return $caches;
}

