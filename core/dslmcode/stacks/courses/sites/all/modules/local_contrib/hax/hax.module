<?php
/**
 * @file
 * Headless Authoring eXperience, all we do is accept calls and make things haxable in the first place.
 */

/**
 * Implements hook_permission().
 */
function hax_permission() {
  return array(
    'use hax' =>  array(
      'title' => t('Use HAX editor'),
      'description' => t('Advanced authoring experience that is pulled in from hax capable web components.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function hax_menu() {
  // hax-endpoint/update/node/123-123-4342-11cd/1333f-ffdd223f-sfad-adsdsdd
  // callback path, operation, entity type, uuid, session token
  $items['hax-endpoint/%/%/%/%'] = array(
    'title' => 'HAX API callback',
    'description' => 'HAX API endpoint',
    'page callback' => '_hax_endpoint',
    'page arguments' => array(1, 2, 3, 4),
    'type' => MENU_CALLBACK,
    'access callback' => '_hax_endpoint_access',
    'access arguments' => array(1, 2, 3, 4),
  );
  return $items;
}

/**
 * Access callback to ensure hax can be used on this node
 */
function _hax_endpoint_access($op, $etype, $uuid, $token) {
  // most basic of checks for permission vars set and session token hash
  if (user_access('use hax') && !empty($op) && !empty($etype) && !empty($uuid) && !empty($token) && drupal_valid_token($token, 'hax')) {
    // try and load the entity by uuid, simplifies implementations
    $entities = entity_uuid_load($etype, array($uuid));
    // pop one off if we got anything, otherwise let this fail
    if (is_array($entities) && !empty($entities)) {
      $entity = array_pop($entities);
      // ensure they have access to perform this operation on this entity in general
      if (entity_access($op, $etype, $entity)) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Callback to perform the operation on the entity as per update
 * @return [type] [description]
 */
function _hax_endpoint($op, $etype, $uuid, $token) {
  $vars = array('status' => 100);
  $entity = new stdClass();
  $entity = array_pop($entities);
  // silly check, ensure this has a concept of keys
  if (isset($info['bundle keys']['bundle'])) {
    switch ($op) {
      // update the only real one for now
      case 'update':
        $properties = _hax_sanitize($_GET['properties']);
        // ensure we know about this display mode
        if ($webcomponent = webcomponent_load_by_name($properties['tagName'])) {
          // dump this now that it's a full object
          unset($properties['tagName']);
          // starting to look like we might be able to do soemthing with all this..
          $vars['status'] = 200;
          // try and load the entity by uuid, simplifies implementations
          $entities = entity_uuid_load($etype, array($uuid));
          // pop one off if we got anything, otherwise let this fail
          if (is_array($entities) && !empty($entities)) {
            $info = entity_get_info($etype);
            field_attach_prepare_view($etype, array($entity->nid => $entity), $webcomponent->machine_name);
            entity_prepare_view($etype, array($entity->nid => $entity));
            $field_map += field_attach_view($etype, $entity, $webcomponent->machine_name);
          }
          // now we run through the properties and do our map back
          foreach ($properties as $key => $value) {
            if (isset($webcomponent->properties[$key])) {

            }
          }
        }
      break;
      // nothing to support this yet
      case 'insert':
      break;
    }
  }
  drupal_add_http_header('Content-Type', 'application/json');
  // define status
  drupal_add_http_header('Status', $vars['status']);
  // output the response as json
  print drupal_json_output($vars);
}

/**
 * Ensure this is a simple array and nothing evil is there.
 * @param  array $properties array of values from the front end
 * @return array             cleaned out value set
 */
function _hax_sanitize($properties) {
  // filter out potentially nasty things coming back in house
  foreach ($properties as $key => $value) {
    // ensure this pass back is as simple as possible
    if (!is_array($value)) {
      $properties[filter_xss($key)] = filter_xss($value);
    }
    else {
      unset($properties[$value]);
    }
  }
  return $properties;
}

/**
 * Implements hook_hax_webcomponent_render_alter().
 * Make sure we wrap on the haxable property and ajax submitter
 */
function hax_webcomponent_render_alter($vars, $webcomponent) {
  $vars['wrap_tag'] = '<hax-ajax can-hax >'
  $vars['wrap_tag_close'] = '</hax-ajax>'
}
