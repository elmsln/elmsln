<?php

/**
 * Define some constants
 */
defined('AUDIO_RENDERING_PENDING')
or define('AUDIO_RENDERING_PENDING', 1);
defined('AUDIO_RENDERING_ACTIVE')
or define('AUDIO_RENDERING_ACTIVE', 5);
defined('AUDIO_RENDERING_COMPLETE')
or define('AUDIO_RENDERING_COMPLETE', 10);
defined('AUDIO_RENDERING_FAILED')
or define('AUDIO_RENDERING_FAILED', 20);

/**
 *Implementation of hook_menu()
 */
function audioconverter_menu() {
  $items['admin/config/media/audio-converter'] = array(
    'title' => 'Audio Converter',
    'description' => 'Configure Audio Converter.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('audioconverter_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implementation of hook_entity_presave()
 */
function audioconverter_entity_presave($entity, $type) {
  if ($type != 'file') {
    _audioconverter_process_entity($entity, $type);
  }
}

function _audioconverter_process_entity($entity, $type) {
  $finfo = _field_info_collate_fields();
  if ($type == 'node') {
    $ntype = $entity->type;
    $fields = $finfo['instances']['node'][$ntype];
  }
  elseif ($type == 'user') {
    $fields = $finfo['instances']['user']['user'];
  }
  elseif ($type == 'comment') {
    $ntype = $entity->node_type;
    $fields = $finfo['instances']['comment'][$ntype];
  }
  else {
    //Todo: need to check about other entity type structures
    $fields = $finfo['instances'][$type];
  }
  if (is_array($fields)) {
    foreach ($fields as $field) {
      //Filter only allowed audio fields
      if (isset($field['widget']) && in_array($field['widget']['module'], audioconverter_allowed_fields())) {
        $fname = $field['field_name'];
        //Only convert if conversion is enabled for all fields or for this field.
        $field_settings = variable_get('audioconverter_' . $fname, 0);
        $global_settings = variable_get('audioconverter_all', 0);
        if ($global_settings || $field_settings) {
          //Use field_get_items as part of the field localisation
          $values = field_get_items($type, $entity, $fname);
          if($values) {
            foreach ($values as $field_data) {
              //Check if field is empty
              if (empty($field_data['fid'])) {
                continue;
              }
              //Check if this file is already in queue
              $exist = _audioconverter_file_in_queue($field_data['fid']);
              if ($exist) {
                continue;
              }
              $rfile = file_load($field_data['fid']);

              $info = pathinfo($rfile->uri);
              $op = $info['extension'];

              if ($op == 'mp3') {
                continue;
              }
              #Else:
              audioconverter_save_file($field_data['fid']);
              if (variable_get('audioconverter_on_save', 0)) {
                //Convert now
                $job = _audio_render_load_job($field_data['fid']);
                _audioconverter_scheduler_start($job);
                drupal_set_message(t('Audio converted to mp3.'));
                // support entitycache if tables exist
                if (module_exists('entitycache') && $type == 'node') {
                  if (isset($entity->nid)){
                    cache_clear_all($entity->nid, 'cache_entity_node');
                  }
                }
              }
              else {
                drupal_set_message(t('Audio submission queued for processing. Please wait: our servers are preparing your audio for web displaying.'));
              }
            }
          }
        }
      }
    }
  }
}

/**
 * Implementation of hook_form_[form_id]_alter().
 * Add per field settings.
 */
//TODO: We need per field settings, not per node settings
/*function audioconverter_form_alter(&$form, &$form_state , $form_id) {
  if (!empty($form['type']['#value'])) {
    $finfo = _field_info_collate_fields();
    $fields =  $finfo['instances']['node'][$form['type']['#value']];
    foreach ($fields as $field) {
    if (in_array($field['widget']['module'], audioconverter_allowed_fields())) {
      $field_name = $form['nid']['#value'];
      $form['audioconverter'] = array(
        '#type' => 'fieldset',
        '#title' => t('Audio Converter Settings'),
        '#collapsible' => TRUE,
        '#collapsed' => FALSE
      );

      $form['audioconverter']['autoconversion'] = array(
        '#type' => 'checkbox',
        '#title' => t('Enable automatic audio conversion.'),
        '#description' => t('Automatically convert existing audio fields to mp3. Please make sure the Audio Converter settings are properly configured.'),
        '#default_value' => variable_get('audioconverter_' . $field_name, 0),
      );
      $form['submit']['#weight']=10;
      $form['#submit'][]='audioconverter_form_field_submit';
      }
    }
}
}*/

/* Save per field settings */
//TODO: We need per field settings, not per node settings
/*function audioconverter_form_field_submit(&$form, &$form_state) {
  $field_name =  $form['nid']['#value'] ;
  variable_set('audioconverter_' . $field_name, $form_state['values']['autoconversion']);
}*/

/**
 * Implementation of hook_form_[form_id]_alter().
 * Add per field settings.
 */
function audioconverter_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  if (in_array($form['#instance']['widget']['module'], audioconverter_allowed_fields())) {
    $field_name = $form['#instance']['field_name'];
    $form['audioconverter'] = array(
      '#type' => 'fieldset',
      '#title' => t('Audio Converter Settings'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE
    );

    $form['audioconverter']['autoconversion'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable automatic audio conversion.'),
      '#description' => t('Automatically convert existing audio fields to mp3. Please make sure the Audio Converter settings are properly configured.'),
      '#default_value' => variable_get('audioconverter_' . $field_name, 0),
    );

    $form['submit']['#weight'] = 10;
    $form['#submit'][] = 'audioconverter_form_field_submit';
  }
}

/* Save per field settings */
function audioconverter_form_field_submit(&$form, &$form_state) {
  $field_name = $form['#instance']['field_name'];
  variable_set('audioconverter_' . $field_name, $form_state['values']['autoconversion']);
}

/**
 * Configuration Form
 *
 * @return
 *   string of form content or error message
 */
function audioconverter_admin_settings_form() {
  $form = array();
  $form['audioconverter'] = array(
    '#type' => 'radios',
    '#title' => t('Audio Converter'),
    '#default_value' => variable_get('audioconverter', 0),
    '#options' => array('FFMPEG', 'SOX Utility (not yet supported)'),
    '#description' => 'Please select the application to be used when converting audio files to the mp3 format. For additional information about FFMPEG, check the ' . l(t('FFMPEG Online Manual'), 'http://www.ffmpeg.org/') . '.',
  );

  $form['audioconverter_all'] = array(
    '#type' => 'radios',
    '#title' => t('Audio fields to be converted'),
    '#default_value' => variable_get('audioconverter_all', 0),
    '#options' => array(
      'Use individual field settings',
      'Automatically convert all audio fields in the system'
    ),
  );

  $form['audioconverter_on_save'] = array(
    '#type' => 'radios',
    '#title' => t('Audio conversion time'),
    '#default_value' => variable_get('audioconverter_on_save', 0),
    '#options' => array(
      'Audio files should be converted on cron',
      'Audio files should be converted on Node Submit'
    ),
  );

  $form['audioconverter_wav_setting'] = array(
    '#type' => 'radios',
    '#title' => t('What to do after converting files to mp3?'),
    '#default_value' => variable_get('audioconverter_wav_setting', 1),
    '#options' => array(
      'Delete existing .wav files',
      'Leave .wav files untouched'
    ),
  );

  $form['ffmpeg'] = array(
    '#type' => 'fieldset',
    '#title' => t('FFMPEG Settings'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE
  );

  $form['ffmpeg']['ffmpeg_executable_path'] = array(
    '#type' => 'textfield',
    '#title' => t('FFMPEG Path'),
    '#default_value' => variable_get('ffmpeg_executable_path', '/usr/bin/ffmpeg'),
    '#description' => t('Path to FFMPEG (ie. /usr/bin/ffmpeg, etc.)')
  );

  $form['ffmpeg']['ffmpeg_executable_command'] = array(
    '#type' => 'textfield',
    '#title' => t('FFMPEG Command Options'),
    '#default_value' => variable_get('ffmpeg_executable_command', ' -i %audiofile %convertfile'),
    '#description' => t('Arguments to be passed to FFMPEG. Tokens available: %audiofile - original audio filename, %convertfile - name of the converted file.')
  );

  $form['sox'] = array(
    '#type' => 'fieldset',
    '#title' => t('SOX Utility Settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE
  );

  $form['sox']['sox_executable_path'] = array(
    '#type' => 'textfield',
    '#title' => t('SOX Utility Path'),
    '#default_value' => variable_get('sox_executable_path', '/usr/bin/sox'),
    '#description' => t('Path to the SOX Utility (ie. /usr/bin/sox, etc.')
  );

  $form['sox']['sox_executable_command'] = array(
    '#type' => 'textfield',
    '#title' => t('SOX Command Options'),
    '#default_value' => variable_get('sox_executable_command', ''),
    '#description' => t('Arguments to be passed to the SOX Utility.')
  );
  return system_settings_form($form);
}

/**
 * Implementation of hook_cron().
 */
function audioconverter_cron() {
  if ($jobs = _audioconverter_scheduler_select()) {
    foreach ($jobs as $job) {
      _audioconverter_scheduler_start($job);
    }
  }
  else {
    watchdog('audioconverter', 'no audio conversion jobs to schedule.', array(), WATCHDOG_DEBUG);
  }
}

function _audioconverter_scheduler_select() {
  // load node and its file object
  $jobs = array();
  $i = 0;
  $result = db_query('SELECT f.fid, f.uri, f.filesize, f.filename, f.filemime, f.status FROM {audio_rendering} ar INNER JOIN {file_managed}
      f ON ar.fid = f.fid WHERE ar.fid = f.fid AND ar.status = :as AND f.status = :fs ORDER BY f.timestamp',
    array(':as' => AUDIO_RENDERING_PENDING, ':fs' => 1));
  foreach ($result as $job) {
    $jobs[] = $job;
  }
  return $jobs;
}


function _audioconverter_scheduler_start($job) {
  $fid = $job->fid;
  _audioconverter_render_job_change_status($fid, AUDIO_RENDERING_ACTIVE);

  if (variable_get('audioconverter', 0) == 0) {
    _audioconverter_scheduler_ffmpeg_helper($job);
  }
  else {
    _audioconverter_scheduler_sox_helper($job);
  }


  if (empty($job->converted)) {
    watchdog('audioconverter', 'converted file is an empty file.', array(), WATCHDOG_ERROR);
    _audioconverter_render_job_change_status($fid, AUDIO_RENDERING_FAILED);
    return;
  }
  else {
    $file = $job->converted;
    //update the file table entry and copy file content to new one
    $file->fid = $fid;
    //update file with new converted file
    drupal_write_record('file_managed', $file, 'fid');
    if (variable_get('audioconverter_wav_setting', 1) == 1) {
      //add new file entry for original file
      //TODO: throws error Duplicate entry 'public://1321374184_0.mp3' for key 'uri'
      unset($job->fid);
      drupal_write_record('file_managed', $job);
    }
    else {
      //delete original file
      //TODO: D7 takes file object as param
      //file_delete($file);
      drupal_unlink($job->uri);
    }
    // support entitycache if tables exist
    if (module_exists('entitycache')) {
      if (db_table_exists('cache_entity_file')) {
        cache_clear_all($file->fid, 'cache_entity_file');
      }
    }
    // TODO : add data of rendering
    _audioconverter_render_job_change_status($fid, AUDIO_RENDERING_COMPLETE);
    // clear all cache data 
    field_cache_clear();
    watchdog('audioconverter', 'successfully converted %orig to %dest', array(
      '%orig' => $job->uri,
      '%dest' => $file->uri
    ), WATCHDOG_INFO);
  }
  /*else {
    
    // get the username of the process owner
    $ownerarray = posix_getpwuid(posix_getuid());
    $owner=$ownerarray['name'];
    // get the username of the destination folder owner
    $fownerarray = posix_getpwuid(fileowner($dest_dir));
    $fowner=$fownerarray['name'];
    // get destination folder permissions
    $perms = substr(sprintf('%o', fileperms($dest_dir)), -4);
    watchdog('audioconverter', 'error moving audio %vid_file with nid = %nid to %dir the final directory. Check folder permissions.<br />The script was run by %uname .<br />The folder owner is %fowner .<br />The folder permissions are %perms .', array('%vid_file' => $job->origfile, '%nid' => $job->nid, '%dir' => $dest_dir, '%uname' => $owner, '%fowner' => $fowner, '%perms' => $perms), WATCHDOG_ERROR);
  }*/
}

function _audioconverter_scheduler_ffmpeg_helper(&$job) {

  $info = pathinfo($job->uri);
  $scheme = file_uri_scheme($job->uri);
  $wrapper = file_stream_wrapper_get_instance_by_scheme($scheme);
  //$audiofile = file_create_url($job->uri);
  $audiofile = drupal_realpath($job->uri);
  //$convfile =  getcwd(). '/'. $wrapper->getDirectoryPath() . '/' . $info['filename'] . ".mp3";
  $convfile = $audiofile . ".mp3";
  $converter = variable_get('ffmpeg_executable_path', '/usr/bin/ffmpeg');
  /*$options = preg_replace(array('/%audiofile/', '/%convertfile/'),
  array($audiofile, $convfile),
  variable_get('ffmpeg_executable_command', ' -i %audiofile %convertfile'));*/

  $options = str_replace('%audiofile', $audiofile, variable_get('ffmpeg_executable_command', ' -i %audiofile %convertfile'));
  $options = str_replace('%convertfile', $convfile, $options);
  // set to the converted file output
  $job->convfile = $convfile;
  $command = " $converter $options";
  watchdog('audioconverter', 'executing: ' . $command, array(), WATCHDOG_DEBUG);
  ob_start();
  passthru($command . " 2>&1", $command_return);
  $command_output = ob_get_contents();
  ob_end_clean();
  if (!file_exists($job->convfile) || !filesize($job->convfile)) {
    watchdog('audioconverter', 'Audio conversion failed. FFMPEG reported the following output: ' . $command_output, array(), WATCHDOG_ERROR);
  }
  else {
    $file = new stdClass();
    //TODO: uid always empty, should add field to the table and store it 
    global $user;
    $file->uid = $user->uid;
    //$file->uid      = $job->uid;
    $file->status = FILE_STATUS_PERMANENT;
    $file->filename = basename($job->convfile);
    $file->uri = $job->uri . ".mp3";
    $file->filemime = file_get_mimetype($job->convfile);
    $file->filesize = filesize($job->convfile);
    $file->timestamp = time();
    $job->converted = $file;
  }
}

function _audioconverter_scheduler_sox_helper(&$job) {
  $info = pathinfo($job->uri);
  $scheme = file_uri_scheme($job->uri);
  $wrapper = file_stream_wrapper_get_instance_by_scheme($scheme);
  $audiofile = file_create_url($job->uri);
  $convfile = getcwd() . '/' . $wrapper->getDirectoryPath() . '/' . $info['filename'] . ".mp3";

  $converter = variable_get('sox_executable_path', '/usr/bin/sox');

  $options = preg_replace(array('/%videofile/', '/%convertfile/'),
    array($audiofile, $convfile),
    variable_get('sox_executable_command',
      '%videofile %convertfile'));

  // set to the converted file output
  $job->convfile = $convfile;

  $command = " $converter $options";

  watchdog('audioconverter', 'executing: ' . $command, array(), WATCHDOG_DEBUG);
  ob_start();
  passthru($command . " 2>&1", $command_return);
  $command_output = ob_get_contents();
  ob_end_clean();

  if (!file_exists($job->convfile) || !filesize($job->convfile)) {
    watchdog('audioconverter', 'Audio conversion failed. SOX reported the following output: ' . $command_output, array(), WATCHDOG_ERROR);

  }
  else {
    $file_name = $convfile;
    $file = new stdClass();
    $file->status = FILE_STATUS_PERMANENT;
    $file->filename = basename($job->convfile);
    $file->uri = $job->uri . ".mp3";
    $file->filemime = file_get_mimetype($job->convfile);
    $file->filesize = filesize($job->convfile);
    $file->timestamp = time();
    $job->converted = $file;
  }
}

function _audio_render_load_job($fid) {
  $result = db_query('SELECT f.fid,f.uid,f.filename,f.uri,f.filemime,f.filesize,f.status
      FROM {audio_rendering} ar INNER JOIN {file_managed} f
      ON ar.fid = f.fid WHERE ar.fid = f.fid AND f.fid = :fid', array(":fid" => $fid))->fetchObject();
  return $result;
}

function _audioconverter_render_job_change_status($fid, $status) {
  $result = db_update('audio_rendering')
    ->fields(array('status' => $status))
    ->condition('fid', $fid)
    ->execute();
}

function _audioconverter_file_in_queue($fid) {
  $fid = db_query('SELECT fid FROM {audio_rendering} WHERE fid=:fid ', array(':fid' => $fid))->fetchField();
  return $fid;
}

function audioconverter_save_file($fid) {
  //TODO: do we need pid?
  $arr = array(
    'fid' => $fid,
    'pid' => 0,
    'status' => AUDIO_RENDERING_PENDING,
    'started' => 0,
    'complete' => 0
  );
  $result = drupal_write_record('audio_rendering', $arr);
}

/* Return array of supported CCK fields */
function audioconverter_allowed_fields() {
  //Invoke hook_audioconverter_allowed_fields()
  $fields = module_invoke_all('audioconverter_allowed_fields');
  $fields[] = 'audiofield';
  $fields[] = 'audiorecorderfield';
  $fields[] = 'media_recorder';
  $fields[] = 'file';
  return $fields;
}