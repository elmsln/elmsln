<?php

/**
 * Callback to return all data about the current entity from
 * our xAPI / LRS data we can drum up that's meaningful.
 */
function _elmsln_core_data_page($etype, $entity, $context = FALSE) {
  $aggregates = array(
    'verbs' => array(),
    'users' => array(),
    'counts' => array(),
    'icons' => array(),
    'colors' => array(),
    'user_list' => array(),
    'percent_used' => array(),
  );
  // make initial query scaffold we need for all calls for data
  $query = array(
    'pipeline' => array(
      array(
        '$match' => array(),
      ),
    )
  );
  $uri = entity_uri($etype, $entity);
  $url = url($uri['path'], array('absolute' => TRUE));
  // show query data specific to the entity type in question
  switch ($etype) {
    case 'user':
      $entity->name = 'bto108';
      $query['pipeline'][0]['$match']['statement.actor.name'] = $entity->name;
    break;
    case 'node':
      if ($context) {
        $query['pipeline'][0]['$match']['statement.context.contextActivities.parent.id'] = $url;
      }
      else {
        $query['pipeline'][0]['$match']['statement.object.id'] = $url;
      }
    break;
  }
  $query['pipeline'] = json_encode($query['pipeline']);
  $result = _elmsln_core_lrs_query($query, TRUE);
  // start cleaning up the data to make it more useful downstream
  $data = $result['result'];
  foreach ($data as $key => $record) {
    // make our own custom area for more data
    $data[$key]['_elmsln'] = array();
    // engineer verb agnostic of language
    $verb = array_pop($record['statement']['verb']['display']);
    $verb = t($verb);
    $data[$key]['_elmsln']['verb'] = $verb;
    $aggregates['verbs'][$record['statement']['verb']['id']] = $verb;
    // count verbs
    if (!isset($aggregates['counts'][$verb])) {
      $aggregates['counts'][$verb] = 0;
    }
    $aggregates['counts'][$verb]++;
    $aggregates['users'][$verb][$record['statement']['actor']['name']] = $record['statement']['actor']['name'];
    $aggregates['user_list'][$record['statement']['actor']['name']] = $record['statement']['actor']['name'];
  }
  // load in the icon associations
  $icons = _elmsln_core_icon_map();
  foreach ($aggregates['verbs'] as $verb) {
    if (isset($icons[$verb])) {
      $aggregates['colors'][$verb] = $icons[$verb]['color'];
      $aggregates['icons'][$verb] = $icons[$verb]['icon'];
    }
    else {
      $aggregates['colors'][$verb] = ELMSLN_XAPI_DEFAULT_COLOR;
      $aggregates['icons'][$verb] = ELMSLN_XAPI_DEFAULT_ICON;
    }
    $aggregates['percent_used'][$verb] = 100 * round(count($aggregates['users'][$verb]) / count($aggregates['user_list']), 2);
  }
  // make a decent title
  if (!$context) {
    $datatitle = t('@statements Direct statements generated by @users users.', array('@statements' => count($data), '@users' => count($aggregates['user_list'])));
  }
  else {
    $datatitle = t('@statements Contextual statements generated by @users users.', array('@statements' => count($data), '@users' => count($aggregates['user_list'])));
  }
  // send off for theming
  $vars = array(
    'datatitle' => $datatitle,
    'data' => $data,
    'aggregates' => $aggregates,
  );
  $output = '';
  if (!$context) {
    $output = _elmsln_core_data_page($etype, $entity, TRUE);
  }
  return theme('elmsln_core_lrs_data', $vars) . $output;
}
