<?php

/**
 * Callback to return all data about the current entity from
 * our xAPI / LRS data we can drum up that's meaningful.
 */
function _elmsln_core_data_page($etype, $entity) {
  $aggregates = array(
    'verbs' => array(),
    'users' => array(),
    'counts' => array(),
    'icons' => array(),
    'colors' => array(),
    'user_list' => array(),
    'percent_used' => array(),
  );
  // make initial query scaffold we need for all calls for data
  $query = array(
    'pipeline' => array(
      array(
        '$match' => array(),
      ),
    )
  );
  $uri = entity_uri($etype, $entity);
  $url = url($uri['path'], array('absolute' => TRUE));
  // show query data specific to the entity type in question
  switch ($etype) {
    case 'user':
      $entity->name = 'bto108';
      $query['pipeline'][0]['$match']['statement.actor.name'] = $entity->name;
    break;
    case 'node':
      $query['pipeline'][0]['$match']['$or'][]['statement.context.contextActivities.parent.id'] = $url;
      $query['pipeline'][0]['$match']['$or'][]['statement.object.id'] = $url;
      // @todo figure out the encoding issue so that we can query anything that's in scope; probably bypassing the other two entirely
      $query['pipeline'][0]['$match']['$or'][]['statement.context.extensions.https://www%252646;elmsln%252646;org/x-api/elmsln-url'] = $url;
    break;
  }
  $query['pipeline'] = json_encode($query['pipeline']);
  $result = _elmsln_core_lrs_query($query, FALSE);
  // start cleaning up the data to make it more useful downstream
  $data = $result['result'];
  foreach ($data as $key => $record) {
    // make our own custom area for more data
    $data[$key]['_elmsln'] = array();
    // engineer verb agnostic of language
    $verb = array_pop($record['statement']['verb']['display']);
    $verb = t($verb);
    $data[$key]['_elmsln']['verb'] = $verb;
    $aggregates['verbs'][$record['statement']['verb']['id']] = $verb;
    // count verbs
    if (!isset($aggregates['counts'][$verb])) {
      $aggregates['counts'][$verb] = 0;
    }
    $aggregates['counts'][$verb]++;
    $aggregates['users'][$verb][$record['statement']['actor']['name']] = $record['statement']['actor']['name'];
    $aggregates['user_list'][$record['statement']['actor']['name']] = $record['statement']['actor']['name'];
  }
  // order from biggest to smallest xAPI counts
  uasort($aggregates['counts'], '_elmsln_uasortcmp');
  // load in the icon associations
  $icons = _elmsln_core_icon_map();
  foreach ($aggregates['verbs'] as $verb) {
    if (isset($icons[$verb])) {
      $aggregates['colors'][$verb] = $icons[$verb]['color'];
      $aggregates['icons'][$verb] = $icons[$verb]['icon'];
    }
    else {
      $aggregates['colors'][$verb] = ELMSLN_XAPI_DEFAULT_COLOR;
      $aggregates['icons'][$verb] = ELMSLN_XAPI_DEFAULT_ICON;
    }
    $aggregates['percent_used'][$verb] = 100 * round(count($aggregates['users'][$verb]) / count($aggregates['user_list']), 2);
  }
  // make a decent title
  $datatitle = t('@statements statements generated by @users users.', array('@statements' => count($data), '@users' => count($aggregates['user_list'])));
  // send off for theming
  $vars = array(
    'datatitle' => $datatitle,
    'data' => $data,
    'aggregates' => $aggregates,
  );
  $output = '';
  // load up read time if it exists
  if ($etype == 'node' && module_exists('read_time')) {
    $output = theme('read_time', array('node' => $entity));
  }
  return $output . theme('elmsln_core_lrs_data', $vars);
}

/**
 * callback for uasort comparison of array values
 */
function _elmsln_uasortcmp($a, $b) {
    if ($a == $b) {
        return 0;
    }
    return ($a > $b) ? -1 : 1;
}