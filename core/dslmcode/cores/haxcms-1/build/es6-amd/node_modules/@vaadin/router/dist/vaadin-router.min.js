define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Router = _exports.Resolver = void 0;

  function t(t) {
    return t = t || [], Array.isArray(t) ? t : [t];
  }

  function e(t) {
    return `[Vaadin.Router] ${t}`;
  }

  const n = "module",
        r = "nomodule",
        o = [n, r];

  function i(t) {
    if (!t.match(/.+\.[m]?js$/)) throw new Error(e(`Unsupported type for bundle "${t}": .js or .mjs expected.`));
  }

  function s(t) {
    if (!t || !l(t.path)) throw new Error(e('Expected route config to be an object with a "path" string property, or an array of such objects'));
    const s = t.bundle,
          c = ["component", "redirect", "bundle"];
    if (!(f(t.action) || Array.isArray(t.children) || f(t.children) || h(s) || c.some(e => l(t[e])))) throw new Error(e(`Expected route config "${t.path}" to include either "${c.join('", "')}" ` + 'or "action" function but none found.'));
    if (s) if (l(s)) i(s);else {
      if (!o.some(t => t in s)) throw new Error(e('Expected route bundle to include either "' + r + '" or "' + n + '" keys, or both'));
      o.forEach(t => t in s && i(s[t]));
    }
    t.redirect && ["bundle", "component"].forEach(n => {
      n in t && console.warn(e(`Route config "${t.path}" has both "redirect" and "${n}" properties, ` + `and "redirect" will always override the latter. Did you mean to only use "${n}"?`));
    });
  }

  function c(e) {
    t(e).forEach(t => s(t));
  }

  function u(t, e) {
    let o = document.head.querySelector('script[src="' + t + '"][async]');
    return o || ((o = document.createElement("script")).setAttribute("src", t), e === n ? o.setAttribute("type", n) : e === r && o.setAttribute(r, ""), o.async = !0), new Promise((t, e) => {
      o.onreadystatechange = o.onload = e => {
        o.t = !0, t(e);
      }, o.onerror = t => {
        o.parentNode && o.parentNode.removeChild(o), e(t);
      }, null === o.parentNode ? document.head.appendChild(o) : o.t && t();
    });
  }

  function a(t, e) {
    return !window.dispatchEvent(new CustomEvent(`vaadin-router-${t}`, {
      cancelable: "go" === t,
      detail: e
    }));
  }

  function h(t) {
    return "object" == typeof t && !!t;
  }

  function f(t) {
    return "function" == typeof t;
  }

  function l(t) {
    return "string" == typeof t;
  }

  function d(t) {
    const n = new Error(e(`Page not found (${t.pathname})`));
    return n.context = t, n.code = 404, n;
  }

  const p = new class {}();

  function w(t) {
    if (t.defaultPrevented) return;
    if (0 !== t.button) return;
    if (t.shiftKey || t.ctrlKey || t.altKey || t.metaKey) return;
    let e = t.target;
    const n = t.composedPath ? t.composedPath() : t.path || [];

    for (let t = 0; t < n.length; t++) {
      const r = n[t];

      if (r.nodeName && "a" === r.nodeName.toLowerCase()) {
        e = r;
        break;
      }
    }

    for (; e && "a" !== e.nodeName.toLowerCase();) e = e.parentNode;

    if (!e || "a" !== e.nodeName.toLowerCase()) return;
    if (e.target && "_self" !== e.target.toLowerCase()) return;
    if (e.hasAttribute("download")) return;
    if (e.hasAttribute("router-ignore")) return;
    if (e.pathname === window.location.pathname && "" !== e.hash) return;
    if ((e.origin || function (t) {
      const e = t.port,
            n = t.protocol;
      return `${n}//${"http:" === n && "80" === e || "https:" === n && "443" === e ? t.hostname : t.host}`;
    }(e)) !== window.location.origin) return;
    const {
      pathname: r,
      search: o,
      hash: i
    } = e;
    a("go", {
      pathname: r,
      search: o,
      hash: i
    }) && t.preventDefault();
  }

  const m = {
    activate() {
      window.document.addEventListener("click", w);
    },

    inactivate() {
      window.document.removeEventListener("click", w);
    }

  };

  function v(t) {
    if ("vaadin-router-ignore" === t.state) return;
    const {
      pathname: e,
      search: n,
      hash: r
    } = window.location;
    a("go", {
      pathname: e,
      search: n,
      hash: r
    });
  }

  /Trident/.test(navigator.userAgent) && !f(window.PopStateEvent) && (window.PopStateEvent = function (t, e) {
    e = e || {};
    var n = document.createEvent("Event");
    return n.initEvent(t, Boolean(e.bubbles), Boolean(e.cancelable)), n.state = e.state || null, n;
  }, window.PopStateEvent.prototype = window.Event.prototype);
  const b = {
    activate() {
      window.addEventListener("popstate", v);
    },

    inactivate() {
      window.removeEventListener("popstate", v);
    }

  };

  var y = B,
      g = R,
      _ = function (t, e) {
    return P(R(t, e));
  },
      E = P,
      $ = T,
      O = "/",
      j = "./",
      x = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g");

  function R(t, e) {
    for (var n, r = [], o = 0, i = 0, s = "", c = e && e.delimiter || O, u = e && e.delimiters || j, a = !1; null !== (n = x.exec(t));) {
      var h = n[0],
          f = n[1],
          l = n.index;
      if (s += t.slice(i, l), i = l + h.length, f) s += f[1], a = !0;else {
        var d = "",
            p = t[i],
            w = n[2],
            m = n[3],
            v = n[4],
            b = n[5];

        if (!a && s.length) {
          var y = s.length - 1;
          u.indexOf(s[y]) > -1 && (d = s[y], s = s.slice(0, y));
        }

        s && (r.push(s), s = "", a = !1);

        var g = "" !== d && void 0 !== p && p !== d,
            _ = "+" === b || "*" === b,
            E = "?" === b || "*" === b,
            $ = d || c,
            R = m || v;

        r.push({
          name: w || o++,
          prefix: d,
          delimiter: $,
          optional: E,
          repeat: _,
          partial: g,
          pattern: R ? A(R) : "[^" + k($) + "]+?"
        });
      }
    }

    return (s || i < t.length) && r.push(s + t.substr(i)), r;
  }

  function P(t) {
    for (var e = new Array(t.length), n = 0; n < t.length; n++) "object" == typeof t[n] && (e[n] = new RegExp("^(?:" + t[n].pattern + ")$"));

    return function (n, r) {
      for (var o = "", i = r && r.encode || encodeURIComponent, s = 0; s < t.length; s++) {
        var c = t[s];

        if ("string" != typeof c) {
          var u,
              a = n ? n[c.name] : void 0;

          if (Array.isArray(a)) {
            if (!c.repeat) throw new TypeError('Expected "' + c.name + '" to not repeat, but got array');

            if (0 === a.length) {
              if (c.optional) continue;
              throw new TypeError('Expected "' + c.name + '" to not be empty');
            }

            for (var h = 0; h < a.length; h++) {
              if (u = i(a[h], c), !e[s].test(u)) throw new TypeError('Expected all "' + c.name + '" to match "' + c.pattern + '"');
              o += (0 === h ? c.prefix : c.delimiter) + u;
            }
          } else if ("string" != typeof a && "number" != typeof a && "boolean" != typeof a) {
            if (!c.optional) throw new TypeError('Expected "' + c.name + '" to be ' + (c.repeat ? "an array" : "a string"));
            c.partial && (o += c.prefix);
          } else {
            if (u = i(String(a), c), !e[s].test(u)) throw new TypeError('Expected "' + c.name + '" to match "' + c.pattern + '", but got "' + u + '"');
            o += c.prefix + u;
          }
        } else o += c;
      }

      return o;
    };
  }

  function k(t) {
    return t.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
  }

  function A(t) {
    return t.replace(/([=!:$/()])/g, "\\$1");
  }

  function C(t) {
    return t && t.sensitive ? "" : "i";
  }

  function T(t, e, n) {
    for (var r = (n = n || {}).strict, o = !1 !== n.start, i = !1 !== n.end, s = k(n.delimiter || O), c = n.delimiters || j, u = [].concat(n.endsWith || []).map(k).concat("$").join("|"), a = o ? "^" : "", h = 0 === t.length, f = 0; f < t.length; f++) {
      var l = t[f];
      if ("string" == typeof l) a += k(l), h = f === t.length - 1 && c.indexOf(l[l.length - 1]) > -1;else {
        var d = l.repeat ? "(?:" + l.pattern + ")(?:" + k(l.delimiter) + "(?:" + l.pattern + "))*" : l.pattern;
        e && e.push(l), l.optional ? l.partial ? a += k(l.prefix) + "(" + d + ")?" : a += "(?:" + k(l.prefix) + "(" + d + "))?" : a += k(l.prefix) + "(" + d + ")";
      }
    }

    return i ? (r || (a += "(?:" + s + ")?"), a += "$" === u ? "$" : "(?=" + u + ")") : (r || (a += "(?:" + s + "(?=" + u + "))?"), h || (a += "(?=" + s + "|" + u + ")")), new RegExp(a, C(n));
  }

  function B(t, e, n) {
    return t instanceof RegExp ? function (t, e) {
      if (!e) return t;
      var n = t.source.match(/\((?!\?)/g);
      if (n) for (var r = 0; r < n.length; r++) e.push({
        name: r,
        prefix: null,
        delimiter: null,
        optional: !1,
        repeat: !1,
        partial: !1,
        pattern: null
      });
      return t;
    }(t, e) : Array.isArray(t) ? function (t, e, n) {
      for (var r = [], o = 0; o < t.length; o++) r.push(B(t[o], e, n).source);

      return new RegExp("(?:" + r.join("|") + ")", C(n));
    }(t, e, n) : function (t, e, n) {
      return T(R(t, n), e, n);
    }(t, e, n);
  }

  y.parse = g, y.compile = _, y.tokensToFunction = E, y.tokensToRegExp = $;
  const {
    hasOwnProperty: M
  } = Object.prototype,
        S = new Map();

  function U(t) {
    try {
      return decodeURIComponent(t);
    } catch (e) {
      return t;
    }
  }

  function I(t, e, n, r, o) {
    let i,
        s,
        c = 0,
        u = t.path || "";
    return "/" === u.charAt(0) && (n && (u = u.substr(1)), n = !0), {
      next(a) {
        if (t === a) return {
          done: !0
        };
        const h = t.o = t.o || t.children;
        if (!i && (i = function (t, e, n, r, o) {
          const i = `${t}|${n = !!n}`;
          let s = S.get(i);

          if (!s) {
            const e = [];
            s = {
              keys: e,
              pattern: y(t, e, {
                end: n,
                strict: "" === t
              })
            }, S.set(i, s);
          }

          const c = s.pattern.exec(e);
          if (!c) return null;
          const u = Object.assign({}, o);

          for (let t = 1; t < c.length; t++) {
            const e = s.keys[t - 1],
                  n = e.name,
                  r = c[t];
            void 0 === r && M.call(u, n) || (e.repeat ? u[n] = r ? r.split(e.delimiter).map(U) : [] : u[n] = r ? U(r) : r);
          }

          return {
            path: c[0],
            keys: (r || []).concat(s.keys),
            params: u
          };
        }(u, e, !h, r, o))) return {
          done: !1,
          value: {
            route: t,
            keys: i.keys,
            params: i.params,
            path: i.path
          }
        };
        if (i && h) for (; c < h.length;) {
          if (!s) {
            const r = h[c];
            r.parent = t;
            let o = i.path.length;
            o > 0 && "/" === e.charAt(o) && (o += 1), s = I(r, e.substr(o), n, i.keys, i.params);
          }

          const r = s.next(a);
          if (!r.done) return {
            done: !1,
            value: r.value
          };
          s = null, c++;
        }
        return {
          done: !0
        };
      }

    };
  }

  function L(t) {
    if (f(t.route.action)) return t.route.action(t);
  }

  S.set("|false", {
    keys: [],
    pattern: /(?:)/
  });

  class D {
    constructor(t, e = {}) {
      if (Object(t) !== t) throw new TypeError("Invalid routes");
      this.baseUrl = e.baseUrl || "", this.errorHandler = e.errorHandler, this.resolveRoute = e.resolveRoute || L, this.context = Object.assign({
        resolver: this
      }, e.context), this.root = Array.isArray(t) ? {
        path: "",
        o: t,
        parent: null,
        i: !0
      } : t, this.root.parent = null;
    }

    getRoutes() {
      return [...this.root.o];
    }

    setRoutes(e) {
      c(e);
      const n = [...t(e)];
      this.root.o = n;
    }

    addRoutes(e) {
      return c(e), this.root.o.push(...t(e)), this.getRoutes();
    }

    removeRoutes() {
      this.setRoutes([]);
    }

    resolve(t) {
      const e = Object.assign({}, this.context, l(t) ? {
        pathname: t
      } : t),
            n = I(this.root, this.s(e.pathname), this.baseUrl),
            r = this.resolveRoute;
      let o = null,
          i = null,
          s = e;

      function c(t, u = o.value.route, a) {
        const h = null === a && o.value.route;
        return o = i || n.next(h), i = null, t || !o.done && function (t, e) {
          let n = e;

          for (; n;) if ((n = n.parent) === t) return !0;

          return !1;
        }(u, o.value.route) ? o.done ? Promise.reject(d(e)) : (function (t, e) {
          const {
            route: n,
            path: r
          } = e;

          if (n && !n.i) {
            const e = {
              path: r,
              route: n
            };

            if (t.chain) {
              if (n.parent) {
                let e = t.chain.length;

                for (; e-- && t.chain[e].route && t.chain[e].route !== n.parent;) t.chain.pop();
              }
            } else t.chain = [];

            t.chain.push(e);
          }
        }(s = Object.assign(s ? {
          chain: s.chain ? s.chain.slice(0) : []
        } : {}, e, o.value), o.value), Promise.resolve(r(s)).then(e => null !== e && void 0 !== e && e !== p ? (s.result = e.result || e, s) : c(t, u, e))) : (i = o, Promise.resolve(p));
      }

      return e.next = c, Promise.resolve().then(() => c(!0, this.root)).catch(t => {
        const e = function (t) {
          let e = `Path '${t.pathname}' is not properly resolved due to an error.`;
          const n = (t.route || {}).path;
          return n && (e += ` Resolution had failed on route: '${n}'`), e;
        }(s);

        if (t ? console.warn(e) : t = new Error(e), t.context = t.context || s, t instanceof DOMException || (t.code = t.code || 500), this.errorHandler) return s.result = this.errorHandler(t), s;
        throw t;
      });
    }

    static u(t, e) {
      return new URL(t, e);
    }

    get h() {
      return this.baseUrl ? this.constructor.u(this.baseUrl, document.baseURI || document.URL).href.replace(/[^\/]*$/, "") : "";
    }

    s(t) {
      if (!this.baseUrl) return t;
      const e = this.h,
            n = this.constructor.u(t, e).href;
      return n.slice(0, e.length) === e ? n.slice(e.length) : void 0;
    }

  }

  _exports.Resolver = D;
  D.pathToRegexp = y;
  const {
    pathToRegexp: F
  } = D,
        N = new Map();

  function H(t, e) {
    const n = t.get(e);
    if (n && n.length > 1) throw new Error(`Duplicate route with name "${e}".` + " Try seting unique 'name' route properties.");
    return n && n[0];
  }

  function W(t) {
    let e = t.path;
    return void 0 !== (e = Array.isArray(e) ? e[0] : e) ? e : "";
  }

  function q(t, e = {}) {
    if (!(t instanceof D)) throw new TypeError("An instance of Resolver is expected");
    const n = new Map();
    return (r, o) => {
      let i = H(n, r);
      if (!(i || (n.clear(), function t(e, n, r) {
        const o = n.name || n.component;
        if (o && (e.has(o) ? e.get(o).push(n) : e.set(o, [n])), Array.isArray(r)) for (let o = 0; o < r.length; o++) {
          const i = r[o];
          i.parent = n, t(e, i, i.o || i.children);
        }
      }(n, t.root, t.root.o), i = H(n, r)))) throw new Error(`Route "${r}" not found`);
      let s = N.get(i.fullPath);

      if (!s) {
        let t = W(i),
            e = i.parent;

        for (; e;) {
          const n = W(e);
          n && (t = n.replace(/\/$/, "") + "/" + t.replace(/^\//, "")), e = e.parent;
        }

        const n = F.parse(t),
              r = F.tokensToFunction(n),
              o = Object.create(null);

        for (let t = 0; t < n.length; t++) l(n[t]) || (o[n[t].name] = !0);

        s = {
          toPath: r,
          keys: o
        }, N.set(t, s), i.fullPath = t;
      }

      let c = s.toPath(o, e) || "/";

      if (e.stringifyQueryParams && o) {
        const t = {},
              n = Object.keys(o);

        for (let e = 0; e < n.length; e++) {
          const r = n[e];
          s.keys[r] || (t[r] = o[r]);
        }

        const r = e.stringifyQueryParams(t);
        r && (c += "?" === r.charAt(0) ? r : `?${r}`);
      }

      return c;
    };
  }

  let z = [];

  function J(t) {
    z.forEach(t => t.inactivate()), t.forEach(t => t.activate()), z = t;
  }

  const K = t => {
    const e = getComputedStyle(t).getPropertyValue("animation-name");
    return e && "none" !== e;
  },
        V = (t, e) => {
    const n = () => {
      t.removeEventListener("animationend", n), e();
    };

    t.addEventListener("animationend", n);
  };

  function G(t, e) {
    return t.classList.add(e), new Promise(n => {
      if (K(t)) {
        const r = t.getBoundingClientRect(),
              o = `height: ${r.bottom - r.top}px; width: ${r.right - r.left}px`;
        t.setAttribute("style", `position: absolute; ${o}`), V(t, () => {
          t.classList.remove(e), t.removeAttribute("style"), n();
        });
      } else t.classList.remove(e), n();
    });
  }

  const Q = 256;

  function X(t) {
    return null !== t && void 0 !== t;
  }

  function Y({
    pathname: t = "",
    search: e = "",
    hash: n = "",
    chain: r = [],
    params: o = {},
    redirectFrom: i,
    resolver: s
  }, c) {
    const u = r.map(t => t.route);
    return {
      baseUrl: s && s.baseUrl || "",
      pathname: t,
      search: e,
      hash: n,
      routes: u,
      route: c || u.length && u[u.length - 1] || null,
      params: o,
      redirectFrom: i,
      getUrl: (t = {}) => rt(it.pathToRegexp.compile(ot(u))(Object.assign({}, o, t)), s)
    };
  }

  function Z(t, e) {
    const n = Object.assign({}, t.params);
    return {
      redirect: {
        pathname: e,
        from: t.pathname,
        params: n
      }
    };
  }

  function tt(t, e, n) {
    if (f(t)) return t.apply(n, e);
  }

  function et(t, e, n) {
    return r => r && (r.cancel || r.redirect) ? r : n ? tt(n[t], e, n) : void 0;
  }

  function nt(t) {
    if (t && t.length) {
      const e = t[0].parentNode;

      for (let n = 0; n < t.length; n++) e.removeChild(t[n]);
    }
  }

  function rt(t, e) {
    const n = e.h;
    return n ? e.constructor.u(t.replace(/^\//, ""), n).pathname : t;
  }

  function ot(t) {
    return t.map(t => t.path).reduce((t, e) => e.length ? t.replace(/\/$/, "") + "/" + e.replace(/^\//, "") : t, "");
  }

  class it extends D {
    constructor(t, e) {
      const n = document.head.querySelector("base"),
            r = n && n.getAttribute("href");
      super([], Object.assign({
        baseUrl: r && D.u(r, document.URL).pathname.replace(/[^\/]*$/, "")
      }, e)), this.resolveRoute = t => this.l(t);
      const o = it.NavigationTrigger;
      it.setTriggers.apply(it, Object.keys(o).map(t => o[t])), this.baseUrl, this.ready, this.ready = Promise.resolve(t), this.location, this.location = Y({
        resolver: this
      }), this.p = 0, this.m = this.v.bind(this), this.setOutlet(t), this.subscribe(), this.g = new WeakMap(), this._ = new WeakMap();
    }

    l(n) {
      const r = n.route;
      let i = Promise.resolve();
      f(r.children) && (i = i.then(() => r.children(function (t) {
        const e = Object.assign({}, t);
        return delete e.next, e;
      }(n))).then(n => {
        X(n) || f(r.children) || (n = r.children), function (n, r) {
          if (!Array.isArray(n) && !h(n)) throw new Error(e(`Incorrect "children" value for the route ${r.path}: expected array or object, but got ${n}`));
          r.o = [];
          const o = t(n);

          for (let t = 0; t < o.length; t++) s(o[t]), r.o.push(o[t]);
        }(n, r);
      }));
      const c = {
        redirect: t => Z(n, t),
        component: t => {
          const e = document.createElement(t);
          return this.g.set(e, !0), e;
        }
      };
      return i.then(() => {
        if (this.$(n)) return tt(r.action, [n, c], r);
      }).then(t => X(t) && (t instanceof HTMLElement || t.redirect || t === p) ? t : l(r.redirect) ? c.redirect(r.redirect) : r.bundle ? (a = r.bundle, l(a) ? u(a) : Promise.race(o.filter(t => t in a).map(t => u(a[t], t)))).then(() => {}, () => {
        throw new Error(e(`Bundle not found: ${r.bundle}. Check if the file name is correct`));
      }) : void 0).then(t => X(t) ? t : l(r.component) ? c.component(r.component) : void 0);
      var a;
    }

    setOutlet(t) {
      t && this.O(t), this.j = t;
    }

    getOutlet() {
      return this.j;
    }

    setRoutes(t, e = !1) {
      return this.R = void 0, this.P = void 0, super.setRoutes(t), e || this.v(), this.ready;
    }

    render(t, e) {
      const n = ++this.p,
            r = Object.assign({
        search: "",
        hash: ""
      }, l(t) ? {
        pathname: t
      } : t, {
        k: n
      });
      return this.ready = this.resolve(r).then(t => this.A(t)).then(t => {
        if (this.$(t)) {
          const r = this.R;
          if (t === r) return this.C(r, !0), this.location;
          if (this.location = Y(t), e && this.C(t, 1 === n), a("location-changed", {
            router: this,
            location: this.location
          }), t.T) return this.B(t, r), this.R = t, this.location;
          this.M(t, r);
          const o = this.S(t);
          return this.U(t), this.I(t, r), o.then(() => {
            if (this.$(t)) return this.L(), this.R = t, this.location;
          });
        }
      }).catch(t => {
        if (n === this.p) throw e && this.C(r), nt(this.j && this.j.children), this.location = Y(Object.assign(r, {
          resolver: this
        })), a("error", Object.assign({
          router: this,
          error: t
        }, r)), t;
      }), this.ready;
    }

    A(t, e = t) {
      return this.D(e).then(n => {
        const r = n !== e ? n : t,
              o = rt(ot(n.chain), n.resolver) === n.pathname,
              i = (t, e = t.route, n) => t.next(void 0, e, n).then(n => null === n || n === p ? o ? t : null !== e.parent ? i(t, e.parent, n) : n : n);

        return i(n).then(t => {
          if (null === t || t === p) throw d(r);
          return t && t !== p && t !== n ? this.A(r, t) : this.F(n);
        });
      });
    }

    D(t) {
      const n = t.result;
      return n instanceof HTMLElement ? (function (t, e) {
        e.location = Y(t);
        const n = t.chain.map(t => t.route).indexOf(t.route);
        t.chain[n].element = e;
      }(t, n), Promise.resolve(t)) : n.redirect ? this.N(n.redirect, t.H, t.k).then(t => this.D(t)) : n instanceof Error ? Promise.reject(n) : Promise.reject(new Error(e(`Invalid route resolution result for path "${t.pathname}". ` + `Expected redirect object or HTML element, but got: "${function (t) {
        if ("object" != typeof t) return String(t);
        const e = Object.prototype.toString.call(t).match(/ (.*)\]$/)[1];
        return "Object" === e || "Array" === e ? `${e} ${JSON.stringify(t)}` : e;
      }(n)}". ` + "Double check the action return value for the route.")));
    }

    F(t) {
      return this.W(t).then(e => e === this.R || e === t ? e : this.A(e));
    }

    W(t) {
      const e = this.R || {},
            n = e.chain || [],
            r = t.chain;
      let o = Promise.resolve();

      const i = () => ({
        cancel: !0
      }),
            s = e => Z(t, e);

      if (t.q = 0, t.T = !1, n.length) {
        for (let e = 0; e < Math.min(n.length, r.length) && n[e].route === r[e].route && (n[e].path === r[e].path || n[e].element === r[e].element) && this.J(n[e].element, r[e].element); e = ++t.q);

        if (t.T = r.length === n.length && t.q == r.length && this.J(t.result, e.result), t.T) {
          for (let e = r.length - 1; e >= 0; e--) o = this.K(o, t, {
            prevent: i
          }, n[e]);

          for (let e = 0; e < r.length; e++) o = this.V(o, t, {
            prevent: i,
            redirect: s
          }, r[e]), n[e].element.location = Y(t, n[e].route);
        } else for (let e = n.length - 1; e >= t.q; e--) o = this.K(o, t, {
          prevent: i
        }, n[e]);
      }

      if (!t.T) for (let e = 0; e < r.length; e++) e < t.q ? e < n.length && n[e].element && (n[e].element.location = Y(t, n[e].route)) : (o = this.V(o, t, {
        prevent: i,
        redirect: s
      }, r[e]), r[e].element && (r[e].element.location = Y(t, r[e].route)));
      return o.then(e => {
        if (e) {
          if (e.cancel) return this.R.k = t.k, this.R;
          if (e.redirect) return this.N(e.redirect, t.H, t.k);
        }

        return t;
      });
    }

    K(t, e, n, r) {
      const o = Y(e);
      return t.then(t => {
        if (this.$(e)) {
          return et("onBeforeLeave", [o, n, this], r.element)(t);
        }
      }).then(t => {
        if (!(t || {}).redirect) return t;
      });
    }

    V(t, e, n, r) {
      const o = Y(e, r.route);
      return t.then(t => {
        if (this.$(e)) {
          return et("onBeforeEnter", [o, n, this], r.element)(t);
        }
      });
    }

    J(t, e) {
      return !(!t || !e) && (this.g.get(t) && this.g.get(e) ? t.localName === e.localName : t === e);
    }

    $(t) {
      return t.k === this.p;
    }

    N(t, n, r) {
      if (n > Q) throw new Error(e(`Too many redirects when rendering ${t.from}`));
      return this.resolve({
        pathname: this.urlForPath(t.pathname, t.params),
        redirectFrom: t.from,
        H: (n || 0) + 1,
        k: r
      });
    }

    O(t = this.j) {
      if (!(t instanceof Node)) throw new TypeError(e(`Expected router outlet to be a valid DOM Node (but got ${t})`));
    }

    C({
      pathname: t,
      search: e = "",
      hash: n = ""
    }, r) {
      if (window.location.pathname !== t || window.location.search !== e || window.location.hash !== n) {
        const o = r ? "replaceState" : "pushState";
        window.history[o](null, document.title, t + e + n), window.dispatchEvent(new PopStateEvent("popstate", {
          state: "vaadin-router-ignore"
        }));
      }
    }

    B(t, e) {
      let n = this.j;

      for (let r = 0; r < t.q; r++) {
        const o = e && e.chain[r].element;

        if (o) {
          if (o.parentNode !== n) break;
          t.chain[r].element = o, n = o;
        }
      }

      return n;
    }

    M(t, e) {
      this.O(), this.G();
      const n = this.B(t, e);
      this.X = [], this.Y = Array.from(n.children).filter(e => this._.get(e) && e !== t.result);
      let r = n;

      for (let e = t.q; e < t.chain.length; e++) {
        const o = t.chain[e].element;
        o && (r.appendChild(o), this._.set(o, !0), r === n && this.X.push(o), r = o);
      }
    }

    L() {
      this.Y && nt(this.Y), this.Y = null, this.X = null;
    }

    G() {
      this.Y && this.X && (nt(this.X), this.Y = null, this.X = null);
    }

    I(t, e) {
      if (e) for (let n = e.chain.length - 1; n >= t.q && this.$(t); n--) {
        const r = e.chain[n].element;
        if (r) try {
          const n = Y(t);
          tt(r.onAfterLeave, [n, {}, e.resolver], r);
        } finally {
          this.Y.indexOf(r) > -1 && nt(r.children);
        }
      }
    }

    U(t) {
      for (let e = t.q; e < t.chain.length && this.$(t); e++) {
        const n = t.chain[e].element || {},
              r = Y(t, t.chain[e].route);
        tt(n.onAfterEnter, [r, {}, t.resolver], n);
      }
    }

    S(t) {
      const e = (this.Y || [])[0],
            n = (this.X || [])[0],
            r = [],
            o = t.chain;
      let i;

      for (let t = o.length; t > 0; t--) if (o[t - 1].route.animate) {
        i = o[t - 1].route.animate;
        break;
      }

      if (e && n && i) {
        const t = h(i) && i.leave || "leaving",
              o = h(i) && i.enter || "entering";
        r.push(G(e, t)), r.push(G(n, o));
      }

      return Promise.all(r).then(() => t);
    }

    subscribe() {
      window.addEventListener("vaadin-router-go", this.m);
    }

    unsubscribe() {
      window.removeEventListener("vaadin-router-go", this.m);
    }

    v(t) {
      const {
        pathname: e,
        search: n,
        hash: r
      } = t ? t.detail : window.location;
      l(this.s(e)) && (t && t.preventDefault && t.preventDefault(), this.render({
        pathname: e,
        search: n,
        hash: r
      }, !0));
    }

    static setTriggers(...t) {
      J(t);
    }

    urlForName(t, e) {
      return this.P || (this.P = q(this)), rt(this.P(t, e), this);
    }

    urlForPath(t, e) {
      return rt(it.pathToRegexp.compile(t)(e), this);
    }

    static go(t) {
      const {
        pathname: e,
        search: n,
        hash: r
      } = l(t) ? this.u(t, "http://a") : t;
      return a("go", {
        pathname: e,
        search: n,
        hash: r
      });
    }

  }

  _exports.Router = it;
  const st = /\/\*\*\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i,
        ct = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;

  function ut(t, e) {
    if ("function" != typeof t) return;
    const n = st.exec(t.toString());
    if (n) try {
      t = new Function(n[1]);
    } catch (t) {
      console.log("vaadin-development-mode-detector: uncommentAndRun() failed", t);
    }
    return t(e);
  }

  window.Vaadin = window.Vaadin || {};

  const at = function (t, e) {
    if (window.Vaadin.developmentMode) return ut(t, e);
  };

  function ht() {}

  void 0 === window.Vaadin.developmentMode && (window.Vaadin.developmentMode = function () {
    try {
      return !!localStorage.getItem("vaadin.developmentmode.force") || ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0 && (ct ? !function () {
        if (ct) {
          const t = Object.keys(ct).map(t => ct[t]).filter(t => t.productionMode);
          if (t.length > 0) return !0;
        }

        return !1;
      }() : !ut(function () {
        return !0;
      }));
    } catch (t) {
      return !1;
    }
  }());
  window.Vaadin = window.Vaadin || {}, window.Vaadin.registrations = window.Vaadin.registrations || [], window.Vaadin.registrations.push({
    is: "@vaadin/router",
    version: "1.7.2"
  }), at(ht), it.NavigationTrigger = {
    POPSTATE: b,
    CLICK: m
  };
});