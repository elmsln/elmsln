define(["exports", "../../lit-element/lit-element.js", "../json-editor/json-editor.js", "../code-editor/code-editor.js", "../../@vaadin/vaadin-split-layout/vaadin-split-layout.js", "../../@polymer/paper-button/paper-button.js", "../hax-body/lib/hax-schema-form.js", "../hax-body-behaviors/hax-body-behaviors.js"], function (_exports, _litElement, _jsonEditor, _codeEditor, _vaadinSplitLayout, _paperButton, _haxSchemaForm, _haxBodyBehaviors) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxschemaBuilder = void 0;

  /**
   * Copyright 2019 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `haxschema-builder`
   * `dynamically build and visualize HAXschema`
   * @demo demo/index.html
   * @element haxschema-builder
   */
  class HaxschemaBuilder extends _litElement.LitElement {
    //styles function
    static get styles() {
      return [(0, _litElement.css)`
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none;
        }

        code-editor {
          height: 500px;
        }
      `];
    } // render function


    render() {
      return (0, _litElement.html)` <vaadin-split-layout>
      <div>
        <paper-button raised noink @click="${this.addConfigure}"
          >Add to configure</paper-button
        >
        <paper-button raised noink @click="${this.addAdvanced}"
          >Add to advanced</paper-button
        >
        <code-editor
          id="code"
          @value-changed="${this._editorDataChanged}"
          .value="{}"
          language="json"
        ></code-editor>
        <json-editor
          id="json"
          label="JSON"
          @value-changed="${this.__haxSchemaChanged}"
          value="${this.haxSchema}"
        ></json-editor>
      </div>
      <div>
        <hax-schema-form
          id="form"
          value="${this.value}"
          @value-changed="${this.__valueChanged}"
        ></hax-schema-form>
      </div>
    </vaadin-split-layout>`;
    } // haxProperty definition


    static get haxProperties() {
      return {
        canScale: true,
        canPosition: true,
        canEditSource: true,
        gizmo: {
          title: "Haxschema builder",
          description: "dynamically build and visualize HAXschema",
          icon: "icons:android",
          color: "green",
          groups: ["Builder"],
          handles: [],
          meta: {
            author: "btopro",
            owner: "The Pennsylvania State University"
          }
        },
        settings: {
          quick: [],
          configure: [{
            property: "source",
            description: "",
            inputMethod: "textfield",
            required: true,
            icon: "icons:link",
            validationType: "url"
          }],
          advanced: []
        }
      };
    } // properties available to the custom element for data binding


    static get properties() {
      return { ...super.properties,

        /**
         * schema to extract for whatever you wanted it for
         */
        haxSchema: {
          type: String,
          attribute: "hax-schema"
        },

        /**
         * Optional remote source to pull in
         */
        source: {
          type: String
        },

        /**
         * String based value passed between the elements to stitch together
         */
        value: {
          type: String
        }
      };
    }
    /**
     * Store the tag name to make it easier to obtain directly.
     * @notice function name must be here for tooling to operate correctly
     */


    static get tag() {
      return "haxschema-builder";
    }

    constructor() {
      super();
      this.HAXWiring = new _haxBodyBehaviors.HAXWiring();
      this.haxSchema = "{}";
    }

    updated(changedProperties) {
      changedProperties.forEach((oldValue, propName) => {
        if (propName == "haxSchema") {
          // notify
          this.dispatchEvent(new CustomEvent("hax-schema-changed", {
            value: this[propName]
          }));

          this._haxSchemaChanged(this[propName], oldValue);
        }
      });
    }
    /**
     * life cycle, element is afixed to the DOM
     */


    firstUpdated() {
      setTimeout(() => {
        if (!this.source) {
          this.haxSchema = JSON.stringify(this.HAXWiring.prototypeHaxProperties(), null, 2);
        }
      }, 0); // HACK to get initial paint to have the correct form

      this.shadowRoot.querySelector("#form").modeTab = "advanced";
      setTimeout(() => {
        this.shadowRoot.querySelector("#form").modeTab = "configure";
      }, 2000);
    }
    /**
     * Force an update on code editor when this value changes
     */


    _haxSchemaChanged(newValue) {
      if (newValue) {
        this.shadowRoot.querySelector("#code").editorValue = newValue;
      }
    }
    /**
     * Notice code editor changes and reflect them into this element
     */


    _editorDataChanged(e) {
      // value coming up off of this and get it propegated correctly
      this.haxSchema = e.detail.value;
      let hs = JSON.parse(this.haxSchema);

      for (var key in hs.settings) {
        let schema = this.HAXWiring.getHaxJSONSchema(key, hs);
        this.shadowRoot.querySelector("#form")[key + "Schema"] = Object.assign({}, schema);
      }
    }

    addAdvanced(e) {
      let hs = JSON.parse(this.haxSchema);
      hs.settings.advanced.push(this.__propPrototype());

      this.__refreshSchemas(hs);
    }

    addConfigure(e) {
      let hs = JSON.parse(this.haxSchema);
      hs.settings.configure.push(this.__propPrototype());

      this.__refreshSchemas(hs);
    }

    __refreshSchemas(hs) {
      for (var key in hs.settings) {
        let schema = this.HAXWiring.getHaxJSONSchema(key, hs);
        this.shadowRoot.querySelector("#form")[key + "Schema"] = Object.assign({}, schema);
      }

      this.haxSchema = JSON.stringify(hs);
    }

    __propPrototype() {
      return {
        property: "title",
        title: "Title",
        description: "",
        inputMethod: "textfield",
        icon: "android",
        required: true,
        validationType: "text"
      };
    }

    __haxSchemaChanged(e) {
      this.haxSchema = e.detail.value;
    }

    __valueChanged(e) {
      this.value = e.detail.value;
    }

  }

  _exports.HaxschemaBuilder = HaxschemaBuilder;
  window.customElements.define(HaxschemaBuilder.tag, HaxschemaBuilder);
});