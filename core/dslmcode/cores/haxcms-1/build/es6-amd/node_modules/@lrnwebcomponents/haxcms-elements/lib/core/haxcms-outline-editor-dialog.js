define(["exports", "require", "../../../../@polymer/polymer/polymer-element.js", "../../../../@polymer/polymer/lib/utils/render-status.js", "./haxcms-site-store.js", "../../../../mobx/lib/mobx.module.js", "../../../json-outline-schema/json-outline-schema.js", "../../../json-editor/json-editor.js", "../../../editable-outline/editable-outline.js"], function (_exports, _require, _polymerElement, _renderStatus, _haxcmsSiteStore, _mobxModule, _jsonOutlineSchema, _jsonEditor, _editableOutline) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSOutlineEditorDialog = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  /**
   * `haxcms-outline-editor-dialog`
   * `Dialog for presenting an editable outline`
   *
   * @demo demo/index.html
   *
   * @microcopy - the mental model for this element
   */
  class HAXCMSOutlineEditorDialog extends _polymerElement.PolymerElement {
    /**
     * Store the tag name to make it easier to obtain directly.
     * @notice function name must be here for tooling to operate correctly
     */
    static get tag() {
      return "haxcms-outline-editor-dialog";
    }

    constructor() {
      super();
      new Promise((res, rej) => _require.default(["../../../../@polymer/paper-button/paper-button.js"], res, rej));
      new Promise((res, rej) => _require.default(["../../../../@polymer/iron-icon/iron-icon.js"], res, rej));
      new Promise((res, rej) => _require.default(["../../../../@polymer/iron-icons/iron-icons.js"], res, rej));
    } // render function


    static get template() {
      return _polymerElement.html`
      <style>
        :host {
          display: block;
          height: 60vh;
          min-width: 50vw;
        }
        .buttons {
          position: absolute;
          bottom: 0;
          z-index: 1000000;
          background-color: var(--simple-modal-titlebar-background, #ddd);
          left: 0;
          right: 0;
        }
        editable-outline:not(:defined),
        json-editor:not(:defined),
        paper-button:not(:defined) {
          display: none;
        }
        #toggle {
          float: right;
          text-transform: unset;
        }
        editable-outline,
        json-editor {
          margin-bottom: 32px;
        }
      </style>
      <editable-outline
        id="outline"
        edit-mode
        hidden$="[[viewMode]]"
        items="[[manifestItems]]"
      ></editable-outline>
      <json-editor
        id="editor"
        label="JSON Outline Schema items"
        value="[[manifestItemsStatic]]"
        hidden$="[[!viewMode]]"
      ></json-editor>
      <div class="buttons">
        <paper-button dialog-confirm on-click="_saveTap">Save</paper-button>
        <paper-button dialog-dismiss>Cancel</paper-button>
        <paper-button id="toggle" on-click="toggleView"
          ><iron-icon icon="[[_viewIcon]]"></iron-icon
          >[[viewLabel]]</paper-button
        >
      </div>
    `;
    }

    static get properties() {
      return {
        /**
         * opened state of the dialog inside here
         */
        opened: {
          type: Boolean,
          notify: true
        },

        /**
         * Outline of items in json outline schema format
         */
        manifestItems: {
          type: Array,
          observer: "_manifestItemsChanged"
        },

        /**
         * Stringify'ed representation of items
         */
        manifestItemsStatic: {
          type: String
        },

        /**
         * Display label, switch when hitting the toggle button
         */
        viewLabel: {
          type: String,
          computed: "_getViewLabel(viewMode)"
        },

        /**
         * Which edit mode to display
         */
        viewMode: {
          type: Boolean,
          value: false,
          observer: "_viewModeChanged"
        }
      };
    }

    _manifestItemsChanged(newValue) {
      if (newValue) {
        window.JSONOutlineSchema.requestAvailability().items = newValue;
        this.manifestItemsStatic = JSON.stringify(newValue, null, 2);
      }
    }

    ready() {
      super.ready();
      (0, _renderStatus.afterNextRender)(this, function () {
        this.$.editor.addEventListener("current-data-changed", e => {
          if (e.detail.value) {
            this.set("manifestItems", e.detail.value);
            this.$.outline.importJsonOutlineSchemaItems();
          }
        });
      });
    }
    /**
     * attached life cycle
     */


    connectedCallback() {
      super.connectedCallback();
      this.__disposer = [];
      (0, _mobxModule.autorun)(reaction => {
        setTimeout(() => {
          this.manifestItems = Object.assign([], (0, _mobxModule.toJS)(_haxcmsSiteStore.store.manifest.items));

          this.__disposer.push(reaction);
        }, 500);
      });
    }
    /**
     * detached life cycle
     */


    disconnectedCallback() {
      for (var i in this.__disposer) {
        this.__disposer[i].dispose();
      }

      this.$.editor.removeEventListener("current-data-changed", e => {
        if (e.detail.value) {
          this.set("manifestItems", e.detail.value);
          this.$.outline.importJsonOutlineSchemaItems();
        }
      });
      super.disconnectedCallback();
    }
    /**
     * Switch view
     */


    toggleView(e) {
      this.viewMode = !this.viewMode;
    }
    /**
     * Get the active label
     */


    _getViewLabel(mode) {
      if (mode) {
        this._viewIcon = "icons:view-list";
        return "Outline mode";
      } else {
        this._viewIcon = "icons:code";
        return "Developer mode";
      }
    }
    /**
     * Ensure that data is correct between the outline and advanced view
     */


    _viewModeChanged(newValue, oldValue) {
      // odd I know, but this is the default outline view
      if (!newValue) {
        this.$.outline.importJsonOutlineSchemaItems();
      } else {
        const items = this.$.outline.exportJsonOutlineSchemaItems(true);
        this.set("manifestItems", items);
      }
    }
    /**
     * Save hit, send the message to push up the outline changes.
     */


    _saveTap(e) {
      window.dispatchEvent(new CustomEvent("haxcms-save-outline", {
        bubbles: true,
        composed: true,
        detail: this.$.outline.exportJsonOutlineSchemaItems(true)
      }));
    }

  }

  _exports.HAXCMSOutlineEditorDialog = HAXCMSOutlineEditorDialog;
  window.customElements.define(HAXCMSOutlineEditorDialog.tag, HAXCMSOutlineEditorDialog);
});