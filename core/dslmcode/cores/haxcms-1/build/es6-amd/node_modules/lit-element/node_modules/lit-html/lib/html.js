define(["exports", "./template.js"], function (_exports, _template) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HTMLTemplate = void 0;
  const markerRegex = /{{(.*?)}}/;

  class HTMLTemplate {
    constructor(element) {
      this.parts = [];
      this.element = element;
      let index = -1;
      let partIndex = 0;
      const nodesToRemove = [];
      const walker = document.createTreeWalker(element.content, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);

      while (walker.nextNode()) {
        index++;
        const node = walker.currentNode;

        if (node.nodeType === 1
        /* Node.ELEMENT_NODE */
        ) {
            if (node.hasAttributes()) {
              const attributes = Array.from(node.attributes);

              for (let i = 0; i < attributes.length; i++) {
                const attr = attributes[i];
                const result = attr.value.split(markerRegex);
                console.log('result', result);
                const attributeStrings = result.filter((_, i) => i % 2 === 0); // const exprStrings = result.filter((_, i) => i % 2 === 1);

                console.log('attributeStrings', attributeStrings);

                if (attributeStrings.length > 0) {
                  this.parts.push({
                    type: 'attribute',
                    index,
                    name,
                    strings: attributeStrings
                  });
                  node.removeAttribute(attr.name);
                  partIndex += attributeStrings.length - 1;
                }
              }
            }
          } else if (node.nodeType === 3
        /* Node.TEXT_NODE */
        ) {
            const data = node.data;
            const parent = node.parentNode;
            const result = data.split(markerRegex);
            const strings = result.filter((_, i) => i % 2 === 0);

            if (strings.length > 0) {
              const lastIndex = strings.length - 1; // Generate a new text node for each literal section
              // These nodes are also used as the markers for node parts

              for (let i = 0; i < lastIndex; i++) {
                parent.insertBefore(strings[i] === '' ? (0, _template.createMarker)() : document.createTextNode(strings[i]), node);
                this.parts.push({
                  type: 'node',
                  index: ++index
                });
              } // If there's no text, we must insert a comment to mark our place.
              // Else, we can trust it will stick around after cloning.


              if (strings[lastIndex] === '') {
                parent.insertBefore((0, _template.createMarker)(), node);
                nodesToRemove.push(node);
              } else {
                node.data = strings[lastIndex];
              } // We have a part for each match found


              partIndex += lastIndex;
            }
          }
      }
    }

  }

  _exports.HTMLTemplate = HTMLTemplate;
});