const t=0,e=1,r=2,n={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function isType(t,e){return t.type===e}export function parsePath(s){const a=[],o=function tokenize(n){const s=new Array;for(;""!==n;)if(n.match(/^([ \t\r\n,]+)/))n=n.substr(RegExp.$1.length);else if(n.match(/^([aAcChHlLmMqQsStTvVzZ])/))s[s.length]={type:t,text:RegExp.$1},n=n.substr(RegExp.$1.length);else{if(!n.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];s[s.length]={type:e,text:`${parseFloat(RegExp.$1)}`},n=n.substr(RegExp.$1.length)}return s[s.length]={type:r,text:""},s}(s);let h="BOD",c=0,p=o[c];for(;!isType(p,r);){let t=0;const r=[];if("BOD"===h){if("M"!==p.text&&"m"!==p.text)return parsePath("M0,0"+s);c++,t=n[p.text],h=p.text}else isType(p,e)?t=n[h]:(c++,t=n[p.text],h=p.text);if(!(c+t<o.length))throw new Error("Path data ended short");for(let n=c;n<c+t;n++){const t=o[n];if(!isType(t,e))throw new Error("Param not a number: "+h+","+t.text);r[r.length]=+t.text}if("number"!=typeof n[h])throw new Error("Bad segment: "+h);{const e={key:h,data:r};a.push(e),c+=t,p=o[c],"M"===h&&(h="L"),"m"===h&&(h="l")}}return a}export function serialize(t){const e=[];for(const{key:r,data:n}of t)switch(e.push(r),r){case"C":case"c":e.push(n[0],`${n[1]},`,n[2],`${n[3]},`,n[4],n[5]);break;case"S":case"s":case"Q":case"q":e.push(n[0],`${n[1]},`,n[2],n[3]);break;default:e.push(...n)}return e.join(" ")}