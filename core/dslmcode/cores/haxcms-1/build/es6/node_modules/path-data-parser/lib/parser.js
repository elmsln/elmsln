const t={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function isType(t,e){return t.type===e}export function parsePath(e){const r=[],n=function tokenize(t){const e=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:0,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];e[e.length]={type:1,text:`${parseFloat(RegExp.$1)}`},t=t.substr(RegExp.$1.length)}return e[e.length]={type:2,text:""},e}(e);let s="BOD",a=0,o=n[a];for(;!isType(o,2);){let h=0;const c=[];if("BOD"===s){if("M"!==o.text&&"m"!==o.text)return parsePath("M0,0"+e);a++,h=t[o.text],s=o.text}else isType(o,1)?h=t[s]:(a++,h=t[o.text],s=o.text);if(!(a+h<n.length))throw new Error("Path data ended short");for(let t=a;t<a+h;t++){const e=n[t];if(!isType(e,1))throw new Error("Param not a number: "+s+","+e.text);c[c.length]=+e.text}if("number"!=typeof t[s])throw new Error("Bad segment: "+s);{const t={key:s,data:c};r.push(t),a+=h,o=n[a],"M"===s&&(s="L"),"m"===s&&(s="l")}}return r}export function serialize(t){const e=[];for(const{key:r,data:n}of t)switch(e.push(r),r){case"C":case"c":e.push(n[0],`${n[1]},`,n[2],`${n[3]},`,n[4],n[5]);break;case"S":case"s":case"Q":case"q":e.push(n[0],`${n[1]},`,n[2],n[3]);break;default:e.push(...n)}return e.join(" ")}