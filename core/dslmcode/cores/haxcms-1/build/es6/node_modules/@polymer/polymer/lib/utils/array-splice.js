/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
import"./boot.js";function newSplice(index,removed,addedCount){return{index,removed,addedCount}}const EDIT_LEAVE=0,EDIT_UPDATE=1,EDIT_ADD=2,EDIT_DELETE=3;function calcSplices(current,currentStart,currentEnd,old,oldStart,oldEnd){let splice,prefixCount=0,suffixCount=0,minLength=Math.min(currentEnd-currentStart,oldEnd-oldStart);if(0==currentStart&&0==oldStart&&(prefixCount=function sharedPrefix(current,old,searchLength){for(let i=0;i<searchLength;i++)if(!equals(current[i],old[i]))return i;return searchLength}(current,old,minLength)),currentEnd==current.length&&oldEnd==old.length&&(suffixCount=function sharedSuffix(current,old,searchLength){let index1=current.length,index2=old.length,count=0;for(;count<searchLength&&equals(current[--index1],old[--index2]);)count++;return count}(current,old,minLength-prefixCount)),oldStart+=prefixCount,oldEnd-=suffixCount,(currentEnd-=suffixCount)-(currentStart+=prefixCount)==0&&oldEnd-oldStart==0)return[];if(currentStart==currentEnd){for(splice=newSplice(currentStart,[],0);oldStart<oldEnd;)splice.removed.push(old[oldStart++]);return[splice]}if(oldStart==oldEnd)return[newSplice(currentStart,[],currentEnd-currentStart)];let ops=function spliceOperationsFromEditDistances(distances){let i=distances.length-1,j=distances[0].length-1,current=distances[i][j],edits=[];for(;i>0||j>0;){if(0==i){edits.push(EDIT_ADD),j--;continue}if(0==j){edits.push(EDIT_DELETE),i--;continue}let min,northWest=distances[i-1][j-1],west=distances[i-1][j],north=distances[i][j-1];min=west<north?west<northWest?west:northWest:north<northWest?north:northWest,min==northWest?(northWest==current?edits.push(EDIT_LEAVE):(edits.push(EDIT_UPDATE),current=northWest),i--,j--):min==west?(edits.push(EDIT_DELETE),i--,current=west):(edits.push(EDIT_ADD),j--,current=north)}return edits.reverse(),edits}(function calcEditDistances(current,currentStart,currentEnd,old,oldStart,oldEnd){let rowCount=oldEnd-oldStart+1,columnCount=currentEnd-currentStart+1,distances=new Array(rowCount);for(let i=0;i<rowCount;i++)distances[i]=new Array(columnCount),distances[i][0]=i;for(let j=0;j<columnCount;j++)distances[0][j]=j;for(let i=1;i<rowCount;i++)for(let j=1;j<columnCount;j++)if(equals(current[currentStart+j-1],old[oldStart+i-1]))distances[i][j]=distances[i-1][j-1];else{let north=distances[i-1][j]+1,west=distances[i][j-1]+1;distances[i][j]=north<west?north:west}return distances}(current,currentStart,currentEnd,old,oldStart,oldEnd));splice=void 0;let splices=[],index=currentStart,oldIndex=oldStart;for(let i=0;i<ops.length;i++)switch(ops[i]){case EDIT_LEAVE:splice&&(splices.push(splice),splice=void 0),index++,oldIndex++;break;case EDIT_UPDATE:splice||(splice=newSplice(index,[],0)),splice.addedCount++,index++,splice.removed.push(old[oldIndex]),oldIndex++;break;case EDIT_ADD:splice||(splice=newSplice(index,[],0)),splice.addedCount++,index++;break;case EDIT_DELETE:splice||(splice=newSplice(index,[],0)),splice.removed.push(old[oldIndex]),oldIndex++}return splice&&splices.push(splice),splices}export function calculateSplices(current,previous){return calcSplices(current,0,current.length,previous,0,previous.length)}function equals(currentValue,previousValue){return currentValue===previousValue}