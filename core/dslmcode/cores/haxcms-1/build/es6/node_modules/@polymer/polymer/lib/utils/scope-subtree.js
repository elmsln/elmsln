/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
import"./boot.js";import{wrap}from"./wrap.js";const ShadyDOM=window.ShadyDOM,ShadyCSS=window.ShadyCSS;function sameScope(node,scope){return wrap(node).getRootNode()===scope}export function scopeSubtree(container,shouldObserve=!1){if(!ShadyDOM||!ShadyCSS)return null;if(!ShadyDOM.handlesDynamicScoping)return null;const ScopingShim=ShadyCSS.ScopingShim;if(!ScopingShim)return null;const containerScope=ScopingShim.scopeForNode(container),root=wrap(container).getRootNode(),scopify=node=>{if(!sameScope(node,root))return;const elements=Array.from(ShadyDOM.nativeMethods.querySelectorAll.call(node,"*"));elements.push(node);for(let i=0;i<elements.length;i++){const el=elements[i];if(!sameScope(el,root))continue;const currentScope=ScopingShim.currentScopeForNode(el);currentScope!==containerScope&&(""!==currentScope&&ScopingShim.unscopeNode(el,currentScope),ScopingShim.scopeNode(el,containerScope))}};if(scopify(container),shouldObserve){const mo=new MutationObserver(mxns=>{for(let i=0;i<mxns.length;i++){const mxn=mxns[i];for(let j=0;j<mxn.addedNodes.length;j++){const addedNode=mxn.addedNodes[j];addedNode.nodeType===Node.ELEMENT_NODE&&scopify(addedNode)}}});return mo.observe(container,{childList:!0,subtree:!0}),mo}return null}