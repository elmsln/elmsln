var a=require("assert"),e=require("jszip"),t=require("../lib/zipfile"),n=require("./test")(module);n("file in zip can be read after being written",(function(){return function emptyZipFile(){return(new e).generateAsync({type:"arraybuffer"}).then((function(a){return t.openArrayBuffer(a)}))}().then((function(e){return a(!e.exists("song/title")),e.write("song/title","Dark Blue"),a(e.exists("song/title")),e.read("song/title","utf8").then((function(e){a.equal(e,"Dark Blue")}))}))})),n("splitPath splits zip paths on last forward slash",(function(){a.deepEqual(t.splitPath("a/b"),{dirname:"a",basename:"b"}),a.deepEqual(t.splitPath("a/b/c"),{dirname:"a/b",basename:"c"}),a.deepEqual(t.splitPath("/a/b/c"),{dirname:"/a/b",basename:"c"})})),n("when path has no forward slashes then splitPath returns empty dirname",(function(){a.deepEqual(t.splitPath("name"),{dirname:"",basename:"name"})})),n("joinPath joins arguments with forward slashes",(function(){a.equal(t.joinPath("a","b"),"a/b"),a.equal(t.joinPath("a/b","c"),"a/b/c"),a.equal(t.joinPath("a","b/c"),"a/b/c"),a.equal(t.joinPath("/a/b","c"),"/a/b/c")})),n("empty parts are ignored when joining paths",(function(){a.equal(t.joinPath("a",""),"a"),a.equal(t.joinPath("","b"),"b"),a.equal(t.joinPath("a","","b"),"a/b")})),n("when joining paths then absolute paths ignore earlier paths",(function(){a.equal(t.joinPath("a","/b"),"/b"),a.equal(t.joinPath("a","/b","c"),"/b/c"),a.equal(t.joinPath("/a","/b"),"/b"),a.equal(t.joinPath("/a"),"/a")}));