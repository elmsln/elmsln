var e=require("assert"),t=require("underscore"),o=require("../test")(module),l=require("../../lib/html"),n=require("../../lib/styles/html-paths"),s=l.nonFreshElement,r=l.text;function simplifyNode(e){return l.simplify([e])}function concat(){return t.flatten(arguments,!0)}function pathToNodes(e,t){return e.wrap((function(){return t}))}o("empty text nodes are removed",(function(){e.deepEqual(simplifyNode(r("")),[])})),o("elements with no children are removed",(function(){e.deepEqual(simplifyNode(s("p",{},[])),[])})),o("elements only containing empty nodes are removed",(function(){e.deepEqual(simplifyNode(s("p",{},[r("")])),[])})),o("empty children of element are removed",(function(){e.deepEqual(simplifyNode(s("p",{},[r("Hello"),r("")])),[s("p",{},[r("Hello")])])})),o("successive fresh elements are not collapsed",(function(){var t=n.elements([n.element("p",{},{fresh:!0})]),o=concat(pathToNodes(t,[r("Hello")]),pathToNodes(t,[r(" there")]));e.deepEqual(l.simplify(o),o)})),o("successive plain non-fresh elements are collapsed if they have the same tag name",(function(){var t=n.elements([n.element("p",{},{fresh:!1})]);e.deepEqual(l.simplify(concat(pathToNodes(t,[r("Hello")]),pathToNodes(t,[r(" there")]))),pathToNodes(t,[r("Hello"),r(" there")]))})),o("non-fresh can collapse into preceding fresh element",(function(){var t=n.elements([n.element("p",{},{fresh:!0})]),o=n.elements([n.element("p",{},{fresh:!1})]);e.deepEqual(l.simplify(concat(pathToNodes(t,[r("Hello")]),pathToNodes(o,[r(" there")]))),pathToNodes(t,[r("Hello"),r(" there")]))})),o("children of collapsed element can collapse with children of another collapsed element",(function(){e.deepEqual(l.simplify([s("blockquote",{},[s("p",{},[r("Hello")])]),s("blockquote",{},[s("p",{},[r("there")])])]),[s("blockquote",{},[s("p",{},[r("Hello"),r("there")])])])})),o("empty elements are removed before collapsing",(function(){var t=n.elements([n.element("p",{},{fresh:!0})]),o=n.elements([n.element("p",{},{fresh:!1})]);e.deepEqual(l.simplify(concat(pathToNodes(o,[r("Hello")]),pathToNodes(t,[]),pathToNodes(o,[r(" there")]))),pathToNodes(o,[r("Hello"),r(" there")]))})),o("when separator is present then separator is prepended to collapsed element",(function(){var t=n.elements([n.element("pre",{},{fresh:!1})]),o=n.elements([n.element("pre",{},{fresh:!1,separator:"\n"})]);e.deepEqual(l.simplify(concat(pathToNodes(t,[r("Hello")]),pathToNodes(o,[r(" the"),r("re")]))),pathToNodes(t,[r("Hello"),r("\n"),r(" the"),r("re")]))}));