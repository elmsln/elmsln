/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
import{nativeShadow,nativeCssVariables,cssBuild}from"./style-settings.js";import{parse,stringify,types,StyleNode}from"./css-parse.js";import{MEDIA_MATCH}from"./common-regex.js";import{processUnscopedStyle,isUnscopedStyle}from"./unscoped-style-handler.js";export function toCssText(rules,callback){return rules?("string"==typeof rules&&(rules=parse(rules)),callback&&forEachRule(rules,callback),stringify(rules,nativeCssVariables)):""}export function rulesForStyle(style){return!style.__cssRules&&style.textContent&&(style.__cssRules=parse(style.textContent)),style.__cssRules||null}export function isKeyframesSelector(rule){return Boolean(rule.parent)&&rule.parent.type===types.KEYFRAMES_RULE}export function forEachRule(node,styleRuleCallback,keyframesRuleCallback,onlyActiveRules){if(!node)return;let skipRules=!1,type=node.type;if(onlyActiveRules&&type===types.MEDIA_RULE){let matchMedia=node.selector.match(MEDIA_MATCH);matchMedia&&(window.matchMedia(matchMedia[1]).matches||(skipRules=!0))}type===types.STYLE_RULE?styleRuleCallback(node):keyframesRuleCallback&&type===types.KEYFRAMES_RULE?keyframesRuleCallback(node):type===types.MIXIN_RULE&&(skipRules=!0);let r$=node.rules;if(r$&&!skipRules)for(let r,i=0,l=r$.length;i<l&&(r=r$[i]);i++)forEachRule(r,styleRuleCallback,keyframesRuleCallback,onlyActiveRules)}export function applyCss(cssText,moniker,target,contextNode){let style=createScopeStyle(cssText,moniker);return applyStyle(style,target,contextNode),style}export function createScopeStyle(cssText,moniker){let style=document.createElement("style");return moniker&&style.setAttribute("scope",moniker),style.textContent=cssText,style}let lastHeadApplyNode=null;export function applyStylePlaceHolder(moniker){let placeHolder=document.createComment(" Shady DOM styles for "+moniker+" "),after=lastHeadApplyNode?lastHeadApplyNode.nextSibling:null,scope=document.head;return scope.insertBefore(placeHolder,after||scope.firstChild),lastHeadApplyNode=placeHolder,placeHolder}export function applyStyle(style,target,contextNode){target=target||document.head;let after=contextNode&&contextNode.nextSibling||target.firstChild;if(target.insertBefore(style,after),lastHeadApplyNode){style.compareDocumentPosition(lastHeadApplyNode)===Node.DOCUMENT_POSITION_PRECEDING&&(lastHeadApplyNode=style)}else lastHeadApplyNode=style}export function isTargetedBuild(buildType){return nativeShadow?"shadow"===buildType:"shady"===buildType}export function findMatchingParen(text,start){let level=0;for(let i=start,l=text.length;i<l;i++)if("("===text[i])level++;else if(")"===text[i]&&0==--level)return i;return-1}export function processVariableAndFallback(str,callback){let start=str.indexOf("var(");if(-1===start)return callback(str,"","","");let end=findMatchingParen(str,start+3),inner=str.substring(start+4,end),prefix=str.substring(0,start),suffix=processVariableAndFallback(str.substring(end+1),callback),comma=inner.indexOf(",");return-1===comma?callback(prefix,inner.trim(),"",suffix):callback(prefix,inner.substring(0,comma).trim(),inner.substring(comma+1).trim(),suffix)}export function setElementClassRaw(element,value){nativeShadow?element.setAttribute("class",value):window.ShadyDOM.nativeMethods.setAttribute.call(element,"class",value)}export const wrap=window.ShadyDOM&&window.ShadyDOM.wrap||(node=>node);export function getIsExtends(element){let localName=element.localName,is="",typeExtension="";return localName?localName.indexOf("-")>-1?is=localName:(typeExtension=localName,is=element.getAttribute&&element.getAttribute("is")||""):(is=element.is,typeExtension=element.extends),{is:is,typeExtension:typeExtension}}export function gatherStyleText(element){const styleTextParts=[],styles=element.querySelectorAll("style");for(let i=0;i<styles.length;i++){const style=styles[i];isUnscopedStyle(style)?nativeShadow||(processUnscopedStyle(style),style.parentNode.removeChild(style)):(styleTextParts.push(style.textContent),style.parentNode.removeChild(style))}return styleTextParts.join("").trim()}export function splitSelectorList(selector){const parts=[];let part="";for(let i=0;i>=0&&i<selector.length;i++)if("("===selector[i]){const end=findMatchingParen(selector,i);part+=selector.slice(i,end+1),i=end}else","===selector[i]?(parts.push(part),part=""):part+=selector[i];return part&&parts.push(part),parts}const CSS_BUILD_ATTR="css-build";export function getCssBuild(element){if(void 0!==cssBuild)return cssBuild;if(void 0===element.__cssBuild){const attrValue=element.getAttribute(CSS_BUILD_ATTR);if(attrValue)element.__cssBuild=attrValue;else{const buildComment=getBuildComment(element);""!==buildComment&&function removeBuildComment(element){const buildComment="template"===element.localName?element.content.firstChild:element.firstChild;buildComment.parentNode.removeChild(buildComment)}(element),element.__cssBuild=buildComment}}return element.__cssBuild||""}export function elementHasBuiltCss(element){return""!==getCssBuild(element)}export function getBuildComment(element){const buildComment="template"===element.localName?element.content.firstChild:element.firstChild;if(buildComment instanceof Comment){const commentParts=buildComment.textContent.trim().split(":");if(commentParts[0]===CSS_BUILD_ATTR)return commentParts[1]}return""}export function isOptimalCssBuild(cssBuild=""){return!(""===cssBuild||!nativeCssVariables)&&(nativeShadow?"shadow"===cssBuild:"shady"===cssBuild)}