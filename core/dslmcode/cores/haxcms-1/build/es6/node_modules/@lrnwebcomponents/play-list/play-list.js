/**
 * Copyright 2023
 * @license , see License.md for full text.
 */
import{LitElement as t,html as e,css as i,nothing as s}from"../../lit/index.js";import{unsafeHTML as a}from"../../lit/directives/unsafe-html.js";import"../../@shoelace-style/shoelace/dist/components/carousel/carousel.js";import"../../@shoelace-style/shoelace/dist/components/carousel-item/carousel-item.js";import{generateStyleLinkEls as r}from"./lib/SLStyleManager.js";import{haxElementToNode as o,nodeToHaxElement as l}from"../utils/utils.js";class PlayList extends t{constructor(){super(),r(),this.items=[],this.navigation=!0,this.pagination=!0,this.aspectRatio="16:9",this.slide=0,this.orientation="horizontal",this._observer=new MutationObserver((t=>{clearTimeout(this._debounceMutations),this._debounceMutations=setTimeout((()=>{this.mirrorLightDomToItems()}),100)})),this._observer.observe(this,{childList:!0,subtree:!0})}async mirrorLightDomToItems(){let t=Array.from(this.children);1===t.length&&"TEMPLATE"===t[0].tagName&&(t=Array.from(t[0].children)),0!==t.length?await Promise.all(t.map((async t=>await l(t)))).then((t=>{this.items=t})):this.items=[]}renderHAXItem(t){return t.properties.innerHTML&&delete t.properties.innerHTML,e`${a(o(t).outerHTML)}`}static get haxProperties(){return new URL(`./lib/${this.tag}.haxProperties.json`,import.meta.url).href}disconnectedCallback(){this._linkEls&&(document.head.removeChild(this._linkEls[0]),document.head.removeChild(this._linkEls[1])),super.disconnectedCallback()}static get properties(){return{items:{type:Array},navigation:{type:Boolean,reflect:!0},pagination:{type:Boolean,reflect:!0},aspectRatio:{type:String,reflect:!0,attribute:"aspect-ratio"},orientation:{type:String,reflect:!0},slide:{type:Number,reflect:!0}}}static get styles(){let t=[];return super.styles&&(t=super.styles),[...t,i`
        :host {
          display: block;
        }
        :host([orientation="vertical"]),
        :host([orientation="vertical"]) .carousel,
        :host([orientation="vertical"]) .carousel .item {
          max-height: 400px;
        }
        :host([orientation="vertical"]) .carousel .item video-player {
          max-height: 400px;
          width: 500px;
        }

        :host .carousel .item .play-list-item {
          width: 100%;
          min-height: 400px;
        }

        :host([orientation="vertical"]) .carousel::part(base) {
          grid-template-areas: "slides slides pagination";
        }
        :host([orientation="vertical"]) .carousel::part(pagination) {
          flex-direction: column;
        }

        :host([orientation="vertical"]) .carousel::part(navigation) {
          transform: rotate(90deg);
          display: flex;
        }
        sl-carousel-item {
          max-height: 400px;
          overflow-y: auto;
          justify-content: unset;
        }
      `]}render(){return e`
      ${this.items.length>0?e`
            <sl-carousel
              ?navigation="${this.navigation&&"horizontal"===this.orientation}"
              ?pagination="${this.pagination}"
              orientation="${this.orientation}"
              @sl-slide-change="${this.slideIndexChanged}"
              class="carousel"
              style="--aspect-ratio: ${this.aspectRatio};"
            >
              ${this.items.map(((t,i)=>e`
                  <sl-carousel-item class="item">
                    ${this.renderHAXItem(t)}
                  </sl-carousel-item>
                `))}
            </sl-carousel>
          `:s}
    `}slideIndexChanged(t){this.slide=t.detail.index}static get tag(){return"play-list"}firstUpdated(t){super.firstUpdated&&super.firstUpdated(t),this.mirrorLightDomToItems()}updated(t){super.updated&&super.updated(t),t.forEach(((t,e)=>{"slide"==e&&this.shadowRoot&&void 0!==t&&(this.dispatchEvent(new CustomEvent(`${e}-changed`,{detail:{value:this[e]}})),this.shadowRoot.querySelector(".carousel").activeSlide,this[e])}))}}customElements.define(PlayList.tag,PlayList);export{PlayList};