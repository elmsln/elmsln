{"version":3,"file":"Layout.js","sourceRoot":"","sources":["../../src/layouts/shared/Layout.ts"],"names":[],"mappings":"AAAA;;;;GAIG","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport type dimension = 'height' | 'width';\nexport type Size = {\n  [key in dimension]: number;\n};\n\nexport type margin =\n  | 'marginTop'\n  | 'marginRight'\n  | 'marginBottom'\n  | 'marginLeft';\n\nexport type Margins = {\n  [key in margin]: number;\n};\n\nexport type ItemBox = Size | (Size & Margins);\n\nexport type position = 'left' | 'top';\nexport type offset = 'top' | 'right' | 'bottom' | 'left';\nexport type offsetAxis = 'xOffset' | 'yOffset';\n\n// TODO (graynorton@): This has become a bit of a\n// grab-bag. It might make sense to let each layout define\n// its own type and provide its own implementation of\n// `positionChildren()` that knows how to translate the\n// provided fields into the appropriate DOM manipulations.\nexport type Positions = {\n  left: number;\n  top: number;\n  width?: number;\n  height?: number;\n  xOffset?: number;\n  yOffset?: number;\n};\n\nexport interface Range {\n  first: number;\n  last: number;\n}\nexport interface InternalRange extends Range {\n  firstVisible: number;\n  lastVisible: number;\n}\n\nexport interface StateChangedMessage {\n  type: 'stateChanged';\n  scrollSize: Size;\n  range: InternalRange;\n  childPositions: ChildPositions;\n  scrollError?: Positions;\n}\n\nexport interface VisibilityChangedMessage {\n  type: 'visibilityChanged';\n  firstVisible: number;\n  lastVisible: number;\n}\n\nexport interface UnpinnedMessage {\n  type: 'unpinned';\n}\n\nexport type LayoutHostMessage =\n  | StateChangedMessage\n  | UnpinnedMessage\n  | VisibilityChangedMessage;\n\nexport type LayoutHostSink = (message: LayoutHostMessage) => void;\n\nexport type ChildPositions = Map<number, Positions>;\n\nexport type ChildMeasurements = {[key: number]: ItemBox};\n\nexport type MeasureChildFunction = <T>(element: Element, item: T) => ItemBox;\n\nexport interface PinOptions {\n  index: number;\n  block?: ScrollLogicalPosition;\n}\n\nexport type LayoutConstructor = new (\n  sink: LayoutHostSink,\n  config?: object\n) => Layout;\n\nexport interface LayoutSpecifier {\n  type: LayoutConstructor;\n}\n\nexport type LayoutSpecifierFactory = (config?: object) => LayoutSpecifier;\n\nexport interface BaseLayoutConfig {\n  direction?: ScrollDirection;\n  pin?: PinOptions;\n}\n\nexport type LayoutConfigValue = LayoutSpecifier | BaseLayoutConfig;\n\nexport interface ScrollToCoordinates {\n  top?: number;\n  left?: number;\n}\n\nexport type ScrollDirection = 'vertical' | 'horizontal';\n\n/**\n * Interface for layouts consumed by Virtualizer.\n */\nexport interface Layout {\n  config?: object;\n\n  items: unknown[];\n\n  direction: ScrollDirection;\n\n  viewportSize: Size;\n\n  viewportScroll: Positions;\n\n  totalScrollSize: Size;\n\n  offsetWithinScroller: Positions;\n\n  readonly measureChildren?: boolean | MeasureChildFunction;\n\n  readonly listenForChildLoadEvents?: boolean;\n\n  updateItemSizes?: (sizes: ChildMeasurements) => void;\n\n  pin: PinOptions | null;\n\n  unpin: Function;\n\n  getScrollIntoViewCoordinates: (options: PinOptions) => ScrollToCoordinates;\n\n  /**\n   * Called by a Virtualizer when an update that\n   * potentially affects layout has occurred. For example, a viewport size\n   * change.\n   *\n   * The layout is in turn responsible for dispatching events, as necessary,\n   * to the Virtualizer. Each of the following events\n   * represents an update that should be determined during a reflow. Dispatch\n   * each event at maximum once during a single reflow.\n   *\n   * Events that should be dispatched:\n   * - scrollsizechange\n   *     Dispatch when the total length of all items in the scrolling direction,\n   *     including spacing, changes.\n   *     detail: {\n   *       'height' | 'width': number\n   *     }\n   * - rangechange\n   *     Dispatch when the range of children that should be displayed changes.\n   *     detail: {\n   *       first: number,\n   *       last: number,\n   *       num: number,\n   *       stable: boolean,\n   *       remeasure: boolean,\n   *       firstVisible: number,\n   *       lastVisible: number,\n   *     }\n   * - itempositionchange\n   *     Dispatch when the child positions change, for example due to a range\n   *     change.\n   *     detail {\n   *       [number]: {\n   *         left: number,\n   *         top: number\n   *       }\n   *     }\n   * - scrollerrorchange\n   *     Dispatch when the set viewportScroll offset is not what it should be.\n   *     detail {\n   *       height: number,\n   *       width: number,\n   *     }\n   */\n  reflowIfNeeded: (force?: boolean) => void;\n}\n"]}