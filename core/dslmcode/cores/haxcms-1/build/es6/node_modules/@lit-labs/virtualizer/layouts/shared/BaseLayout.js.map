{"version":3,"file":"BaseLayout.js","sourceRoot":"","sources":["../../src/layouts/shared/BaseLayout.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  Layout,\n  ChildPositions,\n  Positions,\n  ScrollDirection,\n  Size,\n  dimension,\n  position,\n  PinOptions,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  StateChangedMessage,\n  LayoutHostSink,\n} from './Layout.js';\n\ntype UpdateVisibleIndicesOptions = {\n  emit?: boolean;\n};\n\nexport function dim1(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\n\nexport function dim2(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\n\nexport function pos1(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\n\nexport function pos2(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\n\nexport abstract class BaseLayout<C extends BaseLayoutConfig> implements Layout {\n  /**\n   * The last set viewport scroll position.\n   */\n  private _latestCoords: Positions = {left: 0, top: 0};\n\n  /**\n   * Scrolling direction.\n   */\n  private _direction: ScrollDirection | null = null;\n\n  /**\n   * Dimensions of the viewport.\n   */\n  private _viewportSize: Size = {width: 0, height: 0};\n\n  public totalScrollSize: Size = {width: 0, height: 0};\n\n  public offsetWithinScroller: Positions = {left: 0, top: 0};\n\n  /**\n   * Flag for debouncing asynchronous reflow requests.\n   */\n  private _pendingReflow = false;\n\n  private _pendingLayoutUpdate = false;\n\n  protected _pin: PinOptions | null = null;\n\n  /**\n   * The index of the first item intersecting the viewport.\n   */\n  protected _firstVisible = 0;\n\n  /**\n   * The index of the last item intersecting the viewport.\n   */\n  protected _lastVisible = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the first child.\n   */\n  protected _physicalMin = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the last child.\n   */\n  protected _physicalMax = 0;\n\n  /**\n   * Index of the first child.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child.\n   */\n  protected _last = -1;\n\n  /**\n   * Length in the scrolling direction.\n   */\n  protected _sizeDim: dimension = 'height';\n\n  /**\n   * Length in the non-scrolling direction.\n   */\n  protected _secondarySizeDim: dimension = 'width';\n\n  /**\n   * Position in the scrolling direction.\n   */\n  protected _positionDim: position = 'top';\n\n  /**\n   * Position in the non-scrolling direction.\n   */\n  protected _secondaryPositionDim: position = 'left';\n\n  /**\n   * Current scroll offset in pixels.\n   */\n  protected _scrollPosition = 0;\n\n  /**\n   * Difference between current scroll offset and scroll offset calculated due\n   * to a reflow.\n   */\n  protected _scrollError = 0;\n\n  /**\n   * Total number of items that could possibly be displayed. Used to help\n   * calculate the scroll size.\n   */\n  protected _items: unknown[] = [];\n\n  /**\n   * The total (estimated) length of all items in the scrolling direction.\n   */\n  protected _scrollSize = 1;\n\n  /**\n   * Number of pixels beyond the viewport to still include\n   * in the active range of items.\n   */\n  // TODO (graynorton): Probably want to make this something we calculate based\n  // on viewport size, item size, other factors, possibly still with a dial of some kind\n  protected _overhang = 1000;\n\n  /**\n   * Call this to deliver messages (e.g. stateChanged, unpinned) to host\n   */\n  private _hostSink: LayoutHostSink;\n\n  protected _getDefaultConfig(): C {\n    return {\n      direction: 'vertical',\n    } as C;\n  }\n\n  constructor(hostSink: LayoutHostSink, config?: C) {\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(\n      () => (this.config = config || this._getDefaultConfig())\n    );\n  }\n\n  set config(config: C) {\n    Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n  }\n\n  get config(): C {\n    return {\n      direction: this.direction,\n    } as C;\n  }\n\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items(): unknown[] {\n    return this._items;\n  }\n\n  set items(items: unknown[]) {\n    this._setItems(items);\n  }\n\n  protected _setItems(items: unknown[]) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n\n  /**\n   * Primary scrolling direction.\n   */\n  get direction(): ScrollDirection {\n    return this._direction!;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize(): Size {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {_viewDim1, _viewDim2} = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll(): Positions {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n\n  set pin(options: PinOptions | null) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n\n  get pin() {\n    if (this._pin !== null) {\n      const {index, block} = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block,\n      };\n    }\n    return null;\n  }\n\n  _clampScrollPosition(val: number) {\n    return Math.max(\n      -this.offsetWithinScroller[this._positionDim],\n      Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1)\n    );\n  }\n\n  unpin() {\n    if (this._pin !== null) {\n      this._sendUnpinnedMessage();\n      this._pin = null;\n    }\n  }\n\n  /**\n   * Get the top and left positioning of the item at idx.\n   */\n  protected abstract _getItemPosition(idx: number): Positions;\n\n  /**\n   * Update _first and _last based on items that should be in the current\n   * range.\n   */\n  protected abstract _getActiveItems(): void;\n\n  protected abstract _getItemSize(_idx: number): Size;\n\n  /**\n   * Calculates (precisely or by estimating, if needed) the total length of all items in\n   * the scrolling direction, including spacing, caching the value in the `_scrollSize` field.\n   *\n   * Should return a minimum value of 1 to ensure at least one item is rendered.\n   * TODO (graynorton): Possibly no longer required, but leaving here until it can be verified.\n   */\n  protected abstract _updateScrollSize(): void;\n\n  protected _updateLayout(): void {\n    // Override\n  }\n\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  protected get _viewDim1(): number {\n    return this._viewportSize[this._sizeDim];\n  }\n\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  protected get _viewDim2(): number {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  protected _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  protected _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  protected _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n\n  protected _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._sendStateChangedMessage();\n  }\n\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  protected _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {index, block} = this.pin;\n      this._scrollPosition =\n        this._calculateScrollIntoViewPosition({\n          index,\n          block: block || 'start',\n        }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  protected _calculateScrollIntoViewPosition(options: PinOptions) {\n    const {block} = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition =\n          itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition =\n            Math.abs(currentScrollPosition - itemStartPosition) <\n            Math.abs(currentScrollPosition - itemEndPosition)\n              ? itemStartPosition\n              : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n\n  public getScrollIntoViewCoordinates(\n    options: PinOptions\n  ): ScrollToCoordinates {\n    return {\n      [this._positionDim as position]:\n        this._calculateScrollIntoViewPosition(options),\n    } as ScrollToOptions;\n  }\n\n  private _sendUnpinnedMessage() {\n    this._hostSink({\n      type: 'unpinned',\n    });\n  }\n\n  private _sendVisibilityChangedMessage() {\n    this._hostSink({\n      type: 'visibilityChanged',\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible,\n    });\n  }\n\n  protected _sendStateChangedMessage() {\n    const childPositions: ChildPositions = new Map();\n    if (this._first !== -1 && this._last !== -1) {\n      for (let idx = this._first; idx <= this._last; idx++) {\n        childPositions.set(idx, this._getItemPosition(idx));\n      }\n    }\n    const message: StateChangedMessage = {\n      type: 'stateChanged',\n      scrollSize: {\n        [this._sizeDim]: this._scrollSize,\n        [this._secondarySizeDim]: null,\n      } as Size,\n      range: {\n        first: this._first,\n        last: this._last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible,\n      },\n      childPositions,\n    };\n    if (this._scrollError) {\n      message.scrollError = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0,\n      } as Positions;\n      this._scrollError = 0;\n    }\n    this._hostSink(message);\n  }\n\n  /**\n   * Number of items to display.\n   */\n  private get _num(): number {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n\n  private _checkThresholds() {\n    if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(\n        this._scrollSize,\n        this._scrollPosition + this._viewDim1 + this._overhang\n      );\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      } else {\n        this._updateVisibleIndices({emit: true});\n      }\n    }\n  }\n\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  protected _updateVisibleIndices(options?: UpdateVisibleIndicesOptions) {\n    if (this._first === -1 || this._last === -1) return;\n\n    let firstVisible = this._first;\n    while (\n      firstVisible < this._last &&\n      Math.round(\n        this._getItemPosition(firstVisible)[this._positionDim] +\n          this._getItemSize(firstVisible)[this._sizeDim]\n      ) <= Math.round(this._scrollPosition)\n    ) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n    while (\n      lastVisible > this._first &&\n      Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n        Math.round(this._scrollPosition + this._viewDim1)\n    ) {\n      lastVisible--;\n    }\n\n    if (\n      firstVisible !== this._firstVisible ||\n      lastVisible !== this._lastVisible\n    ) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._sendVisibilityChangedMessage();\n      }\n    }\n  }\n}\n"]}