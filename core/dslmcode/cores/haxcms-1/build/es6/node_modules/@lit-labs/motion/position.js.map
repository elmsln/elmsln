{"version":3,"file":"position.js","sources":["src/position.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {LitElement} from 'lit';\nimport {nothing, AttributePart} from 'lit/html.js';\nimport {directive, PartInfo, PartType} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\n\ninterface Positionables {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n}\n\ntype Ref = {value: HTMLElement};\nexport type TargetCallbackOrRef = (() => HTMLElement) | Ref;\n\nexport type Positions = Array<keyof Positionables>;\n\nconst positionedPoints = ['top', 'right', 'bottom', 'left'];\n\nexport class Position extends AsyncDirective {\n  private _host?: LitElement;\n  private _element?: Element;\n  private _targetCallbackOrRef!: TargetCallbackOrRef;\n  private _positions?: Positions;\n\n  constructor(part: PartInfo) {\n    super(part);\n    if (part.type !== PartType.ELEMENT) {\n      throw new Error(\n        'The `position` directive must be used in attribute position.'\n      );\n    }\n  }\n\n  render(_targetCallbackOrRef: TargetCallbackOrRef, _positions: Positions) {\n    return nothing;\n  }\n\n  override update(\n    part: AttributePart,\n    [target, positions]: Parameters<this['render']>\n  ) {\n    if (this._host === undefined) {\n      this._host = part.options?.host as LitElement;\n      this._host.addController(this);\n    }\n    this._element = part.element;\n    this._targetCallbackOrRef = target;\n    this._positions = positions ?? ['left', 'top', 'width', 'height'];\n    return this.render(target, positions);\n  }\n\n  hostUpdated() {\n    this._position();\n  }\n\n  private _position() {\n    const target =\n      typeof this._targetCallbackOrRef === 'function'\n        ? this._targetCallbackOrRef()\n        : this._targetCallbackOrRef?.value;\n    const parent = target.offsetParent;\n    if (target === undefined || !parent) {\n      return;\n    }\n    const tr = target.getBoundingClientRect();\n    const pr = parent.getBoundingClientRect();\n    this._positions?.forEach((p) => {\n      const x = positionedPoints.includes(p) ? tr[p] - pr[p] : tr[p];\n      (this._element as HTMLElement).style[p] = `${x}px`;\n    });\n  }\n}\n\n/**\n * Positions and sizes the element on which the `position()` directive is used\n * relative to the given target element.\n */\nexport const position = directive(Position);\n"],"names":["positionedPoints","Position","AsyncDirective","constructor","part","super","type","PartType","ELEMENT","Error","render","_targetCallbackOrRef","_positions","nothing","update","target","positions","undefined","this","_host","options","host","addController","_element","element","hostUpdated","_position","value","parent","offsetParent","tr","getBoundingClientRect","pr","forEach","p","x","includes","style","position","directive"],"mappings":"yJAwBA,MAAMA,EAAmB,CAAC,MAAO,QAAS,SAAU,QAE9C,MAAOC,UAAiBC,EAM5B,WAAAC,CAAYC,GAEV,GADAC,MAAMD,GACFA,EAAKE,OAASC,EAASC,QACzB,MAAUC,MACR,+DAGL,CAED,MAAAC,CAAOC,EAA2CC,GAChD,OAAOC,CACR,CAEQ,MAAAC,CACPV,GACCW,EAAQC,IAST,YAPmBC,IAAfC,KAAKC,IACPD,KAAKC,EAAQf,EAAKgB,SAASC,KAC3BH,KAAKC,EAAMG,cAAcJ,OAE3BA,KAAKK,EAAWnB,EAAKoB,QACrBN,KAAKP,EAAuBI,EAC5BG,KAAKN,EAAaI,GAAa,CAAC,OAAQ,MAAO,QAAS,UACjDE,KAAKR,OAAOK,EAAQC,EAC5B,CAED,WAAAS,GACEP,KAAKQ,GACN,CAEO,CAAAA,GACN,MAAMX,EACiC,mBAA9BG,KAAKP,EACRO,KAAKP,IACLO,KAAKP,GAAsBgB,MAC3BC,EAASb,EAAOc,aACtB,QAAeZ,IAAXF,IAAyBa,EAC3B,OAEF,MAAME,EAAKf,EAAOgB,wBACZC,EAAKJ,EAAOG,wBAClBb,KAAKN,GAAYqB,SAASC,IACxB,MAAMC,EAAInC,EAAiBoC,SAASF,GAAKJ,EAAGI,GAAKF,EAAGE,GAAKJ,EAAGI,GAC3DhB,KAAKK,EAAyBc,MAAMH,GAAQC,EAAH,IAAQ,GAErD,QAOUG,EAAWC,EAAUtC"}