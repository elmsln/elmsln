import{authState as e,assertAuthTokens as t}from"./internal/auth-state.js";import{formatFileSystemTree as r}from"./util.js";import{PreviewMessageType as n}from"./preview-message-types.js";import{Comlink as s}from"./vendor/index.js";import{auth as i}from"./internal/auth-state.js";import{addAccessTokenChangedListener as o}from"./internal/tokens.js";import{iframeSettings as a}from"./internal/iframe-url.js";import{isPreviewMessage as c}from"./utils.js";export const auth=i;export{n as PreviewMessageType};export*from"./utils.js";let l=null,h=null,u={};const d=new TextDecoder,w=new TextEncoder;export class WebContainer{_instance;_runtimeInfo;fs;static _instance=null;_tornDown=!1;_unsubscribeFromTokenChangedListener=()=>{};constructor(r,n,s){this._instance=r,this._runtimeInfo=s,this.fs=new FileSystemAPIClient(n);e.initialized&&(this._unsubscribeFromTokenChangedListener=o((t=>{this._instance.setCredentials({accessToken:t,editorOrigin:e.editorOrigin})})),(async()=>{await e.authComplete.promise,this._tornDown||(t(e.tokens),await this._instance.setCredentials({accessToken:e.tokens.access,editorOrigin:e.editorOrigin}))})().catch((e=>{console.error(e)})))}async spawn(e,t,r){let n,s=[];Array.isArray(t)?s=t:r=t;let i,o,a=new ReadableStream;if(!1!==r?.output){const e=function streamWithPush(){let e=null;const t=new ReadableStream({start(t){e=t}});return{stream:t,push:t=>{null!=t?e?.enqueue(t):(e?.close(),e=null)}}}();n=e.push,a=e.stream}const c=proxyListener(binaryListener(n)),l=proxyListener(binaryListener(i)),h=proxyListener(binaryListener(o)),u=await this._instance.run({command:e,args:s,cwd:r?.cwd,env:r?.env,terminal:r?.terminal},l,h,c);return new WebContainerProcessImpl(u,a,undefined,undefined)}on(e,t){if("preview-message"===e){const e=t;t=t=>{c(t)&&e(t)}}const{listener:r,subscribe:n}=function syncSubscription(e){let t=!1,unsubscribe=()=>{};const wrapped=(...r)=>{t||e(...r)};return{subscribe:e=>(e.then((e=>{unsubscribe=e,t&&unsubscribe()})),()=>{t=!0,unsubscribe()}),listener:wrapped}}(t);return n(this._instance.on(e,s.proxy(r)))}mount(e,t){const n=e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):w.encode(JSON.stringify(r(e)));return this._instance.loadFiles(s.transfer(n,[n.buffer]),{mountPoints:t?.mountPoint})}get path(){return this._runtimeInfo.path}get workdir(){return this._runtimeInfo.cwd}teardown(){if(this._tornDown)throw new Error("WebContainer already torn down");this._tornDown=!0,this._unsubscribeFromTokenChangedListener(),this.fs._teardown(),this._instance.teardown(),this._instance[s.releaseProxy](),WebContainer._instance===this&&(WebContainer._instance=null)}static async boot(t={}){const{workdirName:r}=t;if(window.crossOriginIsolated&&"none"===t.coep&&console.warn("A Cross-Origin-Embedder-Policy header is required in cross origin isolated environments.\nSet the 'coep' option to 'require-corp'."),r?.includes("/")||".."===r||"."===r)throw new Error("workdirName should be a valid folder name");for(e.bootCalled=!0;l;)await l;if(WebContainer._instance)throw new Error("Only a single WebContainer instance can be booted");const n=async function unsynchronizedBoot(e){const{serverPromise:t}=function serverFactory(e){if(null!=h)return e.coep!==u.coep&&(console.warn(`Attempting to boot WebContainer with 'coep: ${e.coep}'`),console.warn(`First boot had 'coep: ${u.coep}', new settings will not take effect!`)),{serverPromise:h};const t=document.createElement("iframe");t.style.display="none",t.setAttribute("allow","cross-origin-isolated");const r=a.url;e.coep&&r.searchParams.set("coep",e.coep);t.src=r.toString();const{origin:n}=r;return u={...e},h=new Promise((e=>{const onMessage=t=>{if(t.origin!==n)return;const{data:r}=t;"init"!==r.type?"warning"!==r.type||console[r.level].call(console,r.message):e(s.wrap(t.ports[0]))};window.addEventListener("message",onMessage)})),document.body.insertBefore(t,null),{serverPromise:h}}(e),r=await t,n=await r.build({host:window.location.host,version:"1.3.0",workdirName:e.workdirName,forwardPreviewErrors:e.forwardPreviewErrors}),i=await n.fs(),o=await n.runtimeInfo();return new WebContainer(n,i,o)}(t);l=n.catch((()=>{}));try{const e=await n;return WebContainer._instance=e,e}finally{l=null}}}export function configureAPIKey(t){if(e.bootCalled)throw new Error("`configureAPIKey` should always be called before `WebContainer.boot`");a.setQueryParam("client_id",t)}class DirEntImpl{name;_type;constructor(e,t){this.name=e,this._type=t}isFile(){return 1===this._type}isDirectory(){return 2===this._type}}class FSWatcher{_apiClient;_path;_options;_listener;_wrappedListener;_watcher;_closed=!1;constructor(e,t,r,n){this._apiClient=e,this._path=t,this._options=r,this._listener=n,this._apiClient._watchers.add(this),this._wrappedListener=(e,t)=>{this._listener&&!this._closed&&this._listener(e,t)},this._apiClient._fs.watch(this._path,this._options,proxyListener(this._wrappedListener)).then((e=>{this._watcher=e,this._closed&&this._teardown()})).catch(console.error)}close(){this._closed||(this._closed=!0,this._apiClient._watchers.delete(this),this._teardown())}_teardown(){this._watcher?.close().finally((()=>{this._watcher?.[s.releaseProxy]()}))}}class WebContainerProcessImpl{output;input;exit;_process;stdout;stderr;constructor(e,t,r,n){this.output=t,this._process=e,this.input=new WritableStream({write:e=>{this._getProcess()?.write(e).catch((()=>{}))}}),this.exit=this._onExit(),this.stdout=r,this.stderr=n}kill(){this._getProcess()?.kill()}resize(e){this._getProcess()?.resize(e)}async _onExit(){try{return await this._process.onExit}finally{this._process?.[s.releaseProxy](),this._process=null}}_getProcess(){return null==this._process&&console.warn("This process already exited"),this._process}}class FileSystemAPIClient{_fs;_watchers=new Set([]);constructor(e){this._fs=e}rm(...e){return this._fs.rm(...e)}async readFile(e,t){return await this._fs.readFile(e,t)}async rename(e,t){return await this._fs.rename(e,t)}async writeFile(e,t,r){if(t instanceof Uint8Array){const e=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength);t=s.transfer(new Uint8Array(e),[e])}await this._fs.writeFile(e,t,r)}async readdir(e,t){const r=await this._fs.readdir(e,t);if(function isStringArray(e){return"string"==typeof e[0]}(r))return r;if(function isTypedArrayCollection(e){return e[0]instanceof Uint8Array}(r))return r;return r.map((e=>new DirEntImpl(e.name,e["Symbol(type)"])))}async mkdir(e,t){return await this._fs.mkdir(e,t)}watch(e,t,r){return"function"==typeof t&&(r=t,t=null),new FSWatcher(this,e,t,r)}_teardown(){this._fs[s.releaseProxy]();for(const e of this._watchers)e.close()}}function binaryListener(e){if(null!=e)return t=>{t instanceof Uint8Array?e(d.decode(t)):null==t&&e(null)}}function proxyListener(e){if(null!=e)return s.proxy(e)}