import{noChange as e,_$LH as t}from"./lit-html.js";import{PartType as r}from"./directive.js";import{isPrimitive as n,isTemplateResult as a,isSingleExpression as i}from"./directive-helpers.js";
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{D:l,V:o,I:s,H:d,W:c}=t,f=(e,t,r={})=>{if(void 0!==t._$litPart$)throw Error("container already contains a live render");let n,a;const i=[],l=document.createTreeWalker(t,NodeFilter.SHOW_COMMENT,null,!1);let o;for(;null!==(o=l.nextNode());){const t=o.data;if(t.startsWith("lit-part")){if(0===i.length&&void 0!==n)throw Error("there must be only one root part per container");a=p(e,o,i,r),null!=n||(n=a)}else if(t.startsWith("lit-node"))h(o,i,r);else if(t.startsWith("/lit-part")){if(1===i.length&&a!==n)throw Error("internal error");a=u(o,a,i)}}console.assert(void 0!==n,"there should be exactly one root part in a render container"),t._$litPart$=n},p=(t,r,i,c)=>{let v,y;if(0===i.length)y=new d(r,null,void 0,c),v=t;else{const e=i[i.length-1];if("template-instance"===e.type)y=new d(r,null,e.instance,c),e.instance.v.push(y),v=e.result.values[e.instancePartIndex++],e.templatePartIndex++;else if("iterable"===e.type){y=new d(r,null,e.part,c);const t=e.iterator.next();if(t.done)throw v=void 0,e.done=!0,Error("Unhandled shorter than expected iterable");v=t.value,e.part._$AH.push(y)}else y=new d(r,null,e.part,c)}if(v=s(y,v),v===e)i.push({part:y,type:"leaf"});else if(n(v))i.push({part:y,type:"leaf"}),y._$AH=v;else if(a(v)){const e="lit-part "+m(v);if(r.data!==e)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const e=d.prototype._$AC(v),t=new l(e,y);i.push({type:"template-instance",instance:t,part:y,templatePartIndex:0,instancePartIndex:0,result:v}),y._$AH=t}}else o(v)?(i.push({part:y,type:"iterable",value:v,iterator:v[Symbol.iterator](),done:!1}),y._$AH=[]):(i.push({part:y,type:"leaf"}),y._$AH=null==v?"":v);return y},u=(e,t,r)=>{if(void 0===t)throw Error("unbalanced part marker");t._$AB=e;const n=r.pop();if("iterable"===n.type&&!n.iterator.next().done)throw Error("unexpected longer than expected iterable");if(r.length>0)return r[r.length-1].part},h=(e,t,n)=>{var a;const l=/lit-node (\d+)/.exec(e.data),o=parseInt(l[1]),d=null!==(a=e.previousElementSibling)&&void 0!==a?a:e.parentElement;if(null===d)throw Error("could not find node for attribute parts");d.removeAttribute("defer-hydration");const v=t[t.length-1];if("template-instance"!==v.type)throw Error("internal error");{const e=v.instance;for(;;){const t=e._$AD.parts[v.templatePartIndex];if(void 0===t||t.type!==r.ATTRIBUTE&&t.type!==r.ELEMENT||t.index!==o)break;if(t.type===r.ATTRIBUTE){const a=new t.ctor(d,t.name,t.strings,v.instance,n),l=i(a)?v.result.values[v.instancePartIndex]:v.result.values,o=!(a.type===r.EVENT||a.type===r.PROPERTY);a._$AI(l,a,v.instancePartIndex,o),v.instancePartIndex+=t.strings.length-1,e.v.push(a)}else{const t=new c(d,v.instance,n);s(t,v.result.values[v.instancePartIndex++]),e.v.push(t)}v.templatePartIndex++}}},m=e=>{const t=new Uint32Array(2).fill(5381);for(const r of e.strings)for(let e=0;e<r.length;e++)t[e%2]=33*t[e%2]^r.charCodeAt(e);return btoa(String.fromCharCode(...new Uint8Array(t.buffer)))};export{m as digestForTemplateResult,f as hydrate};