/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var e=this&&this.__asyncValues||function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e="function"==typeof __values?__values(e):e[Symbol.iterator](),t={},verb("next"),verb("throw"),verb("return"),t[Symbol.asyncIterator]=function(){return this},t);function verb(r){t[r]=e[r]&&function(t){return new Promise((function(n,o){(function settle(e,t,r,n){Promise.resolve(n).then((function(t){e({value:t,done:r})}),t)})(n,o,(t=e[r](t)).done,t.value)}))}}};import{createMarker as t,directive as r,NodePart as n}from"../lit-html.js";export const asyncAppend=r(((r,o)=>async a=>{var i,l;if(!(a instanceof n))throw new Error("asyncAppend can only be used in text bindings");if(r===a.value)return;let s;a.value=r;let c=0;try{for(var u,f=e(r);!(u=await f.next()).done;){let e=u.value;if(a.value!==r)break;0===c&&a.clear(),void 0!==o&&(e=o(e,c));let i=a.startNode;void 0!==s&&(i=t(),s.endNode=i,a.endNode.parentNode.insertBefore(i,a.endNode)),s=new n(a.options),s.insertAfterNode(i),s.setValue(e),s.commit(),c++}}catch(e){i={error:e}}finally{try{u&&!u.done&&(l=f.return)&&await l.call(f)}finally{if(i)throw i.error}}}));