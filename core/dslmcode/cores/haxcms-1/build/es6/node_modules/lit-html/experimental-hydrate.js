import{noChange as e,_$LH as t}from"./lit-html.js";import{PartType as r}from"./directive.js";import{isPrimitive as n,isTemplateResult as a,isSingleExpression as o}from"./directive-helpers.js";
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{L:i,D:l,R:s,I:d,F:c}=t,f=(e,t,r={})=>{if(console.warn("Importing `hydrate()` from `lit-html/experimental-hydrate.js` is deprecated.Import from `@lit-labs/ssr-client` instead."),void 0!==t._$litPart$)throw Error("container already contains a live render");let n,a,o;const i=[],l=document.createTreeWalker(t,NodeFilter.SHOW_COMMENT,null,!1);let s;for(;null!==(s=l.nextNode());){const t=s.data;if(t.startsWith("lit-part")){if(0===i.length&&void 0!==n)throw Error(`There must be only one root part per container. Found a part marker (${s}) when we already have a root part marker (${a})`);o=p(e,s,i,r),null!=n||(n=o),null!=a||(a=s)}else if(t.startsWith("lit-node"))h(s,i,r);else if(t.startsWith("/lit-part")){if(1===i.length&&o!==n)throw Error("internal error");o=m(s,o,i)}}if(void 0===n){const e=t instanceof ShadowRoot?"{container.host.localName}'s shadow root":t instanceof DocumentFragment?"DocumentFragment":t.localName;console.error(`There should be exactly one root part in a render container, but we didn't find any in ${e}.`)}t._$litPart$=n},p=(t,r,o,c)=>{let y,w;if(0===o.length)w=new d(r,null,void 0,c),y=t;else{const e=o[o.length-1];if("template-instance"===e.type)w=new d(r,null,e.instance,c),e.instance._$AV.push(w),y=e.result.values[e.instancePartIndex++],e.templatePartIndex++;else if("iterable"===e.type){w=new d(r,null,e.part,c);const t=e.iterator.next();if(t.done)throw y=void 0,e.done=!0,Error("Unhandled shorter than expected iterable");y=t.value,e.part._$AH.push(w)}else w=new d(r,null,e.part,c)}if(y=s(w,y),y===e)o.push({part:w,type:"leaf"});else if(n(y))o.push({part:w,type:"leaf"}),w._$AH=y;else if(a(y)){const e="lit-part "+u(y);if(r.data!==e)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const e=d.prototype._$AC(y),t=new i(e,w);o.push({type:"template-instance",instance:t,part:w,templatePartIndex:0,instancePartIndex:0,result:y}),w._$AH=t}}else l(y)?(o.push({part:w,type:"iterable",value:y,iterator:y[Symbol.iterator](),done:!1}),w._$AH=[]):(o.push({part:w,type:"leaf"}),w._$AH=null==y?"":y);return w},m=(e,t,r)=>{if(void 0===t)throw Error("unbalanced part marker");t._$AB=e;const n=r.pop();if("iterable"===n.type&&!n.iterator.next().done)throw Error("unexpected longer than expected iterable");if(r.length>0)return r[r.length-1].part},h=(e,t,n)=>{const a=/lit-node (\d+)/.exec(e.data),i=parseInt(a[1]),l=e.nextElementSibling;if(null===l)throw Error("could not find node for attribute parts");l.removeAttribute("defer-hydration");const d=t[t.length-1];if("template-instance"!==d.type)throw Error("internal error");{const e=d.instance;for(;;){const t=e._$AD.parts[d.templatePartIndex];if(void 0===t||t.type!==r.ATTRIBUTE&&t.type!==r.ELEMENT||t.index!==i)break;if(t.type===r.ATTRIBUTE){const a=new t.ctor(l,t.name,t.strings,d.instance,n),i=o(a)?d.result.values[d.instancePartIndex]:d.result.values,s=!(a.type===r.EVENT||a.type===r.PROPERTY);a._$AI(i,a,d.instancePartIndex,s),d.instancePartIndex+=t.strings.length-1,e._$AV.push(a)}else{const t=new c(l,d.instance,n);s(t,d.result.values[d.instancePartIndex++]),e._$AV.push(t)}d.templatePartIndex++}}},u=e=>{const t=new Uint32Array(2).fill(5381);for(const r of e.strings)for(let e=0;e<r.length;e++)t[e%2]=33*t[e%2]^r.charCodeAt(e);const r=String.fromCharCode(...new Uint8Array(t.buffer));return btoa(r)};export{u as digestForTemplateResult,f as hydrate};