/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import{noChange as e,_$LH as t}from"./lit-html.js";import{PartType as r}from"./directive.js";import{isPrimitive as n,isSingleExpression as a,isTemplateResult as l}from"./directive-helpers.js";const{_TemplateInstance:o,_isIterable:i,_resolveDirective:s,_ChildPart:p,_ElementPart:d}=t;export const hydrate=(e,t,r={})=>{if(void 0!==t._$litPart$)throw new Error("container already contains a live render");let n,a;const l=[],o=document.createTreeWalker(t,NodeFilter.SHOW_COMMENT,null,!1);let i;for(;null!==(i=o.nextNode());){const t=i.data;if(t.startsWith("lit-part")){if(0===l.length&&void 0!==n)throw new Error("there must be only one root part per container");a=openChildPart(e,i,l,r),null!=n||(n=a)}else if(t.startsWith("lit-node"))createAttributeParts(i,l,r);else if(t.startsWith("/lit-part")){if(1===l.length&&a!==n)throw new Error("internal error");a=closeChildPart(i,a,l)}}console.assert(void 0!==n,"there should be exactly one root part in a render container"),t._$litPart$=n};const openChildPart=(t,r,a,d)=>{let c,u;if(0===a.length)u=new p(r,null,void 0,d),c=t;else{const e=a[a.length-1];if("template-instance"===e.type)u=new p(r,null,e.instance,d),e.instance._parts.push(u),c=e.result.values[e.instancePartIndex++],e.templatePartIndex++;else if("iterable"===e.type){u=new p(r,null,e.part,d);const t=e.iterator.next();if(t.done)throw c=void 0,e.done=!0,new Error("Unhandled shorter than expected iterable");c=t.value,e.part._$committedValue.push(u)}else u=new p(r,null,e.part,d)}if(c=s(u,c),c===e)a.push({part:u,type:"leaf"});else if(n(c))a.push({part:u,type:"leaf"}),u._$committedValue=c;else if(l(c)){const e=`lit-part ${digestForTemplateResult(c)}`;if(r.data!==e)throw new Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const e=p.prototype._$getTemplate(c),t=new o(e,u);a.push({type:"template-instance",instance:t,part:u,templatePartIndex:0,instancePartIndex:0,result:c}),u._$committedValue=t}}else i(c)?(a.push({part:u,type:"iterable",value:c,iterator:c[Symbol.iterator](),done:!1}),u._$committedValue=[]):(a.push({part:u,type:"leaf"}),u._$committedValue=null==c?"":c);return u},closeChildPart=(e,t,r)=>{if(void 0===t)throw new Error("unbalanced part marker");t._$endNode=e;const n=r.pop();if("iterable"===n.type&&!n.iterator.next().done)throw new Error("unexpected longer than expected iterable");if(r.length>0){return r[r.length-1].part}},createAttributeParts=(e,t,n)=>{var l;const o=/lit-node (\d+)/.exec(e.data),i=parseInt(o[1]),p=null!==(l=e.previousElementSibling)&&void 0!==l?l:e.parentElement;if(null===p)throw new Error("could not find node for attribute parts");p.removeAttribute("defer-hydration");const c=t[t.length-1];if("template-instance"!==c.type)throw new Error("internal error");{const e=c.instance;for(;;){const t=e._$template.parts[c.templatePartIndex];if(void 0===t||t.type!==r.ATTRIBUTE&&t.type!==r.ELEMENT||t.index!==i)break;if(t.type===r.ATTRIBUTE){const l=new t.ctor(p,t.name,t.strings,c.instance,n),o=a(l)?c.result.values[c.instancePartIndex]:c.result.values,i=!(l.type===r.EVENT||l.type===r.PROPERTY);l._$setValue(o,l,c.instancePartIndex,i),c.instancePartIndex+=t.strings.length-1,e._parts.push(l)}else{const t=new d(p,c.instance,n);s(t,c.result.values[c.instancePartIndex++]),e._parts.push(t)}c.templatePartIndex++}}};export const digestForTemplateResult=e=>{const t=new Uint32Array(2).fill(5381);for(const r of e.strings)for(let e=0;e<r.length;e++)t[e%2]=33*t[e%2]^r.charCodeAt(e);return btoa(String.fromCharCode(...new Uint8Array(t.buffer)))};