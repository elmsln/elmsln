/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
import{isTemplatePartActive}from"./template.js";const walkerNodeFilter=133;export function removeNodesFromTemplate(template,nodesToRemove){const{element:{content},parts}=template,walker=document.createTreeWalker(content,walkerNodeFilter,null,!1);let partIndex=nextActiveIndexInTemplateParts(parts),part=parts[partIndex],nodeIndex=-1,removeCount=0;const nodesToRemoveInTemplate=[];let currentRemovingNode=null;for(;walker.nextNode();){nodeIndex++;const node=walker.currentNode;for(node.previousSibling===currentRemovingNode&&(currentRemovingNode=null),nodesToRemove.has(node)&&(nodesToRemoveInTemplate.push(node),null===currentRemovingNode&&(currentRemovingNode=node)),null!==currentRemovingNode&&removeCount++;void 0!==part&&part.index===nodeIndex;)part.index=null!==currentRemovingNode?-1:part.index-removeCount,partIndex=nextActiveIndexInTemplateParts(parts,partIndex),part=parts[partIndex]}nodesToRemoveInTemplate.forEach(n=>n.parentNode.removeChild(n))}const countNodes=node=>{let count=11===node.nodeType?0:1;const walker=document.createTreeWalker(node,walkerNodeFilter,null,!1);for(;walker.nextNode();)count++;return count},nextActiveIndexInTemplateParts=(parts,startIndex=-1)=>{for(let i=startIndex+1;i<parts.length;i++){const part=parts[i];if(isTemplatePartActive(part))return i}return-1};export function insertNodeIntoTemplate(template,node,refNode=null){const{element:{content},parts}=template;if(null==refNode)return void content.appendChild(node);const walker=document.createTreeWalker(content,walkerNodeFilter,null,!1);let partIndex=nextActiveIndexInTemplateParts(parts),insertCount=0,walkerIndex=-1;for(;walker.nextNode();){for(walkerIndex++,walker.currentNode===refNode&&(insertCount=countNodes(node),refNode.parentNode.insertBefore(node,refNode));-1!==partIndex&&parts[partIndex].index===walkerIndex;){if(insertCount>0){for(;-1!==partIndex;)parts[partIndex].index+=insertCount,partIndex=nextActiveIndexInTemplateParts(parts,partIndex);return}partIndex=nextActiveIndexInTemplateParts(parts,partIndex)}}}