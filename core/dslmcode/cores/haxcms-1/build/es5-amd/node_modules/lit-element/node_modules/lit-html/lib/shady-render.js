define(["exports","./dom.js","./modify-template.js","./render.js","./template-factory.js","./template-instance.js","./template-result.js","./template.js","../lit-html.js"],function(_exports,_dom,_modifyTemplate,_render,_templateFactory,_templateInstance,_templateResult,_template,_litHtml){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});Object.defineProperty(_exports,"html",{enumerable:!0,get:function get(){return _litHtml.html}});Object.defineProperty(_exports,"svg",{enumerable:!0,get:function get(){return _litHtml.svg}});Object.defineProperty(_exports,"TemplateResult",{enumerable:!0,get:function get(){return _litHtml.TemplateResult}});_exports.render=void 0;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * Module to add shady DOM/shady CSS polyfill support to lit-html template
 * rendering. See the [[render]] method for details.
 *
 * @module shady-render
 * @preferred
 */ /**
 * Do not remove this comment; it keeps typedoc from misplacing the module
 * docs.
 */ // Get a key to lookup in `templateCaches`.
var getTemplateCacheKey=function getTemplateCacheKey(type,scopeName){return"".concat(type,"--").concat(scopeName)},compatibleShadyCSSVersion=!0;if("undefined"===typeof window.ShadyCSS){compatibleShadyCSSVersion=!1}else if("undefined"===typeof window.ShadyCSS.prepareTemplateDom){console.warn("Incompatible ShadyCSS version detected."+"Please update to at least @webcomponents/webcomponentsjs@2.0.2 and"+"@webcomponents/shadycss@1.3.1.");compatibleShadyCSSVersion=!1}/**
 * Template factory which scopes template DOM using ShadyCSS.
 * @param scopeName {string}
 */var shadyTemplateFactory=function shadyTemplateFactory(scopeName){return function(result){var cacheKey=getTemplateCacheKey(result.type,scopeName),templateCache=_templateFactory.templateCaches.get(cacheKey);if(templateCache===void 0){templateCache={stringsArray:new WeakMap,keyString:new Map};_templateFactory.templateCaches.set(cacheKey,templateCache)}var template=templateCache.stringsArray.get(result.strings);if(template!==void 0){return template}var key=result.strings.join(_template.marker);template=templateCache.keyString.get(key);if(template===void 0){var element=result.getTemplateElement();if(compatibleShadyCSSVersion){window.ShadyCSS.prepareTemplateDom(element,scopeName)}template=new _template.Template(result,element);templateCache.keyString.set(key,template)}templateCache.stringsArray.set(result.strings,template);return template}},TEMPLATE_TYPES=["html","svg"],removeStylesFromLitTemplates=function removeStylesFromLitTemplates(scopeName){TEMPLATE_TYPES.forEach(function(type){var templates=_templateFactory.templateCaches.get(getTemplateCacheKey(type,scopeName));if(templates!==void 0){templates.keyString.forEach(function(template){var content=template.element.content,styles=new Set;// IE 11 doesn't support the iterable param Set constructor
Array.from(content.querySelectorAll("style")).forEach(function(s){styles.add(s)});(0,_modifyTemplate.removeNodesFromTemplate)(template,styles)})}})},shadyRenderSet=new Set,prepareTemplateStyles=function prepareTemplateStyles(renderedDOM,template,scopeName){shadyRenderSet.add(scopeName);// Move styles out of rendered DOM and store.
var styles=renderedDOM.querySelectorAll("style");// If there are no styles, skip unnecessary work
if(0===styles.length){// Ensure prepareTemplateStyles is called to support adding
// styles via `prepareAdoptedCssText` since that requires that
// `prepareTemplateStyles` is called.
window.ShadyCSS.prepareTemplateStyles(template.element,scopeName);return}// Collect styles into a single style. This helps us make sure ShadyCSS
// manipulations will not prevent us from being able to fix up template
// part indices.
// NOTE: collecting styles is inefficient for browsers but ShadyCSS
// currently does this anyway. When it does not, this should be changed.
for(var condensedStyle=document.createElement("style"),i=0,style;i<styles.length;i++){style=styles[i];style.parentNode.removeChild(style);condensedStyle.textContent+=style.textContent}// Remove styles from nested templates in this scope.
removeStylesFromLitTemplates(scopeName);// And then put the condensed style into the "root" template passed in as
// `template`.
(0,_modifyTemplate.insertNodeIntoTemplate)(template,condensedStyle,template.element.content.firstChild);// Note, it's important that ShadyCSS gets the template that `lit-html`
// will actually render so that it can update the style inside when
// needed (e.g. @apply native Shadow DOM case).
window.ShadyCSS.prepareTemplateStyles(template.element,scopeName);if(window.ShadyCSS.nativeShadow){// When in native Shadow DOM, re-add styling to rendered content using
// the style ShadyCSS produced.
var _style=template.element.content.querySelector("style");renderedDOM.insertBefore(_style.cloneNode(!0),renderedDOM.firstChild)}else{// When not in native Shadow DOM, at this point ShadyCSS will have
// removed the style from the lit template and parts will be broken as a
// result. To fix this, we put back the style node ShadyCSS removed
// and then tell lit to remove that node from the template.
// NOTE, ShadyCSS creates its own style so we can safely add/remove
// `condensedStyle` here.
template.element.content.insertBefore(condensedStyle,template.element.content.firstChild);var removes=new Set([condensedStyle]);(0,_modifyTemplate.removeNodesFromTemplate)(template,removes)}},render=function render(result,container,options){var scopeName=options.scopeName,hasRendered=_render.parts.has(container),needsScoping=babelHelpers.instanceof(container,ShadowRoot)&&compatibleShadyCSSVersion&&babelHelpers.instanceof(result,_templateResult.TemplateResult),firstScopeRender=needsScoping&&!shadyRenderSet.has(scopeName),renderContainer=firstScopeRender?document.createDocumentFragment():container;(0,_render.render)(result,renderContainer,Object.assign({templateFactory:shadyTemplateFactory(scopeName)},options));// When performing first scope render,
// (1) We've rendered into a fragment so that there's a chance to
// `prepareTemplateStyles` before sub-elements hit the DOM
// (which might cause them to render based on a common pattern of
// rendering in a custom element's `connectedCallback`);
// (2) Scope the template with ShadyCSS one time only for this scope.
// (3) Render the fragment into the container and make sure the
// container knows its `part` is the one we just rendered. This ensures
// DOM will be re-used on subsequent renders.
if(firstScopeRender){var part=_render.parts.get(renderContainer);_render.parts.delete(renderContainer);if(babelHelpers.instanceof(part.value,_templateInstance.TemplateInstance)){prepareTemplateStyles(renderContainer,part.value.template,scopeName)}(0,_dom.removeNodes)(container,container.firstChild);container.appendChild(renderContainer);_render.parts.set(container,part)}// After elements have hit the DOM, update styling if this is the
// initial render to this container.
// This is needed whenever dynamic changes are made so it would be
// safest to do every render; however, this would regress performance
// so we leave it up to the user to call `ShadyCSSS.styleElement`
// for dynamic changes.
if(!hasRendered&&needsScoping){window.ShadyCSS.styleElement(container.host)}};_exports.render=render});