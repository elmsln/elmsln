define(["exports", "./directive-helpers.js", "./directive.js"], function (_exports, _directiveHelpers, _directive) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.AsyncDirective = void 0;
  Object.defineProperty(_exports, "directive", {
    enumerable: true,
    get: function get() {
      return _directive.directive;
    }
  });

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var DEV_MODE = true;
  /**
   * Recursively walks down the tree of Parts/TemplateInstances/Directives to set
   * the connected state of directives and run `disconnected`/ `reconnected`
   * callbacks.
   *
   * @return True if there were children to disconnect; false otherwise
   */

  var notifyChildrenConnectedChanged = function notifyChildrenConnectedChanged(parent, isConnected) {
    var _a, _b;

    var children = parent._$disconnectableChildren;

    if (children === undefined) {
      return false;
    }

    var _iterator = _createForOfIteratorHelper(children),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var obj = _step.value;
        // The existence of `_$notifyDirectiveConnectionChanged` is used as a "brand" to
        // disambiguate AsyncDirectives from other DisconnectableChildren
        // (as opposed to using an instanceof check to know when to call it); the
        // redundancy of "Directive" in the API name is to avoid conflicting with
        // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in
        // this list
        // Disconnect Directive (and any nested directives contained within)
        // This property needs to remain unminified.
        (_b = (_a = obj)['_$notifyDirectiveConnectionChanged']) === null || _b === void 0 ? void 0 : _b.call(_a, isConnected, false); // Disconnect Part/TemplateInstance

        notifyChildrenConnectedChanged(obj, isConnected);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  };
  /**
   * Removes the given child from its parent list of disconnectable children, and
   * if the parent list becomes empty as a result, removes the parent from its
   * parent, and so forth up the tree when that causes subsequent parent lists to
   * become empty.
   */


  var removeDisconnectableFromParent = function removeDisconnectableFromParent(obj) {
    var parent, children;

    do {
      if ((parent = obj._$parent) === undefined) {
        break;
      }

      children = parent._$disconnectableChildren;
      children.delete(obj);
      obj = parent;
    } while ((children === null || children === void 0 ? void 0 : children.size) === 0);
  };

  var addDisconnectableToParent = function addDisconnectableToParent(obj) {
    // Climb the parent tree, creating a sparse tree of children needing
    // disconnection
    for (var parent; parent = obj._$parent; obj = parent) {
      var children = parent._$disconnectableChildren;

      if (children === undefined) {
        parent._$disconnectableChildren = children = new Set();
      } else if (children.has(obj)) {
        // Once we've reached a parent that already contains this child, we
        // can short-circuit
        break;
      }

      children.add(obj);
      installDisconnectAPI(parent);
    }
  };
  /**
   * Changes the parent reference of the ChildPart, and updates the sparse tree of
   * Disconnectable children accordingly.
   *
   * Note, this method will be patched onto ChildPart instances and called from
   * the core code when parts are moved between different parents.
   */


  function reparentDisconnectables(newParent) {
    if (this._$disconnectableChildren !== undefined) {
      removeDisconnectableFromParent(this);
      this._$parent = newParent;
      addDisconnectableToParent(this);
    } else {
      this._$parent = newParent;
    }
  }
  /**
   * Sets the connected state on any directives contained within the committed
   * value of this part (i.e. within a TemplateInstance or iterable of
   * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within
   * any directives stored on the ChildPart (when `valueOnly` is false).
   *
   * `isClearingValue` should be passed as `true` on a top-level part that is
   * clearing itself, and not as a result of recursively disconnecting directives
   * as part of a `clear` operation higher up the tree. This both ensures that any
   * directive on this ChildPart that produced a value that caused the clear
   * operation is not disconnected, and also serves as a performance optimization
   * to avoid needless bookkeeping when a subtree is going away; when clearing a
   * subtree, only the top-most part need to remove itself from the parent.
   *
   * `fromPartIndex` is passed only in the case of a partial `_clear` running as a
   * result of truncating an iterable.
   *
   * Note, this method will be patched onto ChildPart instances and called from the
   * core code when parts are cleared or the connection state is changed by the
   * user.
   */


  function notifyChildPartConnectedChanged(isConnected) {
    var isClearingValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var fromPartIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var value = this._$committedValue;
    var children = this._$disconnectableChildren;

    if (children === undefined || children.size === 0) {
      return;
    }

    if (isClearingValue) {
      if (Array.isArray(value)) {
        // Iterable case: Any ChildParts created by the iterable should be
        // disconnected and removed from this ChildPart's disconnectable
        // children (starting at `fromPartIndex` in the case of truncation)
        for (var i = fromPartIndex; i < value.length; i++) {
          notifyChildrenConnectedChanged(value[i], false);
          removeDisconnectableFromParent(value[i]);
        }
      } else if (value != null) {
        // TemplateInstance case: If the value has disconnectable children (will
        // only be in the case that it is a TemplateInstance), we disconnect it
        // and remove it from this ChildPart's disconnectable children
        notifyChildrenConnectedChanged(value, false);
        removeDisconnectableFromParent(value);
      }
    } else {
      notifyChildrenConnectedChanged(this, isConnected);
    }
  }
  /**
   * Patches disconnection API onto ChildParts.
   */


  var installDisconnectAPI = function installDisconnectAPI(obj) {
    var _a, _b;

    var _c, _d;

    if (obj.type == _directive.PartType.CHILD) {
      (_a = (_c = obj)._$notifyConnectionChanged) !== null && _a !== void 0 ? _a : _c._$notifyConnectionChanged = notifyChildPartConnectedChanged;
      (_b = (_d = obj)._$reparentDisconnectables) !== null && _b !== void 0 ? _b : _d._$reparentDisconnectables = reparentDisconnectables;
    }
  };
  /**
   * An abstract `Directive` base class whose `disconnected` method will be
   * called when the part containing the directive is cleared as a result of
   * re-rendering, or when the user calls `part.setConnected(false)` on
   * a part that was previously rendered containing the directive (as happens
   * when e.g. a LitElement disconnects from the DOM).
   *
   * If `part.setConnected(true)` is subsequently called on a
   * containing part, the directive's `reconnected` method will be called prior
   * to its next `update`/`render` callbacks. When implementing `disconnected`,
   * `reconnected` should also be implemented to be compatible with reconnection.
   *
   * Note that updates may occur while the directive is disconnected. As such,
   * directives should generally check the `this.isConnected` flag during
   * render/update to determine whether it is safe to subscribe to resources
   * that may prevent garbage collection.
   */


  var AsyncDirective = /*#__PURE__*/function (_Directive) {
    babelHelpers.inherits(AsyncDirective, _Directive);

    var _super = _createSuper(AsyncDirective);

    function AsyncDirective() {
      var _this;

      babelHelpers.classCallCheck(this, AsyncDirective);
      _this = _super.apply(this, arguments); // @internal

      _this._$disconnectableChildren = undefined;
      return _this;
    }
    /**
     * Initialize the part with internal fields
     * @param part
     * @param parent
     * @param attributeIndex
     */


    babelHelpers.createClass(AsyncDirective, [{
      key: "_$initialize",
      value: function _$initialize(part, parent, attributeIndex) {
        babelHelpers.get(babelHelpers.getPrototypeOf(AsyncDirective.prototype), "_$initialize", this).call(this, part, parent, attributeIndex);
        addDisconnectableToParent(this);
        this.isConnected = part._$isConnected;
      } // This property needs to remain unminified.

      /**
       * Called from the core code when a directive is going away from a part (in
       * which case `shouldRemoveFromParent` should be true), and from the
       * `setChildrenConnected` helper function when recursively changing the
       * connection state of a tree (in which case `shouldRemoveFromParent` should
       * be false).
       *
       * @param isConnected
       * @param isClearingDirective - True when the directive itself is being
       *     removed; false when the tree is being disconnected
       * @internal
       */

    }, {
      key: '_$notifyDirectiveConnectionChanged',
      value: function _$notifyDirectiveConnectionChanged(isConnected) {
        var isClearingDirective = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var _a, _b;

        if (isConnected !== this.isConnected) {
          this.isConnected = isConnected;

          if (isConnected) {
            (_a = this.reconnected) === null || _a === void 0 ? void 0 : _a.call(this);
          } else {
            (_b = this.disconnected) === null || _b === void 0 ? void 0 : _b.call(this);
          }
        }

        if (isClearingDirective) {
          notifyChildrenConnectedChanged(this, isConnected);
          removeDisconnectableFromParent(this);
        }
      }
      /**
       * Sets the value of the directive's Part outside the normal `update`/`render`
       * lifecycle of a directive.
       *
       * This method should not be called synchronously from a directive's `update`
       * or `render`.
       *
       * @param directive The directive to update
       * @param value The value to set
       */

    }, {
      key: "setValue",
      value: function setValue(value) {
        if ((0, _directiveHelpers.isSingleExpression)(this.__part)) {
          this.__part._$setValue(value, this);
        } else {
          // this.__attributeIndex will be defined in this case, but
          // assert it in dev mode
          if (DEV_MODE && this.__attributeIndex === undefined) {
            throw new Error("Expected this.__attributeIndex to be a number");
          }

          var newValues = babelHelpers.toConsumableArray(this.__part._$committedValue);
          newValues[this.__attributeIndex] = value;

          this.__part._$setValue(newValues, this, 0);
        }
      }
      /**
       * User callbacks for implementing logic to release any resources/subscriptions
       * that may have been retained by this directive. Since directives may also be
       * re-connected, `reconnected` should also be implemented to restore the
       * working state of the directive prior to the next render.
       */

    }, {
      key: "disconnected",
      value: function disconnected() {}
    }, {
      key: "reconnected",
      value: function reconnected() {}
    }]);
    return AsyncDirective;
  }(_directive.Directive);

  _exports.AsyncDirective = AsyncDirective;
});