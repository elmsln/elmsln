define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.TimeUntilElement = _exports.TimeAgoElement = _exports.RelativeTimeElement = _exports.LocalTimeElement = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

  function pad(num) {
    return "0".concat(num).slice(-2);
  }

  function strftime(time, formatString) {
    var day = time.getDay();
    var date = time.getDate();
    var month = time.getMonth();
    var year = time.getFullYear();
    var hour = time.getHours();
    var minute = time.getMinutes();
    var second = time.getSeconds();
    return formatString.replace(/%([%aAbBcdeHIlmMpPSwyYZz])/g, function (_arg) {
      var match;
      var modifier = _arg[1];

      switch (modifier) {
        case '%':
          return '%';

        case 'a':
          return weekdays[day].slice(0, 3);

        case 'A':
          return weekdays[day];

        case 'b':
          return months[month].slice(0, 3);

        case 'B':
          return months[month];

        case 'c':
          return time.toString();

        case 'd':
          return pad(date);

        case 'e':
          return String(date);

        case 'H':
          return pad(hour);

        case 'I':
          return pad(strftime(time, '%l'));

        case 'l':
          if (hour === 0 || hour === 12) {
            return String(12);
          } else {
            return String((hour + 12) % 12);
          }

        case 'm':
          return pad(month + 1);

        case 'M':
          return pad(minute);

        case 'p':
          if (hour > 11) {
            return 'PM';
          } else {
            return 'AM';
          }

        case 'P':
          if (hour > 11) {
            return 'pm';
          } else {
            return 'am';
          }

        case 'S':
          return pad(second);

        case 'w':
          return String(day);

        case 'y':
          return pad(year % 100);

        case 'Y':
          return String(year);

        case 'Z':
          match = time.toString().match(/\((\w+)\)$/);
          return match ? match[1] : '';

        case 'z':
          match = time.toString().match(/\w([+-]\d\d\d\d) /);
          return match ? match[1] : '';
      }

      return '';
    });
  }

  function makeFormatter(options) {
    var format;
    return function () {
      if (format) return format;

      if ('Intl' in window) {
        try {
          format = new Intl.DateTimeFormat(undefined, options);
          return format;
        } catch (e) {
          if (!babelHelpers.instanceof(e, RangeError)) {
            throw e;
          }
        }
      }
    };
  }

  var dayFirst = null;
  var dayFirstFormatter = makeFormatter({
    day: 'numeric',
    month: 'short'
  });

  function isDayFirst() {
    if (dayFirst !== null) {
      return dayFirst;
    }

    var formatter = dayFirstFormatter();

    if (formatter) {
      var output = formatter.format(new Date(0));
      dayFirst = !!output.match(/^\d/);
      return dayFirst;
    } else {
      return false;
    }
  }

  var yearSeparator = null;
  var yearFormatter = makeFormatter({
    day: 'numeric',
    month: 'short',
    year: 'numeric'
  });

  function isYearSeparator() {
    if (yearSeparator !== null) {
      return yearSeparator;
    }

    var formatter = yearFormatter();

    if (formatter) {
      var output = formatter.format(new Date(0));
      yearSeparator = !!output.match(/\d,/);
      return yearSeparator;
    } else {
      return true;
    }
  }

  function isThisYear(date) {
    var now = new Date();
    return now.getUTCFullYear() === date.getUTCFullYear();
  }

  function makeRelativeFormat(locale, options) {
    if ('Intl' in window && 'RelativeTimeFormat' in window.Intl) {
      try {
        return new Intl.RelativeTimeFormat(locale, options);
      } catch (e) {
        if (!babelHelpers.instanceof(e, RangeError)) {
          throw e;
        }
      }
    }
  }

  function localeFromElement(el) {
    var container = el.closest('[lang]');

    if (babelHelpers.instanceof(container, HTMLElement) && container.lang) {
      return container.lang;
    }

    return 'default';
  }

  var datetimes = new WeakMap();

  var ExtendedTimeElement = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(ExtendedTimeElement, _HTMLElement);

    var _super = _createSuper(ExtendedTimeElement);

    function ExtendedTimeElement() {
      babelHelpers.classCallCheck(this, ExtendedTimeElement);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(ExtendedTimeElement, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        var title = this.getFormattedTitle();

        if (title && !this.hasAttribute('title')) {
          this.setAttribute('title', title);
        }

        var text = this.getFormattedDate();

        if (text) {
          this.textContent = text;
        }
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attrName, oldValue, newValue) {
        var oldTitle = this.getFormattedTitle();

        if (attrName === 'datetime') {
          var millis = Date.parse(newValue);

          if (isNaN(millis)) {
            datetimes.delete(this);
          } else {
            datetimes.set(this, new Date(millis));
          }
        }

        var title = this.getFormattedTitle();
        var currentTitle = this.getAttribute('title');

        if (attrName !== 'title' && title && (!currentTitle || currentTitle === oldTitle)) {
          this.setAttribute('title', title);
        }

        var text = this.getFormattedDate();

        if (text) {
          this.textContent = text;
        }
      }
    }, {
      key: "date",
      get: function get() {
        return datetimes.get(this);
      }
    }, {
      key: "getFormattedTitle",
      value: function getFormattedTitle() {
        var date = this.date;
        if (!date) return;
        var formatter = titleFormatter();

        if (formatter) {
          return formatter.format(date);
        } else {
          try {
            return date.toLocaleString();
          } catch (e) {
            if (babelHelpers.instanceof(e, RangeError)) {
              return date.toString();
            } else {
              throw e;
            }
          }
        }
      }
    }, {
      key: "getFormattedDate",
      value: function getFormattedDate() {
        return;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ['datetime', 'day', 'format', 'lang', 'hour', 'minute', 'month', 'second', 'title', 'weekday', 'year', 'time-zone-name'];
      }
    }]);
    return ExtendedTimeElement;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  var titleFormatter = makeFormatter({
    day: 'numeric',
    month: 'short',
    year: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    timeZoneName: 'short'
  });
  var formatters = new WeakMap();

  var LocalTimeElement = /*#__PURE__*/function (_ExtendedTimeElement) {
    babelHelpers.inherits(LocalTimeElement, _ExtendedTimeElement);

    var _super2 = _createSuper(LocalTimeElement);

    function LocalTimeElement() {
      babelHelpers.classCallCheck(this, LocalTimeElement);
      return _super2.apply(this, arguments);
    }

    babelHelpers.createClass(LocalTimeElement, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attrName, oldValue, newValue) {
        if (attrName === 'hour' || attrName === 'minute' || attrName === 'second' || attrName === 'time-zone-name') {
          formatters.delete(this);
        }

        babelHelpers.get(babelHelpers.getPrototypeOf(LocalTimeElement.prototype), "attributeChangedCallback", this).call(this, attrName, oldValue, newValue);
      }
    }, {
      key: "getFormattedDate",
      value: function getFormattedDate() {
        var d = this.date;
        if (!d) return;
        var date = formatDate(this, d) || '';
        var time = formatTime(this, d) || '';
        return "".concat(date, " ").concat(time).trim();
      }
    }]);
    return LocalTimeElement;
  }(ExtendedTimeElement);

  _exports.LocalTimeElement = LocalTimeElement;

  function formatDate(el, date) {
    var props = {
      weekday: {
        short: '%a',
        long: '%A'
      },
      day: {
        numeric: '%e',
        '2-digit': '%d'
      },
      month: {
        short: '%b',
        long: '%B'
      },
      year: {
        numeric: '%Y',
        '2-digit': '%y'
      }
    };
    var format = isDayFirst() ? 'weekday day month year' : 'weekday month day, year';

    for (var prop in props) {
      var value = props[prop][el.getAttribute(prop) || ''];
      format = format.replace(prop, value || '');
    }

    format = format.replace(/(\s,)|(,\s$)/, '');
    return strftime(date, format).replace(/\s+/, ' ').trim();
  }

  function formatTime(el, date) {
    var options = {};
    var hour = el.getAttribute('hour');
    if (hour === 'numeric' || hour === '2-digit') options.hour = hour;
    var minute = el.getAttribute('minute');
    if (minute === 'numeric' || minute === '2-digit') options.minute = minute;
    var second = el.getAttribute('second');
    if (second === 'numeric' || second === '2-digit') options.second = second;
    var tz = el.getAttribute('time-zone-name');
    if (tz === 'short' || tz === 'long') options.timeZoneName = tz;

    if (Object.keys(options).length === 0) {
      return;
    }

    var factory = formatters.get(el);

    if (!factory) {
      factory = makeFormatter(options);
      formatters.set(el, factory);
    }

    var formatter = factory();

    if (formatter) {
      return formatter.format(date);
    } else {
      var timef = options.second ? '%H:%M:%S' : '%H:%M';
      return strftime(date, timef);
    }
  }

  if (!window.customElements.get('local-time')) {
    window.LocalTimeElement = LocalTimeElement;
    window.customElements.define('local-time', LocalTimeElement);
  }

  var RelativeTime = /*#__PURE__*/function () {
    function RelativeTime(date, locale) {
      babelHelpers.classCallCheck(this, RelativeTime);
      this.date = date;
      this.locale = locale;
    }

    babelHelpers.createClass(RelativeTime, [{
      key: "toString",
      value: function toString() {
        var ago = this.timeElapsed();

        if (ago) {
          return ago;
        } else {
          var ahead = this.timeAhead();

          if (ahead) {
            return ahead;
          } else {
            return "on ".concat(this.formatDate());
          }
        }
      }
    }, {
      key: "timeElapsed",
      value: function timeElapsed() {
        var ms = new Date().getTime() - this.date.getTime();
        var sec = Math.round(ms / 1000);
        var min = Math.round(sec / 60);
        var hr = Math.round(min / 60);
        var day = Math.round(hr / 24);

        if (ms >= 0 && day < 30) {
          return this.timeAgoFromMs(ms);
        } else {
          return null;
        }
      }
    }, {
      key: "timeAhead",
      value: function timeAhead() {
        var ms = this.date.getTime() - new Date().getTime();
        var sec = Math.round(ms / 1000);
        var min = Math.round(sec / 60);
        var hr = Math.round(min / 60);
        var day = Math.round(hr / 24);

        if (ms >= 0 && day < 30) {
          return this.timeUntil();
        } else {
          return null;
        }
      }
    }, {
      key: "timeAgo",
      value: function timeAgo() {
        var ms = new Date().getTime() - this.date.getTime();
        return this.timeAgoFromMs(ms);
      }
    }, {
      key: "timeAgoFromMs",
      value: function timeAgoFromMs(ms) {
        var sec = Math.round(ms / 1000);
        var min = Math.round(sec / 60);
        var hr = Math.round(min / 60);
        var day = Math.round(hr / 24);
        var month = Math.round(day / 30);
        var year = Math.round(month / 12);

        if (ms < 0) {
          return formatRelativeTime(this.locale, 0, 'second');
        } else if (sec < 10) {
          return formatRelativeTime(this.locale, 0, 'second');
        } else if (sec < 45) {
          return formatRelativeTime(this.locale, -sec, 'second');
        } else if (sec < 90) {
          return formatRelativeTime(this.locale, -min, 'minute');
        } else if (min < 45) {
          return formatRelativeTime(this.locale, -min, 'minute');
        } else if (min < 90) {
          return formatRelativeTime(this.locale, -hr, 'hour');
        } else if (hr < 24) {
          return formatRelativeTime(this.locale, -hr, 'hour');
        } else if (hr < 36) {
          return formatRelativeTime(this.locale, -day, 'day');
        } else if (day < 30) {
          return formatRelativeTime(this.locale, -day, 'day');
        } else if (month < 18) {
          return formatRelativeTime(this.locale, -month, 'month');
        } else {
          return formatRelativeTime(this.locale, -year, 'year');
        }
      }
    }, {
      key: "microTimeAgo",
      value: function microTimeAgo() {
        var ms = new Date().getTime() - this.date.getTime();
        var sec = Math.round(ms / 1000);
        var min = Math.round(sec / 60);
        var hr = Math.round(min / 60);
        var day = Math.round(hr / 24);
        var month = Math.round(day / 30);
        var year = Math.round(month / 12);

        if (min < 1) {
          return '1m';
        } else if (min < 60) {
          return "".concat(min, "m");
        } else if (hr < 24) {
          return "".concat(hr, "h");
        } else if (day < 365) {
          return "".concat(day, "d");
        } else {
          return "".concat(year, "y");
        }
      }
    }, {
      key: "timeUntil",
      value: function timeUntil() {
        var ms = this.date.getTime() - new Date().getTime();
        return this.timeUntilFromMs(ms);
      }
    }, {
      key: "timeUntilFromMs",
      value: function timeUntilFromMs(ms) {
        var sec = Math.round(ms / 1000);
        var min = Math.round(sec / 60);
        var hr = Math.round(min / 60);
        var day = Math.round(hr / 24);
        var month = Math.round(day / 30);
        var year = Math.round(month / 12);

        if (month >= 18) {
          return formatRelativeTime(this.locale, year, 'year');
        } else if (month >= 12) {
          return formatRelativeTime(this.locale, year, 'year');
        } else if (day >= 45) {
          return formatRelativeTime(this.locale, month, 'month');
        } else if (day >= 30) {
          return formatRelativeTime(this.locale, month, 'month');
        } else if (hr >= 36) {
          return formatRelativeTime(this.locale, day, 'day');
        } else if (hr >= 24) {
          return formatRelativeTime(this.locale, day, 'day');
        } else if (min >= 90) {
          return formatRelativeTime(this.locale, hr, 'hour');
        } else if (min >= 45) {
          return formatRelativeTime(this.locale, hr, 'hour');
        } else if (sec >= 90) {
          return formatRelativeTime(this.locale, min, 'minute');
        } else if (sec >= 45) {
          return formatRelativeTime(this.locale, min, 'minute');
        } else if (sec >= 10) {
          return formatRelativeTime(this.locale, sec, 'second');
        } else {
          return formatRelativeTime(this.locale, 0, 'second');
        }
      }
    }, {
      key: "microTimeUntil",
      value: function microTimeUntil() {
        var ms = this.date.getTime() - new Date().getTime();
        var sec = Math.round(ms / 1000);
        var min = Math.round(sec / 60);
        var hr = Math.round(min / 60);
        var day = Math.round(hr / 24);
        var month = Math.round(day / 30);
        var year = Math.round(month / 12);

        if (day >= 365) {
          return "".concat(year, "y");
        } else if (hr >= 24) {
          return "".concat(day, "d");
        } else if (min >= 60) {
          return "".concat(hr, "h");
        } else if (min > 1) {
          return "".concat(min, "m");
        } else {
          return '1m';
        }
      }
    }, {
      key: "formatDate",
      value: function formatDate() {
        var format = isDayFirst() ? '%e %b' : '%b %e';

        if (!isThisYear(this.date)) {
          format += isYearSeparator() ? ', %Y' : ' %Y';
        }

        return strftime(this.date, format);
      }
    }, {
      key: "formatTime",
      value: function formatTime() {
        var formatter = timeFormatter();

        if (formatter) {
          return formatter.format(this.date);
        } else {
          return strftime(this.date, '%l:%M%P');
        }
      }
    }]);
    return RelativeTime;
  }();

  function formatRelativeTime(locale, value, unit) {
    var formatter = makeRelativeFormat(locale, {
      numeric: 'auto'
    });

    if (formatter) {
      return formatter.format(value, unit);
    } else {
      return formatEnRelativeTime(value, unit);
    }
  }

  function formatEnRelativeTime(value, unit) {
    if (value === 0) {
      switch (unit) {
        case 'year':
        case 'quarter':
        case 'month':
        case 'week':
          return "this ".concat(unit);

        case 'day':
          return 'today';

        case 'hour':
        case 'minute':
          return "in 0 ".concat(unit, "s");

        case 'second':
          return 'now';
      }
    } else if (value === 1) {
      switch (unit) {
        case 'year':
        case 'quarter':
        case 'month':
        case 'week':
          return "next ".concat(unit);

        case 'day':
          return 'tomorrow';

        case 'hour':
        case 'minute':
        case 'second':
          return "in 1 ".concat(unit);
      }
    } else if (value === -1) {
      switch (unit) {
        case 'year':
        case 'quarter':
        case 'month':
        case 'week':
          return "last ".concat(unit);

        case 'day':
          return 'yesterday';

        case 'hour':
        case 'minute':
        case 'second':
          return "1 ".concat(unit, " ago");
      }
    } else if (value > 1) {
      switch (unit) {
        case 'year':
        case 'quarter':
        case 'month':
        case 'week':
        case 'day':
        case 'hour':
        case 'minute':
        case 'second':
          return "in ".concat(value, " ").concat(unit, "s");
      }
    } else if (value < -1) {
      switch (unit) {
        case 'year':
        case 'quarter':
        case 'month':
        case 'week':
        case 'day':
        case 'hour':
        case 'minute':
        case 'second':
          return "".concat(-value, " ").concat(unit, "s ago");
      }
    }

    throw new RangeError("Invalid unit argument for format() '".concat(unit, "'"));
  }

  var timeFormatter = makeFormatter({
    hour: 'numeric',
    minute: '2-digit'
  });

  var RelativeTimeElement = /*#__PURE__*/function (_ExtendedTimeElement2) {
    babelHelpers.inherits(RelativeTimeElement, _ExtendedTimeElement2);

    var _super3 = _createSuper(RelativeTimeElement);

    function RelativeTimeElement() {
      babelHelpers.classCallCheck(this, RelativeTimeElement);
      return _super3.apply(this, arguments);
    }

    babelHelpers.createClass(RelativeTimeElement, [{
      key: "getFormattedDate",
      value: function getFormattedDate() {
        var date = this.date;
        if (!date) return;
        return new RelativeTime(date, localeFromElement(this)).toString();
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        nowElements.push(this);

        if (!updateNowElementsId) {
          updateNowElements();
          updateNowElementsId = window.setInterval(updateNowElements, 60 * 1000);
        }

        babelHelpers.get(babelHelpers.getPrototypeOf(RelativeTimeElement.prototype), "connectedCallback", this).call(this);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        var ix = nowElements.indexOf(this);

        if (ix !== -1) {
          nowElements.splice(ix, 1);
        }

        if (!nowElements.length) {
          if (updateNowElementsId) {
            clearInterval(updateNowElementsId);
            updateNowElementsId = null;
          }
        }
      }
    }]);
    return RelativeTimeElement;
  }(ExtendedTimeElement);

  _exports.RelativeTimeElement = RelativeTimeElement;
  var nowElements = [];
  var updateNowElementsId;

  function updateNowElements() {
    var time, i, len;

    for (i = 0, len = nowElements.length; i < len; i++) {
      time = nowElements[i];
      time.textContent = time.getFormattedDate() || '';
    }
  }

  if (!window.customElements.get('relative-time')) {
    window.RelativeTimeElement = RelativeTimeElement;
    window.customElements.define('relative-time', RelativeTimeElement);
  }

  var TimeAgoElement = /*#__PURE__*/function (_RelativeTimeElement) {
    babelHelpers.inherits(TimeAgoElement, _RelativeTimeElement);

    var _super4 = _createSuper(TimeAgoElement);

    function TimeAgoElement() {
      babelHelpers.classCallCheck(this, TimeAgoElement);
      return _super4.apply(this, arguments);
    }

    babelHelpers.createClass(TimeAgoElement, [{
      key: "getFormattedDate",
      value: function getFormattedDate() {
        var format = this.getAttribute('format');
        var date = this.date;
        if (!date) return;

        if (format === 'micro') {
          return new RelativeTime(date, localeFromElement(this)).microTimeAgo();
        } else {
          return new RelativeTime(date, localeFromElement(this)).timeAgo();
        }
      }
    }]);
    return TimeAgoElement;
  }(RelativeTimeElement);

  _exports.TimeAgoElement = TimeAgoElement;

  if (!window.customElements.get('time-ago')) {
    window.TimeAgoElement = TimeAgoElement;
    window.customElements.define('time-ago', TimeAgoElement);
  }

  var TimeUntilElement = /*#__PURE__*/function (_RelativeTimeElement2) {
    babelHelpers.inherits(TimeUntilElement, _RelativeTimeElement2);

    var _super5 = _createSuper(TimeUntilElement);

    function TimeUntilElement() {
      babelHelpers.classCallCheck(this, TimeUntilElement);
      return _super5.apply(this, arguments);
    }

    babelHelpers.createClass(TimeUntilElement, [{
      key: "getFormattedDate",
      value: function getFormattedDate() {
        var format = this.getAttribute('format');
        var date = this.date;
        if (!date) return;

        if (format === 'micro') {
          return new RelativeTime(date, localeFromElement(this)).microTimeUntil();
        } else {
          return new RelativeTime(date, localeFromElement(this)).timeUntil();
        }
      }
    }]);
    return TimeUntilElement;
  }(RelativeTimeElement);

  _exports.TimeUntilElement = TimeUntilElement;

  if (!window.customElements.get('time-until')) {
    window.TimeUntilElement = TimeUntilElement;
    window.customElements.define('time-until', TimeUntilElement);
  }
});