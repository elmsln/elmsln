define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/utils/gestures.js", "../../../@polymer/polymer/lib/elements/dom-repeat.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "../../vaadin-button/src/vaadin-button.js", "./vaadin-upload-icons.js", "./vaadin-upload-file.js", "../../vaadin-element-mixin/vaadin-element-mixin.js", "../../../@polymer/polymer/lib/utils/html-tag.js"], function (_exports, _polymerElement, _gestures, _domRepeat, _vaadinThemableMixin, _vaadinButton, _vaadinUploadIcons, _vaadinUploadFile, _vaadinElementMixin, _htmlTag) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.UploadElement = void 0;

  var _templateObject_ccb8ff50809211edaa2833647dc78c6c;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `<vaadin-upload>` is a Web Component for uploading multiple files with drag and drop support.
   *
   * Example:
   *
   * ```
   * <vaadin-upload></vaadin-upload>
   * ```
   *
   * ### Styling
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name | Description
   * ---|---
   * `primary-buttons` | Upload container
   * `upload-button` | Upload button
   * `drop-label` | Label for drop indicator
   * `drop-label-icon` | Icon for drop indicator
   * `file-list` | File list container
   *
   * The following state attributes are available for styling:
   *
   * Attribute | Description | Part name
   * ---|---|---
   * `nodrop` | Set when drag and drop is disabled (e. g., on touch devices) | `:host`
   * `dragover` | A file is being dragged over the element | `:host`
   * `dragover-valid` | A dragged file is valid with `maxFiles` and `accept` criteria | `:host`
   * `max-files-reached` | The maximum number of files that the user is allowed to add to the upload has been reached | `:host`
   *
   * See [ThemableMixin â€“ how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
   *
   * @extends PolymerElement
   * @mixes ThemableMixin
   * @mixes ElementMixin
   * @demo demo/index.html
   */
  var UploadElement = /*#__PURE__*/function (_ElementMixin) {
    babelHelpers.inherits(UploadElement, _ElementMixin);

    var _super = _createSuper(UploadElement);

    function UploadElement() {
      babelHelpers.classCallCheck(this, UploadElement);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(UploadElement, [{
      key: "ready",
      value:
      /** @protected */
      function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(UploadElement.prototype), "ready", this).call(this);
        this.addEventListener('dragover', this._onDragover.bind(this));
        this.addEventListener('dragleave', this._onDragleave.bind(this));
        this.addEventListener('drop', this._onDrop.bind(this));
        this.addEventListener('file-retry', this._onFileRetry.bind(this));
        this.addEventListener('file-abort', this._onFileAbort.bind(this));
        this.addEventListener('file-remove', this._onFileRemove.bind(this));
        this.addEventListener('file-start', this._onFileStart.bind(this));
      }
      /** @private */

    }, {
      key: "_formatSize",
      value: function _formatSize(bytes) {
        if (typeof this.i18n.formatSize === 'function') {
          return this.i18n.formatSize(bytes);
        } // https://wiki.ubuntu.com/UnitsPolicy


        var base = this.i18n.units.sizeBase || 1000;
        var unit = ~~(Math.log(bytes) / Math.log(base));
        var dec = Math.max(0, Math.min(3, unit - 1));
        var size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
        return size + ' ' + this.i18n.units.size[unit];
      }
      /** @private */

    }, {
      key: "_splitTimeByUnits",
      value: function _splitTimeByUnits(time) {
        var unitSizes = [60, 60, 24, Infinity];
        var timeValues = [0];

        for (var i = 0; i < unitSizes.length && time > 0; i++) {
          timeValues[i] = time % unitSizes[i];
          time = Math.floor(time / unitSizes[i]);
        }

        return timeValues;
      }
      /** @private */

    }, {
      key: "_formatTime",
      value: function _formatTime(seconds, split) {
        if (typeof this.i18n.formatTime === 'function') {
          return this.i18n.formatTime(seconds, split);
        } // Fill HH:MM:SS with leading zeros


        while (split.length < 3) {
          split.push(0);
        }

        return split.reverse().map(function (number) {
          return (number < 10 ? '0' : '') + number;
        }).join(':');
      }
      /** @private */

    }, {
      key: "_formatFileProgress",
      value: function _formatFileProgress(file) {
        return file.totalStr + ': ' + file.progress + '% (' + (file.loaded > 0 ? this.i18n.uploading.remainingTime.prefix + file.remainingStr : this.i18n.uploading.remainingTime.unknown) + ')';
      }
      /** @private */

    }, {
      key: "_maxFilesAdded",
      value: function _maxFilesAdded(maxFiles, numFiles) {
        return maxFiles >= 0 && numFiles >= maxFiles;
      }
      /** @private */

    }, {
      key: "_onDragover",
      value: function _onDragover(event) {
        event.preventDefault();

        if (!this.nodrop && !this._dragover) {
          this._dragoverValid = !this.maxFilesReached;
          this._dragover = true;
        }

        event.dataTransfer.dropEffect = !this._dragoverValid || this.nodrop ? 'none' : 'copy';
      }
      /** @private */

    }, {
      key: "_onDragleave",
      value: function _onDragleave(event) {
        event.preventDefault();

        if (this._dragover && !this.nodrop) {
          this._dragover = this._dragoverValid = false;
        }
      }
      /** @private */

    }, {
      key: "_onDrop",
      value: function _onDrop(event) {
        if (!this.nodrop) {
          event.preventDefault();
          this._dragover = this._dragoverValid = false;

          this._addFiles(event.dataTransfer.files);
        }
      }
      /** @private */

    }, {
      key: "_createXhr",
      value: function _createXhr() {
        return new XMLHttpRequest();
      }
      /** @private */

    }, {
      key: "_configureXhr",
      value: function _configureXhr(xhr) {
        if (typeof this.headers == 'string') {
          try {
            this.headers = JSON.parse(this.headers);
          } catch (e) {
            this.headers = undefined;
          }
        }

        for (var key in this.headers) {
          xhr.setRequestHeader(key, this.headers[key]);
        }

        if (this.timeout) {
          xhr.timeout = this.timeout;
        }

        xhr.withCredentials = this.withCredentials;
      }
      /** @private */

    }, {
      key: "_setStatus",
      value: function _setStatus(file, total, loaded, elapsed) {
        file.elapsed = elapsed;
        file.elapsedStr = this._formatTime(file.elapsed, this._splitTimeByUnits(file.elapsed));
        file.remaining = Math.ceil(elapsed * (total / loaded - 1));
        file.remainingStr = this._formatTime(file.remaining, this._splitTimeByUnits(file.remaining));
        file.speed = ~~(total / elapsed / 1024);
        file.totalStr = this._formatSize(total);
        file.loadedStr = this._formatSize(loaded);
        file.status = this._formatFileProgress(file);
      }
      /**
       * Triggers the upload of any files that are not completed
       *
       * @param {!UploadFile | !Array<!UploadFile>=} files - Files being uploaded. Defaults to all outstanding files
       */

    }, {
      key: "uploadFiles",
      value: function uploadFiles(files) {
        if (files && !Array.isArray(files)) {
          files = [files];
        }

        files = files || this.files;
        files = files.filter(function (file) {
          return !file.complete;
        });
        Array.prototype.forEach.call(files, this._uploadFile.bind(this));
      }
      /** @private */

    }, {
      key: "_uploadFile",
      value: function _uploadFile(file) {
        var _this = this;

        if (file.uploading) {
          return;
        }

        var ini = Date.now();

        var xhr = file.xhr = this._createXhr();

        var stalledId, last; // onprogress is called always after onreadystatechange

        xhr.upload.onprogress = function (e) {
          clearTimeout(stalledId);
          last = Date.now();
          var elapsed = (last - ini) / 1000;
          var loaded = e.loaded,
              total = e.total,
              progress = ~~(loaded / total * 100);
          file.loaded = loaded;
          file.progress = progress;
          file.indeterminate = loaded <= 0 || loaded >= total;

          if (file.error) {
            file.indeterminate = file.status = undefined;
          } else if (!file.abort) {
            if (progress < 100) {
              _this._setStatus(file, total, loaded, elapsed);

              stalledId = setTimeout(function () {
                file.status = _this.i18n.uploading.status.stalled;

                _this._notifyFileChanges(file);
              }, 2000);
            } else {
              file.loadedStr = file.totalStr;
              file.status = _this.i18n.uploading.status.processing;
            }
          }

          _this._notifyFileChanges(file);

          _this.dispatchEvent(new CustomEvent('upload-progress', {
            detail: {
              file: file,
              xhr: xhr
            }
          }));
        }; // More reliable than xhr.onload


        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4) {
            clearTimeout(stalledId);
            file.indeterminate = file.uploading = false;

            if (file.abort) {
              _this._notifyFileChanges(file);

              return;
            }

            file.status = ''; // Custom listener can modify the default behavior either
            // preventing default, changing the xhr, or setting the file error

            var _evt = _this.dispatchEvent(new CustomEvent('upload-response', {
              detail: {
                file: file,
                xhr: xhr
              },
              cancelable: true
            }));

            if (!_evt) {
              return;
            }

            if (xhr.status === 0) {
              file.error = _this.i18n.uploading.error.serverUnavailable;
            } else if (xhr.status >= 500) {
              file.error = _this.i18n.uploading.error.unexpectedServerError;
            } else if (xhr.status >= 400) {
              file.error = _this.i18n.uploading.error.forbidden;
            }

            file.complete = !file.error;

            _this.dispatchEvent(new CustomEvent("upload-".concat(file.error ? 'error' : 'success'), {
              detail: {
                file: file,
                xhr: xhr
              }
            }));

            _this._notifyFileChanges(file);
          }
        };

        var formData = new FormData();
        file.uploadTarget = file.uploadTarget || this.target || '';
        file.formDataName = this.formDataName;
        var evt = this.dispatchEvent(new CustomEvent('upload-before', {
          detail: {
            file: file,
            xhr: xhr
          },
          cancelable: true
        }));

        if (!evt) {
          return;
        }

        formData.append(file.formDataName, file, file.name);
        xhr.open(this.method, file.uploadTarget, true);

        this._configureXhr(xhr);

        file.status = this.i18n.uploading.status.connecting;
        file.uploading = file.indeterminate = true;
        file.complete = file.abort = file.error = file.held = false;

        xhr.upload.onloadstart = function () {
          _this.dispatchEvent(new CustomEvent('upload-start', {
            detail: {
              file: file,
              xhr: xhr
            }
          }));

          _this._notifyFileChanges(file);
        }; // Custom listener could modify the xhr just before sending it
        // preventing default


        var uploadEvt = this.dispatchEvent(new CustomEvent('upload-request', {
          detail: {
            file: file,
            xhr: xhr,
            formData: formData
          },
          cancelable: true
        }));

        if (uploadEvt) {
          xhr.send(formData);
        }
      }
      /** @private */

    }, {
      key: "_retryFileUpload",
      value: function _retryFileUpload(file) {
        var evt = this.dispatchEvent(new CustomEvent('upload-retry', {
          detail: {
            file: file,
            xhr: file.xhr
          },
          cancelable: true
        }));

        if (evt) {
          this._uploadFile(file);
        }
      }
      /** @private */

    }, {
      key: "_abortFileUpload",
      value: function _abortFileUpload(file) {
        var evt = this.dispatchEvent(new CustomEvent('upload-abort', {
          detail: {
            file: file,
            xhr: file.xhr
          },
          cancelable: true
        }));

        if (evt) {
          file.abort = true;

          if (file.xhr) {
            file.xhr.abort();
          }

          this._notifyFileChanges(file);
        }
      }
      /** @private */

    }, {
      key: "_notifyFileChanges",
      value: function _notifyFileChanges(file) {
        var p = 'files.' + this.files.indexOf(file) + '.';

        for (var i in file) {
          if (file.hasOwnProperty(i)) {
            this.notifyPath(p + i, file[i]);
          }
        }
      }
      /** @private */

    }, {
      key: "_addFiles",
      value: function _addFiles(files) {
        Array.prototype.forEach.call(files, this._addFile.bind(this));
      }
      /**
       * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.
       *
       * @param {!UploadFile} file File being added
       * @protected
       */

    }, {
      key: "_addFile",
      value: function _addFile(file) {
        if (this.maxFilesReached) {
          this.dispatchEvent(new CustomEvent('file-reject', {
            detail: {
              file: file,
              error: this.i18n.error.tooManyFiles
            }
          }));
          return;
        }

        if (this.maxFileSize >= 0 && file.size > this.maxFileSize) {
          this.dispatchEvent(new CustomEvent('file-reject', {
            detail: {
              file: file,
              error: this.i18n.error.fileIsTooBig
            }
          }));
          return;
        }

        var fileExt = file.name.match(/\.[^\.]*$|$/)[0];
        var re = new RegExp('^(' + this.accept.replace(/[, ]+/g, '|').replace(/\/\*/g, '/.*') + ')$', 'i');

        if (this.accept && !(re.test(file.type) || re.test(fileExt))) {
          this.dispatchEvent(new CustomEvent('file-reject', {
            detail: {
              file: file,
              error: this.i18n.error.incorrectFileType
            }
          }));
          return;
        }

        file.loaded = 0;
        file.held = true;
        file.status = this.i18n.uploading.status.held;
        this.unshift('files', file);

        if (!this.noAuto) {
          this._uploadFile(file);
        }
      }
      /**
       * Remove file from upload list. Called internally if file upload was canceled.
       * @param {!UploadFile} file File to remove
       * @protected
       */

    }, {
      key: "_removeFile",
      value: function _removeFile(file) {
        if (this.files.indexOf(file) > -1) {
          this.splice('files', this.files.indexOf(file), 1);
        }
      }
      /** @private */

    }, {
      key: "_onAddFilesTouchEnd",
      value: function _onAddFilesTouchEnd(e) {
        // Cancel the event to avoid the following click event
        e.preventDefault(); // FIXME(platosha): workaround for Polymer Gestures mouseCanceller
        // cancelling the following synthetic click. See also:
        // https://github.com/Polymer/polymer/issues/5289

        this.__resetMouseCanceller();

        this._onAddFilesClick();
      }
      /** @private */

    }, {
      key: "__resetMouseCanceller",
      value: function __resetMouseCanceller() {
        (0, _gestures.resetMouseCanceller)();
      }
      /** @private */

    }, {
      key: "_onAddFilesClick",
      value: function _onAddFilesClick() {
        if (this.maxFilesReached) {
          return;
        }

        this.$.fileInput.value = '';
        this.$.fileInput.click();
      }
      /** @private */

    }, {
      key: "_onFileInputChange",
      value: function _onFileInputChange(event) {
        this._addFiles(event.target.files);
      }
      /** @private */

    }, {
      key: "_onFileStart",
      value: function _onFileStart(event) {
        this._uploadFile(event.detail.file);
      }
      /** @private */

    }, {
      key: "_onFileRetry",
      value: function _onFileRetry(event) {
        this._retryFileUpload(event.detail.file);
      }
      /** @private */

    }, {
      key: "_onFileAbort",
      value: function _onFileAbort(event) {
        this._abortFileUpload(event.detail.file);
      }
      /** @private */

    }, {
      key: "_onFileRemove",
      value: function _onFileRemove(event) {
        this._removeFile(event.detail.file);
      }
      /** @private */

    }, {
      key: "_dragoverChanged",
      value: function _dragoverChanged(dragover) {
        dragover ? this.setAttribute('dragover', dragover) : this.removeAttribute('dragover');
      }
      /** @private */

    }, {
      key: "_dragoverValidChanged",
      value: function _dragoverValidChanged(dragoverValid) {
        dragoverValid ? this.setAttribute('dragover-valid', dragoverValid) : this.removeAttribute('dragover-valid');
      }
      /** @private */

    }, {
      key: "_i18nPlural",
      value: function _i18nPlural(value, plural) {
        return value == 1 ? plural.one : plural.many;
      }
      /** @private */

    }, {
      key: "_isMultiple",
      value: function _isMultiple(maxFiles) {
        return maxFiles != 1;
      }
      /**
      * Fired when a file cannot be added to the queue due to a constrain:
      *  file-size, file-type or maxFiles
      *
      * @event file-reject
      * @param {Object} detail
      * @param {Object} detail.file the file added
      * @param {string} detail.error the cause
      */

      /**
      * Fired before the XHR is opened. Could be used for changing the request
      * URL. If the default is prevented, then XHR would not be opened.
      *
      * @event upload-before
      * @param {Object} detail
      * @param {Object} detail.xhr the xhr
      * @param {Object} detail.file the file being uploaded
      * @param {Object} detail.file.uploadTarget the upload request URL, initialized with the value of vaadin-upload `target` property
      */

      /**
      * Fired when the XHR has been opened but not sent yet. Useful for appending
      * data keys to the FormData object, for changing some parameters like
      * headers, etc. If the event is defaultPrevented, `vaadin-upload` will not
      * send the request allowing the user to do something on his own.
      *
      * @event upload-request
      * @param {Object} detail
      * @param {Object} detail.xhr the xhr
      * @param {Object} detail.file the file being uploaded
      * @param {Object} detail.formData the FormData object
      */

      /**
      * Fired when the XHR is sent.
      *
      * @event upload-start
      * @param {Object} detail
      * @param {Object} detail.xhr the xhr
      * @param {Object} detail.file the file being uploaded
      */

      /**
      * Fired as many times as the progress is updated.
      *
      * @event upload-progress
      * @param {Object} detail
      * @param {Object} detail.xhr the xhr
      * @param {Object} detail.file the file being uploaded with loaded info
      */

      /**
      * Fired when we have the actual server response, and before the component
      * analyses it. It's useful for developers to make the upload fail depending
      * on the server response. If the event is defaultPrevented the vaadin-upload
      * will return allowing the user to do something on his own like retry the
      * upload, etc. since he has full access to the `xhr` and `file` objects.
      * Otherwise, if the event is not prevented default `vaadin-upload` continues
      * with the normal workflow checking the `xhr.status` and `file.error`
      * which also might be modified by the user to force a customized response.
      *
      * @event upload-response
      * @param {Object} detail
      * @param {Object} detail.xhr the xhr
      * @param {Object} detail.file the file being uploaded
      */

      /**
      * Fired in case the upload process succeed.
      *
      * @event upload-success
      * @param {Object} detail
      * @param {Object} detail.xhr the xhr
      * @param {Object} detail.file the file being uploaded with loaded info
      */

      /**
      * Fired in case the upload process failed.
      *
      * @event upload-error
      * @param {Object} detail
      * @param {Object} detail.xhr the xhr
      * @param {Object} detail.file the file being uploaded
      */

      /**
      * Fired when retry upload is requested. If the default is prevented, then
      * retry would not be performed.
      *
      * @event upload-retry
      * @param {Object} detail
      * @param {Object} detail.xhr the previous upload xhr
      * @param {Object} detail.file the file being uploaded
      */

      /**
      * Fired when retry abort is requested. If the default is prevented, then the
      * file upload would not be aborted.
      *
      * @event upload-abort
      * @param {Object} detail
      * @param {Object} detail.xhr the xhr
      * @param {Object} detail.file the file being uploaded
      */

    }], [{
      key: "template",
      get: function get() {
        return (0, _htmlTag.html)(_templateObject_ccb8ff50809211edaa2833647dc78c6c || (_templateObject_ccb8ff50809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: block;\n        position: relative;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      [hidden] {\n        display: none !important;\n      }\n    </style>\n\n    <div part=\"primary-buttons\">\n      <div id=\"addFiles\" on-touchend=\"_onAddFilesTouchEnd\" on-click=\"_onAddFilesClick\">\n        <slot name=\"add-button\">\n          <vaadin-button part=\"upload-button\" id=\"addButton\" disabled=\"[[maxFilesReached]]\">\n            [[_i18nPlural(maxFiles, i18n.addFiles, i18n.addFiles.*)]]\n          </vaadin-button>\n        </slot>\n      </div>\n      <div part=\"drop-label\" hidden$=\"[[nodrop]]\" id=\"dropLabelContainer\">\n        <slot name=\"drop-label-icon\">\n          <div part=\"drop-label-icon\"></div>\n        </slot>\n        <slot name=\"drop-label\" id=\"dropLabel\">\n          [[_i18nPlural(maxFiles, i18n.dropFiles, i18n.dropFiles.*)]]\n        </slot>\n      </div>\n    </div>\n    <slot name=\"file-list\">\n      <div id=\"fileList\" part=\"file-list\">\n        <template is=\"dom-repeat\" items=\"[[files]]\" as=\"file\">\n          <vaadin-upload-file file=\"[[file]]\"></vaadin-upload-file>\n        </template>\n      </div>\n    </slot>\n    <slot></slot>\n    <input type=\"file\" id=\"fileInput\" on-change=\"_onFileInputChange\" hidden=\"\" accept$=\"{{accept}}\" multiple$=\"[[_isMultiple(maxFiles)]]\" capture$=\"[[capture]]\">\n"], ["\n    <style>\n      :host {\n        display: block;\n        position: relative;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      [hidden] {\n        display: none !important;\n      }\n    </style>\n\n    <div part=\"primary-buttons\">\n      <div id=\"addFiles\" on-touchend=\"_onAddFilesTouchEnd\" on-click=\"_onAddFilesClick\">\n        <slot name=\"add-button\">\n          <vaadin-button part=\"upload-button\" id=\"addButton\" disabled=\"[[maxFilesReached]]\">\n            [[_i18nPlural(maxFiles, i18n.addFiles, i18n.addFiles.*)]]\n          </vaadin-button>\n        </slot>\n      </div>\n      <div part=\"drop-label\" hidden\\$=\"[[nodrop]]\" id=\"dropLabelContainer\">\n        <slot name=\"drop-label-icon\">\n          <div part=\"drop-label-icon\"></div>\n        </slot>\n        <slot name=\"drop-label\" id=\"dropLabel\">\n          [[_i18nPlural(maxFiles, i18n.dropFiles, i18n.dropFiles.*)]]\n        </slot>\n      </div>\n    </div>\n    <slot name=\"file-list\">\n      <div id=\"fileList\" part=\"file-list\">\n        <template is=\"dom-repeat\" items=\"[[files]]\" as=\"file\">\n          <vaadin-upload-file file=\"[[file]]\"></vaadin-upload-file>\n        </template>\n      </div>\n    </slot>\n    <slot></slot>\n    <input type=\"file\" id=\"fileInput\" on-change=\"_onFileInputChange\" hidden=\"\" accept\\$=\"{{accept}}\" multiple\\$=\"[[_isMultiple(maxFiles)]]\" capture\\$=\"[[capture]]\">\n"])));
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-upload';
      }
    }, {
      key: "version",
      get: function get() {
        return '4.4.3';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Define whether the element supports dropping files on it for uploading.
           * By default it's enabled in desktop and disabled in touch devices
           * because mobile devices do not support drag events in general. Setting
           * it false means that drop is enabled even in touch-devices, and true
           * disables drop in all devices.
           *
           * @type {boolean}
           * @default true in touch-devices, false otherwise.
           */
          nodrop: {
            type: Boolean,
            reflectToAttribute: true,
            value: function value() {
              try {
                return !!document.createEvent('TouchEvent');
              } catch (e) {
                return false;
              }
            }
          },

          /**
           * The server URL. The default value is an empty string, which means that
           * _window.location_ will be used.
           * @type {string}
           */
          target: {
            type: String,
            value: ''
          },

          /**
           * HTTP Method used to send the files. Only POST and PUT are allowed.
           * @type {!UploadMethod}
           */
          method: {
            type: String,
            value: 'POST'
          },

          /**
           * Key-Value map to send to the server. If you set this property as an
           * attribute, use a valid JSON string, for example:
           * ```
           * <vaadin-upload headers='{"X-Foo": "Bar"}'></vaadin-upload>
           * ```
           * @type {object | string}
           */
          headers: {
            type: Object,
            value: {}
          },

          /**
           * Max time in milliseconds for the entire upload process, if exceeded the
           * request will be aborted. Zero means that there is no timeout.
           * @type {number}
           */
          timeout: {
            type: Number,
            value: 0
          },

          /** @private */
          _dragover: {
            type: Boolean,
            value: false,
            observer: '_dragoverChanged'
          },

          /**
           * The array of files being processed, or already uploaded.
           *
           * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
           * object with a number of extra properties  to track the upload process:
           * - `uploadTarget`: The target URL used to upload this file.
           * - `elapsed`: Elapsed time since the upload started.
           * - `elapsedStr`: Human-readable elapsed time.
           * - `remaining`: Number of seconds remaining for the upload to finish.
           * - `remainingStr`: Human-readable remaining time for the upload to finish.
           * - `progress`: Percentage of the file already uploaded.
           * - `speed`: Upload speed in kB/s.
           * - `size`: File size in bytes.
           * - `totalStr`: Human-readable total size of the file.
           * - `loaded`: Bytes transferred so far.
           * - `loadedStr`: Human-readable uploaded size at the moment.
           * - `status`: Status of the upload process.
           * - `error`: Error message in case the upload failed.
           * - `abort`: True if the file was canceled by the user.
           * - `complete`: True when the file was transferred to the server.
           * - `uploading`: True while transferring data to the server.
           * @type {!Array<!UploadFile>}
           */
          files: {
            type: Array,
            notify: true,
            value: function value() {
              return [];
            }
          },

          /**
           * Limit of files to upload, by default it is unlimited. If the value is
           * set to one, native file browser will prevent selecting multiple files.
           * @attr {number} max-files
           * @type {number}
           */
          maxFiles: {
            type: Number,
            value: Infinity
          },

          /**
           * Specifies if the maximum number of files have been uploaded
           * @attr {boolean} max-files-reached
           * @type {boolean}
           */
          maxFilesReached: {
            type: Boolean,
            value: false,
            notify: true,
            readOnly: true,
            reflectToAttribute: true,
            computed: '_maxFilesAdded(maxFiles, files.length)'
          },

          /**
           * Specifies the types of files that the server accepts.
           * Syntax: a comma-separated list of MIME type patterns (wildcards are
           * allowed) or file extensions.
           * Notice that MIME types are widely supported, while file extensions
           * are only implemented in certain browsers, so avoid using it.
           * Example: accept="video/*,image/tiff" or accept=".pdf,audio/mp3"
           * @type {string}
           */
          accept: {
            type: String,
            value: ''
          },

          /**
           * Specifies the maximum file size in bytes allowed to upload.
           * Notice that it is a client-side constraint, which will be checked before
           * sending the request. Obviously you need to do the same validation in
           * the server-side and be sure that they are aligned.
           * @attr {number} max-file-size
           * @type {number}
           */
          maxFileSize: {
            type: Number,
            value: Infinity
          },

          /**
           * Specifies if the dragover is validated with maxFiles and
           * accept properties.
           * @private
           */
          _dragoverValid: {
            type: Boolean,
            value: false,
            observer: '_dragoverValidChanged'
          },

          /**
           * Specifies the 'name' property at Content-Disposition
           * @attr {string} form-data-name
           * @type {string}
           */
          formDataName: {
            type: String,
            value: 'file'
          },

          /**
           * Prevents upload(s) from immediately uploading upon adding file(s).
           * When set, you must manually trigger uploads using the `uploadFiles` method
           * @attr {boolean} no-auto
           * @type {boolean}
           */
          noAuto: {
            type: Boolean,
            value: false
          },

          /**
           * Set the withCredentials flag on the request.
           * @attr {boolean} with-credentials
           * @type {boolean}
           */
          withCredentials: {
            type: Boolean,
            value: false
          },

          /**
           * Pass-through to input's capture attribute. Allows user to trigger device inputs
           * such as camera or microphone immediately.
           */
          capture: String,

          /**
           * The object used to localize this component.
           * For changing the default localization, change the entire
           * _i18n_ object or just the property you want to modify.
           *
           * The object has the following JSON structure and default values:
           {
            dropFiles: {
            one: 'Drop file here
            many: 'Drop files here
            },
            addFiles: {
            one: 'Select File...',
            many: 'Upload Files...'
            },
            cancel: 'Cancel',
            error: {
            tooManyFiles: 'Too Many Files.',
            fileIsTooBig: 'File is Too Big.',
            incorrectFileType: 'Incorrect File Type.'
            },
            uploading: {
            status: {
              connecting: 'Connecting...',
              stalled: 'Stalled',
              processing: 'Processing File...',
              held: 'Queued'
            },
            remainingTime: {
              prefix: 'remaining time: ',
              unknown: 'unknown remaining time'
            },
            error: {
              serverUnavailable: 'Server Unavailable',
              unexpectedServerError: 'Unexpected Server Error',
              forbidden: 'Forbidden'
            }
            },
            units: {
            size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            sizeBase: 1000
            },
            formatSize: function(bytes) {
            // returns the size followed by the best suitable unit
            },
            formatTime: function(seconds, [secs, mins, hours]) {
            // returns a 'HH:MM:SS' string
            }
          }
           * @type {!UploadI18n}
          * @default {English}
          */
          i18n: {
            type: Object,
            value: function value() {
              return {
                dropFiles: {
                  one: 'Drop file here',
                  many: 'Drop files here'
                },
                addFiles: {
                  one: 'Upload File...',
                  many: 'Upload Files...'
                },
                cancel: 'Cancel',
                error: {
                  tooManyFiles: 'Too Many Files.',
                  fileIsTooBig: 'File is Too Big.',
                  incorrectFileType: 'Incorrect File Type.'
                },
                uploading: {
                  status: {
                    connecting: 'Connecting...',
                    stalled: 'Stalled.',
                    processing: 'Processing File...',
                    held: 'Queued'
                  },
                  remainingTime: {
                    prefix: 'remaining time: ',
                    unknown: 'unknown remaining time'
                  },
                  error: {
                    serverUnavailable: 'Server Unavailable',
                    unexpectedServerError: 'Unexpected Server Error',
                    forbidden: 'Forbidden'
                  }
                },
                units: {
                  size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
                }
              };
            }
          }
        };
      }
    }]);
    return UploadElement;
  }((0, _vaadinElementMixin.ElementMixin)((0, _vaadinThemableMixin.ThemableMixin)(_polymerElement.PolymerElement)));

  _exports.UploadElement = UploadElement;
  customElements.define(UploadElement.is, UploadElement);
});