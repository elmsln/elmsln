define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/mixins/gesture-event-listeners.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "../../vaadin-control-state-mixin/vaadin-control-state-mixin.js", "../../vaadin-element-mixin/vaadin-element-mixin.js", "../../../@polymer/polymer/lib/utils/html-tag.js", "../../../@polymer/polymer/lib/utils/gestures.js"], function (_exports, _polymerElement, _gestureEventListeners, _vaadinThemableMixin, _vaadinControlStateMixin, _vaadinElementMixin, _htmlTag, _gestures) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ButtonElement = void 0;

  var _templateObject_cbd9e9f0809211edaa2833647dc78c6c;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `<vaadin-button>` is a Web Component providing an accessible and customizable button.
   *
   * ```html
   * <vaadin-button>
   * </vaadin-button>
   * ```
   *
   * ```js
   * document.querySelector('vaadin-button').addEventListener('click', () => alert('Hello World!'));
   * ```
   *
   * ### Styling
   *
   * The following shadow DOM parts are exposed for styling:
   *
   * Part name | Description
   * ----------------|----------------
   * `label` | The label (text) inside the button
   * `prefix` | A slot for e.g. an icon before the label
   * `suffix` | A slot for e.g. an icon after the label
   *
   *
   * The following attributes are exposed for styling:
   *
   * Attribute | Description
   * --------- | -----------
   * `active` | Set when the button is pressed down, either with mouse, touch or the keyboard.
   * `disabled` | Set when the button is disabled.
   * `focus-ring` | Set when the button is focused using the keyboard.
   * `focused` | Set when the button is focused.
   *
   * See [ThemableMixin â€“ how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
   *
   * @extends PolymerElement
   * @mixes ElementMixin
   * @mixes ControlStateMixin
   * @mixes ThemableMixin
   * @mixes GestureEventListeners
   * @demo demo/index.html
   */
  var ButtonElement = /*#__PURE__*/function (_ElementMixin) {
    babelHelpers.inherits(ButtonElement, _ElementMixin);

    var _super = _createSuper(ButtonElement);

    function ButtonElement() {
      babelHelpers.classCallCheck(this, ButtonElement);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(ButtonElement, [{
      key: "ready",
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(ButtonElement.prototype), "ready", this).call(this); // Leaving default role in the native button, makes navigation announcement
        // being different when using focus navigation (tab) versus using normal
        // navigation (arrows). The first way announces the label on a button
        // since the focus is moved programmatically, and the second on a group.

        this.setAttribute('role', 'button');
        this.$.button.setAttribute('role', 'presentation');

        this._addActiveListeners(); // Fix for https://github.com/vaadin/vaadin-button-flow/issues/120


        window.ShadyDOM && window.ShadyDOM.flush();
      }
      /**
       * @protected
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(ButtonElement.prototype), "disconnectedCallback", this).call(this); // `active` state is preserved when the element is disconnected between keydown and keyup events.
        // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.

        if (this.hasAttribute('active')) {
          this.removeAttribute('active');
        }
      }
      /** @private */

    }, {
      key: "_addActiveListeners",
      value: function _addActiveListeners() {
        var _this = this;

        (0, _gestures.addListener)(this, 'down', function () {
          return !_this.disabled && _this.setAttribute('active', '');
        });
        (0, _gestures.addListener)(this, 'up', function () {
          return _this.removeAttribute('active');
        });
        this.addEventListener('keydown', function (e) {
          return !_this.disabled && [13, 32].indexOf(e.keyCode) >= 0 && _this.setAttribute('active', '');
        });
        this.addEventListener('keyup', function () {
          return _this.removeAttribute('active');
        });
        this.addEventListener('blur', function () {
          return _this.removeAttribute('active');
        });
      }
      /**
       * @protected
       * @return {Element}
       */

    }, {
      key: "focusElement",
      get: function get() {
        return this.$.button;
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _htmlTag.html)(_templateObject_cbd9e9f0809211edaa2833647dc78c6c || (_templateObject_cbd9e9f0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n        outline: none;\n        white-space: nowrap;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      /* Ensure the button is always aligned on the baseline */\n      .vaadin-button-container::before {\n        content: \"\\2003\";\n        display: inline-block;\n        width: 0;\n      }\n\n      .vaadin-button-container {\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n        text-align: center;\n        width: 100%;\n        height: 100%;\n        min-height: inherit;\n        text-shadow: inherit;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        user-select: none;\n      }\n\n      [part=\"prefix\"],\n      [part=\"suffix\"] {\n        flex: none;\n      }\n\n      [part=\"label\"] {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      #button {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        width: 100%;\n        height: 100%;\n        opacity: 0;\n        cursor: inherit;\n      }\n    </style>\n    <div class=\"vaadin-button-container\">\n      <div part=\"prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div part=\"label\">\n        <slot></slot>\n      </div>\n      <div part=\"suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <button id=\"button\" type=\"button\"></button>\n"], ["\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n        outline: none;\n        white-space: nowrap;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      /* Ensure the button is always aligned on the baseline */\n      .vaadin-button-container::before {\n        content: \"\\\\2003\";\n        display: inline-block;\n        width: 0;\n      }\n\n      .vaadin-button-container {\n        display: inline-flex;\n        align-items: center;\n        justify-content: center;\n        text-align: center;\n        width: 100%;\n        height: 100%;\n        min-height: inherit;\n        text-shadow: inherit;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        user-select: none;\n      }\n\n      [part=\"prefix\"],\n      [part=\"suffix\"] {\n        flex: none;\n      }\n\n      [part=\"label\"] {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n      }\n\n      #button {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        width: 100%;\n        height: 100%;\n        opacity: 0;\n        cursor: inherit;\n      }\n    </style>\n    <div class=\"vaadin-button-container\">\n      <div part=\"prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div part=\"label\">\n        <slot></slot>\n      </div>\n      <div part=\"suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <button id=\"button\" type=\"button\"></button>\n"])));
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-button';
      }
    }, {
      key: "version",
      get: function get() {
        return '2.4.0';
      }
    }]);
    return ButtonElement;
  }((0, _vaadinElementMixin.ElementMixin)((0, _vaadinControlStateMixin.ControlStateMixin)((0, _vaadinThemableMixin.ThemableMixin)((0, _gestureEventListeners.GestureEventListeners)(_polymerElement.PolymerElement)))));

  _exports.ButtonElement = ButtonElement;
  customElements.define(ButtonElement.is, ButtonElement);
});