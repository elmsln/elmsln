define(["exports", "../../../@polymer/polymer/lib/utils/async.js", "../../../@polymer/polymer/lib/utils/debounce.js", "../../../@polymer/polymer/lib/utils/html-tag.js"], function (_exports, _async, _debounce, _htmlTag) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.TextFieldMixin = void 0;

  var _templateObject_a456fe10942811ecb1937969798b231a;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var $_documentContainer = (0, _htmlTag.html)(_templateObject_a456fe10942811ecb1937969798b231a || (_templateObject_a456fe10942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["<dom-module id=\"vaadin-text-field-shared-styles\">\n  <template>\n    <style>\n      :host {\n        display: inline-flex;\n        outline: none;\n      }\n\n      :host::before {\n        content: \"\\2003\";\n        width: 0;\n        display: inline-block;\n        /* Size and position this element on the same vertical position as the input-field element\n           to make vertical align for the host element work as expected */\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      .vaadin-text-field-container,\n      .vaadin-text-area-container {\n        display: flex;\n        flex-direction: column;\n        min-width: 100%;\n        max-width: 100%;\n        width: var(--vaadin-text-field-default-width, 12em);\n      }\n\n      [part=\"label\"]:empty {\n        display: none;\n      }\n\n      [part=\"input-field\"] {\n        display: flex;\n        align-items: center;\n        flex: auto;\n      }\n\n      .vaadin-text-field-container [part=\"input-field\"] {\n        flex-grow: 0;\n      }\n\n      /* Reset the native input styles */\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(input),\n      [part=\"input-field\"] ::slotted(textarea) {\n        -webkit-appearance: none;\n        -moz-appearance: none;\n        outline: none;\n        margin: 0;\n        padding: 0;\n        border: 0;\n        border-radius: 0;\n        min-width: 0;\n        font: inherit;\n        font-size: 1em;\n        line-height: normal;\n        color: inherit;\n        background-color: transparent;\n        /* Disable default invalid style in Firefox */\n        box-shadow: none;\n      }\n\n      [part=\"input-field\"] ::slotted(*) {\n        flex: none;\n      }\n\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(input),\n      [part=\"input-field\"] ::slotted(textarea),\n      /* Slotted by vaadin-select-text-field */\n      [part=\"input-field\"] ::slotted([part=\"value\"]) {\n        flex: auto;\n        white-space: nowrap;\n        overflow: hidden;\n        width: 100%;\n        height: 100%;\n      }\n\n      [part=\"input-field\"] ::slotted(textarea) {\n        resize: none;\n      }\n\n      [part=\"value\"]::-ms-clear,\n      [part=\"input-field\"] ::slotted(input)::-ms-clear {\n        display: none;\n      }\n\n      [part=\"clear-button\"] {\n        cursor: default;\n      }\n\n      [part=\"clear-button\"]::before {\n        content: \"\u2715\";\n      }\n    </style>\n  </template>\n</dom-module>"], ["<dom-module id=\"vaadin-text-field-shared-styles\">\n  <template>\n    <style>\n      :host {\n        display: inline-flex;\n        outline: none;\n      }\n\n      :host::before {\n        content: \"\\\\2003\";\n        width: 0;\n        display: inline-block;\n        /* Size and position this element on the same vertical position as the input-field element\n           to make vertical align for the host element work as expected */\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      .vaadin-text-field-container,\n      .vaadin-text-area-container {\n        display: flex;\n        flex-direction: column;\n        min-width: 100%;\n        max-width: 100%;\n        width: var(--vaadin-text-field-default-width, 12em);\n      }\n\n      [part=\"label\"]:empty {\n        display: none;\n      }\n\n      [part=\"input-field\"] {\n        display: flex;\n        align-items: center;\n        flex: auto;\n      }\n\n      .vaadin-text-field-container [part=\"input-field\"] {\n        flex-grow: 0;\n      }\n\n      /* Reset the native input styles */\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(input),\n      [part=\"input-field\"] ::slotted(textarea) {\n        -webkit-appearance: none;\n        -moz-appearance: none;\n        outline: none;\n        margin: 0;\n        padding: 0;\n        border: 0;\n        border-radius: 0;\n        min-width: 0;\n        font: inherit;\n        font-size: 1em;\n        line-height: normal;\n        color: inherit;\n        background-color: transparent;\n        /* Disable default invalid style in Firefox */\n        box-shadow: none;\n      }\n\n      [part=\"input-field\"] ::slotted(*) {\n        flex: none;\n      }\n\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(input),\n      [part=\"input-field\"] ::slotted(textarea),\n      /* Slotted by vaadin-select-text-field */\n      [part=\"input-field\"] ::slotted([part=\"value\"]) {\n        flex: auto;\n        white-space: nowrap;\n        overflow: hidden;\n        width: 100%;\n        height: 100%;\n      }\n\n      [part=\"input-field\"] ::slotted(textarea) {\n        resize: none;\n      }\n\n      [part=\"value\"]::-ms-clear,\n      [part=\"input-field\"] ::slotted(input)::-ms-clear {\n        display: none;\n      }\n\n      [part=\"clear-button\"] {\n        cursor: default;\n      }\n\n      [part=\"clear-button\"]::before {\n        content: \"\u2715\";\n      }\n    </style>\n  </template>\n</dom-module>"])));
  document.head.appendChild($_documentContainer.content);
  var HOST_PROPS = {
    default: ['list', 'autofocus', 'pattern', 'autocapitalize', 'autocorrect', 'maxlength', 'minlength', 'name', 'placeholder', 'autocomplete', 'title', 'disabled', 'readonly', 'required'],
    accessible: ['invalid']
  };
  var PROP_TYPE = {
    DEFAULT: 'default',
    ACCESSIBLE: 'accessible'
  };
  /**
   * @polymerMixin
   */

  var TextFieldMixin = function TextFieldMixin(subclass) {
    return /*#__PURE__*/function (_subclass) {
      babelHelpers.inherits(VaadinTextFieldMixin, _subclass);

      var _super = _createSuper(VaadinTextFieldMixin);

      function VaadinTextFieldMixin() {
        babelHelpers.classCallCheck(this, VaadinTextFieldMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(VaadinTextFieldMixin, [{
        key: "focusElement",
        get:
        /**
         * @return {HTMLElement | undefined}
         * @protected
         */
        function get() {
          if (!this.shadowRoot) {
            return;
          }

          var slotted = this.querySelector("".concat(this._slottedTagName, "[slot=\"").concat(this._slottedTagName, "\"]"));

          if (slotted) {
            return slotted;
          }

          return this.shadowRoot.querySelector('[part="value"]');
        }
        /**
         * @return {HTMLElement | undefined}}
         * @protected
         */

      }, {
        key: "inputElement",
        get: function get() {
          return this.focusElement;
        }
        /**
         * @return {string}
         * @protected
         */

      }, {
        key: "_slottedTagName",
        get: function get() {
          return 'input';
        }
        /** @protected */

      }, {
        key: "_createConstraintsObserver",
        value: function _createConstraintsObserver() {
          // This complex observer needs to be added dynamically here (instead of defining it above in the `get observers()`)
          // so that it runs after complex observers of inheriting classes. Otherwise e.g. `_stepOrMinChanged()` observer of
          // vaadin-number-field would run after this and the `min` and `step` properties would not yet be propagated to
          // the `inputElement` when this runs.
          this._createMethodObserver('_constraintsChanged(required, minlength, maxlength, pattern)');
        }
        /** @private */

      }, {
        key: "_onInput",
        value: function _onInput(e) {
          var _this = this;

          if (this.__preventInput) {
            e.stopImmediatePropagation();
            this.__preventInput = false;
            return;
          }

          if (this.preventInvalidInput) {
            var input = this.inputElement;

            if (input.value.length > 0 && !this.checkValidity()) {
              input.value = this.value || ''; // add input-prevented attribute for 200ms

              this.setAttribute('input-prevented', '');
              this._inputDebouncer = _debounce.Debouncer.debounce(this._inputDebouncer, _async.timeOut.after(200), function () {
                _this.removeAttribute('input-prevented');
              });
              return;
            }
          }

          if (!e.__fromClearButton) {
            this.__userInput = true;
          }

          this.value = e.target.value;
          this.__userInput = false;
        } // NOTE(yuriy): Workaround needed for IE11 and Edge for proper displaying
        // of the clear button instead of setting display property for it depending on state.

        /** @private */

      }, {
        key: "_stateChanged",
        value: function _stateChanged(disabled, readonly, clearButtonVisible, hasValue) {
          if (!disabled && !readonly && clearButtonVisible && hasValue) {
            this.$.clearButton.removeAttribute('hidden');
          } else {
            this.$.clearButton.setAttribute('hidden', true);
          }
        }
        /**
         * @param {!Event} e
         * @protected
         */

      }, {
        key: "_onChange",
        value: function _onChange(e) {
          if (this._valueClearing) {
            return;
          } // In the Shadow DOM, the `change` event is not leaked into the
          // ancestor tree, so we must do this manually.


          var changeEvent = new CustomEvent('change', {
            detail: {
              sourceEvent: e
            },
            bubbles: e.bubbles,
            cancelable: e.cancelable
          });
          this.dispatchEvent(changeEvent);
        }
        /**
         * @param {unknown} newVal
         * @param {unknown} oldVal
         * @protected
         */

      }, {
        key: "_valueChanged",
        value: function _valueChanged(newVal, oldVal) {
          // setting initial value to empty string, skip validation
          if (newVal === '' && oldVal === undefined) {
            return;
          }

          if (newVal !== '' && newVal != null) {
            this.hasValue = true;
          } else {
            this.hasValue = false;
          }

          if (this.__userInput) {
            return;
          } else if (newVal !== undefined) {
            this.inputElement.value = newVal;
          } else {
            this.value = this.inputElement.value = '';
          }

          if (this.invalid) {
            this.validate();
          }
        }
        /** @private */

      }, {
        key: "_labelChanged",
        value: function _labelChanged(label) {
          this._setOrToggleAttribute('has-label', !!label, this);
        }
        /** @private */

      }, {
        key: "_helperTextChanged",
        value: function _helperTextChanged(helperText) {
          this._setOrToggleAttribute('has-helper', !!helperText, this);
        }
        /** @private */

      }, {
        key: "_errorMessageChanged",
        value: function _errorMessageChanged(errorMessage) {
          this._setOrToggleAttribute('has-error-message', !!errorMessage, this);
        }
        /** @private */

      }, {
        key: "_onHelperSlotChange",
        value: function _onHelperSlotChange() {
          var slottedNodes = this.shadowRoot.querySelector("[name=\"helper\"]").assignedNodes({
            flatten: true
          }); // Only has slotted helper if not a text node
          // Text nodes are added by the helperText prop and not the helper slot
          // The filter is added due to shady DOM triggering this callback on helperText prop change

          this._hasSlottedHelper = slottedNodes.filter(function (node) {
            return node.nodeType !== 3;
          }).length;

          if (this._hasSlottedHelper) {
            this.setAttribute('has-helper', 'slotted');
          } else if (this.helperText === '' || this.helperText === null) {
            this.removeAttribute('has-helper');
          }
        }
        /** @private */

      }, {
        key: "_onSlotChange",
        value: function _onSlotChange() {
          var _this2 = this;

          var slotted = this.querySelector("".concat(this._slottedTagName, "[slot=\"").concat(this._slottedTagName, "\"]"));

          if (this.value) {
            this.inputElement.value = this.value;
            this.validate();
          }

          if (slotted && !this._slottedInput) {
            this._validateSlottedValue(slotted);

            this._addInputListeners(slotted);

            this._addIEListeners(slotted);

            this._slottedInput = slotted;
          } else if (!slotted && this._slottedInput) {
            this._removeInputListeners(this._slottedInput);

            this._removeIEListeners(this._slottedInput);

            this._slottedInput = undefined;
          }

          Object.keys(PROP_TYPE).map(function (key) {
            return PROP_TYPE[key];
          }).forEach(function (type) {
            return _this2._propagateHostAttributes(HOST_PROPS[type].map(function (attr) {
              return _this2[attr];
            }), type);
          });
        }
        /** @private */

      }, {
        key: "_hostPropsChanged",
        value: function _hostPropsChanged() {
          for (var _len = arguments.length, attributesValues = new Array(_len), _key = 0; _key < _len; _key++) {
            attributesValues[_key] = arguments[_key];
          }

          this._propagateHostAttributes(attributesValues, PROP_TYPE.DEFAULT);
        }
        /** @private */

      }, {
        key: "_hostAccessiblePropsChanged",
        value: function _hostAccessiblePropsChanged() {
          for (var _len2 = arguments.length, attributesValues = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            attributesValues[_key2] = arguments[_key2];
          }

          this._propagateHostAttributes(attributesValues, PROP_TYPE.ACCESSIBLE);
        }
        /** @private */

      }, {
        key: "_validateSlottedValue",
        value: function _validateSlottedValue(slotted) {
          if (slotted.value !== this.value) {
            console.warn('Please define value on the vaadin-text-field component!');
            slotted.value = '';
          }
        }
        /** @private */

      }, {
        key: "_propagateHostAttributes",
        value: function _propagateHostAttributes(attributesValues, type) {
          var _this3 = this;

          var input = this.inputElement;
          var attributeNames = HOST_PROPS[type];

          if (type === PROP_TYPE.ACCESSIBLE) {
            attributeNames.forEach(function (attr, index) {
              _this3._setOrToggleAttribute(attr, attributesValues[index], input);

              _this3._setOrToggleAttribute("aria-".concat(attr), attributesValues[index] ? 'true' : false, input);
            });
          } else {
            attributeNames.forEach(function (attr, index) {
              _this3._setOrToggleAttribute(attr, attributesValues[index], input);
            });
          }
        }
        /** @private */

      }, {
        key: "_setOrToggleAttribute",
        value: function _setOrToggleAttribute(name, value, node) {
          if (!name || !node) {
            return;
          }

          if (value) {
            node.setAttribute(name, typeof value === 'boolean' ? '' : value);
          } else {
            node.removeAttribute(name);
          }
        }
        /**
         * @param {boolean | undefined} required
         * @param {number | undefined} minlength
         * @param {number | undefined} maxlength
         * @param {string | undefined} maxlength
         * @protected
         */

      }, {
        key: "_constraintsChanged",
        value: function _constraintsChanged(required, minlength, maxlength, pattern) {
          if (!this.invalid) {
            return;
          }

          if (!required && !minlength && !maxlength && !pattern) {
            this.invalid = false;
          } else {
            this.validate();
          }
        }
        /**
         * Returns true if the current input value satisfies all constraints (if any)
         * @return {boolean}
         */

      }, {
        key: "checkValidity",
        value: function checkValidity() {
          // Note (Yuriy): `__forceCheckValidity` is used in containing components (i.e. `vaadin-date-picker`) in order
          // to force the checkValidity instead of returning the previous invalid state.
          if (this.required || this.pattern || this.maxlength || this.minlength || this.__forceCheckValidity) {
            return this.inputElement.checkValidity();
          } else {
            return !this.invalid;
          }
        }
        /** @private */

      }, {
        key: "_addInputListeners",
        value: function _addInputListeners(node) {
          node.addEventListener('input', this._boundOnInput);
          node.addEventListener('change', this._boundOnChange);
          node.addEventListener('blur', this._boundOnBlur);
          node.addEventListener('focus', this._boundOnFocus);
          node.addEventListener('paste', this._boundOnPaste);
          node.addEventListener('drop', this._boundOnDrop);
          node.addEventListener('beforeinput', this._boundOnBeforeInput);
        }
        /** @private */

      }, {
        key: "_removeInputListeners",
        value: function _removeInputListeners(node) {
          node.removeEventListener('input', this._boundOnInput);
          node.removeEventListener('change', this._boundOnChange);
          node.removeEventListener('blur', this._boundOnBlur);
          node.removeEventListener('focus', this._boundOnFocus);
          node.removeEventListener('paste', this._boundOnPaste);
          node.removeEventListener('drop', this._boundOnDrop);
          node.removeEventListener('beforeinput', this._boundOnBeforeInput);
        }
        /** @protected */

      }, {
        key: "ready",
        value: function ready() {
          var _this4 = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(VaadinTextFieldMixin.prototype), "ready", this).call(this);

          this._createConstraintsObserver();

          this._boundOnInput = this._onInput.bind(this);
          this._boundOnChange = this._onChange.bind(this);
          this._boundOnBlur = this._onBlur.bind(this);
          this._boundOnFocus = this._onFocus.bind(this);
          this._boundOnPaste = this._onPaste.bind(this);
          this._boundOnDrop = this._onDrop.bind(this);
          this._boundOnBeforeInput = this._onBeforeInput.bind(this);
          var defaultInput = this.shadowRoot.querySelector('[part="value"]');
          this._slottedInput = this.querySelector("".concat(this._slottedTagName, "[slot=\"").concat(this._slottedTagName, "\"]"));

          this._addInputListeners(defaultInput);

          this._addIEListeners(defaultInput);

          if (this._slottedInput) {
            this._addIEListeners(this._slottedInput);

            this._addInputListeners(this._slottedInput);
          }

          this.shadowRoot.querySelector('[name="input"], [name="textarea"]').addEventListener('slotchange', this._onSlotChange.bind(this));

          this._onHelperSlotChange();

          this.shadowRoot.querySelector('[name="helper"]').addEventListener('slotchange', this._onHelperSlotChange.bind(this));

          if (!(window.ShadyCSS && window.ShadyCSS.nativeCss)) {
            this.updateStyles();
          }

          this.$.clearButton.addEventListener('mousedown', function () {
            return _this4._valueClearing = true;
          });
          this.$.clearButton.addEventListener('mouseleave', function () {
            return _this4._valueClearing = false;
          });
          this.$.clearButton.addEventListener('click', this._onClearButtonClick.bind(this));
          this.addEventListener('keydown', this._onKeyDown.bind(this));
          var uniqueId = TextFieldMixin._uniqueId = 1 + TextFieldMixin._uniqueId || 0;
          this._errorId = "".concat(this.constructor.is, "-error-").concat(uniqueId);
          this._labelId = "".concat(this.constructor.is, "-label-").concat(uniqueId);
          this._helperTextId = "".concat(this.constructor.is, "-helper-").concat(uniqueId);
          this._inputId = "".concat(this.constructor.is, "-input-").concat(uniqueId); // Lumo theme defines a max-height transition for the "error-message"
          // part on invalid state change.

          this.shadowRoot.querySelector('[part="error-message"]').addEventListener('transitionend', function () {
            _this4.__observeOffsetHeight();
          });
        }
        /**
         * Returns true if `value` is valid.
         * `<iron-form>` uses this to check the validity for all its elements.
         *
         * @return {boolean} True if the value is valid.
         */

      }, {
        key: "validate",
        value: function validate() {
          return !(this.invalid = !this.checkValidity());
        }
      }, {
        key: "clear",
        value: function clear() {
          this.value = '';
        }
        /** @private */

      }, {
        key: "_onBlur",
        value: function _onBlur() {
          this.validate();
        }
        /** @private */

      }, {
        key: "_onFocus",
        value: function _onFocus() {
          var _this5 = this;

          if (this.autoselect) {
            this.inputElement.select(); // iOS 9 workaround: https://stackoverflow.com/a/7436574

            setTimeout(function () {
              try {
                _this5.inputElement.setSelectionRange(0, 9999);
              } catch (e) {// The workaround may cause errors on different input types.
                // Needs to be suppressed. See https://github.com/vaadin/flow/issues/6070
              }
            });
          }
        }
        /** @private */

      }, {
        key: "_onClearButtonClick",
        value: function _onClearButtonClick(e) {
          e.preventDefault(); // NOTE(yuriy): This line won't affect focus on the host. Cannot be properly tested.

          this.inputElement.focus();
          this.clear();
          this._valueClearing = false;

          if (navigator.userAgent.match(/Trident/)) {
            // Disable IE input" event prevention here, we want the input event from
            // below to propagate normally.
            this.__preventInput = false;
          }

          var inputEvent = new Event('input', {
            bubbles: true,
            composed: true
          });
          inputEvent.__fromClearButton = true;
          var changeEvent = new Event('change', {
            bubbles: !this._slottedInput
          });
          changeEvent.__fromClearButton = true;
          this.inputElement.dispatchEvent(inputEvent);
          this.inputElement.dispatchEvent(changeEvent);
        }
        /**
         * @param {!KeyboardEvent} e
         * @protected
         */

      }, {
        key: "_onKeyDown",
        value: function _onKeyDown(e) {
          if (e.keyCode === 27 && this.clearButtonVisible) {
            var dispatchChange = !!this.value;
            this.clear();
            dispatchChange && this.inputElement.dispatchEvent(new Event('change', {
              bubbles: !this._slottedInput
            }));
          }

          if (this._enabledCharPattern && !this.__shouldAcceptKey(e)) {
            e.preventDefault();
          }
        }
        /** @private */

      }, {
        key: "__shouldAcceptKey",
        value: function __shouldAcceptKey(event) {
          return event.metaKey || event.ctrlKey || !event.key // allow typing anything if event.key is not supported
          || event.key.length !== 1 // allow "Backspace", "ArrowLeft" etc.
          || this.__enabledCharRegExp.test(event.key);
        }
        /** @private */

      }, {
        key: "_onPaste",
        value: function _onPaste(e) {
          if (this._enabledCharPattern) {
            var pastedText = (e.clipboardData || window.clipboardData).getData('text');

            if (!this.__enabledTextRegExp.test(pastedText)) {
              e.preventDefault();
            }
          }
        }
        /** @private */

      }, {
        key: "_onDrop",
        value: function _onDrop(e) {
          if (this._enabledCharPattern) {
            var draggedText = e.dataTransfer.getData('text');

            if (!this.__enabledTextRegExp.test(draggedText)) {
              e.preventDefault();
            }
          }
        }
        /** @private */

      }, {
        key: "_onBeforeInput",
        value: function _onBeforeInput(e) {
          // The `beforeinput` event covers all the cases for `_enabledCharPattern`: keyboard, pasting and dropping,
          // but it is still experimental technology so we can't rely on it. It's used here just as an additional check,
          // because it seems to be the only way to detect and prevent specific keys on mobile devices. See issue #429.
          if (this._enabledCharPattern && e.data && !this.__enabledTextRegExp.test(e.data)) {
            e.preventDefault();
          }
        }
        /** @private */

      }, {
        key: "__enabledCharPatternChanged",
        value: function __enabledCharPatternChanged(_enabledCharPattern) {
          this.__enabledCharRegExp = _enabledCharPattern && new RegExp('^' + _enabledCharPattern + '$');
          this.__enabledTextRegExp = _enabledCharPattern && new RegExp('^' + _enabledCharPattern + '*$');
        }
        /** @private */

      }, {
        key: "_addIEListeners",
        value: function _addIEListeners(node) {
          var _this6 = this;

          /* istanbul ignore if */
          if (navigator.userAgent.match(/Trident/)) {
            // IE11 dispatches `input` event in following cases:
            // - focus or blur, when placeholder attribute is set
            // - placeholder attribute value changed
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/101220/
            this._shouldPreventInput = function () {
              _this6.__preventInput = true;
              requestAnimationFrame(function () {
                _this6.__preventInput = false;
              });
            };

            node.addEventListener('focusin', this._shouldPreventInput);
            node.addEventListener('focusout', this._shouldPreventInput);

            this._createPropertyObserver('placeholder', this._shouldPreventInput);
          }
        }
        /** @private */

      }, {
        key: "_removeIEListeners",
        value: function _removeIEListeners(node) {
          /* istanbul ignore if */
          if (navigator.userAgent.match(/Trident/)) {
            node.removeEventListener('focusin', this._shouldPreventInput);
            node.removeEventListener('focusout', this._shouldPreventInput);
          }
        }
        /** @private */

      }, {
        key: "_getActiveErrorId",
        value: function _getActiveErrorId(invalid, errorMessage, errorId, helperText, helperTextId, hasSlottedHelper) {
          var ids = [];

          if (helperText || hasSlottedHelper) {
            ids.push(helperTextId);
          }

          if (errorMessage && invalid) {
            ids.push(errorId);
          }

          this._setOrToggleAttribute('aria-describedby', ids.join(' '), this.focusElement);
        }
        /** @private */

      }, {
        key: "_getActiveLabelId",
        value: function _getActiveLabelId(label, _labelId, _inputId) {
          var ids = _inputId;

          if (label) {
            ids = "".concat(_labelId, " ").concat(_inputId);
          }

          this.focusElement.setAttribute('aria-labelledby', ids);
        }
        /** @private */

      }, {
        key: "_getErrorMessageAriaHidden",
        value: function _getErrorMessageAriaHidden(invalid, errorMessage, errorId) {
          return (!(errorMessage && invalid ? errorId : undefined)).toString();
        }
        /** @private */

      }, {
        key: "_dispatchIronResizeEventIfNeeded",
        value: function _dispatchIronResizeEventIfNeeded(sizePropertyName, value) {
          var previousSizePropertyName = '__previous' + sizePropertyName;

          if (this[previousSizePropertyName] !== undefined && this[previousSizePropertyName] !== value) {
            this.dispatchEvent(new CustomEvent('iron-resize', {
              bubbles: true,
              composed: true
            }));
          }

          this[previousSizePropertyName] = value;
        }
        /** @private */

      }, {
        key: "__observeOffsetHeight",
        value: function __observeOffsetHeight() {
          var _this7 = this;

          this.__observeOffsetHeightDebouncer = _debounce.Debouncer.debounce(this.__observeOffsetHeightDebouncer, _async.animationFrame, function () {
            _this7._dispatchIronResizeEventIfNeeded('Height', _this7.offsetHeight);
          });
        }
        /**
         * @param {string} prop
         * @param {string} oldVal
         * @param {string} newVal
         * @protected
         */

      }, {
        key: "attributeChangedCallback",
        value: function attributeChangedCallback(prop, oldVal, newVal) {
          babelHelpers.get(babelHelpers.getPrototypeOf(VaadinTextFieldMixin.prototype), "attributeChangedCallback", this).call(this, prop, oldVal, newVal); // Needed until Edge has CSS Custom Properties (present in Edge Preview)

          /* istanbul ignore if */

          if (!(window.ShadyCSS && window.ShadyCSS.nativeCss) && /^(focused|focus-ring|invalid|disabled|placeholder|has-value)$/.test(prop)) {
            this.updateStyles();
          } // Safari has an issue with repainting shadow root element styles when a host attribute changes.
          // Need this workaround (toggle any inline css property on and off) until the issue gets fixed.


          var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          /* istanbul ignore if */

          if (isSafari && this.root) {
            var WEBKIT_PROPERTY = '-webkit-backface-visibility';
            this.root.querySelectorAll('*').forEach(function (el) {
              el.style[WEBKIT_PROPERTY] = 'visible';
              el.style[WEBKIT_PROPERTY] = '';
            });
          }
        } // Workaround for https://github.com/Polymer/polymer/issues/5259

      }, {
        key: "__data",
        get: function get() {
          return this.__dataValue || {};
        },
        set: function set(value) {
          this.__dataValue = value;
        }
        /**
         * Fired when the user commits a value change.
         *
         * @event change
         */

        /**
         * Fired when the value is changed by the user: on every typing keystroke,
         * and the value is cleared using the clear button.
         *
         * @event input
         */

        /**
         * Fired when the size of the element changes.
         *
         * @event iron-resize
         */

      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * Whether the value of the control can be automatically completed by the browser.
             * List of available options at:
             * https://developer.mozilla.org/en/docs/Web/HTML/Element/input#attr-autocomplete
             */
            autocomplete: {
              type: String
            },

            /**
             * This is a property supported by Safari that is used to control whether
             * autocorrection should be enabled when the user is entering/editing the text.
             * Possible values are:
             * on: Enable autocorrection.
             * off: Disable autocorrection.
             * @type {!TextFieldAutoCorrect | undefined}
             */
            autocorrect: {
              type: String
            },

            /**
             * This is a property supported by Safari and Chrome that is used to control whether
             * autocapitalization should be enabled when the user is entering/editing the text.
             * Possible values are:
             * characters: Characters capitalization.
             * words: Words capitalization.
             * sentences: Sentences capitalization.
             * none: No capitalization.
             * @type {!TextFieldAutoCapitalize | undefined}
             */
            autocapitalize: {
              type: String
            },

            /**
             * Specify that the value should be automatically selected when the field gains focus.
             * @type {boolean}
             */
            autoselect: {
              type: Boolean,
              value: false
            },

            /**
             * Set to true to display the clear icon which clears the input.
             * @attr {boolean} clear-button-visible
             * @type {boolean}
             */
            clearButtonVisible: {
              type: Boolean,
              value: false
            },

            /**
             * Error to show when the input value is invalid.
             * @attr {string} error-message
             * @type {string}
             */
            errorMessage: {
              type: String,
              value: '',
              observer: '_errorMessageChanged'
            },

            /**
             * Object with translated strings used for localization. Has
             * the following structure and default values:
             *
             * ```
             * {
             *   // Translation of the clear icon button accessible label
             *   clear: 'Clear'
             * }
             * ```
             * @type {{clear: string}}
             */
            i18n: {
              type: Object,
              value: function value() {
                return {
                  clear: 'Clear'
                };
              }
            },

            /**
             * String used for the label element.
             * @type {string}
             */
            label: {
              type: String,
              value: '',
              observer: '_labelChanged'
            },

            /**
             * String used for the helper text.
             * @attr {string} helper-text
             * @type {string | null}
             */
            helperText: {
              type: String,
              value: '',
              observer: '_helperTextChanged'
            },

            /**
             * Maximum number of characters (in Unicode code points) that the user can enter.
             */
            maxlength: {
              type: Number
            },

            /**
             * Minimum number of characters (in Unicode code points) that the user can enter.
             */
            minlength: {
              type: Number
            },

            /**
             * The name of the control, which is submitted with the form data.
             */
            name: {
              type: String
            },

            /**
             * A hint to the user of what can be entered in the control.
             */
            placeholder: {
              type: String
            },

            /**
             * This attribute indicates that the user cannot modify the value of the control.
             */
            readonly: {
              type: Boolean,
              reflectToAttribute: true
            },

            /**
             * Specifies that the user must fill in a value.
             */
            required: {
              type: Boolean,
              reflectToAttribute: true
            },

            /**
             * The initial value of the control.
             * It can be used for two-way data binding.
             * @type {string}
             */
            value: {
              type: String,
              value: '',
              observer: '_valueChanged',
              notify: true
            },

            /**
             * This property is set to true when the control value is invalid.
             * @type {boolean}
             */
            invalid: {
              type: Boolean,
              reflectToAttribute: true,
              notify: true,
              value: false
            },

            /**
             * Specifies that the text field has value.
             * @attr {boolean} has-value
             */
            hasValue: {
              type: Boolean,
              reflectToAttribute: true
            },

            /**
             * When set to true, user is prevented from typing a value that
             * conflicts with the given `pattern`.
             * @attr {boolean} prevent-invalid-input
             */
            preventInvalidInput: {
              type: Boolean
            },

            /**
             * A pattern matched against individual characters the user inputs.
             * When set, the field will prevent:
             * - `keyDown` events if the entered key doesn't match `/^_enabledCharPattern$/`
             * - `paste` events if the pasted text doesn't match `/^_enabledCharPattern*$/`
             * - `drop` events if the dropped text doesn't match `/^_enabledCharPattern*$/`
             *
             * For example, to enable entering only numbers and minus signs,
             * `_enabledCharPattern = "[\\d-]"`
             * @protected
             */
            _enabledCharPattern: String,

            /** @private */
            _labelId: String,

            /** @private */
            _helperTextId: String,

            /** @private */
            _errorId: String,

            /** @private */
            _inputId: String,

            /** @private */
            _hasSlottedHelper: Boolean
          };
        }
      }, {
        key: "observers",
        get: function get() {
          return ['_stateChanged(disabled, readonly, clearButtonVisible, hasValue)', '_hostPropsChanged(' + HOST_PROPS.default.join(', ') + ')', '_hostAccessiblePropsChanged(' + HOST_PROPS.accessible.join(', ') + ')', '_getActiveErrorId(invalid, errorMessage, _errorId, helperText, _helperTextId, _hasSlottedHelper)', '_getActiveLabelId(label, _labelId, _inputId)', '__observeOffsetHeight(errorMessage, invalid, label, helperText)', '__enabledCharPatternChanged(_enabledCharPattern)'];
        }
      }]);
      return VaadinTextFieldMixin;
    }(subclass);
  };

  _exports.TextFieldMixin = TextFieldMixin;
});