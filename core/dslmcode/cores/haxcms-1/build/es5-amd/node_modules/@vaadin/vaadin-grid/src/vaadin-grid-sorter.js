define(["exports", "../../../@polymer/polymer/polymer-legacy.js", "../../../@polymer/polymer/lib/elements/custom-style.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "../../vaadin-element-mixin/vaadin-dir-mixin.js", "../../../@polymer/polymer/lib/utils/html-tag.js", "../../../@polymer/polymer/polymer-element.js"], function (_exports, _polymerLegacy, _customStyle, _vaadinThemableMixin, _vaadinDirMixin, _htmlTag, _polymerElement) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.GridSorterElement = void 0;

  var _templateObject_cc6253d0809211edaa2833647dc78c6c;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var $_documentContainer = document.createElement('template');
  $_documentContainer.innerHTML = "<custom-style>\n  <style>\n    @font-face {\n      font-family: 'vaadin-grid-sorter-icons';\n      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQwAA0AAAAABuwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEFAAAABkAAAAcfep+mUdERUYAAAP4AAAAHAAAAB4AJwAOT1MvMgAAAZgAAAA/AAAAYA8TBPpjbWFwAAAB7AAAAFUAAAFeF1fZ4mdhc3AAAAPwAAAACAAAAAgAAAAQZ2x5ZgAAAlgAAABcAAAAnMvguMloZWFkAAABMAAAAC8AAAA2C5Ap72hoZWEAAAFgAAAAHQAAACQGbQPHaG10eAAAAdgAAAAUAAAAHAoAAABsb2NhAAACRAAAABIAAAASAIwAYG1heHAAAAGAAAAAFgAAACAACwAKbmFtZQAAArQAAAECAAACZxWCgKhwb3N0AAADuAAAADUAAABZCrApUXicY2BkYGAA4rDECVrx/DZfGbhZGEDgyqNPOxH0/wNMq5kPALkcDEwgUQBWRA0dAHicY2BkYGA+8P8AAwMLAwgwrWZgZEAFbABY4QM8AAAAeJxjYGRgYOAAQiYGEICQSAAAAi8AFgAAeJxjYGY6yziBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKoAkwODAwvmRiPvD/AIMDMxCD1CDJKjAwAgBktQsXAHicY2GAAMZQCM0EwqshbAALxAEKeJxjYGBgZoBgGQZGBhCIAPIYwXwWBhsgzcXAwcAEhIwMCi+Z/v/9/x+sSuElA4T9/4k4K1gHFwMMMILMY2QDYmaoABOQYGJABUA7WBiGNwAAJd4NIQAAAAAAAAAACAAIABAAGAAmAEAATgAAeJyNjLENgDAMBP9tIURJwQCMQccSZgk2i5fIYBDAidJjycXr7x5EPwE2wY8si7jmyBNXGo/bNBerxJNrpxhbO3/fEFpx8ZICpV+ghxJ74fAMe+h7Ox14AbrsHB14nK2QQWrDMBRER4mTkhQK3ZRQKOgCNk7oGQqhhEIX2WSlWEI1BAlkJ5CDdNsj5Ey9Rncdi38ES+jzNJo/HwTgATcoDEthhY3wBHc4CE+pfwsX5F/hGe7Vo/AcK/UhvMSz+mGXKhZU6pww8ISz3oWn1BvhgnwTnuEJf8Jz1OpFeIlX9YULDLdFi4ASHolkSR0iuYdjLak1vAequBhj21D61Nqyi6l3qWybGPjySbPHGScGJl6dP58MYcQRI0bts7mjebBqrFENH7t3qWtj0OuqHnXcW7b0HOTZFnKryRGW2hFX1m0O2vEM3opNMfTau+CS6Z3Vx6veNnEXY6jwDxhsc2gAAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSrpYEBlIbxjQDrzgsuAAAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKyoz1cD0o087YTQATOcIewAAAA==) format('woff');\n      font-weight: normal;\n      font-style: normal;\n    }\n  </style>\n</custom-style>";
  document.head.appendChild($_documentContainer.content);
  /**
   * `<vaadin-grid-sorter>` is a helper element for the `<vaadin-grid>` that provides out-of-the-box UI controls,
   * visual feedback, and handlers for sorting the grid data.
   *
   * #### Example:
   * ```html
   * <vaadin-grid-column>
   *   <template class="header">
   *     <vaadin-grid-sorter path="name.first">First name</vaadin-grid-sorter>
   *   </template>
   *   <template>[[item.name.first]]</template>
   * </vaadin-grid-column>
   * ```
   *
   * ### Styling
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name | Description
   * ----------------|----------------
   * `content` | The slotted content wrapper
   * `indicators` | The internal sorter indicators.
   * `order` | The internal sorter order
   *
   * The following state attributes are available for styling:
   *
   * Attribute    | Description | Part name
   * -------------|-------------|------------
   * `direction` | Sort direction of a sorter | :host
   *
   * @extends PolymerElement
   */

  var GridSorterElement = /*#__PURE__*/function (_ThemableMixin) {
    babelHelpers.inherits(GridSorterElement, _ThemableMixin);

    var _super = _createSuper(GridSorterElement);

    function GridSorterElement() {
      babelHelpers.classCallCheck(this, GridSorterElement);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(GridSorterElement, [{
      key: "ready",
      value:
      /** @protected */
      function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridSorterElement.prototype), "ready", this).call(this);
        this.addEventListener('click', this._onClick.bind(this));
      }
      /** @protected */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridSorterElement.prototype), "connectedCallback", this).call(this);
        this._isConnected = true;
      }
      /** @protected */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridSorterElement.prototype), "disconnectedCallback", this).call(this);
        this._isConnected = false;
      }
      /** @private */

    }, {
      key: "_pathOrDirectionChanged",
      value: function _pathOrDirectionChanged() {
        this.__dispatchSorterChangedEvenIfPossible();
      }
      /** @private */

    }, {
      key: "__isConnectedChanged",
      value: function __isConnectedChanged(newValue, oldValue) {
        if (oldValue === false) {
          return;
        }

        this.__dispatchSorterChangedEvenIfPossible();
      }
      /** @private */

    }, {
      key: "__dispatchSorterChangedEvenIfPossible",
      value: function __dispatchSorterChangedEvenIfPossible() {
        if (this.path === undefined || this.direction === undefined || !this._isConnected) {
          return;
        }

        this.dispatchEvent(new CustomEvent('sorter-changed', {
          bubbles: true,
          composed: true
        }));
      }
      /** @private */

    }, {
      key: "_getDisplayOrder",
      value: function _getDisplayOrder(order) {
        return order === null ? '' : order + 1;
      }
      /** @private */

    }, {
      key: "_onClick",
      value: function _onClick(e) {
        var activeElement = this.getRootNode().activeElement;

        if (this !== activeElement && this.contains(activeElement)) {
          // Some focusable content inside the sorter was clicked, do nothing.
          return;
        }

        e.preventDefault();

        if (this.direction === 'asc') {
          this.direction = 'desc';
        } else if (this.direction === 'desc') {
          this.direction = null;
        } else {
          this.direction = 'asc';
        }
      }
      /** @private */

    }, {
      key: "_directionOrOrderChanged",
      value: function _directionOrOrderChanged(direction, order) {
        if (direction === undefined || order === undefined) {
          return;
        } // Safari has an issue with repainting shadow root element styles when a host attribute changes.
        // Need this workaround (toggle any inline css property on and off) until the issue gets fixed.


        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

        if (isSafari && this.root) {
          this.root.querySelectorAll('*').forEach(function (el) {
            el.style['-webkit-backface-visibility'] = 'visible';
            el.style['-webkit-backface-visibility'] = '';
          });
        }
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _htmlTag.html)(_templateObject_cc6253d0809211edaa2833647dc78c6c || (_templateObject_cc6253d0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: inline-flex;\n        cursor: pointer;\n        max-width: 100%;\n      }\n\n      [part=\"content\"] {\n        flex: 1 1 auto;\n      }\n\n      [part=\"indicators\"] {\n        position: relative;\n        align-self: center;\n        flex: none;\n      }\n\n      [part=\"order\"] {\n        display: inline;\n        vertical-align: super;\n      }\n\n      [part=\"indicators\"]::before {\n        font-family: 'vaadin-grid-sorter-icons';\n        display: inline-block;\n      }\n\n      :host(:not([direction])) [part=\"indicators\"]::before {\n        content: \"\\e901\";\n      }\n\n      :host([direction=asc]) [part=\"indicators\"]::before {\n        content: \"\\e900\";\n      }\n\n      :host([direction=desc]) [part=\"indicators\"]::before {\n        content: \"\\e902\";\n      }\n    </style>\n\n    <div part=\"content\">\n      <slot></slot>\n    </div>\n    <div part=\"indicators\">\n      <span part=\"order\">[[_getDisplayOrder(_order)]]</span>\n    </div>\n"], ["\n    <style>\n      :host {\n        display: inline-flex;\n        cursor: pointer;\n        max-width: 100%;\n      }\n\n      [part=\"content\"] {\n        flex: 1 1 auto;\n      }\n\n      [part=\"indicators\"] {\n        position: relative;\n        align-self: center;\n        flex: none;\n      }\n\n      [part=\"order\"] {\n        display: inline;\n        vertical-align: super;\n      }\n\n      [part=\"indicators\"]::before {\n        font-family: 'vaadin-grid-sorter-icons';\n        display: inline-block;\n      }\n\n      :host(:not([direction])) [part=\"indicators\"]::before {\n        content: \"\\\\e901\";\n      }\n\n      :host([direction=asc]) [part=\"indicators\"]::before {\n        content: \"\\\\e900\";\n      }\n\n      :host([direction=desc]) [part=\"indicators\"]::before {\n        content: \"\\\\e902\";\n      }\n    </style>\n\n    <div part=\"content\">\n      <slot></slot>\n    </div>\n    <div part=\"indicators\">\n      <span part=\"order\">[[_getDisplayOrder(_order)]]</span>\n    </div>\n"])));
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-grid-sorter';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * JS Path of the property in the item used for sorting the data.
           */
          path: String,

          /**
           * How to sort the data.
           * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in
           * descending direction, or `null` for not sorting the data.
           * @type {GridSorterDirection | undefined}
           */
          direction: {
            type: String,
            reflectToAttribute: true,
            notify: true,
            value: null
          },

          /**
           * @type {number | null}
           * @protected
           */
          _order: {
            type: Number,
            value: null
          },

          /** @private */
          _isConnected: {
            type: Boolean,
            observer: '__isConnectedChanged'
          }
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ['_pathOrDirectionChanged(path, direction)', '_directionOrOrderChanged(direction, _order)'];
      }
    }]);
    return GridSorterElement;
  }((0, _vaadinThemableMixin.ThemableMixin)((0, _vaadinDirMixin.DirMixin)(_polymerElement.PolymerElement)));

  _exports.GridSorterElement = GridSorterElement;
  customElements.define(GridSorterElement.is, GridSorterElement);
});