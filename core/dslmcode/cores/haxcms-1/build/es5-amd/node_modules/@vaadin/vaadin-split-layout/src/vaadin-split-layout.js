define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/mixins/gesture-event-listeners.js", "../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js", "../../../@polymer/iron-resizable-behavior/iron-resizable-behavior.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "../../vaadin-element-mixin/vaadin-element-mixin.js", "../../../@polymer/polymer/lib/utils/html-tag.js", "../../../@polymer/polymer/lib/legacy/class.js"], function (_exports, _polymerElement, _gestureEventListeners, _flattenedNodesObserver, _ironResizableBehavior, _vaadinThemableMixin, _vaadinElementMixin, _htmlTag, _class) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SplitLayoutElement = void 0;

  var _templateObject_cc91c840809211edaa2833647dc78c6c;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `<vaadin-split-layout>` is a Web Component implementing a split layout for two
   * content elements with a draggable splitter between them.
   *
   * ```html
   * <vaadin-split-layout>
   *   <div>First content element</div>
   *   <div>Second content element</div>
   * </vaadin-split-layout>
   * ```
   *
   * ### Horizontal and Vertical Layouts
   *
   * By default, the split's orientation is horizontal, meaning that the content elements are
   * positioned side by side in a flex container with a horizontal layout.
   *
   * You can change the split mode to vertical by setting the `orientation` attribute to `"vertical"`:
   *
   * ```html
   * <vaadin-split-layout orientation="vertical">
   *   <div>Content on the top</div>
   *   <div>Content on the bottom</div>
   * </vaadin-split-layout>
   * ```
   *
   * ### Layouts Combination
   *
   * For the layout contents, we usually use `<div>` elements in the examples,
   * although you can use any other elements as well.
   *
   * For instance, in order to have a nested vertical split layout inside a
   * horizontal one, you can include `<vaadin-split-layout>` as a content element
   * inside another split layout:
   *
   * ```html
   * <vaadin-split-layout>
   *   <div>First content element</div>
   *   <vaadin-split-layout orientation="vertical">
   *     <div>Second content element</div>
   *     <div>Third content element</div>
   *   </vaadin-split-layout>
   * </vaadin-split-layout>
   * ```
   *
   * You can also trigger the vertical mode in JavaScript by setting the property:
   * `splitLayout.orientation = "vertical";`.
   *
   * ### Split Layout Element Height
   *
   * `<vaadin-split-layout>` element itself is a flex container. It does not inherit
   * the parent height by default, but rather sets its height depending on the
   * content.
   *
   * You can use CSS to set the fixed height for the split layout, as usual with any
   * block element:
   *
   * ```html
   * <vaadin-split-layout style="height: 200px;">
   *   <div>First content element</div>
   *   <div>Second content element</div>
   * </vaadin-split-layout>
   * ```
   *
   * It is possible to define percentage height as well. Note that you have to set
   * the parent height in order to make percentages work correctly. In the following
   * example, the `<body>` is resized to fill the entire viewport, and the
   * `<vaadin-split-layout>` element is set to take 100% height of the `<body>`:
   *
   * ```html
   * <body style="height: 100vh; margin: 0;">
   *   <vaadin-split-layout style="height: 100%;">
   *     <div>First</div>
   *     <div>Second</div>
   *   </vaadin-split-layout>
   * </body>
   * ```
   *
   * Alternatively, you can use a flexbox layout to make `<vaadin-split-layout>`
   * fill up the parent:
   *
   * ```html
   * <body style="height: 100vh; margin: 0; display: flex;">
   *   <vaadin-split-layout style="flex: 1;">
   *     <div>First</div>
   *     <div>Second</div>
   *   </vaadin-split-layout>
   * </body>
   * ```
   *
   * ### Initial Splitter Position
   *
   * The initial splitter position is determined from the sizes of the content elements
   * inside the split layout. Therefore, changing `width` on the content elements
   * affects the initial splitter position for the horizontal layouts, while `height`
   * affects the vertical ones.
   *
   * Note that when the total size of the content elements does not fit the layout,
   * the content elements are scaled proportionally.
   *
   * When setting initial sizes with relative units, such as percentages, it is
   * recommended to assign the size for both content elements:
   *
   * ```html
   * <vaadin-split-layout>
   *   <div style="width: 75%;">Three fourths</div>
   *   <div style="width: 25%;">One fourth</div>
   * </vaadin-split-layout>
   * ```
   *
   * ### Size Limits
   *
   * The `min-width`/`min-height`, and `max-width`/`max-height` CSS size values
   * for the content elements are respected and used to limit the splitter position
   * when it is dragged.
   *
   * It is preferred to set the limits only for a single content element, in order
   * to avoid size conflicts:
   *
   * ```html
   * <vaadin-split-layout>
   *   <div style="min-width: 50px; max-width: 150px;">First</div>
   *   <div>Second</div>
   * </vaadin-split-layout>
   * ```
   *
   * ### Resize Notification
   *
   * This element implements `IronResizableBehavior` to notify the nested resizables
   * when the splitter is dragged. In order to define a resizable and receive that
   * notification in a nested element, include `IronResizableBehavior` and listen
   * for the `iron-resize` event.
   *
   * ### Styling
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name | Description | Theme for Element
   * ----------------|----------------|----------------
   * `splitter` | Split element | vaadin-split-layout
   * `handle` | The handle of the splitter | vaadin-split-layout
   *
   * See [ThemableMixin â€“ how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
   *
   * @extends PolymerElement
   * @mixes ElementMixin
   * @mixes ThemableMixin
   * @mixes GestureEventListeners
   * @demo demo/index.html
   */
  var SplitLayoutElement = /*#__PURE__*/function (_ElementMixin) {
    babelHelpers.inherits(SplitLayoutElement, _ElementMixin);

    var _super = _createSuper(SplitLayoutElement);

    function SplitLayoutElement() {
      babelHelpers.classCallCheck(this, SplitLayoutElement);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(SplitLayoutElement, [{
      key: "ready",
      value:
      /** @protected */
      function ready() {
        var _this = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(SplitLayoutElement.prototype), "ready", this).call(this);
        new _flattenedNodesObserver.FlattenedNodesObserver(this, function (info) {
          _this._cleanupNodes(info.removedNodes);

          _this._processChildren();
        });
      }
      /** @private */

    }, {
      key: "_cleanupNodes",
      value: function _cleanupNodes(nodes) {
        nodes.forEach(function (node) {
          node.removeAttribute('slot');
        });
      }
      /** @private */

    }, {
      key: "_processChildren",
      value: function _processChildren() {
        var _this2 = this;

        this.getEffectiveChildren().forEach(function (child, i) {
          if (i === 0) {
            _this2._primaryChild = child;
            child.setAttribute('slot', 'primary');
          } else if (i == 1) {
            _this2._secondaryChild = child;
            child.setAttribute('slot', 'secondary');
          } else {
            child.removeAttribute('slot');
          }
        });
      }
      /** @private */

    }, {
      key: "_setFlexBasis",
      value: function _setFlexBasis(element, flexBasis, containerSize) {
        flexBasis = Math.max(0, Math.min(flexBasis, containerSize));

        if (flexBasis === 0) {
          // Pure zero does not play well in Safari
          flexBasis = 0.000001;
        }

        element.style.flex = '1 1 ' + flexBasis + 'px';
      }
      /** @private */

    }, {
      key: "_setPointerEventsNone",
      value: function _setPointerEventsNone(event) {
        if (!this._primaryChild || !this._secondaryChild) {
          return;
        }

        this._previousPrimaryPointerEvents = this._primaryChild.style.pointerEvents;
        this._previousSecondaryPointerEvents = this._secondaryChild.style.pointerEvents;
        this._primaryChild.style.pointerEvents = 'none';
        this._secondaryChild.style.pointerEvents = 'none';
        event.preventDefault();
      }
      /** @private */

    }, {
      key: "_restorePointerEvents",
      value: function _restorePointerEvents() {
        if (!this._primaryChild || !this._secondaryChild) {
          return;
        }

        this._primaryChild.style.pointerEvents = this._previousPrimaryPointerEvents;
        this._secondaryChild.style.pointerEvents = this._previousSecondaryPointerEvents;
      }
      /** @private */

    }, {
      key: "_onHandleTrack",
      value: function _onHandleTrack(event) {
        if (!this._primaryChild || !this._secondaryChild) {
          return;
        }

        var size = this.orientation === 'vertical' ? 'height' : 'width';

        if (event.detail.state === 'start') {
          this._startSize = {
            container: this.getBoundingClientRect()[size] - this.$.splitter.getBoundingClientRect()[size],
            primary: this._primaryChild.getBoundingClientRect()[size],
            secondary: this._secondaryChild.getBoundingClientRect()[size]
          };
          return;
        }

        var distance = this.orientation === 'vertical' ? event.detail.dy : event.detail.dx;
        var isRtl = this.orientation !== 'vertical' && this.getAttribute('dir') === 'rtl';
        var dirDistance = isRtl ? -distance : distance;

        this._setFlexBasis(this._primaryChild, this._startSize.primary + dirDistance, this._startSize.container);

        this._setFlexBasis(this._secondaryChild, this._startSize.secondary - dirDistance, this._startSize.container);

        this.notifyResize();

        if (event.detail.state === 'end') {
          this.dispatchEvent(new CustomEvent('splitter-dragend'));
          delete this._startSize;
        }
      }
      /**
       * Can be called to manually notify a resizable and its descendant
       * resizables of a resize change.
       */

    }, {
      key: "notifyResize",
      value: function notifyResize() {
        // NOTE: we have this method here to include it to TypeScript definitions.
        // gen-typescript-declarations does not generate types for `mixinBehaviors`
        babelHelpers.get(babelHelpers.getPrototypeOf(SplitLayoutElement.prototype), "notifyResize", this).call(this);
      }
      /**
       * Fired when the splitter is dragged. Non-bubbling. Fired for the splitter
       * element and any nested elements with `IronResizableBehavior`.
       *
       * @event iron-resize
       */

      /**
       * Fired after dragging the splitter have ended.
       *
       * @event splitter-dragend
       */

    }], [{
      key: "template",
      get: function get() {
        return (0, _htmlTag.html)(_templateObject_cc91c840809211edaa2833647dc78c6c || (_templateObject_cc91c840809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: flex;\n        overflow: hidden !important;\n        transform: translateZ(0);\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      :host([orientation=\"vertical\"]) {\n        flex-direction: column;\n      }\n\n      :host ::slotted(*) {\n        flex: 1 1 auto;\n        overflow: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      [part=\"splitter\"] {\n        flex: none;\n        position: relative;\n        z-index: 1;\n        overflow: visible;\n        min-width: 8px;\n        min-height: 8px;\n      }\n\n      :host(:not([orientation=\"vertical\"])) > [part=\"splitter\"] {\n        cursor: ew-resize;\n      }\n\n      :host([orientation=\"vertical\"]) > [part=\"splitter\"] {\n        cursor: ns-resize;\n      }\n\n      [part=\"handle\"] {\n        width: 40px;\n        height: 40px;\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate3d(-50%, -50%, 0);\n      }\n    </style>\n    <slot id=\"primary\" name=\"primary\"></slot>\n    <div part=\"splitter\" id=\"splitter\" on-track=\"_onHandleTrack\" on-down=\"_setPointerEventsNone\" on-up=\"_restorePointerEvents\">\n      <div part=\"handle\"></div>\n    </div>\n    <slot id=\"secondary\" name=\"secondary\"></slot>\n\n    <div hidden=\"\">\n      <!-- Workaround to fix a Shady style scoping issue caused by dynamic slot naming of the child elements (primary/secondary) -->\n      <slot></slot>\n    </div>\n"])));
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-split-layout';
      }
    }, {
      key: "version",
      get: function get() {
        return '4.3.1';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * The split layout's orientation. Possible values are: `horizontal|vertical`.
           * @type {!SplitLayoutOrientation}
           */
          orientation: {
            type: String,
            reflectToAttribute: true,
            value: 'horizontal'
          },

          /** @private */
          _previousPrimaryPointerEvents: String,

          /** @private */
          _previousSecondaryPointerEvents: String
        };
      }
    }]);
    return SplitLayoutElement;
  }((0, _vaadinElementMixin.ElementMixin)((0, _vaadinThemableMixin.ThemableMixin)((0, _gestureEventListeners.GestureEventListeners)((0, _class.mixinBehaviors)([_ironResizableBehavior.IronResizableBehavior], _polymerElement.PolymerElement)))));

  _exports.SplitLayoutElement = SplitLayoutElement;
  customElements.define(SplitLayoutElement.is, SplitLayoutElement);
});