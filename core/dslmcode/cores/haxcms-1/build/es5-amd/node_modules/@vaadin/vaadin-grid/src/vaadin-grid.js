define(["exports", "../../../@polymer/polymer/polymer-legacy.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "./vaadin-grid-scroller.js", "./vaadin-grid-a11y-mixin.js", "./vaadin-grid-active-item-mixin.js", "./vaadin-grid-array-data-provider-mixin.js", "./vaadin-grid-column-resizing-mixin.js", "./vaadin-grid-data-provider-mixin.js", "./vaadin-grid-dynamic-columns-mixin.js", "./vaadin-grid-event-context-mixin.js", "./vaadin-grid-filter-mixin.js", "./vaadin-grid-row-details-mixin.js", "./vaadin-grid-scroll-mixin.js", "./vaadin-grid-selection-mixin.js", "./vaadin-grid-sort-mixin.js", "./vaadin-grid-styling-mixin.js", "./vaadin-grid-drag-and-drop-mixin.js", "./vaadin-grid-keyboard-navigation-mixin.js", "./vaadin-grid-column-reordering-mixin.js", "./vaadin-grid-column.js", "./vaadin-grid-styles.js", "../../vaadin-element-mixin/vaadin-element-mixin.js", "../../../@polymer/polymer/lib/utils/html-tag.js", "../../../@polymer/polymer/lib/utils/render-status.js", "../../../@polymer/polymer/lib/utils/debounce.js", "../../../@polymer/polymer/lib/utils/async.js"], function (_exports, _polymerLegacy, _vaadinThemableMixin, _vaadinGridScroller, _vaadinGridA11yMixin, _vaadinGridActiveItemMixin, _vaadinGridArrayDataProviderMixin, _vaadinGridColumnResizingMixin, _vaadinGridDataProviderMixin, _vaadinGridDynamicColumnsMixin, _vaadinGridEventContextMixin, _vaadinGridFilterMixin, _vaadinGridRowDetailsMixin, _vaadinGridScrollMixin, _vaadinGridSelectionMixin, _vaadinGridSortMixin, _vaadinGridStylingMixin, _vaadinGridDragAndDropMixin, _vaadinGridKeyboardNavigationMixin, _vaadinGridColumnReorderingMixin, _vaadinGridColumn, _vaadinGridStyles, _vaadinElementMixin, _htmlTag, _renderStatus, _debounce, _async) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.GridElement = void 0;

  var _templateObject_a4293750942811ecb1937969798b231a;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TOUCH_DEVICE = function () {
    try {
      document.createEvent('TouchEvent');
      return true;
    } catch (e) {
      return false;
    }
  }();
  /**
   *
   * `<vaadin-grid>` is a free, high quality data grid / data table Web Component. The content of the
   * the grid can be populated in two ways: imperatively by using renderer callback function and
   * declaratively by using Polymer's Templates.
   *
   * ### Quick Start
   *
   * Start with an assigning an array to the [`items`](#/elements/vaadin-grid#property-items) property to visualize your data.
   *
   * Use the [`<vaadin-grid-column>`](#/elements/vaadin-grid-column) element to configure the grid columns. Set `path` and `header`
   * shorthand properties for the columns to define what gets rendered in the cells of the column.
   *
   * #### Example:
   * ```html
   * <vaadin-grid>
   *   <vaadin-grid-column path="name.first" header="First name"></vaadin-grid-column>
   *   <vaadin-grid-column path="name.last" header="Last name"></vaadin-grid-column>
   *   <vaadin-grid-column path="email"></vaadin-grid-column>
   * </vaadin-grid>
   * ```
   *
   * For custom content `vaadin-grid-column` element provides you with three types of `renderer` callback functions: `headerRenderer`,
   * `renderer` and `footerRenderer`.
   *
   * Each of those renderer functions provides `root`, `column`, `model` arguments when applicable.
   * Generate DOM content, append it to the `root` element and control the state
   * of the host element by accessing `column`. Before generating new content,
   * users are able to check if there is already content in `root` for reusing it.
   *
   * Renderers are called on initialization of new column cells and each time the
   * related row model is updated. DOM generated during the renderer call can be reused
   * in the next renderer call and will be provided with the `root` argument.
   * On first call it will be empty.
   *
   * #### Example:
   * ```html
   * <vaadin-grid>
   *   <vaadin-grid-column></vaadin-grid-column>
   *   <vaadin-grid-column></vaadin-grid-column>
   *   <vaadin-grid-column></vaadin-grid-column>
   * </vaadin-grid>
   * ```
   * ```js
   * const grid = document.querySelector('vaadin-grid');
   * grid.items = [{'name': 'John', 'surname': 'Lennon', 'role': 'singer'},
   *               {'name': 'Ringo', 'surname': 'Starr', 'role': 'drums'}];
   *
   * const columns = grid.querySelectorAll('vaadin-grid-column');
   *
   * columns[0].headerRenderer = function(root) {
   *   root.textContent = 'Name';
   * };
   * columns[0].renderer = function(root, column, model) {
   *   root.textContent = model.item.name;
   * };
   *
   * columns[1].headerRenderer = function(root) {
   *   root.textContent = 'Surname';
   * };
   * columns[1].renderer = function(root, column, model) {
   *   root.textContent = model.item.surname;
   * };
   *
   * columns[2].headerRenderer = function(root) {
   *   root.textContent = 'Role';
   * };
   * columns[2].renderer = function(root, column, model) {
   *   root.textContent = model.item.role;
   * };
   * ```
   *
   * Alternatively, the content can be provided with Polymer's Templates:
   *
   * #### Example:
   * ```html
   * <vaadin-grid items='[{"name": "John", "surname": "Lennon", "role": "singer"},
   * {"name": "Ringo", "surname": "Starr", "role": "drums"}]'>
   *   <vaadin-grid-column>
   *     <template class="header">Name</template>
   *     <template>[[item.name]]</template>
   *   </vaadin-grid-column>
   *   <vaadin-grid-column>
   *     <template class="header">Surname</template>
   *     <template>[[item.surname]]</template>
   *   </vaadin-grid-column>
   *   <vaadin-grid-column>
   *     <template class="header">Role</template>
   *     <template>[[item.role]]</template>
   *   </vaadin-grid-column>
   * </vaadin-grid>
   * ```
   *
   * The following helper elements can be used for further customization:
   * - [`<vaadin-grid-column-group>`](#/elements/vaadin-grid-column-group)
   * - [`<vaadin-grid-filter>`](#/elements/vaadin-grid-filter)
   * - [`<vaadin-grid-sorter>`](#/elements/vaadin-grid-sorter)
   * - [`<vaadin-grid-selection-column>`](#/elements/vaadin-grid-selection-column)
   * - [`<vaadin-grid-tree-toggle>`](#/elements/vaadin-grid-tree-toggle)
   *
   * __Note that the helper elements must be explicitly imported.__
   * If you want to import everything at once you can use the `all-imports.html` bundle.
   *
   * A column template can be decorated with one the following class names to specify its purpose
   * - `header`: Marks a header template
   * - `footer`: Marks a footer template
   * - `row-details`: Marks a row details template
   *
   * The following built-in template variables can be bound to inside the column templates:
   * - `[[index]]`: Number representing the row index
   * - `[[item]]` and it's sub-properties: Data object (provided by a data provider / items array)
   * - `{{selected}}`: True if the item is selected (can be two-way bound)
   * - `{{detailsOpened}}`: True if the item has row details opened (can be two-way bound)
   * - `{{expanded}}`: True if the item has tree sublevel expanded (can be two-way bound)
   * - `[[level]]`: Number of the tree sublevel of the item, first level-items have 0
   *
   * ### Lazy Loading with Function Data Provider
   *
   * In addition to assigning an array to the items property, you can alternatively
   * provide the `<vaadin-grid>` data through the
   * [`dataProvider`](#/elements/vaadin-grid#property-dataProvider) function property.
   * The `<vaadin-grid>` calls this function lazily, only when it needs more data
   * to be displayed.
   *
   * See the [`dataProvider`](#/elements/vaadin-grid#property-dataProvider) in
   * the API reference below for the detailed data provider arguments description,
   * and the “Assigning Data” page in the demos.
   *
   * __Note that expanding the tree grid's item will trigger a call to the `dataProvider`.__
   *
   * __Also, note that when using function data providers, the total number of items
   * needs to be set manually. The total number of items can be returned
   * in the second argument of the data provider callback:__
   *
   * ```javascript
   * grid.dataProvider = function(params, callback) {
   *   var url = 'https://api.example/data' +
   *       '?page=' + params.page +        // the requested page index
   *       '&per_page=' + params.pageSize; // number of items on the page
   *   var xhr = new XMLHttpRequest();
   *   xhr.onload = function() {
   *     var response = JSON.parse(xhr.responseText);
   *     callback(
   *       response.employees, // requested page of items
   *       response.totalSize  // total number of items
   *     );
   *   };
   *   xhr.open('GET', url, true);
   *   xhr.send();
   * };
   * ```
   *
   * __Alternatively, you can use the `size` property to set the total number of items:__
   *
   * ```javascript
   * grid.size = 200; // The total number of items
   * grid.dataProvider = function(params, callback) {
   *   var url = 'https://api.example/data' +
   *       '?page=' + params.page +        // the requested page index
   *       '&per_page=' + params.pageSize; // number of items on the page
   *   var xhr = new XMLHttpRequest();
   *   xhr.onload = function() {
   *     var response = JSON.parse(xhr.responseText);
   *     callback(response.employees);
   *   };
   *   xhr.open('GET', url, true);
   *   xhr.send();
   * };
   * ```
   *
   * ### Styling
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name | Description
   * ----------------|----------------
   * `row` | Row in the internal table
   * `cell` | Cell in the internal table
   * `header-cell` | Header cell in the internal table
   * `body-cell` | Body cell in the internal table
   * `footer-cell` | Footer cell in the internal table
   * `details-cell` | Row details cell in the internal table
   * `resize-handle` | Handle for resizing the columns
   * `reorder-ghost` | Ghost element of the header cell being dragged
   *
   * The following state attributes are available for styling:
   *
   * Attribute    | Description | Part name
   * -------------|-------------|------------
   * `loading` | Set when the grid is loading data from data provider | :host
   * `interacting` | Keyboard navigation in interaction mode | :host
   * `navigating` | Keyboard navigation in navigation mode | :host
   * `overflow` | Set when rows are overflowing the grid viewport. Possible values: `top`, `bottom`, `left`, `right` | :host
   * `reordering` | Set when the grid's columns are being reordered | :host
   * `dragover` | Set when the grid (not a specific row) is dragged over | :host
   * `dragging-rows` : Set when grid rows are dragged  | :host
   * `reorder-status` | Reflects the status of a cell while columns are being reordered | cell
   * `frozen` | Frozen cell | cell
   * `last-frozen` | Last frozen cell | cell
   * `first-column` | First visible cell on a row | cell
   * `last-column` | Last visible cell on a row | cell
   * `selected` | Selected row | row
   * `expanded` | Expanded row | row
   * `details-opened` | Row with details open | row
   * `loading` | Row that is waiting for data from data provider | row
   * `odd` | Odd row | row
   * `first` | The first body row | row
   * `last` | The last body row | row
   * `dragstart` | Set for one frame when drag of a row is starting. The value is a number when multiple rows are dragged | row
   * `dragover` | Set when the row is dragged over | row
   * `drag-disabled` | Set to a row that isn't available for dragging | row
   * `drop-disabled` | Set to a row that can't be dropped on top of | row
   *
   * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
   *
   * @extends ScrollerElement
   * @mixes ThemableMixin
   * @mixes A11yMixin
   * @mixes ActiveItemMixin
   * @mixes ArrayDataProviderMixin
   * @mixes ColumnResizingMixin
   * @mixes DataProviderMixin
   * @mixes DynamicColumnsMixin
   * @mixes FilterMixin
   * @mixes RowDetailsMixin
   * @mixes ScrollMixin
   * @mixes SelectionMixin
   * @mixes SortMixin
   * @mixes KeyboardNavigationMixin
   * @mixes ColumnReorderingMixin
   * @mixes EventContextMixin
   * @mixes StylingMixin
   * @mixes DragAndDropMixin
   * @demo demo/index.html
   */


  var GridElement = /*#__PURE__*/function (_ElementMixin) {
    babelHelpers.inherits(GridElement, _ElementMixin);

    var _super = _createSuper(GridElement);

    function GridElement() {
      var _this;

      babelHelpers.classCallCheck(this, GridElement);
      _this = _super.call(this);

      _this.addEventListener('animationend', _this._onAnimationEnd);

      return _this;
    }
    /** @protected */


    babelHelpers.createClass(GridElement, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridElement.prototype), "connectedCallback", this).call(this);
        this.recalculateColumnWidths();
      }
      /**
       * @param {string} name
       * @param {?string} oldValue
       * @param {?string} newValue
       * @protected
       */

    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, oldValue, newValue) {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridElement.prototype), "attributeChangedCallback", this).call(this, name, oldValue, newValue);

        if (name === 'dir') {
          this.__isRTL = newValue === 'rtl';

          this._updateScrollerMeasurements();
        }
      }
      /** @private */

    }, {
      key: "__hasRowsWithClientHeight",
      value: function __hasRowsWithClientHeight() {
        return !!Array.from(this.$.items.children).filter(function (row) {
          return row.clientHeight;
        }).length;
      }
      /** @protected */

    }, {
      key: "__flushPendingRecalculateColumnWidths",
      value: function __flushPendingRecalculateColumnWidths() {
        if (this._recalculateColumnWidthOnceLoadingFinished && !this._cache.isLoading() && this.__hasRowsWithClientHeight() && !this.__isCreatingRows()) {
          this._recalculateColumnWidthOnceLoadingFinished = false;
          this.recalculateColumnWidths();
        }
      }
      /** @private */

    }, {
      key: "__getIntrinsicWidth",
      value: function __getIntrinsicWidth(col) {
        var initialWidth = col.width;
        var initialFlexGrow = col.flexGrow;
        col.width = 'auto';
        col.flexGrow = 0; // Note: _allCells only contains cells which are currently rendered in DOM

        var width = col._allCells.reduce(function (width, cell) {
          // Add 1px buffer to the offset width to avoid too narrow columns (sub-pixel rendering)
          return Math.max(width, cell.offsetWidth + 1);
        }, 0);

        col.flexGrow = initialFlexGrow;
        col.width = initialWidth;
        return width;
      }
      /** @private */

    }, {
      key: "__getDistributedWidth",
      value: function __getDistributedWidth(col, innerColumn) {
        var _this2 = this;

        if (col == null || col === this) {
          return 0;
        }

        var columnWidth = Math.max(this.__getIntrinsicWidth(col), this.__getDistributedWidth(col.parentElement, col)); // we're processing a regular grid-column and not a grid-column-group

        if (!innerColumn) {
          return columnWidth;
        } // At the end, the width of each vaadin-grid-column-group is determined by the sum of the width of its children.
        // Here we determine how much space the vaadin-grid-column-group actually needs to render properly and then we distribute that space
        // to its children, so when we actually do the summation it will be rendered properly.
        // Check out vaadin-grid-column-group:_updateFlexAndWidth


        var columnGroup = col;
        var columnGroupWidth = columnWidth;

        var sumOfWidthOfAllChildColumns = columnGroup._visibleChildColumns.map(function (col) {
          return _this2.__getIntrinsicWidth(col);
        }).reduce(function (sum, curr) {
          return sum + curr;
        }, 0);

        var extraNecessarySpaceForGridColumnGroup = Math.max(0, columnGroupWidth - sumOfWidthOfAllChildColumns); // The distribution of the extra necessary space is done according to the intrinsic width of each child column.
        // Lets say we need 100 pixels of extra space for the grid-column-group to render properly
        // it has two grid-column children, |100px|300px| in total 400px
        // the first column gets 25px of the additional space (100/400)*100 = 25
        // the second column gets the 75px of the additional space (300/400)*100 = 75

        var proportionOfExtraSpace = this.__getIntrinsicWidth(innerColumn) / sumOfWidthOfAllChildColumns;
        var shareOfInnerColumnFromNecessaryExtraSpace = proportionOfExtraSpace * extraNecessarySpaceForGridColumnGroup;
        return this.__getIntrinsicWidth(innerColumn) + shareOfInnerColumnFromNecessaryExtraSpace;
      }
      /**
       * @param {!Array<!GridColumnElement>} cols the columns to auto size based on their content width
       * @private
       */

    }, {
      key: "_recalculateColumnWidths",
      value: function _recalculateColumnWidths(cols) {
        var _this3 = this;

        cols.forEach(function (col) {
          col.width = "".concat(_this3.__getDistributedWidth(col), "px");
        });
      }
      /**
       * Updates the `width` of all columns which have `autoWidth` set to `true`.
       */

    }, {
      key: "recalculateColumnWidths",
      value: function recalculateColumnWidths() {
        if (!this._columnTree) {
          return; // No columns
        }

        if (this._cache.isLoading() || this.__isCreatingRows()) {
          this._recalculateColumnWidthOnceLoadingFinished = true;
        } else {
          var cols = this._getColumns().filter(function (col) {
            return !col.hidden && col.autoWidth;
          });

          this._recalculateColumnWidths(cols);
        }
      }
      /** @private */

    }, {
      key: "_createScrollerRows",
      value: function _createScrollerRows(count) {
        var _this4 = this;

        var rows = [];

        for (var i = 0; i < count; i++) {
          var row = document.createElement('tr');
          row.setAttribute('part', 'row');
          row.setAttribute('role', 'row');

          if (this._columnTree) {
            this._updateRow(row, this._columnTree[this._columnTree.length - 1], 'body', false, true);
          }

          rows.push(row);
        }

        if (this._columnTree) {
          this._columnTree[this._columnTree.length - 1].forEach(function (c) {
            return c.isConnected && c.notifyPath && c.notifyPath('_cells.*', c._cells);
          });
        }

        (0, _renderStatus.beforeNextRender)(this, function () {
          _this4._updateFirstAndLastColumn();

          _this4._resetKeyboardNavigation();
        });
        return rows;
      }
      /** @private */

    }, {
      key: "_getRowTarget",
      value: function _getRowTarget() {
        return this.$.items;
      }
      /** @private */

    }, {
      key: "_createCell",
      value: function _createCell(tagName) {
        var _this5 = this;

        var contentId = this._contentIndex = this._contentIndex + 1 || 0;
        var slotName = 'vaadin-grid-cell-content-' + contentId;
        var cellContent = document.createElement('vaadin-grid-cell-content');
        cellContent.setAttribute('slot', slotName);
        var cell = document.createElement(tagName);
        cell.id = slotName.replace('-content-', '-');
        cell.setAttribute('tabindex', '-1');
        cell.setAttribute('role', tagName === 'td' ? 'gridcell' : 'columnheader');
        var slot = document.createElement('slot');
        slot.setAttribute('name', slotName);
        cell.appendChild(slot);
        cell._content = cellContent; // With native Shadow DOM, mousedown on slotted element does not focus
        // focusable slot wrapper, that is why cells are not focused with
        // mousedown. Workaround: listen for mousedown and focus manually.

        cellContent.addEventListener('mousedown', function () {
          if (window.chrome) {
            // Chrome bug: focusing before mouseup prevents text selection, see http://crbug.com/771903
            var mouseUpListener = function mouseUpListener() {
              if (!cellContent.contains(_this5.getRootNode().activeElement)) {
                cell.focus();
              } // If focus is in the cell content — respect it, do not change.


              document.removeEventListener('mouseup', mouseUpListener, true);
            };

            document.addEventListener('mouseup', mouseUpListener, true);
          } else {
            // Focus on mouseup, on the other hand, removes selection on Safari.
            // Watch out sync focus removal issue, only async focus works here.
            setTimeout(function () {
              if (!cellContent.contains(_this5.getRootNode().activeElement)) {
                cell.focus();
              }
            });
          }
        });
        return cell;
      }
      /**
       * @param {!HTMLTableRowElement} row
       * @param {!Array<!GridColumnElement>} columns
       * @param {?string} section
       * @param {boolean} isColumnRow
       * @param {boolean} noNotify
       * @protected
       */

    }, {
      key: "_updateRow",
      value: function _updateRow(row, columns, section, isColumnRow, noNotify) {
        var _this6 = this;

        section = section || 'body';
        var contentsFragment = document.createDocumentFragment();
        Array.from(row.children).forEach(function (cell) {
          return cell._vacant = true;
        });
        row.innerHTML = '';

        if (row.id !== 'sizer') {
          row.hidden = true;
        }

        columns.filter(function (column) {
          return !column.hidden;
        }).forEach(function (column, index, cols) {
          var cell;

          if (section === 'body') {
            // Body
            column._cells = column._cells || [];
            cell = column._cells.filter(function (cell) {
              return cell._vacant;
            })[0];

            if (!cell) {
              cell = _this6._createCell('td');

              column._cells.push(cell);
            }

            cell.setAttribute('part', 'cell body-cell');
            row.appendChild(cell);

            if (index === cols.length - 1 && (_this6._rowDetailsTemplate || _this6.rowDetailsRenderer)) {
              // Add details cell as last cell to body rows
              _this6._detailsCells = _this6._detailsCells || [];

              var detailsCell = _this6._detailsCells.filter(function (cell) {
                return cell._vacant;
              })[0] || _this6._createCell('td');

              if (_this6._detailsCells.indexOf(detailsCell) === -1) {
                _this6._detailsCells.push(detailsCell);
              }

              if (!detailsCell._content.parentElement) {
                contentsFragment.appendChild(detailsCell._content);
              }

              _this6._configureDetailsCell(detailsCell);

              row.appendChild(detailsCell);

              _this6._a11ySetRowDetailsCell(row, detailsCell);

              detailsCell._vacant = false;
            }

            if (column.notifyPath && !noNotify) {
              column.notifyPath('_cells.*', column._cells);
            }
          } else {
            // Header & footer
            var tagName = section === 'header' ? 'th' : 'td';

            if (isColumnRow || column.localName === 'vaadin-grid-column-group') {
              cell = column["_".concat(section, "Cell")] || _this6._createCell(tagName);
              cell._column = column;
              row.appendChild(cell);
              column["_".concat(section, "Cell")] = cell;
            } else {
              column._emptyCells = column._emptyCells || [];
              cell = column._emptyCells.filter(function (cell) {
                return cell._vacant;
              })[0] || _this6._createCell(tagName);
              cell._column = column;
              row.appendChild(cell);

              if (column._emptyCells.indexOf(cell) === -1) {
                column._emptyCells.push(cell);
              }
            }

            cell.setAttribute('part', "cell ".concat(section, "-cell"));

            _this6.__updateHeaderFooterRowVisibility(row);
          }

          if (!cell._content.parentElement) {
            contentsFragment.appendChild(cell._content);
          }

          cell._vacant = false;
          cell._column = column;
        }); // Might be empty if only cache was used

        this.appendChild(contentsFragment);

        this._frozenCellsChanged();

        this._updateFirstAndLastColumnForRow(row);
      }
      /**
       * @param {HTMLTableRowElement} row
       * @protected
       */

    }, {
      key: "__updateHeaderFooterRowVisibility",
      value: function __updateHeaderFooterRowVisibility(row) {
        var _this7 = this;

        if (!row) {
          return;
        }

        var visibleRowCells = Array.from(row.children).filter(function (cell) {
          var column = cell._column;

          if (column._emptyCells && column._emptyCells.indexOf(cell) > -1) {
            // The cell is an "empty cell"  -> doesn't block hiding the row
            return false;
          }

          if (row.parentElement === _this7.$.header) {
            if (column.headerRenderer || column._headerTemplate) {
              // The cell is the header cell of a column that has a header renderer
              // or a header template -> row should be visible
              return true;
            }

            if (column.header === null) {
              // The column header is explicilty set to null -> doesn't block hiding the row
              return false;
            }

            if (column.path || column.header !== undefined) {
              // The column has an explicit non-null header or a path that generates a header
              // -> row should be visible
              return true;
            }
          } else {
            if (column.footerRenderer || column._footerTemplate) {
              // The cell is the footer cell of a column that has a footer renderer
              // or a footer template -> row should be visible
              return true;
            }
          }
        });

        if (row.hidden !== !visibleRowCells.length) {
          row.hidden = !visibleRowCells.length;
          this.notifyResize();
        }
      }
      /** @private */

    }, {
      key: "_updateScrollerItem",
      value: function _updateScrollerItem(row, index) {
        this._preventScrollerRotatingCellFocus(row, index);

        if (!this._columnTree) {
          return;
        }

        this._toggleAttribute('first', index === 0, row);

        this._toggleAttribute('last', index === this._effectiveSize - 1, row);

        this._toggleAttribute('odd', index % 2, row);

        this._a11yUpdateRowRowindex(row, index);

        this._getItem(index, row);
      }
      /** @private */

    }, {
      key: "_columnTreeChanged",
      value: function _columnTreeChanged(columnTree, splices) {
        this._renderColumnTree(columnTree);

        this.recalculateColumnWidths();
      }
      /**
       * @param {!Array<!GridColumnElement>} columnTree
       * @protected
       */

    }, {
      key: "_renderColumnTree",
      value: function _renderColumnTree(columnTree) {
        var _this8 = this;

        Array.from(this.$.items.children).forEach(function (row) {
          return _this8._updateRow(row, columnTree[columnTree.length - 1], null, false, true);
        });

        while (this.$.header.children.length < columnTree.length) {
          var headerRow = document.createElement('tr');
          headerRow.setAttribute('part', 'row');
          headerRow.setAttribute('role', 'row');
          this.$.header.appendChild(headerRow);
          var footerRow = document.createElement('tr');
          footerRow.setAttribute('part', 'row');
          footerRow.setAttribute('role', 'row');
          this.$.footer.appendChild(footerRow);
        }

        while (this.$.header.children.length > columnTree.length) {
          this.$.header.removeChild(this.$.header.firstElementChild);
          this.$.footer.removeChild(this.$.footer.firstElementChild);
        }

        Array.from(this.$.header.children).forEach(function (headerRow, index) {
          return _this8._updateRow(headerRow, columnTree[index], 'header', index === columnTree.length - 1);
        });
        Array.from(this.$.footer.children).forEach(function (footerRow, index) {
          return _this8._updateRow(footerRow, columnTree[columnTree.length - 1 - index], 'footer', index === 0);
        }); // Sizer rows

        this._updateRow(this.$.sizer, columnTree[columnTree.length - 1]);

        this._resizeHandler();

        this._frozenCellsChanged();

        this._updateFirstAndLastColumn();

        this._resetKeyboardNavigation();

        this._a11yUpdateHeaderRows();

        this._a11yUpdateFooterRows();

        this.__updateFooterPositioning();
      }
    }, {
      key: "__updateFooterPositioning",
      value: function __updateFooterPositioning() {
        var _this9 = this;

        if (this._firefox) {
          // Sticky (or translated) footer in a flexbox host doesn't get included in
          // the scroll height calculation on FF. This is a workaround for the issue.
          this.$.items.style.paddingBottom = 0;

          if (!this.heightByRows && !this.allRowsVisible) {
            this.$.items.style.paddingBottom = "".concat(this.$.footer.offsetHeight, "px");
          }
        }

        if (this._ios) {
          var isOldIOS = !window.CSS.supports('position', 'sticky');

          if (isOldIOS) {
            // Due to a rendering bug, the sticky header may disappear on an older iOS (10-12) Safari
            // if the grid is used inside of a flex box. This is a workaround for the issue.
            this.$.table.style.height = '';
            this.$.table.style.minHeight = '100%';
            this.$.table.style.maxHeight = '100%';
            setTimeout(function () {
              return _this9.$.table.style.height = "".concat(_this9.$.scroller.offsetHeight, "px");
            });
          }
        }
      }
      /**
       * @param {!HTMLElement} row
       * @param {GridItem} item
       * @protected
       */

    }, {
      key: "_updateItem",
      value: function _updateItem(row, item) {
        var _this10 = this;

        row._item = item;

        var model = this.__getRowModel(row);

        this._toggleAttribute('selected', model.selected, row);

        this._a11yUpdateRowSelected(row, model.selected);

        this._a11yUpdateRowLevel(row, model.level);

        this._toggleAttribute('expanded', model.expanded, row);

        this._toggleAttribute('details-opened', this._isDetailsOpened(item), row);

        if (this._rowDetailsTemplate || this.rowDetailsRenderer) {
          this._toggleDetailsCell(row, item);
        }

        this._generateCellClassNames(row, model);

        this._filterDragAndDrop(row, model);

        Array.from(row.children).forEach(function (cell) {
          if (cell._renderer) {
            var owner = cell._column || _this10;

            cell._renderer.call(owner, cell._content, owner, model);
          } else if (cell._instance) {
            cell._instance.__detailsOpened__ = model.detailsOpened;
            cell._instance.__selected__ = model.selected;
            cell._instance.__level__ = model.level;
            cell._instance.__expanded__ = model.expanded;

            cell._instance.setProperties(model);
          }
        });
        this._debouncerUpdateHeights = _debounce.Debouncer.debounce(this._debouncerUpdateHeights, _async.timeOut.after(1), function () {
          _this10._updateMetrics();

          _this10._positionItems();

          _this10._updateScrollerSize();
        });
      }
      /** @private */

    }, {
      key: "_resizeHandler",
      value: function _resizeHandler() {
        this._updateDetailsCellHeights();

        this._accessIronListAPI(babelHelpers.get(babelHelpers.getPrototypeOf(GridElement.prototype), "_resizeHandler", this), true);

        this._updateScrollerMeasurements();

        this.__updateFooterPositioning();
      }
      /** @private */

    }, {
      key: "_onAnimationEnd",
      value: function _onAnimationEnd(e) {
        var _this11 = this;

        // ShadyCSS applies scoping suffixes to animation names
        if (e.animationName.indexOf('vaadin-grid-appear') === 0) {
          this._render();

          e.stopPropagation();
          this.notifyResize();

          this.__flushPendingRecalculateColumnWidths();

          requestAnimationFrame(function () {
            _this11.__scrollToPendingIndex(); // This needs to be set programmatically in order to avoid an iOS 10 bug (disappearing grid)


            _this11.$.table.style.webkitOverflowScrolling = 'touch';
          });
        }
      }
      /**
       * @param {string} name
       * @param {boolean} bool
       * @param {!Element} node
       * @protected
       */

    }, {
      key: "_toggleAttribute",
      value: function _toggleAttribute(name, bool, node) {
        if (node.hasAttribute(name) === !bool) {
          if (bool) {
            node.setAttribute(name, '');
          } else {
            node.removeAttribute(name);
          }
        }
      }
      /**
       * @param {!HTMLTableRowElement} row
       * @return {!GridItemModel}
       * @protected
       */

    }, {
      key: "__getRowModel",
      value: function __getRowModel(row) {
        return {
          index: row.index,
          item: row._item,
          level: this._getIndexLevel(row.index),
          expanded: this._isExpanded(row._item),
          selected: this._isSelected(row._item),
          detailsOpened: !!(this._rowDetailsTemplate || this.rowDetailsRenderer) && this._isDetailsOpened(row._item)
        };
      }
      /**
       * Manually invoke existing renderers for all the columns
       * (header, footer and body cells) and opened row details.
       */

    }, {
      key: "render",
      value: function render() {
        if (this._columnTree) {
          // header and footer renderers
          this._columnTree.forEach(function (level) {
            level.forEach(function (column) {
              return column._renderHeaderAndFooter();
            });
          }); // body and row details renderers


          this._update();
        }
      }
      /**
       * Updates the computed metrics and positioning of internal grid parts
       * (row/details cell positioning etc). Needs to be invoked whenever the sizing of grid
       * content changes asynchronously to ensure consistent appearance (e.g. when a
       * contained image whose bounds aren't known beforehand finishes loading).
       */

    }, {
      key: "notifyResize",
      value: function notifyResize() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridElement.prototype), "notifyResize", this).call(this);
      }
      /** @private */

    }, {
      key: "_allRowsVisibleChanged",
      value: function _allRowsVisibleChanged(value, oldValue) {
        if (value || oldValue) {
          this.notifyResize();
        }
      }
      /** @protected */

    }, {
      key: "__forceReflow",
      value: function __forceReflow() {
        var _this12 = this;

        this._debouncerForceReflow = _debounce.Debouncer.debounce(this._debouncerForceReflow, _async.animationFrame, function () {
          _this12.$.scroller.style.overflow = 'hidden';
          setTimeout(function () {
            return _this12.$.scroller.style.overflow = '';
          });
        });
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _htmlTag.html)(_templateObject_a4293750942811ecb1937969798b231a || (_templateObject_a4293750942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n    <style include=\"vaadin-grid-styles\"></style>\n\n    <div id=\"scroller\" safari$=\"[[_safari]]\" ios$=\"[[_ios]]\" ie$=\"[[_ie]]\" loading$=\"[[loading]]\" column-reordering-allowed$=\"[[columnReorderingAllowed]]\">\n\n      <table id=\"table\" role=\"grid\" aria-multiselectable=\"true\" tabindex=\"0\">\n        <caption id=\"sizer\" part=\"row\"></caption>\n        <thead id=\"header\" role=\"rowgroup\"></thead>\n        <tbody id=\"items\" role=\"rowgroup\"></tbody>\n        <tfoot id=\"footer\" role=\"rowgroup\"></tfoot>\n      </table>\n\n      <div part=\"reorder-ghost\"></div>\n    </div>\n\n    <!-- The template needs at least one slot or else shady doesn't distribute -->\n    <slot name=\"nodistribute\"></slot>\n\n    <div id=\"focusexit\" tabindex=\"0\"></div>\n"], ["\n    <style include=\"vaadin-grid-styles\"></style>\n\n    <div id=\"scroller\" safari\\$=\"[[_safari]]\" ios\\$=\"[[_ios]]\" ie\\$=\"[[_ie]]\" loading\\$=\"[[loading]]\" column-reordering-allowed\\$=\"[[columnReorderingAllowed]]\">\n\n      <table id=\"table\" role=\"grid\" aria-multiselectable=\"true\" tabindex=\"0\">\n        <caption id=\"sizer\" part=\"row\"></caption>\n        <thead id=\"header\" role=\"rowgroup\"></thead>\n        <tbody id=\"items\" role=\"rowgroup\"></tbody>\n        <tfoot id=\"footer\" role=\"rowgroup\"></tfoot>\n      </table>\n\n      <div part=\"reorder-ghost\"></div>\n    </div>\n\n    <!-- The template needs at least one slot or else shady doesn't distribute -->\n    <slot name=\"nodistribute\"></slot>\n\n    <div id=\"focusexit\" tabindex=\"0\"></div>\n"])));
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-grid';
      }
    }, {
      key: "version",
      get: function get() {
        return '5.9.3';
      }
    }, {
      key: "observers",
      get: function get() {
        return ['_columnTreeChanged(_columnTree, _columnTree.*)'];
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /** @private */
          _safari: {
            type: Boolean,
            value: /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
          },

          /** @private */
          _ios: {
            type: Boolean,
            value: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1
          },

          /** @private */
          _edge: {
            type: Boolean,
            value: typeof CSS !== 'undefined' && CSS.supports('(-ms-ime-align:auto)')
          },

          /** @private */
          _ie: {
            type: Boolean,
            value: !!(navigator.userAgent.match(/Trident/) && !navigator.userAgent.match(/MSIE/))
          },

          /** @private */
          _firefox: {
            type: Boolean,
            value: navigator.userAgent.toLowerCase().indexOf('firefox') > -1
          },

          /** @private */
          _android: {
            type: Boolean,
            value: /android/i.test(navigator.userAgent)
          },

          /** @private */
          _touchDevice: {
            type: Boolean,
            value: TOUCH_DEVICE
          },

          /**
           * **Deprecated**
           *
           * See [`allRowsVisible`](#/elements/vaadin-grid#property-allRowsVisible)
           *
           * If true, the grid's height is defined by its rows.
           *
           * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.
           * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.
           * @attr {boolean} height-by-rows
           * @type {boolean}
           *
           * @deprecated
           */
          heightByRows: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: '_allRowsVisibleChanged'
          },

          /**
           * If true, the grid's height is defined by its rows.
           *
           * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.
           * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.
           * @attr {boolean} all-rows-visible
           * @type {boolean}
           */
          allRowsVisible: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: '_allRowsVisibleChanged'
          },

          /** @private */
          _recalculateColumnWidthOnceLoadingFinished: {
            type: Boolean,
            value: true
          }
        };
      }
    }]);
    return GridElement;
  }((0, _vaadinElementMixin.ElementMixin)((0, _vaadinThemableMixin.ThemableMixin)((0, _vaadinGridDataProviderMixin.DataProviderMixin)((0, _vaadinGridArrayDataProviderMixin.ArrayDataProviderMixin)((0, _vaadinGridDynamicColumnsMixin.DynamicColumnsMixin)((0, _vaadinGridActiveItemMixin.ActiveItemMixin)((0, _vaadinGridScrollMixin.ScrollMixin)((0, _vaadinGridSelectionMixin.SelectionMixin)((0, _vaadinGridSortMixin.SortMixin)((0, _vaadinGridRowDetailsMixin.RowDetailsMixin)((0, _vaadinGridKeyboardNavigationMixin.KeyboardNavigationMixin)((0, _vaadinGridA11yMixin.A11yMixin)((0, _vaadinGridFilterMixin.FilterMixin)((0, _vaadinGridColumnReorderingMixin.ColumnReorderingMixin)((0, _vaadinGridColumnResizingMixin.ColumnResizingMixin)((0, _vaadinGridEventContextMixin.EventContextMixin)((0, _vaadinGridDragAndDropMixin.DragAndDropMixin)((0, _vaadinGridStylingMixin.StylingMixin)(_vaadinGridScroller.ScrollerElement)))))))))))))))))));

  _exports.GridElement = GridElement;
  customElements.define(GridElement.is, GridElement);
});