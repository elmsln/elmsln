define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/elements/custom-style.js", "./vaadin-text-field.js", "../../../@polymer/polymer/lib/elements/dom-module.js"], function (_exports, _polymerElement, _customStyle, _vaadinTextField, _domModule) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.NumberFieldElement = void 0;

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */
  var $_documentContainer = document.createElement('template');
  $_documentContainer.innerHTML = "<dom-module id=\"vaadin-number-field-template\">\n  <template>\n    <style>\n      :host([readonly]) {\n        pointer-events: none;\n      }\n\n      [part=\"decrease-button\"]::before {\n        content: \"\u2212\";\n      }\n\n      [part=\"increase-button\"]::before {\n        content: \"+\";\n      }\n\n      [part=\"decrease-button\"],\n      [part=\"increase-button\"] {\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n      }\n\n      /* Hide the native arrow icons */\n      [part=\"value\"]::-webkit-outer-spin-button,\n      [part=\"value\"]::-webkit-inner-spin-button {\n        -webkit-appearance: none;\n        margin: 0;\n      }\n\n      [part=\"value\"] {\n        /* Older Firefox versions (v47.0) requires !important */\n        -moz-appearance: textfield !important;\n      }\n    </style>\n\n    <div disabled$=\"[[!_allowed(-1, value, min, max, step)]]\" part=\"decrease-button\" on-click=\"_decreaseValue\" on-touchend=\"_decreaseButtonTouchend\" hidden$=\"[[!hasControls]]\">\n    </div>\n\n    <div disabled$=\"[[!_allowed(1, value, min, max, step)]]\" part=\"increase-button\" on-click=\"_increaseValue\" on-touchend=\"_increaseButtonTouchend\" hidden$=\"[[!hasControls]]\">\n    </div>\n  </template>\n\n  \n</dom-module>";
  document.head.appendChild($_documentContainer.content);
  var memoizedTemplate;
  /**
  * `<vaadin-number-field>` is a Polymer 2 element for number field control in forms.
  *
  * ```html
  * <vaadin-number-field label="Number">
  * </vaadin-number-field>
  * ```
  *
  * @memberof Vaadin
  * @extends Vaadin.TextFieldElement
  * @demo demo/index.html
  */

  var NumberFieldElement =
  /*#__PURE__*/
  function (_TextFieldElement) {
    babelHelpers.inherits(NumberFieldElement, _TextFieldElement);

    function NumberFieldElement() {
      babelHelpers.classCallCheck(this, NumberFieldElement);
      return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(NumberFieldElement).apply(this, arguments));
    }

    babelHelpers.createClass(NumberFieldElement, [{
      key: "ready",
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(NumberFieldElement.prototype), "ready", this).call(this);
        this.__previousValidInput = this.value || '';
        this.inputElement.type = 'number';
        this.inputElement.addEventListener('keydown', this.__onKeyDown.bind(this));
        this.inputElement.addEventListener('change', this.__onInputChange.bind(this));
      }
    }, {
      key: "_decreaseButtonTouchend",
      value: function _decreaseButtonTouchend(e) {
        // Cancel the following click and focus events
        e.preventDefault();

        this._decreaseValue();
      }
    }, {
      key: "_increaseButtonTouchend",
      value: function _increaseButtonTouchend(e) {
        // Cancel the following click and focus events
        e.preventDefault();

        this._increaseValue();
      }
    }, {
      key: "_decreaseValue",
      value: function _decreaseValue() {
        this._incrementValue(-1);
      }
    }, {
      key: "_increaseValue",
      value: function _increaseValue() {
        this._incrementValue(1);
      }
    }, {
      key: "_incrementValue",
      value: function _incrementValue(incr) {
        if (this.disabled) {
          return;
        }

        var value = parseFloat(this.value);

        if (!this.value) {
          if (this.min == 0 && incr < 0 || this.max == 0 && incr > 0 || this.max == 0 && this.min == 0) {
            incr = 0;
            value = 0;
          } else if ((this.max == null || this.max >= 0) && (this.min == null || this.min <= 0)) {
            value = 0;
          } else if (this.min > 0) {
            value = this.min;

            if (this.max < 0 && incr < 0) {
              value = this.max;
            }

            incr = 0;
          } else if (this.max < 0) {
            value = this.max;

            if (incr < 0) {
              incr = 0;
            } else {
              // FIXME(yuriy): find a proper solution to make correct step back
              if (this._getIncrement(1, value - this.step) > this.max) {
                value -= 2 * this.step;
              } else {
                value -= this.step;
              }
            }
          }
        } else if (value < this.min) {
          incr = 0;
          value = this.min;
        } else if (value > this.max) {
          incr = 0;
          value = this.max;
        }

        var newValue = this._getIncrement(incr, value);

        if (!this.value || incr == 0 || this._incrementIsInsideTheLimits(incr, value)) {
          this._setValue(newValue);
        }
      }
    }, {
      key: "_setValue",
      value: function _setValue(value) {
        this.value = this.inputElement.value = parseFloat(value).toFixed(this.__decimals);
        this.dispatchEvent(new CustomEvent('change', {
          bubbles: true
        }));
      }
    }, {
      key: "_getIncrement",
      value: function _getIncrement(incr, currentValue) {
        var step = this.step || 1,
            min = this.min || 0; // To avoid problems with decimal math, multiplying to operate with integers.

        var multiplier = Math.max(this._getMultiplier(currentValue), this._getMultiplier(step), this._getMultiplier(min));
        step *= multiplier;
        currentValue *= multiplier;
        min *= multiplier;
        var margin = (currentValue - min) % step;

        if (incr > 0) {
          return (currentValue - margin + step) / multiplier;
        } else if (incr < 0) {
          return (currentValue - (margin || step)) / multiplier;
        } else {
          return currentValue / multiplier;
        }
      }
    }, {
      key: "_getMultiplier",
      value: function _getMultiplier(number) {
        if (!isNaN(number)) {
          var multiplier = 1; // Increase the multiplier until the float point will disappear

          while (Math.floor(number * multiplier) !== number * multiplier) {
            multiplier = multiplier * 10;
          }

          return multiplier;
        }
      }
    }, {
      key: "_incrementIsInsideTheLimits",
      value: function _incrementIsInsideTheLimits(incr, value) {
        if (incr < 0) {
          return this.min == null || this._getIncrement(incr, value) >= this.min;
        } else if (incr > 0) {
          return this.max == null || this._getIncrement(incr, value) <= this.max;
        } else {
          return this._getIncrement(incr, value) <= this.max && this._getIncrement(incr, value) >= this.min;
        }
      }
    }, {
      key: "_allowed",
      value: function _allowed(sign) {
        var incr = sign * (this.step || 1);
        var value = parseFloat(this.value);
        return !this.value || !this.disabled && this._incrementIsInsideTheLimits(incr, value);
      }
    }, {
      key: "_maxChanged",
      value: function _maxChanged() {
        this.inputElement.max = this.max;
      }
    }, {
      key: "_valueChanged",
      value: function _valueChanged(newVal, oldVal) {
        // Validate value to be numeric
        if (newVal && isNaN(parseFloat(newVal).toFixed(this.__decimals))) {
          this.value = '';
        } else if (typeof this.value !== 'string') {
          this.value = String(this.value);
        }

        babelHelpers.get(babelHelpers.getPrototypeOf(NumberFieldElement.prototype), "_valueChanged", this).call(this, this.value, oldVal);
      }
    }, {
      key: "__onKeyDown",
      value: function __onKeyDown(e) {
        if (e.keyCode == 38) {
          e.preventDefault();

          this._increaseValue();
        } else if (e.keyCode == 40) {
          e.preventDefault();

          this._decreaseValue();
        }
      }
    }, {
      key: "__onInputChange",
      value: function __onInputChange() {
        this.checkValidity();
      }
    }, {
      key: "_stepOrMinChanged",
      value: function _stepOrMinChanged(step, min) {
        this.inputElement.step = step;
        this.inputElement.min = this.min;

        var countDecimalPlaces = function countDecimalPlaces(number) {
          return number ? String(Math.abs(number)).replace(/^\d*\.?(.*)?$/, '$1').length : 0;
        }; // Compute number of dedimals to display in input based on provided step


        this.__decimals = Math.max(countDecimalPlaces(step), countDecimalPlaces(min));
      }
    }, {
      key: "checkValidity",
      value: function checkValidity() {
        // text-field mixin does not check against `min` and `max`
        if (this.min !== undefined || this.max !== undefined || this.step) {
          this.invalid = !this.inputElement.checkValidity();
        }

        return babelHelpers.get(babelHelpers.getPrototypeOf(NumberFieldElement.prototype), "checkValidity", this).call(this);
      }
    }], [{
      key: "is",
      get: function get() {
        return 'vaadin-number-field';
      }
    }, {
      key: "version",
      get: function get() {
        return '2.3.7';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
          * Set to true to display value increase/decrease controls.
          */
          hasControls: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },

          /**
          * The minimum value of the field.
          */
          min: {
            type: Number,
            reflectToAttribue: true
          },

          /**
           * The maximum value of the field.
           */
          max: {
            type: Number,
            reflectToAttribue: true,
            observer: '_maxChanged'
          },

          /**
           * Specifies the allowed number intervals of the field.
           */
          step: {
            type: Number,
            reflectToAttribue: true,
            value: 1
          }
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ['_stepOrMinChanged(step, min)'];
      }
    }, {
      key: "template",
      get: function get() {
        if (!memoizedTemplate) {
          // Clone the superclass template
          memoizedTemplate = babelHelpers.get(babelHelpers.getPrototypeOf(NumberFieldElement), "template", this).cloneNode(true); // Retrieve this element's dom-module template

          var thisTemplate = _domModule.DomModule.import(this.is + '-template', 'template');

          var decreaseButton = thisTemplate.content.querySelector('[part="decrease-button"]');
          var increaseButton = thisTemplate.content.querySelector('[part="increase-button"]');
          var styles = thisTemplate.content.querySelector('style'); // Add the buttons and styles to the text-field template

          var inputField = memoizedTemplate.content.querySelector('[part="input-field"]');
          var prefixSlot = memoizedTemplate.content.querySelector('[name="prefix"]');
          inputField.insertBefore(decreaseButton, prefixSlot);
          inputField.appendChild(increaseButton);
          memoizedTemplate.content.appendChild(styles);
        }

        return memoizedTemplate;
      }
    }]);
    return NumberFieldElement;
  }(_vaadinTextField.TextFieldElement);

  _exports.NumberFieldElement = NumberFieldElement;
  window.customElements.define(NumberFieldElement.is, NumberFieldElement);
});