define(["exports", "../../input-container/src/vaadin-input-container.js", "../../../@polymer/polymer/polymer-element.js", "../../component-base/src/element-mixin.js", "../../field-base/src/input-controller.js", "../../field-base/src/input-field-mixin.js", "../../field-base/src/labelled-input-controller.js", "../../field-base/src/pattern-mixin.js", "../../field-base/src/styles/input-field-shared-styles.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js"], function (_exports, _vaadinInputContainer, _polymerElement, _elementMixin, _inputController, _inputFieldMixin, _labelledInputController, _patternMixin, _inputFieldSharedStyles, _vaadinThemableMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.TextField = void 0;

  var _templateObject_02e9e0c0942711ec84e88734a30f0661;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  (0, _vaadinThemableMixin.registerStyles)('vaadin-text-field', _inputFieldSharedStyles.inputFieldShared, {
    moduleId: 'vaadin-text-field-styles'
  });
  /**
   * `<vaadin-text-field>` is a web component that allows the user to input and edit text.
   *
   * ```html
   * <vaadin-text-field label="First Name"></vaadin-text-field>
   * ```
   *
   * ### Prefixes and suffixes
   *
   * These are child elements of a `<vaadin-text-field>` that are displayed
   * inline with the input, before or after.
   * In order for an element to be considered as a prefix, it must have the slot
   * attribute set to `prefix` (and similarly for `suffix`).
   *
   * ```html
   * <vaadin-text-field label="Email address">
   *   <div slot="prefix">Sent to:</div>
   *   <div slot="suffix">@vaadin.com</div>
   * </vaadin-text-field>
   * ```
   *
   * ### Styling
   *
   * The following custom properties are available for styling:
   *
   * Custom property                | Description                | Default
   * -------------------------------|----------------------------|---------
   * `--vaadin-field-default-width` | Default width of the field | `12em`
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name            | Description
   * ---------------------|----------------
   * `label`              | The label element
   * `input-field`        | The element that wraps prefix, value and suffix
   * `clear-button`       | The clear button
   * `error-message`      | The error message element
   * `helper-text`        | The helper text element wrapper
   * `required-indicator` | The `required` state indicator element
   *
   * The following state attributes are available for styling:
   *
   * Attribute           | Description | Part name
   * --------------------|-------------|------------
   * `disabled`          | Set to a disabled text field | :host
   * `has-value`         | Set when the element has a value | :host
   * `has-label`         | Set when the element has a label | :host
   * `has-helper`        | Set when the element has helper text or slot | :host
   * `has-error-message` | Set when the element has an error message | :host
   * `invalid`           | Set when the element is invalid | :host
   * `input-prevented`   | Temporarily set when invalid input is prevented | :host
   * `focused`           | Set when the element is focused | :host
   * `focus-ring`        | Set when the element is keyboard focused | :host
   * `readonly`          | Set to a readonly text field | :host
   *
   * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.
   *
   * @fires {Event} input - Fired when the value is changed by the user: on every typing keystroke, and the value is cleared using the clear button.
   * @fires {Event} change - Fired when the user commits a value change.
   * @fires {CustomEvent} invalid-changed - Fired when the `invalid` property changes.
   * @fires {CustomEvent} value-changed - Fired when the `value` property changes.
   *
   * @extends HTMLElement
   * @mixes ElementMixin
   * @mixes ThemableMixin
   * @mixes PatternMixin
   * @mixes InputFieldMixin
   */

  var TextField = /*#__PURE__*/function (_PatternMixin) {
    babelHelpers.inherits(TextField, _PatternMixin);

    var _super = _createSuper(TextField);

    function TextField() {
      var _this;

      babelHelpers.classCallCheck(this, TextField);
      _this = _super.call(this);

      _this._setType('text');

      return _this;
    }
    /** @protected */


    babelHelpers.createClass(TextField, [{
      key: "clearElement",
      get: function get() {
        return this.$.clearButton;
      }
      /** @protected */

    }, {
      key: "ready",
      value: function ready() {
        var _this2 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(TextField.prototype), "ready", this).call(this);
        this.addController(new _inputController.InputController(this, function (input) {
          _this2._setInputElement(input);

          _this2._setFocusElement(input);

          _this2.stateTarget = input;
          _this2.ariaTarget = input;
        }));
        this.addController(new _labelledInputController.LabelledInputController(this.inputElement, this._labelController));
      }
    }], [{
      key: "is",
      get: function get() {
        return 'vaadin-text-field';
      }
    }, {
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_02e9e0c0942711ec84e88734a30f0661 || (_templateObject_02e9e0c0942711ec84e88734a30f0661 = babelHelpers.taggedTemplateLiteral(["\n      <style>\n        [part='input-field'] {\n          flex-grow: 0;\n        }\n      </style>\n\n      <div class=\"vaadin-field-container\">\n        <div part=\"label\">\n          <slot name=\"label\"></slot>\n          <span part=\"required-indicator\" aria-hidden=\"true\" on-click=\"focus\"></span>\n        </div>\n\n        <vaadin-input-container\n          part=\"input-field\"\n          readonly=\"[[readonly]]\"\n          disabled=\"[[disabled]]\"\n          invalid=\"[[invalid]]\"\n          theme$=\"[[theme]]\"\n        >\n          <slot name=\"prefix\" slot=\"prefix\"></slot>\n          <slot name=\"input\"></slot>\n          <slot name=\"suffix\" slot=\"suffix\"></slot>\n          <div id=\"clearButton\" part=\"clear-button\" slot=\"suffix\" aria-hidden=\"true\"></div>\n        </vaadin-input-container>\n\n        <div part=\"helper-text\">\n          <slot name=\"helper\"></slot>\n        </div>\n\n        <div part=\"error-message\">\n          <slot name=\"error-message\"></slot>\n        </div>\n      </div>\n    "])));
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Maximum number of characters (in Unicode code points) that the user can enter.
           */
          maxlength: {
            type: Number
          },

          /**
           * Minimum number of characters (in Unicode code points) that the user can enter.
           */
          minlength: {
            type: Number
          }
        };
      }
    }, {
      key: "delegateAttrs",
      get: function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(TextField), "delegateAttrs", this)), ['maxlength', 'minlength']);
      }
    }, {
      key: "constraints",
      get: function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(TextField), "constraints", this)), ['maxlength', 'minlength']);
      }
    }]);
    return TextField;
  }((0, _patternMixin.PatternMixin)((0, _inputFieldMixin.InputFieldMixin)((0, _vaadinThemableMixin.ThemableMixin)((0, _elementMixin.ElementMixin)(_polymerElement.PolymerElement)))));

  _exports.TextField = TextField;
  customElements.define(TextField.is, TextField);
});