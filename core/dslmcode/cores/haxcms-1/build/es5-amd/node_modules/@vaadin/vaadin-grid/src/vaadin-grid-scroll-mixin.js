define(["exports", "../../../@polymer/polymer/lib/utils/debounce.js", "../../../@polymer/polymer/lib/utils/async.js"], function (_exports, _debounce, _async) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ScrollMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @polymerMixin
   */
  var ScrollMixin = function ScrollMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(ScrollMixin, _superClass);

      var _super = _createSuper(ScrollMixin);

      babelHelpers.createClass(ScrollMixin, [{
        key: "_timeouts",

        /** @private */
        get: function get() {
          return {
            SCROLL_PERIOD: 1000,
            WHEEL_SCROLLING: 200,
            SCROLLING: 100,
            IGNORE_WHEEL: 500
          };
        }
      }, {
        key: "_scrollTop",

        /**
         * Override (from iron-scroll-target-behavior) to avoid document scroll
         * @private
         */
        set: function set(top) {
          this.$.table.scrollTop = top;
        }
        /** @private */
        ,
        get: function get() {
          return this.$.table.scrollTop;
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * Cached array of frozen cells
             * @private
             */
            _frozenCells: {
              type: Array,
              value: function value() {
                return [];
              }
            },

            /**
             * @type {number}
             * @protected
             */
            _scrollbarWidth: {
              type: Number,
              value: function value() {
                // Create the measurement node
                var scrollDiv = document.createElement('div');
                scrollDiv.style.width = '100px';
                scrollDiv.style.height = '100px';
                scrollDiv.style.overflow = 'scroll';
                scrollDiv.style.position = 'absolute';
                scrollDiv.style.top = '-9999px';
                document.body.appendChild(scrollDiv); // Get the scrollbar width

                var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth; // Delete the DIV

                document.body.removeChild(scrollDiv);
                return scrollbarWidth;
              }
            },

            /** @private */
            _rowWithFocusedElement: Element,

            /** @private */
            _deltaYAcc: {
              type: Number,
              value: 0
            }
          };
        }
      }, {
        key: "observers",
        get: function get() {
          return ['_scrollHeightUpdated(_estScrollHeight)', '_scrollViewportHeightUpdated(_viewportHeight)'];
        }
      }]);

      function ScrollMixin() {
        var _this;

        babelHelpers.classCallCheck(this, ScrollMixin);
        _this = _super.call(this);
        _this._scrollLineHeight = _this._getScrollLineHeight();
        return _this;
      }
      /**
       * @returns {Number|undefined} - The browser's default font-size in pixels
       * @private
       */


      babelHelpers.createClass(ScrollMixin, [{
        key: "_getScrollLineHeight",
        value: function _getScrollLineHeight() {
          var el = document.createElement('div');
          el.style.fontSize = 'initial';
          el.style.display = 'none';
          document.body.appendChild(el);
          var fontSize = window.getComputedStyle(el).fontSize;
          document.body.removeChild(el);
          return fontSize ? window.parseInt(fontSize) : undefined;
        }
        /** @private */

      }, {
        key: "_scrollViewportHeightUpdated",
        value: function _scrollViewportHeightUpdated(_viewportHeight) {
          this._scrollPageHeight = _viewportHeight - this.$.header.clientHeight - this.$.footer.clientHeight - this._scrollLineHeight;
        }
        /** @protected */

      }, {
        key: "ready",
        value: function ready() {
          var _this2 = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(ScrollMixin.prototype), "ready", this).call(this);
          this.scrollTarget = this.$.table;
          this.addEventListener('wheel', function (e) {
            _this2._wheelScrolling = true;
            _this2._debouncerWheelScrolling = _debounce.Debouncer.debounce(_this2._debouncerWheelScrolling, _async.timeOut.after(_this2._timeouts.WHEEL_SCROLLING), function () {
              return _this2._wheelScrolling = false;
            });

            _this2._onWheel(e);
          });
          this.$.table.addEventListener('scroll', function (e) {
            if (_this2.$.outerscroller.outerScrolling) {
              e.stopImmediatePropagation();
            }
          }, true);
          this.$.items.addEventListener('focusin', function (e) {
            var itemsIndex = e.composedPath().indexOf(_this2.$.items);
            _this2._rowWithFocusedElement = e.composedPath()[itemsIndex - 1];
          });
          this.$.items.addEventListener('focusout', function () {
            return _this2._rowWithFocusedElement = undefined;
          });
        }
        /**
         * Scroll to a specific row index in the virtual list. Note that the row index is
         * not always the same for any particular item. For example, sorting/filtering/expanding
         * or collapsing hierarchical items can affect the row index related to an item.
         *
         * @param {number} index Row index to scroll to
         */

      }, {
        key: "scrollToIndex",
        value: function scrollToIndex(index) {
          var _this3 = this;

          this._accessIronListAPI(function () {
            return babelHelpers.get(babelHelpers.getPrototypeOf(ScrollMixin.prototype), "scrollToIndex", _this3).call(_this3, index);
          });
        }
        /** @private */

      }, {
        key: "_onWheel",
        value: function _onWheel(e) {
          var _this4 = this;

          if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {
            return;
          }

          var table = this.$.table;
          var deltaY = e.deltaY;

          if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {
            // Scrolling by "lines of text" instead of pixels
            deltaY *= this._scrollLineHeight;
          } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
            // Scrolling by "pages" instead of pixels
            deltaY *= this._scrollPageHeight;
          }

          if (this._wheelAnimationFrame) {
            // Skip new wheel events while one is being processed
            this._deltaYAcc += deltaY;
            e.preventDefault();
            return;
          }

          deltaY += this._deltaYAcc;
          this._deltaYAcc = 0;
          this._wheelAnimationFrame = true;
          this._debouncerWheelAnimationFrame = _debounce.Debouncer.debounce(this._debouncerWheelAnimationFrame, _async.animationFrame, function () {
            return _this4._wheelAnimationFrame = false;
          });
          var momentum = Math.abs(e.deltaX) + Math.abs(deltaY);

          if (this._canScroll(table, e.deltaX, deltaY)) {
            e.preventDefault();
            table.scrollTop += deltaY;
            table.scrollLeft += e.deltaX;

            this._scrollHandler();

            this._hasResidualMomentum = true;
            this._ignoreNewWheel = true;
            this._debouncerIgnoreNewWheel = _debounce.Debouncer.debounce(this._debouncerIgnoreNewWheel, _async.timeOut.after(this._timeouts.IGNORE_WHEEL), function () {
              return _this4._ignoreNewWheel = false;
            });
          } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
            e.preventDefault();
          } else if (momentum > this._previousMomentum) {
            this._hasResidualMomentum = false;
          }

          this._previousMomentum = momentum;
        }
        /**
         * Determines if the element has an ancestor prior to this
         * cell content that handles the scroll delta
         * @private
         */

      }, {
        key: "_hasScrolledAncestor",
        value: function _hasScrolledAncestor(el, deltaX, deltaY) {
          if (el.localName === 'vaadin-grid-cell-content') {
            return false;
          } else if (this._canScroll(el, deltaX, deltaY) && ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1) {
            return true;
          } else if (el !== this && el.parentElement) {
            return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
          }
        }
        /**
         * Determines if the the given scroll deltas can be applied to the element
         * (fully or partially)
         * @private
         */

      }, {
        key: "_canScroll",
        value: function _canScroll(el, deltaX, deltaY) {
          return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;
        }
        /** @private */

      }, {
        key: "_scheduleScrolling",
        value: function _scheduleScrolling() {
          var _this5 = this;

          if (!this._scrollingFrame) {
            // Defer setting state attributes to avoid Edge hiccups
            this._scrollingFrame = requestAnimationFrame(function () {
              return _this5._toggleAttribute('scrolling', true, _this5.$.scroller);
            });
          }

          this._debounceScrolling = _debounce.Debouncer.debounce(this._debounceScrolling, _async.timeOut.after(this._timeouts.SCROLLING), function () {
            cancelAnimationFrame(_this5._scrollingFrame);
            delete _this5._scrollingFrame;

            _this5._toggleAttribute('scrolling', false, _this5.$.scroller);

            if (!_this5.$.outerscroller.outerScrolling) {
              _this5._reorderRows();
            }
          });

          if (!this._scrollPeriodFrame) {
            this._scrollPeriodFrame = requestAnimationFrame(function () {
              return _this5._toggleAttribute('scroll-period', true, _this5.$.scroller);
            });
          }

          this._debounceScrollPeriod = _debounce.Debouncer.debounce(this._debounceScrollPeriod, _async.timeOut.after(this._timeouts.SCROLL_PERIOD), function () {
            cancelAnimationFrame(_this5._scrollPeriodFrame);
            delete _this5._scrollPeriodFrame;

            _this5._toggleAttribute('scroll-period', false, _this5.$.scroller);
          });
        }
        /** @private */

      }, {
        key: "_afterScroll",
        value: function _afterScroll() {
          this._translateStationaryElements();

          if (!this.hasAttribute('reordering')) {
            this._scheduleScrolling();
          }

          var os = this.$.outerscroller;

          if (!this._ios && (this._wheelScrolling || os.passthrough)) {
            os.syncOuterScroller();
          }

          if (this._ios) {
            // Enable vertical rubberband feedback
            var overScroll = Math.max(-os.scrollTop, 0) || Math.min(0, os.scrollHeight - os.scrollTop - os.offsetHeight);
            this.$.items.style.transform = "translateY(".concat(overScroll, "px)");
          }

          this._updateOverflow();
        }
        /** @private */

      }, {
        key: "_updateOverflow",
        value: function _updateOverflow() {
          var _this6 = this;

          // Set overflow styling attributes
          var overflow = '';
          var table = this.$.table;

          if (table.scrollTop < table.scrollHeight - table.clientHeight) {
            overflow += ' bottom';
          }

          if (table.scrollTop > 0) {
            overflow += ' top';
          }

          if (table.scrollLeft < table.scrollWidth - table.clientWidth) {
            overflow += ' right';
          }

          if (table.scrollLeft > 0) {
            overflow += ' left';
          }

          this._debounceOverflow = _debounce.Debouncer.debounce(this._debounceOverflow, _async.animationFrame, function () {
            var value = overflow.trim();

            if (value.length > 0 && _this6.getAttribute('overflow') !== value) {
              _this6.setAttribute('overflow', value);
            } else if (value.length == 0 && _this6.hasAttribute('overflow')) {
              _this6.removeAttribute('overflow');
            }
          });
        }
        /**
         * Correct order needed for preserving correct tab order between cell contents.
         * @private
         */

      }, {
        key: "_reorderRows",
        value: function _reorderRows() {
          var body = this.$.items;
          var items = body.querySelectorAll('tr');

          if (!items.length) {
            return;
          }

          var adjustedVirtualStart = this._virtualStart + this._vidxOffset; // Which row to use as a target?

          var targetRow = this._rowWithFocusedElement || Array.from(items).filter(function (row) {
            return !row.hidden;
          })[0];

          if (!targetRow) {
            // All rows are hidden, don't reorder
            return;
          } // Where the target row should be?


          var targetPhysicalIndex = targetRow.index - adjustedVirtualStart; // Reodrer the DOM elements to keep the target row at the target physical index

          var delta = Array.from(items).indexOf(targetRow) - targetPhysicalIndex;

          if (delta > 0) {
            for (var i = 0; i < delta; i++) {
              body.appendChild(items[i]);
            }
          } else if (delta < 0) {
            for (var _i = items.length + delta; _i < items.length; _i++) {
              body.insertBefore(items[_i], items[0]);
            }
          }
        }
        /** @protected */

      }, {
        key: "_frozenCellsChanged",
        value: function _frozenCellsChanged() {
          var _this7 = this;

          this._debouncerCacheElements = _debounce.Debouncer.debounce(this._debouncerCacheElements, _async.microTask, function () {
            Array.from(_this7.shadowRoot.querySelectorAll('[part~="cell"]')).forEach(function (cell) {
              cell.style.transform = '';
            });
            _this7._frozenCells = Array.prototype.slice.call(_this7.$.table.querySelectorAll('[frozen]'));

            _this7._updateScrollerMeasurements();

            _this7._translateStationaryElements();
          });

          this._updateLastFrozen();
        }
        /** @protected */

      }, {
        key: "_updateScrollerMeasurements",
        value: function _updateScrollerMeasurements() {
          if (this._frozenCells.length > 0 && this.__isRTL) {
            this.__scrollerMetrics = {
              scrollWidth: this.$.outerscroller.scrollWidth,
              clientWidth: this.$.outerscroller.clientWidth
            };
          }
        }
        /** @protected */

      }, {
        key: "_updateLastFrozen",
        value: function _updateLastFrozen() {
          if (!this._columnTree) {
            return;
          }

          var columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);

          columnsRow.sort(function (a, b) {
            return a._order - b._order;
          });
          var lastFrozen = columnsRow.reduce(function (prev, col, index) {
            col._lastFrozen = false;
            return col.frozen && !col.hidden ? index : prev;
          }, undefined);

          if (lastFrozen !== undefined) {
            columnsRow[lastFrozen]._lastFrozen = true;
          }
        }
        /** @private */

      }, {
        key: "_translateStationaryElements",
        value: function _translateStationaryElements() {
          if (this._edge && !this._scrollbarWidth) {
            // Fixed mode (Tablet Edge)
            this.$.items.style.transform = this._getTranslate(-this._scrollLeft || 0, -this._scrollTop || 0);
            this.$.footer.style.transform = this.$.header.style.transform = this._getTranslate(-this._scrollLeft || 0, 0);
          } else {
            this.$.footer.style.transform = this.$.header.style.transform = this._getTranslate(0, this._scrollTop);
          }

          if (this._frozenCells.length > 0) {
            var x = this.__isRTL ? this.__getNormalizedScrollLeft(this.$.table) + this.__scrollerMetrics.clientWidth - this.__scrollerMetrics.scrollWidth : this._scrollLeft;

            var frozenCellTransform = this._getTranslate(x, 0);

            for (var i = 0; i < this._frozenCells.length; i++) {
              this._frozenCells[i].style.transform = frozenCellTransform;
            }
          }
        }
        /** @private */

      }, {
        key: "_getTranslate",
        value: function _getTranslate(x, y) {
          return 'translate(' + x + 'px,' + y + 'px)';
        }
        /** @private */

      }, {
        key: "_scrollHeightUpdated",
        value: function _scrollHeightUpdated(_estScrollHeight) {
          this.$.outersizer.style.top = this.$.fixedsizer.style.top = _estScrollHeight + 'px';
        }
      }]);
      return ScrollMixin;
    }(superClass);
  };

  _exports.ScrollMixin = ScrollMixin;
});