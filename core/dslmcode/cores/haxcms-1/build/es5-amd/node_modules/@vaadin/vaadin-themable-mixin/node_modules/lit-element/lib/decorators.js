define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.property = property;
  _exports.internalProperty = internalProperty;
  _exports.query = query;
  _exports.queryAsync = queryAsync;
  _exports.queryAll = queryAll;
  _exports.eventOptions = eventOptions;
  _exports.queryAssignedNodes = queryAssignedNodes;
  _exports.state = _exports.customElement = void 0;

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var legacyCustomElement = function legacyCustomElement(tagName, clazz) {
    window.customElements.define(tagName, clazz); // Cast as any because TS doesn't recognize the return type as being a
    // subtype of the decorated class when clazz is typed as
    // `Constructor<HTMLElement>` for some reason.
    // `Constructor<HTMLElement>` is helpful to make sure the decorator is
    // applied to elements however.
    // tslint:disable-next-line:no-any

    return clazz;
  };

  var standardCustomElement = function standardCustomElement(tagName, descriptor) {
    var kind = descriptor.kind,
        elements = descriptor.elements;
    return {
      kind: kind,
      elements: elements,
      // This callback is called once the class is otherwise fully defined
      finisher: function finisher(clazz) {
        window.customElements.define(tagName, clazz);
      }
    };
  };
  /**
   * Class decorator factory that defines the decorated class as a custom element.
   *
   * ```
   * @customElement('my-element')
   * class MyElement {
   *   render() {
   *     return html``;
   *   }
   * }
   * ```
   * @category Decorator
   * @param tagName The name of the custom element to define.
   */


  var customElement = function customElement(tagName) {
    return function (classOrDescriptor) {
      return typeof classOrDescriptor === 'function' ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);
    };
  };

  _exports.customElement = customElement;

  var standardProperty = function standardProperty(options, element) {
    // When decorating an accessor, pass it through and add property metadata.
    // Note, the `hasOwnProperty` check in `createProperty` ensures we don't
    // stomp over the user's accessor.
    if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
      return Object.assign(Object.assign({}, element), {
        finisher: function finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      });
    } else {
      // createProperty() takes care of defining the property, but we still
      // must return some kind of descriptor, so return a descriptor for an
      // unused prototype field. The finisher calls createProperty().
      return {
        kind: 'field',
        key: Symbol(),
        placement: 'own',
        descriptor: {},
        // When @babel/plugin-proposal-decorators implements initializers,
        // do this instead of the initializer below. See:
        // https://github.com/babel/babel/issues/9260 extras: [
        //   {
        //     kind: 'initializer',
        //     placement: 'own',
        //     initializer: descriptor.initializer,
        //   }
        // ],
        initializer: function initializer() {
          if (typeof element.initializer === 'function') {
            this[element.key] = element.initializer.call(this);
          }
        },
        finisher: function finisher(clazz) {
          clazz.createProperty(element.key, options);
        }
      };
    }
  };

  var legacyProperty = function legacyProperty(options, proto, name) {
    proto.constructor.createProperty(name, options);
  };
  /**
   * A property decorator which creates a LitElement property which reflects a
   * corresponding attribute value. A [[`PropertyDeclaration`]] may optionally be
   * supplied to configure property features.
   *
   * This decorator should only be used for public fields. Private or protected
   * fields should use the [[`internalProperty`]] decorator.
   *
   * @example
   * ```ts
   * class MyElement {
   *   @property({ type: Boolean })
   *   clicked = false;
   * }
   * ```
   * @category Decorator
   * @ExportDecoratedItems
   */


  function property(options) {
    // tslint:disable-next-line:no-any decorator
    return function (protoOrDescriptor, name) {
      return name !== undefined ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
    };
  }
  /**
   * Declares a private or protected property that still triggers updates to the
   * element when it changes.
   *
   * Properties declared this way must not be used from HTML or HTML templating
   * systems, they're solely for properties internal to the element. These
   * properties may be renamed by optimization tools like the Closure Compiler.
   * @category Decorator
   * @deprecated `internalProperty` has been renamed to `state` in lit-element
   *     3.0. Please update to `state` now to be compatible with 3.0.
   */


  function internalProperty(options) {
    return property({
      attribute: false,
      hasChanged: options === null || options === void 0 ? void 0 : options.hasChanged
    });
  }
  /**
   * Declares a private or protected property that still triggers updates to the
   * element when it changes.
   *
   * Properties declared this way must not be used from HTML or HTML templating
   * systems, they're solely for properties internal to the element. These
   * properties may be renamed by optimization tools like the Closure Compiler.
   * @category Decorator
   */


  var state = function state(options) {
    return internalProperty(options);
  };
  /**
   * A property decorator that converts a class property into a getter that
   * executes a querySelector on the element's renderRoot.
   *
   * @param selector A DOMString containing one or more selectors to match.
   * @param cache An optional boolean which when true performs the DOM query only
   * once and caches the result.
   *
   * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
   *
   * @example
   *
   * ```ts
   * class MyElement {
   *   @query('#first')
   *   first;
   *
   *   render() {
   *     return html`
   *       <div id="first"></div>
   *       <div id="second"></div>
   *     `;
   *   }
   * }
   * ```
   * @category Decorator
   */


  _exports.state = state;

  function query(selector, cache) {
    return function (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
    name) {
      var descriptor = {
        get: function get() {
          return this.renderRoot.querySelector(selector);
        },
        enumerable: true,
        configurable: true
      };

      if (cache) {
        var prop = name !== undefined ? name : protoOrDescriptor.key;
        var key = babelHelpers.typeof(prop) === 'symbol' ? Symbol() : "__".concat(prop);

        descriptor.get = function () {
          if (this[key] === undefined) {
            this[key] = this.renderRoot.querySelector(selector);
          }

          return this[key];
        };
      }

      return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
    };
  } // Note, in the future, we may extend this decorator to support the use case
  // where the queried element may need to do work to become ready to interact
  // with (e.g. load some implementation code). If so, we might elect to
  // add a second argument defining a function that can be run to make the
  // queried element loaded/updated/ready.

  /**
   * A property decorator that converts a class property into a getter that
   * returns a promise that resolves to the result of a querySelector on the
   * element's renderRoot done after the element's `updateComplete` promise
   * resolves. When the queried property may change with element state, this
   * decorator can be used instead of requiring users to await the
   * `updateComplete` before accessing the property.
   *
   * @param selector A DOMString containing one or more selectors to match.
   *
   * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
   *
   * @example
   * ```ts
   * class MyElement {
   *   @queryAsync('#first')
   *   first;
   *
   *   render() {
   *     return html`
   *       <div id="first"></div>
   *       <div id="second"></div>
   *     `;
   *   }
   * }
   *
   * // external usage
   * async doSomethingWithFirst() {
   *  (await aMyElement.first).doSomething();
   * }
   * ```
   * @category Decorator
   */


  function queryAsync(selector) {
    return function (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
    name) {
      var descriptor = {
        get: function () {
          var _get = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.updateComplete;

                  case 2:
                    return _context.abrupt("return", this.renderRoot.querySelector(selector));

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function get() {
            return _get.apply(this, arguments);
          }

          return get;
        }(),
        enumerable: true,
        configurable: true
      };
      return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
    };
  }
  /**
   * A property decorator that converts a class property into a getter
   * that executes a querySelectorAll on the element's renderRoot.
   *
   * @param selector A DOMString containing one or more selectors to match.
   *
   * See:
   * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll
   *
   * @example
   * ```ts
   * class MyElement {
   *   @queryAll('div')
   *   divs;
   *
   *   render() {
   *     return html`
   *       <div id="first"></div>
   *       <div id="second"></div>
   *     `;
   *   }
   * }
   * ```
   * @category Decorator
   */


  function queryAll(selector) {
    return function (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
    name) {
      var descriptor = {
        get: function get() {
          return this.renderRoot.querySelectorAll(selector);
        },
        enumerable: true,
        configurable: true
      };
      return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
    };
  }

  var legacyQuery = function legacyQuery(descriptor, proto, name) {
    Object.defineProperty(proto, name, descriptor);
  };

  var standardQuery = function standardQuery(descriptor, element) {
    return {
      kind: 'method',
      placement: 'prototype',
      key: element.key,
      descriptor: descriptor
    };
  };

  var standardEventOptions = function standardEventOptions(options, element) {
    return Object.assign(Object.assign({}, element), {
      finisher: function finisher(clazz) {
        Object.assign(clazz.prototype[element.key], options);
      }
    });
  };

  var legacyEventOptions = // tslint:disable-next-line:no-any legacy decorator
  function legacyEventOptions(options, proto, name) {
    Object.assign(proto[name], options);
  };
  /**
   * Adds event listener options to a method used as an event listener in a
   * lit-html template.
   *
   * @param options An object that specifies event listener options as accepted by
   * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.
   *
   * Current browsers support the `capture`, `passive`, and `once` options. See:
   * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters
   *
   * @example
   * ```ts
   * class MyElement {
   *   clicked = false;
   *
   *   render() {
   *     return html`
   *       <div @click=${this._onClick}`>
   *         <button></button>
   *       </div>
   *     `;
   *   }
   *
   *   @eventOptions({capture: true})
   *   _onClick(e) {
   *     this.clicked = true;
   *   }
   * }
   * ```
   * @category Decorator
   */


  function eventOptions(options) {
    // Return value typed as any to prevent TypeScript from complaining that
    // standard decorator function signature does not match TypeScript decorator
    // signature
    // TODO(kschaaf): unclear why it was only failing on this decorator and not
    // the others
    return function (protoOrDescriptor, name) {
      return name !== undefined ? legacyEventOptions(options, protoOrDescriptor, name) : standardEventOptions(options, protoOrDescriptor);
    };
  } // x-browser support for matches
  // tslint:disable-next-line:no-any


  var ElementProto = Element.prototype;
  var legacyMatches = ElementProto.msMatchesSelector || ElementProto.webkitMatchesSelector;
  /**
   * A property decorator that converts a class property into a getter that
   * returns the `assignedNodes` of the given named `slot`. Note, the type of
   * this property should be annotated as `NodeListOf<HTMLElement>`.
   *
   * @param slotName A string name of the slot.
   * @param flatten A boolean which when true flattens the assigned nodes,
   * meaning any assigned nodes that are slot elements are replaced with their
   * assigned nodes.
   * @param selector A string which filters the results to elements that match
   * the given css selector.
   *
   * * @example
   * ```ts
   * class MyElement {
   *   @queryAssignedNodes('list', true, '.item')
   *   listItems;
   *
   *   render() {
   *     return html`
   *       <slot name="list"></slot>
   *     `;
   *   }
   * }
   * ```
   * @category Decorator
   */

  function queryAssignedNodes() {
    var slotName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var flatten = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var selector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    return function (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
    name) {
      var descriptor = {
        get: function get() {
          var slotSelector = "slot".concat(slotName ? "[name=".concat(slotName, "]") : ':not([name])');
          var slot = this.renderRoot.querySelector(slotSelector);
          var nodes = slot && slot.assignedNodes({
            flatten: flatten
          });

          if (nodes && selector) {
            nodes = nodes.filter(function (node) {
              return node.nodeType === Node.ELEMENT_NODE && ( // tslint:disable-next-line:no-any testing existence on older browsers
              node.matches ? node.matches(selector) : legacyMatches.call(node, selector));
            });
          }

          return nodes;
        },
        enumerable: true,
        configurable: true
      };
      return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
    };
  }
});