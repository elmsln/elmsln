define(["exports", "./vaadin-grid-column.js", "./vaadin-grid-styles.js", "../../../@polymer/polymer/lib/utils/render-status.js", "../../../@polymer/polymer/polymer-element.js", "../../component-base/src/browser-utils.js", "../../component-base/src/element-mixin.js", "../../component-base/src/templates.js", "../../component-base/src/virtualizer.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "./vaadin-grid-a11y-mixin.js", "./vaadin-grid-active-item-mixin.js", "./vaadin-grid-array-data-provider-mixin.js", "./vaadin-grid-column-reordering-mixin.js", "./vaadin-grid-column-resizing-mixin.js", "./vaadin-grid-data-provider-mixin.js", "./vaadin-grid-drag-and-drop-mixin.js", "./vaadin-grid-dynamic-columns-mixin.js", "./vaadin-grid-event-context-mixin.js", "./vaadin-grid-filter-mixin.js", "./vaadin-grid-keyboard-navigation-mixin.js", "./vaadin-grid-row-details-mixin.js", "./vaadin-grid-scroll-mixin.js", "./vaadin-grid-selection-mixin.js", "./vaadin-grid-sort-mixin.js", "./vaadin-grid-styling-mixin.js"], function (_exports, _vaadinGridColumn, _vaadinGridStyles, _renderStatus, _polymerElement, _browserUtils, _elementMixin, _templates, _virtualizer, _vaadinThemableMixin, _vaadinGridA11yMixin, _vaadinGridActiveItemMixin, _vaadinGridArrayDataProviderMixin, _vaadinGridColumnReorderingMixin, _vaadinGridColumnResizingMixin, _vaadinGridDataProviderMixin, _vaadinGridDragAndDropMixin, _vaadinGridDynamicColumnsMixin, _vaadinGridEventContextMixin, _vaadinGridFilterMixin, _vaadinGridKeyboardNavigationMixin, _vaadinGridRowDetailsMixin, _vaadinGridScrollMixin, _vaadinGridSelectionMixin, _vaadinGridSortMixin, _vaadinGridStylingMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Grid = void 0;

  var _templateObject_0228b3a0942711ec84e88734a30f0661;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `<vaadin-grid>` is a free, high quality data grid / data table Web Component. The content of the
   * the grid can be populated by using renderer callback function.
   *
   * ### Quick Start
   *
   * Start with an assigning an array to the [`items`](#/elements/vaadin-grid#property-items) property to visualize your data.
   *
   * Use the [`<vaadin-grid-column>`](#/elements/vaadin-grid-column) element to configure the grid columns. Set `path` and `header`
   * shorthand properties for the columns to define what gets rendered in the cells of the column.
   *
   * #### Example:
   * ```html
   * <vaadin-grid>
   *   <vaadin-grid-column path="name.first" header="First name"></vaadin-grid-column>
   *   <vaadin-grid-column path="name.last" header="Last name"></vaadin-grid-column>
   *   <vaadin-grid-column path="email"></vaadin-grid-column>
   * </vaadin-grid>
   * ```
   *
   * For custom content `vaadin-grid-column` element provides you with three types of `renderer` callback functions: `headerRenderer`,
   * `renderer` and `footerRenderer`.
   *
   * Each of those renderer functions provides `root`, `column`, `model` arguments when applicable.
   * Generate DOM content, append it to the `root` element and control the state
   * of the host element by accessing `column`. Before generating new content,
   * users are able to check if there is already content in `root` for reusing it.
   *
   * Renderers are called on initialization of new column cells and each time the
   * related row model is updated. DOM generated during the renderer call can be reused
   * in the next renderer call and will be provided with the `root` argument.
   * On first call it will be empty.
   *
   * #### Example:
   * ```html
   * <vaadin-grid>
   *   <vaadin-grid-column></vaadin-grid-column>
   *   <vaadin-grid-column></vaadin-grid-column>
   *   <vaadin-grid-column></vaadin-grid-column>
   * </vaadin-grid>
   * ```
   * ```js
   * const grid = document.querySelector('vaadin-grid');
   * grid.items = [{'name': 'John', 'surname': 'Lennon', 'role': 'singer'},
   *               {'name': 'Ringo', 'surname': 'Starr', 'role': 'drums'}];
   *
   * const columns = grid.querySelectorAll('vaadin-grid-column');
   *
   * columns[0].headerRenderer = function(root) {
   *   root.textContent = 'Name';
   * };
   * columns[0].renderer = function(root, column, model) {
   *   root.textContent = model.item.name;
   * };
   *
   * columns[1].headerRenderer = function(root) {
   *   root.textContent = 'Surname';
   * };
   * columns[1].renderer = function(root, column, model) {
   *   root.textContent = model.item.surname;
   * };
   *
   * columns[2].headerRenderer = function(root) {
   *   root.textContent = 'Role';
   * };
   * columns[2].renderer = function(root, column, model) {
   *   root.textContent = model.item.role;
   * };
   * ```
   *
   * The following properties are available in the `model` argument:
   *
   * Property name | Type | Description
   * --------------|------|------------
   * `index`| Number | The index of the item.
   * `item` | String or Object | The item.
   * `level` | Number | Number of the item's tree sublevel, starts from 0.
   * `expanded` | Boolean | True if the item's tree sublevel is expanded.
   * `selected` | Boolean | True if the item is selected.
   * `detailsOpened` | Boolean | True if the item's row details are open.
   *
   * The following helper elements can be used for further customization:
   * - [`<vaadin-grid-column-group>`](#/elements/vaadin-grid-column-group)
   * - [`<vaadin-grid-filter>`](#/elements/vaadin-grid-filter)
   * - [`<vaadin-grid-sorter>`](#/elements/vaadin-grid-sorter)
   * - [`<vaadin-grid-selection-column>`](#/elements/vaadin-grid-selection-column)
   * - [`<vaadin-grid-tree-toggle>`](#/elements/vaadin-grid-tree-toggle)
   *
   * __Note that the helper elements must be explicitly imported.__
   * If you want to import everything at once you can use the `all-imports.html` bundle.
   *
   * ### Lazy Loading with Function Data Provider
   *
   * In addition to assigning an array to the items property, you can alternatively
   * provide the `<vaadin-grid>` data through the
   * [`dataProvider`](#/elements/vaadin-grid#property-dataProvider) function property.
   * The `<vaadin-grid>` calls this function lazily, only when it needs more data
   * to be displayed.
   *
   * See the [`dataProvider`](#/elements/vaadin-grid#property-dataProvider) in
   * the API reference below for the detailed data provider arguments description,
   * and the “Assigning Data” page in the demos.
   *
   * __Note that expanding the tree grid's item will trigger a call to the `dataProvider`.__
   *
   * __Also, note that when using function data providers, the total number of items
   * needs to be set manually. The total number of items can be returned
   * in the second argument of the data provider callback:__
   *
   * ```javascript
   * grid.dataProvider = ({page, pageSize}, callback) => {
   *   // page: the requested page index
   *   // pageSize: number of items on one page
   *   const url = `https://api.example/data?page=${page}&per_page=${pageSize}`;
   *
   *   fetch(url)
   *     .then((res) => res.json())
   *     .then(({ employees, totalSize }) => {
   *       callback(employees, totalSize);
   *     });
   * };
   * ```
   *
   * __Alternatively, you can use the `size` property to set the total number of items:__
   *
   * ```javascript
   * grid.size = 200; // The total number of items
   * grid.dataProvider = ({page, pageSize}, callback) => {
   *   const url = `https://api.example/data?page=${page}&per_page=${pageSize}`;
   *
   *   fetch(url)
   *     .then((res) => res.json())
   *     .then((resJson) => callback(resJson.employees));
   * };
   * ```
   *
   * ### Styling
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name | Description
   * ----------------|----------------
   * `row` | Row in the internal table
   * `cell` | Cell in the internal table
   * `header-cell` | Header cell in the internal table
   * `body-cell` | Body cell in the internal table
   * `footer-cell` | Footer cell in the internal table
   * `details-cell` | Row details cell in the internal table
   * `resize-handle` | Handle for resizing the columns
   * `reorder-ghost` | Ghost element of the header cell being dragged
   *
   * The following state attributes are available for styling:
   *
   * Attribute    | Description | Part name
   * -------------|-------------|------------
   * `loading` | Set when the grid is loading data from data provider | :host
   * `interacting` | Keyboard navigation in interaction mode | :host
   * `navigating` | Keyboard navigation in navigation mode | :host
   * `overflow` | Set when rows are overflowing the grid viewport. Possible values: `top`, `bottom`, `left`, `right` | :host
   * `reordering` | Set when the grid's columns are being reordered | :host
   * `dragover` | Set when the grid (not a specific row) is dragged over | :host
   * `dragging-rows` : Set when grid rows are dragged  | :host
   * `reorder-status` | Reflects the status of a cell while columns are being reordered | cell
   * `frozen` | Frozen cell | cell
   * `last-frozen` | Last frozen cell | cell
   * `first-column` | First visible cell on a row | cell
   * `last-column` | Last visible cell on a row | cell
   * `selected` | Selected row | row
   * `expanded` | Expanded row | row
   * `details-opened` | Row with details open | row
   * `loading` | Row that is waiting for data from data provider | row
   * `odd` | Odd row | row
   * `first` | The first body row | row
   * `last` | The last body row | row
   * `dragstart` | Set for one frame when drag of a row is starting. The value is a number when multiple rows are dragged | row
   * `dragover` | Set when the row is dragged over | row
   * `drag-disabled` | Set to a row that isn't available for dragging | row
   * `drop-disabled` | Set to a row that can't be dropped on top of | row
   *
   * See [Styling Components](https://vaadin.com/docs/latest/ds/customization/styling-components) documentation.
   *
   * @fires {CustomEvent} active-item-changed - Fired when the `activeItem` property changes.
   * @fires {CustomEvent} cell-activate - Fired when the cell is activated with click or keyboard.
   * @fires {CustomEvent} cell-focus - Fired when a cell is focused with click or keyboard navigation.
   * @fires {CustomEvent} column-reorder - Fired when the columns in the grid are reordered.
   * @fires {CustomEvent} column-resize - Fired when the grid column resize is finished.
   * @fires {CustomEvent} expanded-items-changed - Fired when the `expandedItems` property changes.
   * @fires {CustomEvent} grid-dragstart - Fired when starting to drag grid rows.
   * @fires {CustomEvent} grid-dragend - Fired when the dragging of the rows ends.
   * @fires {CustomEvent} grid-drop - Fired when a drop occurs on top of the grid.
   * @fires {CustomEvent} loading-changed - Fired when the `loading` property changes.
   * @fires {CustomEvent} selected-items-changed - Fired when the `selectedItems` property changes.
   *
   * @extends HTMLElement
   * @mixes ElementMixin
   * @mixes ThemableMixin
   * @mixes A11yMixin
   * @mixes ActiveItemMixin
   * @mixes ArrayDataProviderMixin
   * @mixes ColumnResizingMixin
   * @mixes DataProviderMixin
   * @mixes DynamicColumnsMixin
   * @mixes FilterMixin
   * @mixes RowDetailsMixin
   * @mixes ScrollMixin
   * @mixes SelectionMixin
   * @mixes SortMixin
   * @mixes KeyboardNavigationMixin
   * @mixes ColumnReorderingMixin
   * @mixes EventContextMixin
   * @mixes StylingMixin
   * @mixes DragAndDropMixin
   */
  var Grid = /*#__PURE__*/function (_ElementMixin) {
    babelHelpers.inherits(Grid, _ElementMixin);

    var _super = _createSuper(Grid);

    function Grid() {
      var _this;

      babelHelpers.classCallCheck(this, Grid);
      _this = _super.call(this);

      _this.addEventListener('animationend', _this._onAnimationEnd);

      return _this;
    }
    /** @protected */


    babelHelpers.createClass(Grid, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(Grid.prototype), "connectedCallback", this).call(this);
        this.isAttached = true;
        this.recalculateColumnWidths();
      }
      /** @protected */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(Grid.prototype), "disconnectedCallback", this).call(this);
        this.isAttached = false;
      }
      /** @private */

    }, {
      key: "__getFirstVisibleItem",
      value: function __getFirstVisibleItem() {
        var _this2 = this;

        return this._getVisibleRows().find(function (row) {
          return _this2._isInViewport(row);
        });
      }
      /** @private */

    }, {
      key: "_firstVisibleIndex",
      get: function get() {
        var firstVisibleItem = this.__getFirstVisibleItem();

        return firstVisibleItem ? firstVisibleItem.index : undefined;
      }
      /** @private */

    }, {
      key: "__getLastVisibleItem",
      value: function __getLastVisibleItem() {
        var _this3 = this;

        return this._getVisibleRows().reverse().find(function (row) {
          return _this3._isInViewport(row);
        });
      }
      /** @private */

    }, {
      key: "_lastVisibleIndex",
      get: function get() {
        var lastVisibleItem = this.__getLastVisibleItem();

        return lastVisibleItem ? lastVisibleItem.index : undefined;
      }
      /** @private */

    }, {
      key: "_isInViewport",
      value: function _isInViewport(item) {
        var scrollTargetRect = this.$.table.getBoundingClientRect();
        var itemRect = item.getBoundingClientRect();
        var headerHeight = this.$.header.getBoundingClientRect().height;
        var footerHeight = this.$.footer.getBoundingClientRect().height;
        return itemRect.bottom > scrollTargetRect.top + headerHeight && itemRect.top < scrollTargetRect.bottom - footerHeight;
      }
      /** @private */

    }, {
      key: "_getVisibleRows",
      value: function _getVisibleRows() {
        return Array.from(this.$.items.children).filter(function (item) {
          return !item.hidden;
        }).sort(function (a, b) {
          return a.index - b.index;
        });
      }
      /** @protected */

    }, {
      key: "ready",
      value: function ready() {
        var _this4 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(Grid.prototype), "ready", this).call(this);
        this.__virtualizer = new _virtualizer.Virtualizer({
          createElements: this._createScrollerRows.bind(this),
          updateElement: this._updateScrollerItem.bind(this),
          scrollContainer: this.$.items,
          scrollTarget: this.$.table,
          reorderElements: true
        });
        new ResizeObserver(function () {
          return setTimeout(function () {
            return _this4.__updateFooterPositioning();
          });
        }).observe(this.$.footer);
        (0, _templates.processTemplates)(this);
      }
      /**
       * @param {string} name
       * @param {?string} oldValue
       * @param {?string} newValue
       * @protected
       */

    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, oldValue, newValue) {
        babelHelpers.get(babelHelpers.getPrototypeOf(Grid.prototype), "attributeChangedCallback", this).call(this, name, oldValue, newValue);

        if (name === 'dir') {
          this.__isRTL = newValue === 'rtl';
        }
      }
      /** @private */

    }, {
      key: "__getBodyCellCoordinates",
      value: function __getBodyCellCoordinates(cell) {
        if (this.$.items.contains(cell) && cell.localName === 'td') {
          return {
            item: cell.parentElement._item,
            column: cell._column
          };
        }
      }
      /** @private */

    }, {
      key: "__focusBodyCell",
      value: function __focusBodyCell(_ref) {
        var item = _ref.item,
            column = _ref.column;

        var row = this._getVisibleRows().find(function (row) {
          return row._item === item;
        });

        var cell = row && babelHelpers.toConsumableArray(row.children).find(function (cell) {
          return cell._column === column;
        });
        cell && cell.focus();
      }
      /** @private */

    }, {
      key: "_effectiveSizeChanged",
      value: function _effectiveSizeChanged(effectiveSize, virtualizer, hasData, columnTree) {
        if (virtualizer && hasData && columnTree) {
          // Changing the virtualizer size may result in the row with focus getting hidden
          var cell = this.shadowRoot.activeElement;

          var cellCoordinates = this.__getBodyCellCoordinates(cell);

          virtualizer.size = effectiveSize;
          virtualizer.update();
          virtualizer.flush(); // If the focused cell's parent row got hidden by the size change, focus the corresponding new cell

          cellCoordinates && cell.parentElement.hidden && this.__focusBodyCell(cellCoordinates); // Make sure the body has a tabbable element

          this._resetKeyboardNavigation();
        }
      }
      /** @private */

    }, {
      key: "__hasRowsWithClientHeight",
      value: function __hasRowsWithClientHeight() {
        return !!Array.from(this.$.items.children).filter(function (row) {
          return row.clientHeight;
        }).length;
      }
      /** @protected */

    }, {
      key: "__itemsReceived",
      value: function __itemsReceived() {
        if (this._recalculateColumnWidthOnceLoadingFinished && !this._cache.isLoading() && this.__hasRowsWithClientHeight()) {
          this._recalculateColumnWidthOnceLoadingFinished = false;
          this.recalculateColumnWidths();
        }
      }
      /** @private */

    }, {
      key: "__getIntrinsicWidth",
      value: function __getIntrinsicWidth(col) {
        var _this5 = this;

        var initialWidth = col.width;
        var initialFlexGrow = col.flexGrow;
        col.width = 'auto';
        col.flexGrow = 0; // Note: _allCells only contains cells which are currently rendered in DOM

        var width = col._allCells.filter(function (cell) {
          // Exclude body cells that are out of the visible viewport
          return !_this5.$.items.contains(cell) || _this5._isInViewport(cell.parentElement);
        }).reduce(function (width, cell) {
          // Add 1px buffer to the offset width to avoid too narrow columns (sub-pixel rendering)
          return Math.max(width, cell.offsetWidth + 1);
        }, 0);

        col.flexGrow = initialFlexGrow;
        col.width = initialWidth;
        return width;
      }
      /** @private */

    }, {
      key: "__getDistributedWidth",
      value: function __getDistributedWidth(col, innerColumn) {
        var _this6 = this;

        if (col == null || col === this) return 0;
        var columnWidth = Math.max(this.__getIntrinsicWidth(col), this.__getDistributedWidth(col.parentElement, col)); // we're processing a regular grid-column and not a grid-column-group

        if (!innerColumn) {
          return columnWidth;
        } // At the end, the width of each vaadin-grid-column-group is determined by the sum of the width of its children.
        // Here we determine how much space the vaadin-grid-column-group actually needs to render properly and then we distribute that space
        // to its children, so when we actually do the summation it will be rendered properly.
        // Check out vaadin-grid-column-group:_updateFlexAndWidth


        var columnGroup = col;
        var columnGroupWidth = columnWidth;

        var sumOfWidthOfAllChildColumns = columnGroup._visibleChildColumns.map(function (col) {
          return _this6.__getIntrinsicWidth(col);
        }).reduce(function (sum, curr) {
          return sum + curr;
        }, 0);

        var extraNecessarySpaceForGridColumnGroup = Math.max(0, columnGroupWidth - sumOfWidthOfAllChildColumns); // The distribution of the extra necessary space is done according to the intrinsic width of each child column.
        // Lets say we need 100 pixels of extra space for the grid-column-group to render properly
        // it has two grid-column children, |100px|300px| in total 400px
        // the first column gets 25px of the additional space (100/400)*100 = 25
        // the second column gets the 75px of the additional space (300/400)*100 = 75

        var proportionOfExtraSpace = this.__getIntrinsicWidth(innerColumn) / sumOfWidthOfAllChildColumns;
        var shareOfInnerColumnFromNecessaryExtraSpace = proportionOfExtraSpace * extraNecessarySpaceForGridColumnGroup;
        return this.__getIntrinsicWidth(innerColumn) + shareOfInnerColumnFromNecessaryExtraSpace;
      }
      /**
       * @param {!Array<!GridColumn>} cols the columns to auto size based on their content width
       * @private
       */

    }, {
      key: "_recalculateColumnWidths",
      value: function _recalculateColumnWidths(cols) {
        var _this7 = this;

        // Flush to make sure DOM is up-to-date when measuring the column widths
        this.__virtualizer.flush();

        cols.forEach(function (col) {
          col.width = "".concat(_this7.__getDistributedWidth(col), "px");
        });
      }
      /**
       * Updates the `width` of all columns which have `autoWidth` set to `true`.
       */

    }, {
      key: "recalculateColumnWidths",
      value: function recalculateColumnWidths() {
        if (!this._columnTree) {
          return; // No columns
        }

        if (this._cache.isLoading()) {
          this._recalculateColumnWidthOnceLoadingFinished = true;
        } else {
          var cols = this._getColumns().filter(function (col) {
            return !col.hidden && col.autoWidth;
          });

          this._recalculateColumnWidths(cols);
        }
      }
      /** @private */

    }, {
      key: "_createScrollerRows",
      value: function _createScrollerRows(count) {
        var _this8 = this;

        var rows = [];

        for (var i = 0; i < count; i++) {
          var row = document.createElement('tr');
          row.setAttribute('part', 'row');
          row.setAttribute('role', 'row');
          row.setAttribute('tabindex', '-1');

          if (this._columnTree) {
            this._updateRow(row, this._columnTree[this._columnTree.length - 1], 'body', false, true);
          }

          rows.push(row);
        }

        if (this._columnTree) {
          this._columnTree[this._columnTree.length - 1].forEach(function (c) {
            return c.isConnected && c.notifyPath && c.notifyPath('_cells.*', c._cells);
          });
        }

        (0, _renderStatus.beforeNextRender)(this, function () {
          _this8._updateFirstAndLastColumn();

          _this8._resetKeyboardNavigation();

          _this8._afterScroll();

          _this8.__itemsReceived();
        });
        return rows;
      }
      /** @private */

    }, {
      key: "_createCell",
      value: function _createCell(tagName) {
        var _this9 = this;

        var contentId = this._contentIndex = this._contentIndex + 1 || 0;
        var slotName = 'vaadin-grid-cell-content-' + contentId;
        var cellContent = document.createElement('vaadin-grid-cell-content');
        cellContent.setAttribute('slot', slotName);
        var cell = document.createElement(tagName);
        cell.id = slotName.replace('-content-', '-');
        cell.setAttribute('tabindex', '-1');
        cell.setAttribute('role', tagName === 'td' ? 'gridcell' : 'columnheader');
        var slot = document.createElement('slot');
        slot.setAttribute('name', slotName);
        cell.appendChild(slot);
        cell._content = cellContent; // With native Shadow DOM, mousedown on slotted element does not focus
        // focusable slot wrapper, that is why cells are not focused with
        // mousedown. Workaround: listen for mousedown and focus manually.

        cellContent.addEventListener('mousedown', function () {
          if (window.chrome) {
            // Chrome bug: focusing before mouseup prevents text selection, see http://crbug.com/771903
            var mouseUpListener = function mouseUpListener() {
              if (!cellContent.contains(_this9.getRootNode().activeElement)) {
                cell.focus();
              } // If focus is in the cell content — respect it, do not change.


              document.removeEventListener('mouseup', mouseUpListener, true);
            };

            document.addEventListener('mouseup', mouseUpListener, true);
          } else {
            // Focus on mouseup, on the other hand, removes selection on Safari.
            // Watch out sync focus removal issue, only async focus works here.
            setTimeout(function () {
              if (!cellContent.contains(_this9.getRootNode().activeElement)) {
                cell.focus();
              }
            });
          }
        });
        return cell;
      }
      /**
       * @param {!HTMLTableRowElement} row
       * @param {!Array<!GridColumn>} columns
       * @param {?string} section
       * @param {boolean} isColumnRow
       * @param {boolean} noNotify
       * @protected
       */

    }, {
      key: "_updateRow",
      value: function _updateRow(row, columns, section, isColumnRow, noNotify) {
        var _this10 = this;

        section = section || 'body';
        var contentsFragment = document.createDocumentFragment();
        Array.from(row.children).forEach(function (cell) {
          return cell._vacant = true;
        });
        row.innerHTML = '';
        columns.filter(function (column) {
          return !column.hidden;
        }).forEach(function (column, index, cols) {
          var cell;

          if (section === 'body') {
            // Body
            column._cells = column._cells || [];
            cell = column._cells.filter(function (cell) {
              return cell._vacant;
            })[0];

            if (!cell) {
              cell = _this10._createCell('td');

              column._cells.push(cell);
            }

            cell.setAttribute('part', 'cell body-cell');
            row.appendChild(cell);

            if (index === cols.length - 1 && _this10.rowDetailsRenderer) {
              // Add details cell as last cell to body rows
              _this10._detailsCells = _this10._detailsCells || [];

              var detailsCell = _this10._detailsCells.filter(function (cell) {
                return cell._vacant;
              })[0] || _this10._createCell('td');

              if (_this10._detailsCells.indexOf(detailsCell) === -1) {
                _this10._detailsCells.push(detailsCell);
              }

              if (!detailsCell._content.parentElement) {
                contentsFragment.appendChild(detailsCell._content);
              }

              _this10._configureDetailsCell(detailsCell);

              row.appendChild(detailsCell);

              _this10._a11ySetRowDetailsCell(row, detailsCell);

              detailsCell._vacant = false;
            }

            if (column.notifyPath && !noNotify) {
              column.notifyPath('_cells.*', column._cells);
            }
          } else {
            // Header & footer
            var tagName = section === 'header' ? 'th' : 'td';

            if (isColumnRow || column.localName === 'vaadin-grid-column-group') {
              cell = column["_".concat(section, "Cell")] || _this10._createCell(tagName);
              cell._column = column;
              row.appendChild(cell);
              column["_".concat(section, "Cell")] = cell;
            } else {
              column._emptyCells = column._emptyCells || [];
              cell = column._emptyCells.filter(function (cell) {
                return cell._vacant;
              })[0] || _this10._createCell(tagName);
              cell._column = column;
              row.appendChild(cell);

              if (column._emptyCells.indexOf(cell) === -1) {
                column._emptyCells.push(cell);
              }
            }

            cell.setAttribute('part', "cell ".concat(section, "-cell"));

            _this10.__updateHeaderFooterRowVisibility(row);
          }

          if (!cell._content.parentElement) {
            contentsFragment.appendChild(cell._content);
          }

          cell._vacant = false;
          cell._column = column;
        }); // Might be empty if only cache was used

        this.appendChild(contentsFragment);

        this._frozenCellsChanged();

        this._updateFirstAndLastColumnForRow(row);
      }
      /**
       * @param {HTMLTableRowElement} row
       * @protected
       */

    }, {
      key: "__updateHeaderFooterRowVisibility",
      value: function __updateHeaderFooterRowVisibility(row) {
        var _this11 = this;

        if (!row) {
          return;
        }

        var visibleRowCells = Array.from(row.children).filter(function (cell) {
          var column = cell._column;

          if (column._emptyCells && column._emptyCells.indexOf(cell) > -1) {
            // The cell is an "empty cell"  -> doesn't block hiding the row
            return false;
          }

          if (row.parentElement === _this11.$.header) {
            if (column.headerRenderer) {
              // The cell is the header cell of a column that has a header renderer
              // -> row should be visible
              return true;
            }

            if (column.header === null) {
              // The column header is explicilty set to null -> doesn't block hiding the row
              return false;
            }

            if (column.path || column.header !== undefined) {
              // The column has an explicit non-null header or a path that generates a header
              // -> row should be visible
              return true;
            }
          } else {
            if (column.footerRenderer) {
              // The cell is the footer cell of a column that has a footer renderer
              // -> row should be visible
              return true;
            }
          }
        });

        if (row.hidden !== !visibleRowCells.length) {
          row.hidden = !visibleRowCells.length;
        } // Make sure the section has a tabbable element


        this._resetKeyboardNavigation();
      }
      /** @private */

    }, {
      key: "_updateScrollerItem",
      value: function _updateScrollerItem(row, index) {
        this._preventScrollerRotatingCellFocus(row, index);

        if (!this._columnTree) {
          return;
        }

        row.toggleAttribute('first', index === 0);
        row.toggleAttribute('last', index === this._effectiveSize - 1);
        row.toggleAttribute('odd', index % 2);

        this._a11yUpdateRowRowindex(row, index);

        this._getItem(index, row);
      }
      /** @private */

    }, {
      key: "_columnTreeChanged",
      value: function _columnTreeChanged(columnTree) {
        this._renderColumnTree(columnTree);

        this.recalculateColumnWidths();
      }
      /**
       * @param {!Array<!GridColumn>} columnTree
       * @protected
       */

    }, {
      key: "_renderColumnTree",
      value: function _renderColumnTree(columnTree) {
        var _this12 = this;

        Array.from(this.$.items.children).forEach(function (row) {
          return _this12._updateRow(row, columnTree[columnTree.length - 1], null, false, true);
        });

        while (this.$.header.children.length < columnTree.length) {
          var headerRow = document.createElement('tr');
          headerRow.setAttribute('part', 'row');
          headerRow.setAttribute('role', 'row');
          headerRow.setAttribute('tabindex', '-1');
          this.$.header.appendChild(headerRow);
          var footerRow = document.createElement('tr');
          footerRow.setAttribute('part', 'row');
          footerRow.setAttribute('role', 'row');
          footerRow.setAttribute('tabindex', '-1');
          this.$.footer.appendChild(footerRow);
        }

        while (this.$.header.children.length > columnTree.length) {
          this.$.header.removeChild(this.$.header.firstElementChild);
          this.$.footer.removeChild(this.$.footer.firstElementChild);
        }

        Array.from(this.$.header.children).forEach(function (headerRow, index) {
          return _this12._updateRow(headerRow, columnTree[index], 'header', index === columnTree.length - 1);
        });
        Array.from(this.$.footer.children).forEach(function (footerRow, index) {
          return _this12._updateRow(footerRow, columnTree[columnTree.length - 1 - index], 'footer', index === 0);
        }); // Sizer rows

        this._updateRow(this.$.sizer, columnTree[columnTree.length - 1]);

        this._resizeHandler();

        this._frozenCellsChanged();

        this._updateFirstAndLastColumn();

        this._resetKeyboardNavigation();

        this._a11yUpdateHeaderRows();

        this._a11yUpdateFooterRows();

        this.__updateFooterPositioning();

        this.generateCellClassNames();
      }
    }, {
      key: "__updateFooterPositioning",
      value: function __updateFooterPositioning() {
        if (this._firefox) {
          // Sticky (or translated) footer in a flexbox host doesn't get included in
          // the scroll height calculation on FF. This is a workaround for the issue.
          this.$.items.style.paddingBottom = 0;

          if (!this.allRowsVisible) {
            this.$.items.style.paddingBottom = "".concat(this.$.footer.offsetHeight, "px");
          }
        }
      }
      /**
       * @param {!HTMLElement} row
       * @param {GridItem} item
       * @protected
       */

    }, {
      key: "_updateItem",
      value: function _updateItem(row, item) {
        var _this13 = this;

        row._item = item;

        var model = this.__getRowModel(row);

        this._toggleDetailsCell(row, model.detailsOpened);

        this._a11yUpdateRowLevel(row, model.level);

        this._a11yUpdateRowSelected(row, model.selected);

        row.toggleAttribute('expanded', model.expanded);
        row.toggleAttribute('selected', model.selected);
        row.toggleAttribute('details-opened', model.detailsOpened);

        this._generateCellClassNames(row, model);

        this._filterDragAndDrop(row, model);

        Array.from(row.children).forEach(function (cell) {
          if (cell._renderer) {
            var owner = cell._column || _this13;

            cell._renderer.call(owner, cell._content, owner, model);
          }
        });

        this._updateDetailsCellHeight(row);

        this._a11yUpdateRowExpanded(row, model.expanded);
      }
      /** @private */

    }, {
      key: "_resizeHandler",
      value: function _resizeHandler() {
        this._updateDetailsCellHeights();

        this.__updateFooterPositioning();
      }
      /** @private */

    }, {
      key: "_onAnimationEnd",
      value: function _onAnimationEnd(e) {
        var _this14 = this;

        // ShadyCSS applies scoping suffixes to animation names
        if (e.animationName.indexOf('vaadin-grid-appear') === 0) {
          e.stopPropagation();

          this.__itemsReceived();

          requestAnimationFrame(function () {
            _this14.__scrollToPendingIndex(); // This needs to be set programmatically in order to avoid an iOS 10 bug (disappearing grid)


            _this14.$.table.style.webkitOverflowScrolling = 'touch';
          });
        }
      }
      /**
       * @param {!HTMLTableRowElement} row
       * @return {!GridItemModel}
       * @protected
       */

    }, {
      key: "__getRowModel",
      value: function __getRowModel(row) {
        return {
          index: row.index,
          item: row._item,
          level: this._getIndexLevel(row.index),
          expanded: this._isExpanded(row._item),
          selected: this._isSelected(row._item),
          detailsOpened: !!this.rowDetailsRenderer && this._isDetailsOpened(row._item)
        };
      }
      /**
       * Requests an update for the content of cells.
       *
       * While performing the update, the following renderers are invoked:
       * - `Grid.rowDetailsRenderer`
       * - `GridColumn.renderer`
       * - `GridColumn.headerRenderer`
       * - `GridColumn.footerRenderer`
       *
       * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
       */

    }, {
      key: "requestContentUpdate",
      value: function requestContentUpdate() {
        if (this._columnTree) {
          // header and footer renderers
          this._columnTree.forEach(function (level) {
            level.forEach(function (column) {
              column._renderHeaderAndFooter();
            });
          }); // body and row details renderers


          this.__updateVisibleRows();
        }
      }
      /** @protected */

    }, {
      key: "__updateVisibleRows",
      value: function __updateVisibleRows(start, end) {
        this.__virtualizer && this.__virtualizer.update(start, end);
      }
      /**
       * Updates the computed metrics and positioning of internal grid parts
       * (row/details cell positioning etc). Needs to be invoked whenever the sizing of grid
       * content changes asynchronously to ensure consistent appearance (e.g. when a
       * contained image whose bounds aren't known beforehand finishes loading).
       *
       * @deprecated Since Vaadin 22, `notifyResize()` is deprecated. The component uses a
       * ResizeObserver internally and doesn't need to be explicitly notified of resizes.
       */

    }, {
      key: "notifyResize",
      value: function notifyResize() {
        console.warn("WARNING: Since Vaadin 22, notifyResize() is deprecated. The component uses a ResizeObserver internally and doesn't need to be explicitly notified of resizes.");
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_0228b3a0942711ec84e88734a30f0661 || (_templateObject_0228b3a0942711ec84e88734a30f0661 = babelHelpers.taggedTemplateLiteral(["\n      <div\n        id=\"scroller\"\n        safari$=\"[[_safari]]\"\n        ios$=\"[[_ios]]\"\n        loading$=\"[[loading]]\"\n        column-reordering-allowed$=\"[[columnReorderingAllowed]]\"\n      >\n        <table id=\"table\" role=\"treegrid\" aria-multiselectable=\"true\" tabindex=\"0\">\n          <caption id=\"sizer\" part=\"row\"></caption>\n          <thead id=\"header\" role=\"rowgroup\"></thead>\n          <tbody id=\"items\" role=\"rowgroup\"></tbody>\n          <tfoot id=\"footer\" role=\"rowgroup\"></tfoot>\n        </table>\n\n        <div part=\"reorder-ghost\"></div>\n      </div>\n\n      <div id=\"focusexit\" tabindex=\"0\"></div>\n    "])));
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-grid';
      }
    }, {
      key: "observers",
      get: function get() {
        return ['_columnTreeChanged(_columnTree, _columnTree.*)', '_effectiveSizeChanged(_effectiveSize, __virtualizer, _hasData, _columnTree)'];
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /** @private */
          _safari: {
            type: Boolean,
            value: _browserUtils.isSafari
          },

          /** @private */
          _ios: {
            type: Boolean,
            value: _browserUtils.isIOS
          },

          /** @private */
          _firefox: {
            type: Boolean,
            value: _browserUtils.isFirefox
          },

          /** @private */
          _android: {
            type: Boolean,
            value: _browserUtils.isAndroid
          },

          /** @private */
          _touchDevice: {
            type: Boolean,
            value: _browserUtils.isTouch
          },

          /**
           * If true, the grid's height is defined by its rows.
           *
           * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.
           * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.
           * @attr {boolean} all-rows-visible
           * @type {boolean}
           */
          allRowsVisible: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },

          /** @private */
          _recalculateColumnWidthOnceLoadingFinished: {
            type: Boolean,
            value: true
          },

          /** @private */
          isAttached: {
            value: false
          },

          /**
           * An internal property that is mainly used by `vaadin-template-renderer`
           * to identify grid elements.
           *
           * @private
           */
          __gridElement: {
            type: Boolean,
            value: true
          }
        };
      }
    }]);
    return Grid;
  }((0, _elementMixin.ElementMixin)((0, _vaadinThemableMixin.ThemableMixin)((0, _vaadinGridDataProviderMixin.DataProviderMixin)((0, _vaadinGridArrayDataProviderMixin.ArrayDataProviderMixin)((0, _vaadinGridDynamicColumnsMixin.DynamicColumnsMixin)((0, _vaadinGridActiveItemMixin.ActiveItemMixin)((0, _vaadinGridScrollMixin.ScrollMixin)((0, _vaadinGridSelectionMixin.SelectionMixin)((0, _vaadinGridSortMixin.SortMixin)((0, _vaadinGridRowDetailsMixin.RowDetailsMixin)((0, _vaadinGridKeyboardNavigationMixin.KeyboardNavigationMixin)((0, _vaadinGridA11yMixin.A11yMixin)((0, _vaadinGridFilterMixin.FilterMixin)((0, _vaadinGridColumnReorderingMixin.ColumnReorderingMixin)((0, _vaadinGridColumnResizingMixin.ColumnResizingMixin)((0, _vaadinGridEventContextMixin.EventContextMixin)((0, _vaadinGridDragAndDropMixin.DragAndDropMixin)((0, _vaadinGridStylingMixin.StylingMixin)(_polymerElement.PolymerElement)))))))))))))))))));

  _exports.Grid = Grid;
  customElements.define(Grid.is, Grid);
});