define(["exports", "../../../@polymer/polymer/lib/utils/debounce.js", "../../../@polymer/polymer/lib/utils/async.js"], function (_exports, _debounce, _async) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ItemCache = _exports.DataProviderMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ItemCache = /*#__PURE__*/function () {
    /**
     * @param {!HTMLElement} grid
     * @param {!ItemCache | undefined} parentCache
     * @param {!GridItem | undefined} parentItem
     */
    function ItemCache(grid, parentCache, parentItem) {
      babelHelpers.classCallCheck(this, ItemCache);

      /** @type {!HTMLElement} */
      this.grid = grid;
      /** @type {!ItemCache | undefined} */

      this.parentCache = parentCache;
      /** @type {!GridItem | undefined} */

      this.parentItem = parentItem;
      /** @type {object} */

      this.itemCaches = {};
      /** @type {object} */

      this.items = {};
      /** @type {number} */

      this.effectiveSize = 0;
      /** @type {number} */

      this.size = 0;
      /** @type {object} */

      this.pendingRequests = {};
    }
    /**
     * @return {boolean}
     */


    babelHelpers.createClass(ItemCache, [{
      key: "isLoading",
      value: function isLoading() {
        var _this = this;

        return Boolean(Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(function (index) {
          return _this.itemCaches[index].isLoading();
        })[0]);
      }
      /**
       * @param {number} index
       * @return {!GridItem | undefined}
       */

    }, {
      key: "getItemForIndex",
      value: function getItemForIndex(index) {
        var _this$getCacheAndInde = this.getCacheAndIndex(index),
            cache = _this$getCacheAndInde.cache,
            scaledIndex = _this$getCacheAndInde.scaledIndex;

        return cache.items[scaledIndex];
      }
    }, {
      key: "updateSize",
      value: function updateSize() {
        var _this2 = this;

        this.effectiveSize = !this.parentItem || this.grid._isExpanded(this.parentItem) ? this.size + Object.keys(this.itemCaches).reduce(function (prev, curr) {
          var subCache = _this2.itemCaches[curr];
          subCache.updateSize();
          return prev + subCache.effectiveSize;
        }, 0) : 0;
      }
      /**
       * @param {number} scaledIndex
       */

    }, {
      key: "ensureSubCacheForScaledIndex",
      value: function ensureSubCacheForScaledIndex(scaledIndex) {
        if (!this.itemCaches[scaledIndex]) {
          var subCache = new ItemCache(this.grid, this, this.items[scaledIndex]);
          this.itemCaches[scaledIndex] = subCache;

          this.grid._loadPage(0, subCache);
        }
      }
      /**
       * @param {number} index
       * @return {{cache: !ItemCache, scaledIndex: number}}
       */

    }, {
      key: "getCacheAndIndex",
      value: function getCacheAndIndex(index) {
        var thisLevelIndex = index;
        var keys = Object.keys(this.itemCaches);

        for (var i = 0; i < keys.length; i++) {
          var expandedIndex = Number(keys[i]);
          var subCache = this.itemCaches[expandedIndex];

          if (thisLevelIndex <= expandedIndex) {
            return {
              cache: this,
              scaledIndex: thisLevelIndex
            };
          } else if (thisLevelIndex <= expandedIndex + subCache.effectiveSize) {
            return subCache.getCacheAndIndex(thisLevelIndex - expandedIndex - 1);
          }

          thisLevelIndex -= subCache.effectiveSize;
        }

        return {
          cache: this,
          scaledIndex: thisLevelIndex
        };
      }
    }]);
    return ItemCache;
  }();
  /**
   * @polymerMixin
   */


  _exports.ItemCache = ItemCache;

  var DataProviderMixin = function DataProviderMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(DataProviderMixin, _superClass);

      var _super = _createSuper(DataProviderMixin);

      function DataProviderMixin() {
        babelHelpers.classCallCheck(this, DataProviderMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(DataProviderMixin, [{
        key: "_sizeChanged",
        value:
        /** @private */
        function _sizeChanged(size) {
          var delta = size - this._cache.size;
          this._cache.size += delta;
          this._cache.effectiveSize += delta;
          this._effectiveSize = this._cache.effectiveSize;

          this._increasePoolIfNeeded(0);

          this._debounceIncreasePool && this._debounceIncreasePool.flush();
        }
        /**
         * @param {number} index
         * @param {HTMLElement} el
         * @protected
         */

      }, {
        key: "_getItem",
        value: function _getItem(index, el) {
          if (index >= this._effectiveSize) {
            return;
          }

          el.index = index;

          var _this$_cache$getCache = this._cache.getCacheAndIndex(index),
              cache = _this$_cache$getCache.cache,
              scaledIndex = _this$_cache$getCache.scaledIndex;

          var item = cache.items[scaledIndex];

          if (item) {
            this._toggleAttribute('loading', false, el);

            this._updateItem(el, item);

            if (this._isExpanded(item)) {
              cache.ensureSubCacheForScaledIndex(scaledIndex);
            }
          } else {
            this._toggleAttribute('loading', true, el);

            this._loadPage(this._getPageForIndex(scaledIndex), cache);
          }
        }
        /** @private */

      }, {
        key: "_expandedInstanceChangedCallback",
        value: function _expandedInstanceChangedCallback(inst, value) {
          if (inst.item === undefined) {
            return;
          }

          if (value) {
            this.expandItem(inst.item);
          } else {
            this.collapseItem(inst.item);
          }
        }
        /**
         * Returns a value that identifies the item. Uses `itemIdPath` if available.
         * Can be customized by overriding.
         * @param {!GridItem} item
         * @return {!GridItem | !unknown}
         */

      }, {
        key: "getItemId",
        value: function getItemId(item) {
          return this.itemIdPath ? this.get(this.itemIdPath, item) : item;
        }
        /**
         * @param {!GridItem} item
         * @return {boolean}
         * @protected
         */

      }, {
        key: "_isExpanded",
        value: function _isExpanded(item) {
          return this.__expandedKeys.has(this.getItemId(item));
        }
        /** @private */

      }, {
        key: "_expandedItemsChanged",
        value: function _expandedItemsChanged(e) {
          this.__cacheExpandedKeys();

          this._cache.updateSize();

          this._effectiveSize = this._cache.effectiveSize;

          this._assignModels();
        }
        /** @private */

      }, {
        key: "_itemIdPathChanged",
        value: function _itemIdPathChanged(e) {
          this.__cacheExpandedKeys();
        }
        /** @private */

      }, {
        key: "__cacheExpandedKeys",
        value: function __cacheExpandedKeys() {
          var _this3 = this;

          if (this.expandedItems) {
            this.__expandedKeys = new Set();
            this.expandedItems.forEach(function (item) {
              _this3.__expandedKeys.add(_this3.getItemId(item));
            });
          }
        }
        /**
         * Expands the given item tree.
         * @param {!GridItem} item
         */

      }, {
        key: "expandItem",
        value: function expandItem(item) {
          if (!this._isExpanded(item)) {
            this.push('expandedItems', item);
          }
        }
        /**
         * Collapses the given item tree.
         * @param {!GridItem} item
         */

      }, {
        key: "collapseItem",
        value: function collapseItem(item) {
          if (this._isExpanded(item)) {
            this.splice('expandedItems', this._getItemIndexInArray(item, this.expandedItems), 1);
          }
        }
        /**
         * @param {number} index
         * @return {number}
         * @protected
         */

      }, {
        key: "_getIndexLevel",
        value: function _getIndexLevel(index) {
          var _this$_cache$getCache2 = this._cache.getCacheAndIndex(index),
              cache = _this$_cache$getCache2.cache;

          var level = 0;

          while (cache.parentCache) {
            cache = cache.parentCache;
            level++;
          }

          return level;
        }
        /**
         * @return {boolean}
         * @protected
         */

      }, {
        key: "_canPopulate",
        value: function _canPopulate() {
          return Boolean(this._hasData && this._columnTree);
        }
        /**
         * @param {number} page
         * @param {ItemCache} cache
         * @protected
         */

      }, {
        key: "_loadPage",
        value: function _loadPage(page, cache) {
          var _this4 = this;

          // make sure same page isn't requested multiple times.
          if (!cache.pendingRequests[page] && this.dataProvider) {
            this._setLoading(true);

            cache.pendingRequests[page] = true;
            var params = {
              page: page,
              pageSize: this.pageSize,
              sortOrders: this._mapSorters(),
              filters: this._mapFilters(),
              parentItem: cache.parentItem
            };
            this._debounceIncreasePool && this._debounceIncreasePool.flush();
            this.dataProvider(params, function (items, size) {
              if (size !== undefined) {
                cache.size = size;
              } else {
                if (params.parentItem) {
                  cache.size = items.length;
                }
              }

              var currentItems = Array.from(_this4.$.items.children).map(function (row) {
                return row._item;
              }); // Populate the cache with new items

              items.forEach(function (item, itemsIndex) {
                var itemIndex = page * _this4.pageSize + itemsIndex;
                cache.items[itemIndex] = item;

                if (_this4._isExpanded(item) && currentItems.indexOf(item) > -1) {
                  // Force synchronous data request for expanded item sub-cache
                  cache.ensureSubCacheForScaledIndex(itemIndex);
                }
              });
              _this4._hasData = true;
              delete cache.pendingRequests[page];
              _this4._debouncerApplyCachedData = _debounce.Debouncer.debounce(_this4._debouncerApplyCachedData, _async.timeOut.after(0), function () {
                _this4._setLoading(false);

                _this4._cache.updateSize();

                _this4._effectiveSize = _this4._cache.effectiveSize;
                Array.from(_this4.$.items.children).filter(function (row) {
                  return !row.hidden;
                }).forEach(function (row) {
                  var cachedItem = _this4._cache.getItemForIndex(row.index);

                  if (cachedItem) {
                    _this4._getItem(row.index, row);
                  }
                });

                _this4._increasePoolIfNeeded(0);

                _this4.__scrollToPendingIndex();
              });

              if (!_this4._cache.isLoading()) {
                _this4._debouncerApplyCachedData.flush();
              }

              _this4.__flushPendingRecalculateColumnWidths();
            });
          }
        }
        /**
         * @param {number} index
         * @return {number}
         * @private
         */

      }, {
        key: "_getPageForIndex",
        value: function _getPageForIndex(index) {
          return Math.floor(index / this.pageSize);
        }
        /**
         * Clears the cached pages and reloads data from dataprovider when needed.
         */

      }, {
        key: "clearCache",
        value: function clearCache() {
          this._cache = new ItemCache(this);
          Array.from(this.$.items.children).forEach(function (row) {
            Array.from(row.children).forEach(function (cell) {
              // Force data system to pick up subproperty changes
              cell._instance && cell._instance._setPendingProperty('item', {}, false);
            });
          });
          this._cache.size = this.size || 0;

          this._cache.updateSize();

          this._hasData = false;

          this._assignModels();

          if (!this._effectiveSize || !this._initialPoolCreated) {
            this._loadPage(0, this._cache);
          }
        }
        /** @private */

      }, {
        key: "_pageSizeChanged",
        value: function _pageSizeChanged(pageSize, oldPageSize) {
          if (oldPageSize !== undefined && pageSize !== oldPageSize) {
            this.clearCache();
          }
        }
        /** @protected */

      }, {
        key: "_checkSize",
        value: function _checkSize() {
          if (this.size === undefined && this._effectiveSize === 0) {
            console.warn('The <vaadin-grid> needs the total number of items' + ' in order to display rows. Set the total number of items' + ' to the `size` property, or provide the total number of items' + ' in the second argument of the `dataProvider`â€™s `callback` call.');
          }
        }
        /** @private */

      }, {
        key: "_dataProviderChanged",
        value: function _dataProviderChanged(dataProvider, oldDataProvider) {
          if (oldDataProvider !== undefined) {
            this.clearCache();
          }

          if (dataProvider && this.items && this.items.length) {
            // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>
            this._scrollToIndex(this._firstVisibleIndex);
          }

          this._ensureFirstPageLoaded();

          this._debouncerCheckSize = _debounce.Debouncer.debounce(this._debouncerCheckSize, _async.timeOut.after(2000), this._checkSize.bind(this));

          this._scrollHandler();
        }
        /** @protected */

      }, {
        key: "_ensureFirstPageLoaded",
        value: function _ensureFirstPageLoaded() {
          if (!this._hasData) {
            // load data before adding rows to make sure they have content when
            // rendered for the first time.
            this._loadPage(0, this._cache);
          }
        }
        /**
         * @param {!GridItem} item1
         * @param {!GridItem} item2
         * @return {boolean}
         * @protected
         */

      }, {
        key: "_itemsEqual",
        value: function _itemsEqual(item1, item2) {
          return this.getItemId(item1) === this.getItemId(item2);
        }
        /**
         * @param {!GridItem} item
         * @param {!Array<!GridItem>} array
         * @return {number}
         * @protected
         */

      }, {
        key: "_getItemIndexInArray",
        value: function _getItemIndexInArray(item, array) {
          var _this5 = this;

          var result = -1;
          array.forEach(function (i, idx) {
            if (_this5._itemsEqual(i, item)) {
              result = idx;
            }
          });
          return result;
        }
      }, {
        key: "scrollToIndex",
        value: function scrollToIndex(index) {
          babelHelpers.get(babelHelpers.getPrototypeOf(DataProviderMixin.prototype), "scrollToIndex", this).call(this, index);

          if (!isNaN(index) && (this._cache.isLoading() || !this.clientHeight)) {
            this.__pendingScrollToIndex = index;
          }
        }
      }, {
        key: "__scrollToPendingIndex",
        value: function __scrollToPendingIndex() {
          if (this.__pendingScrollToIndex && this.$.items.children.length) {
            var index = this.__pendingScrollToIndex;
            delete this.__pendingScrollToIndex;

            if (this._debounceIncreasePool) {
              this._debounceIncreasePool.flush();
            }

            this.scrollToIndex(index);
          }
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * Number of items fetched at a time from the dataprovider.
             * @attr {number} page-size
             * @type {number}
             */
            pageSize: {
              type: Number,
              value: 50,
              observer: '_pageSizeChanged'
            },

            /**
             * Function that provides items lazily. Receives arguments `params`, `callback`
             *
             * `params.page` Requested page index
             *
             * `params.pageSize` Current page size
             *
             * `params.filters` Currently applied filters
             *
             * `params.sortOrders` Currently applied sorting orders
             *
             * `params.parentItem` When tree is used, and sublevel items
             * are requested, reference to parent item of the requested sublevel.
             * Otherwise `undefined`.
             *
             * `callback(items, size)` Callback function with arguments:
             *   - `items` Current page of items
             *   - `size` Total number of items. When tree sublevel items
             *     are requested, total number of items in the requested sublevel.
             *     Optional when tree is not used, required for tree.
             *
             * @type {GridDataProvider | null | undefined}
             */
            dataProvider: {
              type: Object,
              notify: true,
              observer: '_dataProviderChanged'
            },

            /**
             * `true` while data is being requested from the data provider.
             */
            loading: {
              type: Boolean,
              notify: true,
              readOnly: true,
              reflectToAttribute: true
            },

            /**
             * @type {!ItemCache}
             * @protected
             */
            _cache: {
              type: Object,
              value: function value() {
                var cache = new ItemCache(this);
                return cache;
              }
            },

            /**
             * Path to an item sub-property that identifies the item.
             * @attr {string} item-id-path
             */
            itemIdPath: {
              type: String,
              value: null
            },

            /**
             * An array that contains the expanded items.
             * @type {!Array<!GridItem>}
             */
            expandedItems: {
              type: Object,
              notify: true,
              value: function value() {
                return [];
              }
            }
          };
        }
      }, {
        key: "observers",
        get: function get() {
          return ['_sizeChanged(size)', '_itemIdPathChanged(itemIdPath)', '_expandedItemsChanged(expandedItems.*)'];
        }
      }]);
      return DataProviderMixin;
    }(superClass);
  };

  _exports.DataProviderMixin = DataProviderMixin;
});