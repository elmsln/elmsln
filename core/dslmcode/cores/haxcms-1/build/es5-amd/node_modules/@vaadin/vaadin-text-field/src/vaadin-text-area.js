define(["exports", "../../../@polymer/polymer/polymer-element.js", "./vaadin-text-field-mixin.js", "../../vaadin-control-state-mixin/vaadin-control-state-mixin.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "../../vaadin-element-mixin/vaadin-element-mixin.js", "../../../@polymer/polymer/lib/utils/html-tag.js"], function (_exports, _polymerElement, _vaadinTextFieldMixin, _vaadinControlStateMixin, _vaadinThemableMixin, _vaadinElementMixin, _htmlTag) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.TextAreaElement = void 0;

  var _templateObject_cca158a0809211edaa2833647dc78c6c;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `<vaadin-text-area>` is a Web Component for text area control in forms.
   *
   * ```html
   * <vaadin-text-area label="Add description">
   * </vaadin-text-area>
   * ```
   *
   * ### Prefixes and suffixes
   *
   * These are child elements of a `<vaadin-text-area>` that are displayed
   * inline with the input, before or after.
   * In order for an element to be considered as a prefix, it must have the slot
   * attribute set to `prefix` (and similarly for `suffix`).
   *
   * ```html
   * <vaadin-text-area label="Add description">
   *   <div slot="prefix">Details:</div>
   *   <div slot="suffix">The end!</div>
   * </vaadin-text-area>
   * ```
   *
   * ### Styling
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name | Description
   * ----------------|----------------
   * `label` | The label element
   * `input-field` | The element that wraps prefix, value and suffix
   * `value` | The text value element inside the `input-field` element
   * `error-message` | The error message element
   *
   * The following state attributes are available for styling:
   *
   * Attribute    | Description | Part name
   * -------------|-------------|------------
   * `disabled` | Set to a disabled text field | :host
   * `has-value` | Set when the element has a value | :host
   * `has-label` | Set when the element has a label | :host
   * `has-helper` | Set when the element has helper text | :host
   * `has-error-message` | Set when the element has an error message | :host
   * `invalid` | Set when the element is invalid | :host
   * `focused` | Set when the element is focused | :host
   * `focus-ring` | Set when the element is keyboard focused | :host
   * `readonly` | Set to a readonly text field | :host
   *
   * See [ThemableMixin â€“ how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
   *
   * @extends PolymerElement
   * @mixes TextFieldMixin
   * @mixes ControlStateMixin
   * @mixes ElementMixin
   * @mixes ThemableMixin
   * @demo demo/index.html
   */
  var TextAreaElement = /*#__PURE__*/function (_ElementMixin) {
    babelHelpers.inherits(TextAreaElement, _ElementMixin);

    var _super = _createSuper(TextAreaElement);

    function TextAreaElement() {
      babelHelpers.classCallCheck(this, TextAreaElement);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(TextAreaElement, [{
      key: "ready",
      value:
      /** @protected */
      function ready() {
        var _this = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(TextAreaElement.prototype), "ready", this).call(this);

        this._updateHeight();

        this.addEventListener('animationend', this._onAnimationEnd);
        this._inputField = this.root.querySelector('[part=input-field]'); // Wheel scrolling results in async scroll events. Preventing the wheel
        // event, scrolling manually and then synchronously updating the scroll position CSS variable
        // allows us to avoid some jumpy behavior that would occur on wheel otherwise.

        this._inputField.addEventListener('wheel', function (e) {
          var scrollTopBefore = _this._inputField.scrollTop;
          _this._inputField.scrollTop += e.deltaY;

          if (scrollTopBefore !== _this._inputField.scrollTop) {
            e.preventDefault();

            _this.__scrollPositionUpdated();
          }
        });

        this.__scrollPositionUpdated();
      }
      /** @private */

    }, {
      key: "__scrollPositionUpdated",
      value: function __scrollPositionUpdated() {
        this.updateStyles({
          '--_text-area-vertical-scroll-position': this._inputField.scrollTop + 'px'
        });
      }
      /** @private */

    }, {
      key: "_onAnimationEnd",
      value: function _onAnimationEnd(e) {
        if (e.animationName.indexOf('vaadin-text-area-appear') === 0) {
          this._updateHeight();
        }
      }
      /**
       * @return {string}
       * @protected
       */

    }, {
      key: "_slottedTagName",
      get: function get() {
        return 'textarea';
      }
      /** @private */

    }, {
      key: "_textAreaValueChanged",
      value: function _textAreaValueChanged(value) {
        this._updateHeight();
      }
      /** @private */

    }, {
      key: "_updateHeight",
      value: function _updateHeight() {
        var inputField = this.root.querySelector('[part=input-field]');
        var scrollTop = inputField.scrollTop;
        var input = this.inputElement; // Only clear the height when the content shortens to minimize scrollbar flickering.

        var valueLength = this.value ? this.value.length : 0;

        if (this._oldValueLength >= valueLength) {
          var inputFieldHeight = getComputedStyle(inputField).height;
          var inputWidth = getComputedStyle(input).width; // Temporarily fix the height of the wrapping input field container to prevent changing the browsers scroll
          // position while resetting the textareas height. If the textarea had a large height, then removing its height
          // will reset its height to the default of two rows. That might reduce the height of the page, and the
          // browser might adjust the scroll position before we can restore the measured height of the textarea.

          inputField.style.display = 'block';
          inputField.style.height = inputFieldHeight; // Fix the input element width so its scroll height isn't affected by host's disappearing scrollbars

          input.style.maxWidth = inputWidth; // Clear the height of the textarea to allow measuring a reduced scroll height

          input.style.height = 'auto';
        }

        this._oldValueLength = valueLength;
        var inputHeight = input.scrollHeight;

        if (inputHeight > input.clientHeight) {
          input.style.height = inputHeight + 'px';
        } // Restore


        input.style.removeProperty('max-width');
        inputField.style.removeProperty('display');
        inputField.style.removeProperty('height');
        inputField.scrollTop = scrollTop;

        this._dispatchIronResizeEventIfNeeded('InputHeight', inputHeight);
      }
      /**
       * Returns true if the current textarea value satisfies all constraints (if any).
       * @return {boolean}
       */

    }, {
      key: "checkValidity",
      value: function checkValidity() {
        if (!babelHelpers.get(babelHelpers.getPrototypeOf(TextAreaElement.prototype), "checkValidity", this).call(this)) {
          return false;
        } // Native <textarea> does not support pattern attribute, so we have a custom logic
        // according to WHATWG spec for <input>, with tests inspired by web-platform-tests
        // https://html.spec.whatwg.org/multipage/input.html#the-pattern-attribute


        if (!this.pattern || !this.inputElement.value) {
          // Mark as valid if there is no pattern, or the value is empty
          return true;
        }

        try {
          var match = this.inputElement.value.match(this.pattern);
          return match ? match[0] === match.input : false;
        } catch (_) {
          // If the pattern can not be compiled, then report as valid
          return true;
        }
      }
      /**
       * Fired when the text-area height changes.
       *
       * @event iron-resize
       */

    }], [{
      key: "template",
      get: function get() {
        return (0, _htmlTag.html)(_templateObject_cca158a0809211edaa2833647dc78c6c || (_templateObject_cca158a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n    <style include=\"vaadin-text-field-shared-styles\">\n      .vaadin-text-area-container {\n        flex: auto;\n        max-height: inherit; /* MSIE 11 */\n        min-height: inherit; /* MSIE 11 */\n      }\n\n      /* The label, helper text and the error message should neither grow nor shrink. */\n      [part=\"label\"],\n      [part=\"helper-text\"],\n      [part=\"error-message\"] {\n        flex: none;\n      }\n\n      [part=\"input-field\"] {\n        overflow: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      [part=\"value\"] {\n        resize: none;\n      }\n\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(*) {\n        align-self: flex-start;\n      }\n\n      @keyframes vaadin-text-area-appear {\n        to {\n          opacity: 1;\n        }\n      }\n\n      :host {\n        animation: 1ms vaadin-text-area-appear;\n      }\n\n      /* Workaround https://bugzilla.mozilla.org/show_bug.cgi?id=1739079 */\n      :host([disabled]) [part='value'] {\n        user-select: none;\n      }\n    </style>\n\n    <div class=\"vaadin-text-area-container\">\n\n      <label part=\"label\" on-click=\"focus\" id=\"[[_labelId]]\">[[label]]</label>\n\n      <div part=\"input-field\" id=\"[[_inputId]]\" on-scroll=\"__scrollPositionUpdated\">\n\n        <slot name=\"prefix\"></slot>\n\n        <slot name=\"textarea\">\n          <textarea part=\"value\"></textarea>\n        </slot>\n\n        <div part=\"clear-button\" id=\"clearButton\" role=\"button\" aria-label$=\"[[i18n.clear]]\"></div>\n        <slot name=\"suffix\"></slot>\n\n      </div>\n\n      <div part=\"helper-text\" id=\"[[_helperTextId]]\">\n        <slot name=\"helper\">[[helperText]]</slot>\n      </div>\n\n      <div part=\"error-message\" id=\"[[_errorId]]\" aria-live=\"assertive\" aria-hidden$=\"[[_getErrorMessageAriaHidden(invalid, errorMessage, _errorId)]]\">[[errorMessage]]</div>\n\n    </div>\n"], ["\n    <style include=\"vaadin-text-field-shared-styles\">\n      .vaadin-text-area-container {\n        flex: auto;\n        max-height: inherit; /* MSIE 11 */\n        min-height: inherit; /* MSIE 11 */\n      }\n\n      /* The label, helper text and the error message should neither grow nor shrink. */\n      [part=\"label\"],\n      [part=\"helper-text\"],\n      [part=\"error-message\"] {\n        flex: none;\n      }\n\n      [part=\"input-field\"] {\n        overflow: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      [part=\"value\"] {\n        resize: none;\n      }\n\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(*) {\n        align-self: flex-start;\n      }\n\n      @keyframes vaadin-text-area-appear {\n        to {\n          opacity: 1;\n        }\n      }\n\n      :host {\n        animation: 1ms vaadin-text-area-appear;\n      }\n\n      /* Workaround https://bugzilla.mozilla.org/show_bug.cgi?id=1739079 */\n      :host([disabled]) [part='value'] {\n        user-select: none;\n      }\n    </style>\n\n    <div class=\"vaadin-text-area-container\">\n\n      <label part=\"label\" on-click=\"focus\" id=\"[[_labelId]]\">[[label]]</label>\n\n      <div part=\"input-field\" id=\"[[_inputId]]\" on-scroll=\"__scrollPositionUpdated\">\n\n        <slot name=\"prefix\"></slot>\n\n        <slot name=\"textarea\">\n          <textarea part=\"value\"></textarea>\n        </slot>\n\n        <div part=\"clear-button\" id=\"clearButton\" role=\"button\" aria-label\\$=\"[[i18n.clear]]\"></div>\n        <slot name=\"suffix\"></slot>\n\n      </div>\n\n      <div part=\"helper-text\" id=\"[[_helperTextId]]\">\n        <slot name=\"helper\">[[helperText]]</slot>\n      </div>\n\n      <div part=\"error-message\" id=\"[[_errorId]]\" aria-live=\"assertive\" aria-hidden\\$=\"[[_getErrorMessageAriaHidden(invalid, errorMessage, _errorId)]]\">[[errorMessage]]</div>\n\n    </div>\n"])));
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-text-area';
      }
    }, {
      key: "version",
      get: function get() {
        return '2.9.2';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * A regular expression that the value is checked against.
           * The pattern must match the entire value, not just some subset.
           */
          pattern: {
            type: String
          }
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ['_textAreaValueChanged(value)'];
      }
    }]);
    return TextAreaElement;
  }((0, _vaadinElementMixin.ElementMixin)((0, _vaadinTextFieldMixin.TextFieldMixin)((0, _vaadinControlStateMixin.ControlStateMixin)((0, _vaadinThemableMixin.ThemableMixin)(_polymerElement.PolymerElement)))));

  _exports.TextAreaElement = TextAreaElement;
  customElements.define(TextAreaElement.is, TextAreaElement);
});