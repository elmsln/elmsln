define(["exports"],function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.DragAndDropMixin=void 0;/**
@license
Copyright (c) 2019 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
*/var DropMode={BETWEEN:"between",ON_TOP:"on-top",ON_TOP_OR_BETWEEN:"on-top-or-between",ON_GRID:"on-grid"},DropLocation={ON_TOP:"on-top",ABOVE:"above",BELOW:"below",EMPTY:"empty"},DragAndDropMixin=function DragAndDropMixin(superClass){return(/*#__PURE__*/function(_superClass){babelHelpers.inherits(DragAndDropMixin,_superClass);function DragAndDropMixin(){babelHelpers.classCallCheck(this,DragAndDropMixin);return babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(DragAndDropMixin).apply(this,arguments))}babelHelpers.createClass(DragAndDropMixin,[{key:"ready",value:function ready(){var _this=this;babelHelpers.get(babelHelpers.getPrototypeOf(DragAndDropMixin.prototype),"ready",this).call(this);this.$.table.addEventListener("dragstart",this._onDragStart.bind(this));this.$.table.addEventListener("dragend",this._onDragEnd.bind(this));this.$.table.addEventListener("dragover",this._onDragOver.bind(this));this.$.table.addEventListener("dragleave",this._onDragLeave.bind(this));this.$.table.addEventListener("drop",this._onDrop.bind(this));this.$.table.addEventListener("dragenter",function(e){if(_this.dropMode){e.preventDefault();e.stopPropagation()}})}},{key:"_onDragStart",value:function _onDragStart(e){var _this2=this;if(this.rowsDraggable){var row=e.target;if("vaadin-grid-cell-content"===row.localName){// The draggable node is the cell content element on browsers that support native shadow
row=row.assignedSlot.parentNode.parentNode}if(row.parentNode!==this.$.items){return}e.stopPropagation();this._toggleAttribute("dragging-rows",!0,this);if(this._safari){// Safari doesn't get proper drag images from transformed
// elements so we need to switch to top temporarily
var transform=row.style.transform;row.style.top=/translateY\((.*)\)/.exec(transform)[1];row.style.transform="none";requestAnimationFrame(function(){row.style.top="";row.style.transform=transform})}var rowRect=row.getBoundingClientRect();if(!window.ShadyDOM){if(this._ios){e.dataTransfer.setDragImage(row)}else{e.dataTransfer.setDragImage(row,e.clientX-rowRect.left,e.clientY-rowRect.top)}}var rows=[row];if(this._isSelected(row._item)){rows=this.__getViewportRows().filter(function(row){return _this2._isSelected(row._item)}).filter(function(row){return!_this2.dragFilter||_this2.dragFilter(_this2.__getRowModel(row))})}// Set the default transfer data
e.dataTransfer.setData("text",this.__formatDefaultTransferData(rows));row.setAttribute("dragstart",1<rows.length?rows.length:"");this.updateStyles({"--_grid-drag-start-x":"".concat(e.clientX-rowRect.left+20,"px"),"--_grid-drag-start-y":"".concat(e.clientY-rowRect.top+10,"px")});requestAnimationFrame(function(){row.removeAttribute("dragstart");_this2.updateStyles({"--_grid-drag-start-x":"","--_grid-drag-start-y":""})});var event=new CustomEvent("grid-dragstart",{detail:{draggedItems:rows.map(function(row){return row._item}),setDragData:function setDragData(type,data){return e.dataTransfer.setData(type,data)},setDraggedItemsCount:function setDraggedItemsCount(count){return row.setAttribute("dragstart",count)}}});event.originalEvent=e;this.dispatchEvent(event)}}},{key:"_onDragEnd",value:function _onDragEnd(e){this._toggleAttribute("dragging-rows",!1,this);e.stopPropagation();var event=new CustomEvent("grid-dragend");event.originalEvent=e;this.dispatchEvent(event)}},{key:"_onDragLeave",value:function _onDragLeave(e){e.stopPropagation();this._clearDragStyles()}},{key:"_onDragOver",value:function _onDragOver(e){if(this.dropMode){this._dropLocation=void 0;this._dragOverItem=void 0;if(this.__dndAutoScroll(e.clientY)){this._clearDragStyles();return}var row=e.composedPath().filter(function(node){return"tr"===node.localName})[0];if(!this._effectiveSize||this.dropMode===DropMode.ON_GRID){// The grid is empty or "on-grid" drop mode was used, always default to "empty"
this._dropLocation=DropLocation.EMPTY}else if(!row||row.parentNode!==this.$.items){// The dragover didn't occur on a body row but the grid has items
if(row){// The dragover occurred over a header/footer row
return}else if(this.dropMode===DropMode.BETWEEN||this.dropMode===DropMode.ON_TOP_OR_BETWEEN){// The drop mode allows setting the last row as the drag over item
row=Array.from(this.$.items.children).filter(function(row){return!row.hidden}).pop();this._dropLocation=DropLocation.BELOW}else{// Drop mode on-top used but the dragover didn't occur over one of the existing rows
return}}else{// The dragover occurred on a body row, determine the drop location from coordinates
var rowRect=row.getBoundingClientRect();this._dropLocation=DropLocation.ON_TOP;if(this.dropMode===DropMode.BETWEEN){var dropAbove=e.clientY-rowRect.top<rowRect.bottom-e.clientY;this._dropLocation=dropAbove?DropLocation.ABOVE:DropLocation.BELOW}else if(this.dropMode===DropMode.ON_TOP_OR_BETWEEN){if(e.clientY-rowRect.top<rowRect.height/3){this._dropLocation=DropLocation.ABOVE}else if(e.clientY-rowRect.top>2*(rowRect.height/3)){this._dropLocation=DropLocation.BELOW}}}if(row&&row.hasAttribute("drop-disabled")){this._dropLocation=void 0;return}e.stopPropagation();e.preventDefault();if(this._dropLocation===DropLocation.EMPTY){this._toggleAttribute("dragover",!0,this)}else if(row){this._dragOverItem=row._item;if(row.getAttribute("dragover")!==this._dropLocation){row.setAttribute("dragover",this._dropLocation)}}else{this._clearDragStyles()}}}},{key:"__dndAutoScroll",value:function __dndAutoScroll(clientY){var _this3=this;if(this.__dndAutoScrolling){return!0}var headerBottom=this.$.header.getBoundingClientRect().bottom,footerTop=this.$.footer.getBoundingClientRect().top,topDiff=headerBottom-clientY+this.__dndAutoScrollThreshold,bottomDiff=clientY-footerTop+this.__dndAutoScrollThreshold,scrollTopDelta=0;if(0<bottomDiff){scrollTopDelta=2*bottomDiff}else if(0<topDiff){scrollTopDelta=2*-topDiff}if(scrollTopDelta){var scrollTop=this.$.table.scrollTop;this.$.table.scrollTop+=scrollTopDelta;var scrollTopChanged=scrollTop!==this.$.table.scrollTop;if(scrollTopChanged){this.__dndAutoScrolling=!0;// Disallow more auto-scrolls within 20ms
setTimeout(function(){return _this3.__dndAutoScrolling=!1},20);this._scrollHandler();return!0}}}},{key:"__getViewportRows",value:function __getViewportRows(){var headerBottom=this.$.header.getBoundingClientRect().bottom,footerTop=this.$.footer.getBoundingClientRect().top;return Array.from(this.$.items.children).filter(function(row){var rowRect=row.getBoundingClientRect();return rowRect.bottom>headerBottom&&rowRect.top<footerTop})}},{key:"_clearDragStyles",value:function _clearDragStyles(){this.removeAttribute("dragover");Array.from(this.$.items.children).forEach(function(row){return row.removeAttribute("dragover")})}},{key:"_onDrop",value:function _onDrop(e){if(this.dropMode){e.stopPropagation();e.preventDefault();var dragData=e.dataTransfer.types&&Array.from(e.dataTransfer.types).map(function(type){return{type:type,data:e.dataTransfer.getData(type)}});this._clearDragStyles();var event=new CustomEvent("grid-drop",{bubbles:e.bubbles,cancelable:e.cancelable,detail:{dropTargetItem:this._dragOverItem,dropLocation:this._dropLocation,dragData:dragData}});event.originalEvent=e;this.dispatchEvent(event)}}},{key:"__formatDefaultTransferData",value:function __formatDefaultTransferData(rows){return rows.map(function(row){return Array.from(row.children).filter(function(cell){return!cell.hidden&&-1===cell.getAttribute("part").indexOf("details-cell")}).sort(function(a,b){return a._column._order>b._column._order?1:-1}).map(function(cell){return cell._content.textContent.trim()}).filter(function(content){return content}).join("\t")}).join("\n")}},{key:"_dragDropAccessChanged",value:function _dragDropAccessChanged(rowsDraggable,dropMode,dragFilter,dropFilter){this.filterDragAndDrop()}/**
   * Runs the `dragFilter` and `dropFilter` hooks for the visible cells.
   * If the filter depends on varying conditions, you may need to
   * call this function manually in order to update the draggability when
   * the conditions change.
   */},{key:"filterDragAndDrop",value:function filterDragAndDrop(){var _this4=this;Array.from(this.$.items.children).filter(function(row){return!row.hidden}).forEach(function(row){_this4._filterDragAndDrop(row,_this4.__getRowModel(row))})}},{key:"_filterDragAndDrop",value:function _filterDragAndDrop(row,rowData){var dragDisabled=!this.rowsDraggable||this.dragFilter&&!this.dragFilter(rowData),dropDisabled=!this.dropMode||this.dropFilter&&!this.dropFilter(rowData),draggableElements=window.ShadyDOM?[row]:Array.from(row.children).map(function(cell){return cell._content});draggableElements.forEach(function(e){if(dragDisabled){e.removeAttribute("draggable")}else{e.setAttribute("draggable",!0)}});this._toggleAttribute("drag-disabled",dragDisabled,row);this._toggleAttribute("drop-disabled",dropDisabled,row)}/**
   * Fired when starting to drag grid rows.
   *
   * @event grid-dragstart
   * @param {Object} originalEvent The native dragstart event
   * @param {Object} detail
   * @param {Object} detail.draggedItems the items in the visible viewport that are dragged
   * @param {Function} detail.setDraggedItemsCount Overrides the default number shown in the drag image on multi row drag.
   * Parameter is of type number.
   * @param {Function} detail.setDragData Sets dataTransfer data for the drag operation.
   * Note that "text" is the only data type supported by all the browsers the grid currently supports (including IE11).
   * The function takes two parameters:
   * - type:string The type of the data
   * - data:string The data
   */ /**
   * Fired when the dragging of the rows ends.
   *
   * @event grid-dragend
   * @param {Object} originalEvent The native dragend event
   */ /**
   * Fired when a drop occurs on top of the grid.
   *
   * @event grid-drop
   * @param {Object} originalEvent The native drop event
   * @param {Object} detail
   * @param {Object} detail.dropTargetItem The item of the grid row on which the drop occurred.
   * @param {string} detail.dropLocation The position at which the drop event took place relative to a row.
   * Depending on the dropMode value, the drop location can be one of the following
   * - `on-top`: when the drop occurred on top of the row
   * - `above`: when the drop occurred above the row
   * - `below`: when the drop occurred below the row
   * - `empty`: when the drop occurred over the grid, not relative to any specific row
   * @param {string} detail.dragData An array of items with the payload as a string representation as the
   * `data` property and the type of the data as `type` property.
   */}],[{key:"properties",get:function get(){return{/**
       * Defines the locations within the Grid row where an element can be dropped.
       *
       * Possible values are:
       * - `between`: The drop event can happen between Grid rows.
       * - `on-top`: The drop event can happen on top of Grid rows.
       * - `on-top-or-between`: The drop event can happen either on top of or between Grid rows.
       * - `on-grid`: The drop event will not happen on any specific row, it will show the drop target outline around the whole grid.
       */dropMode:String,/**
       * Marks the grid's rows to be available for dragging.
       */rowsDraggable:Boolean,/**
       * A function that filters dragging of specific grid rows. The return value should be false
       * if dragging of the row should be disabled.
       *
       * Receives one argument:
       * - `rowData` The object with the properties related with
       *   the rendered item, contains:
       *   - `rowData.index` The index of the item.
       *   - `rowData.item` The item.
       *   - `rowData.expanded` Sublevel toggle state.
       *   - `rowData.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `rowData.selected` Selected state.
       */dragFilter:Function,/**
       * A function that filters dropping on specific grid rows. The return value should be false
       * if dropping on the row should be disabled.
       *
       * Receives one argument:
       * - `rowData` The object with the properties related with
       *   the rendered item, contains:
       *   - `rowData.index` The index of the item.
       *   - `rowData.item` The item.
       *   - `rowData.expanded` Sublevel toggle state.
       *   - `rowData.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `rowData.selected` Selected state.
       */dropFilter:Function,__dndAutoScrollThreshold:{value:50}}}},{key:"observers",get:function get(){return["_dragDropAccessChanged(rowsDraggable, dropMode, dragFilter, dropFilter)"]}}]);return DragAndDropMixin}(superClass))};_exports.DragAndDropMixin=DragAndDropMixin});