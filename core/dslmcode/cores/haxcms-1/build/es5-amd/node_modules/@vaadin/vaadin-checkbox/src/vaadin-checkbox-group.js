define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "./vaadin-checkbox.js", "../../../@polymer/polymer/lib/utils/html-tag.js"], function (_exports, _polymerElement, _flattenedNodesObserver, _vaadinThemableMixin, _vaadinCheckbox, _htmlTag) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.CheckboxGroupElement = void 0;

  function _templateObject_b6b087e0b49511e9bfd4f79a8a57e0f7() {
    var data = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: inline-flex;\n      }\n\n      :host::before {\n        content: \"\\2003\";\n        width: 0;\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      .vaadin-group-field-container {\n        display: flex;\n        flex-direction: column;\n      }\n\n      [part=\"label\"]:empty {\n        display: none;\n      }\n    </style>\n\n    <div class=\"vaadin-group-field-container\">\n      <label part=\"label\">[[label]]</label>\n\n      <div part=\"group-field\">\n        <slot id=\"slot\"></slot>\n      </div>\n\n      <div part=\"error-message\" aria-live=\"assertive\" aria-hidden$=\"[[_getErrorMessageAriaHidden(invalid, errorMessage)]]\">[[errorMessage]]</div>\n\n    </div>\n"], ["\n    <style>\n      :host {\n        display: inline-flex;\n      }\n\n      :host::before {\n        content: \"\\\\2003\";\n        width: 0;\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      .vaadin-group-field-container {\n        display: flex;\n        flex-direction: column;\n      }\n\n      [part=\"label\"]:empty {\n        display: none;\n      }\n    </style>\n\n    <div class=\"vaadin-group-field-container\">\n      <label part=\"label\">[[label]]</label>\n\n      <div part=\"group-field\">\n        <slot id=\"slot\"></slot>\n      </div>\n\n      <div part=\"error-message\" aria-live=\"assertive\" aria-hidden\\$=\"[[_getErrorMessageAriaHidden(invalid, errorMessage)]]\">[[errorMessage]]</div>\n\n    </div>\n"]);

    _templateObject_b6b087e0b49511e9bfd4f79a8a57e0f7 = function _templateObject_b6b087e0b49511e9bfd4f79a8a57e0f7() {
      return data;
    };

    return data;
  }

  /**
   * `<vaadin-checkbox-group>` is a Polymer element for grouping vaadin-checkboxes.
   *
   * ```html
   * <vaadin-checkbox-group label="Preferred language of contact:">
   *  <vaadin-checkbox value="en">English</vaadin-checkbox>
   *  <vaadin-checkbox value="fr">Français</vaadin-checkbox>
   *  <vaadin-checkbox value="de">Deutsch</vaadin-checkbox>
   * </vaadin-checkbox-group>
   * ```
   *
   * ### Styling
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name | Description
   * ----------------|----------------
   * `label` | The label element
   * `group-field` | The element that wraps checkboxes
   * `error-message` | The error message element
   *
   * The following state attributes are available for styling:
   *
   * Attribute  | Description | Part name
   * -----------|-------------|------------
   * `disabled`   | Set when the checkbox group and its children are disabled. | :host
   * `has-label` | Set when the element has a label | :host
   * `has-value` | Set when the element has a value | :host
   * `required` | Set when the element is required | :host
   * `invalid` | Set when the element is invalid | :host
   *
   * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
   *
   * @memberof Vaadin
   * @mixes Vaadin.ThemableMixin
   * @element vaadin-checkbox-group
   * @demo demo/index.html
   */
  var CheckboxGroupElement =
  /*#__PURE__*/
  function (_ThemableMixin) {
    babelHelpers.inherits(CheckboxGroupElement, _ThemableMixin);

    function CheckboxGroupElement() {
      babelHelpers.classCallCheck(this, CheckboxGroupElement);
      return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(CheckboxGroupElement).apply(this, arguments));
    }

    babelHelpers.createClass(CheckboxGroupElement, [{
      key: "ready",
      value: function ready() {
        var _this = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(CheckboxGroupElement.prototype), "ready", this).call(this);
        this.addEventListener('focusout', function (e) {
          // validate when stepping out of the checkbox group
          if (!_this._checkboxes.some(function (checkbox) {
            return e.relatedTarget === checkbox || checkbox.shadowRoot.contains(e.relatedTarget);
          })) {
            _this.validate();
          }
        });

        var checkedChangedListener = function checkedChangedListener(e) {
          _this._changeSelectedCheckbox(e.target);
        };

        this._observer = new _flattenedNodesObserver.FlattenedNodesObserver(this, function (info) {
          var addedCheckboxes = _this._filterCheckboxes(info.addedNodes);

          addedCheckboxes.forEach(function (checkbox) {
            checkbox.addEventListener('checked-changed', checkedChangedListener);

            if (_this.disabled) {
              checkbox.disabled = true;
            }

            if (checkbox.checked) {
              _this._addCheckboxToValue(checkbox.value);
            }
          });

          _this._filterCheckboxes(info.removedNodes).forEach(function (checkbox) {
            checkbox.removeEventListener('checked-changed', checkedChangedListener);

            if (checkbox.checked) {
              _this._removeCheckboxFromValue(checkbox.value);
            }
          });

          if (addedCheckboxes.some(function (checkbox) {
            return !checkbox.hasAttribute('value');
          })) {
            console.warn('Please add value attribute to all checkboxes in checkbox group');
          }
        });
      }
      /**
       * Returns true if `value` is valid.
       * `<iron-form>` uses this to check the validity or all its elements.
       *
       * @return {boolean} True if the value is valid.
       */

    }, {
      key: "validate",
      value: function validate() {
        this.invalid = this.required && this.value.length === 0;
        return !this.invalid;
      }
    }, {
      key: "_filterCheckboxes",
      value: function _filterCheckboxes(nodes) {
        return Array.from(nodes).filter(function (child) {
          return babelHelpers.instanceof(child, _vaadinCheckbox.CheckboxElement);
        });
      }
    }, {
      key: "_disabledChanged",
      value: function _disabledChanged(disabled) {
        this.setAttribute('aria-disabled', disabled);

        this._checkboxes.forEach(function (checkbox) {
          return checkbox.disabled = disabled;
        });
      }
    }, {
      key: "_addCheckboxToValue",
      value: function _addCheckboxToValue(value) {
        var update = this.value.slice(0);
        update.push(value);
        this.value = update;
      }
    }, {
      key: "_removeCheckboxFromValue",
      value: function _removeCheckboxFromValue(value) {
        var update = this.value.slice(0);
        var index = update.indexOf(value);
        update.splice(index, 1);
        this.value = update;
      }
    }, {
      key: "_changeSelectedCheckbox",
      value: function _changeSelectedCheckbox(checkbox) {
        if (this._updatingValue) {
          return;
        }

        if (checkbox.checked) {
          this._addCheckboxToValue(checkbox.value);
        } else {
          this._removeCheckboxFromValue(checkbox.value);
        }
      }
    }, {
      key: "_updateValue",
      value: function _updateValue(value, splices) {
        // setting initial value to empty array, skip validation
        if (value.length === 0 && this._oldValue === undefined) {
          return;
        }

        if (value.length) {
          this.setAttribute('has-value', '');
        } else {
          this.removeAttribute('has-value');
        }

        this._oldValue = value; // set a flag to avoid updating loop

        this._updatingValue = true; // reflect the value array to checkboxes

        this._checkboxes.forEach(function (checkbox) {
          checkbox.checked = value.indexOf(checkbox.value) > -1;
        });

        this._updatingValue = false;
        this.validate();
      }
    }, {
      key: "_labelChanged",
      value: function _labelChanged(label) {
        if (label) {
          this.setAttribute('has-label', '');
        } else {
          this.removeAttribute('has-label');
        }
      }
    }, {
      key: "_getErrorMessageAriaHidden",
      value: function _getErrorMessageAriaHidden(invalid, errorMessage) {
        return (!errorMessage || !invalid).toString();
      }
    }, {
      key: "_checkboxes",
      get: function get() {
        return this._filterCheckboxes(this.querySelectorAll('*'));
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _htmlTag.html)(_templateObject_b6b087e0b49511e9bfd4f79a8a57e0f7());
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-checkbox-group';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * The current disabled state of the checkbox group. True if group and all internal checkboxes are disabled.
           */
          disabled: {
            type: Boolean,
            reflectToAttribute: true,
            observer: '_disabledChanged'
          },

          /**
           * String used for the label element.
           */
          label: {
            type: String,
            value: '',
            observer: '_labelChanged'
          },

          /**
           * Value of the checkbox group.
           * Note: toggling the checkboxes modifies the value by creating new
           * array each time, to override Polymer dirty-checking for arrays.
           * You can still use Polymer array mutation methods to update the value.
           */
          value: {
            type: Array,
            value: function value() {
              return [];
            },
            notify: true
          },

          /**
           * Error to show when the input value is invalid.
           */
          errorMessage: {
            type: String,
            value: ''
          },

          /**
           * Specifies that the user must fill in a value.
           */
          required: {
            type: Boolean,
            reflectToAttribute: true
          },

          /**
           * This property is set to true when the control value is invalid.
           */
          invalid: {
            type: Boolean,
            reflectToAttribute: true,
            notify: true,
            value: false
          }
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ['_updateValue(value, value.splices)'];
      }
    }]);
    return CheckboxGroupElement;
  }((0, _vaadinThemableMixin.ThemableMixin)(_polymerElement.PolymerElement));

  _exports.CheckboxGroupElement = CheckboxGroupElement;
  customElements.define(CheckboxGroupElement.is, CheckboxGroupElement);
});