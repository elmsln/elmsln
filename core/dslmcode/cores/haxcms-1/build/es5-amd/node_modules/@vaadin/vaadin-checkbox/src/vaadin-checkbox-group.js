define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "../../vaadin-element-mixin/vaadin-dir-mixin.js", "./vaadin-checkbox.js", "../../../@polymer/polymer/lib/utils/html-tag.js"], function (_exports, _polymerElement, _flattenedNodesObserver, _vaadinThemableMixin, _vaadinDirMixin, _vaadinCheckbox, _htmlTag) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.CheckboxGroupElement = void 0;

  var _templateObject_a33b54e0942811ecb1937969798b231a;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `<vaadin-checkbox-group>` is a Polymer element for grouping vaadin-checkboxes.
   *
   * ```html
   * <vaadin-checkbox-group label="Preferred language of contact:">
   *  <vaadin-checkbox value="en">English</vaadin-checkbox>
   *  <vaadin-checkbox value="fr">Français</vaadin-checkbox>
   *  <vaadin-checkbox value="de">Deutsch</vaadin-checkbox>
   * </vaadin-checkbox-group>
   * ```
   *
   * ### Styling
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name | Description
   * ----------------|----------------
   * `label` | The label element
   * `group-field` | The element that wraps checkboxes
   * `error-message` | The error message element
   *
   * The following state attributes are available for styling:
   *
   * Attribute  | Description | Part name
   * -----------|-------------|------------
   * `disabled`   | Set when the checkbox group and its children are disabled. | :host
   * `focused` | Set when the checkbox group contains focus | :host
   * `has-label` | Set when the element has a label | :host
   * `has-value` | Set when the element has a value | :host
   * `has-helper` | Set when the element has helper text or slot | :host
   * `has-error-message` | Set when the element has an error message, regardless if the field is valid or not | :host
   * `required` | Set when the element is required | :host
   * `invalid` | Set when the element is invalid | :host
   *
   * See [ThemableMixin – how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
   *
   * @extends PolymerElement
   * @mixes ThemableMixin
   * @mixes DirMixin
   * @element vaadin-checkbox-group
   * @demo demo/index.html
   */
  var CheckboxGroupElement = /*#__PURE__*/function (_ThemableMixin) {
    babelHelpers.inherits(CheckboxGroupElement, _ThemableMixin);

    var _super = _createSuper(CheckboxGroupElement);

    function CheckboxGroupElement() {
      babelHelpers.classCallCheck(this, CheckboxGroupElement);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(CheckboxGroupElement, [{
      key: "ready",
      value: function ready() {
        var _this = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(CheckboxGroupElement.prototype), "ready", this).call(this);
        this.addEventListener('focusin', function () {
          return _this._setFocused(_this._containsFocus());
        });
        this.addEventListener('focusout', function (e) {
          // validate when stepping out of the checkbox group
          if (!_this._checkboxes.some(function (checkbox) {
            return e.relatedTarget === checkbox || checkbox.shadowRoot.contains(e.relatedTarget);
          })) {
            _this.validate();

            _this._setFocused(false);
          }
        });

        var checkedChangedListener = function checkedChangedListener(e) {
          _this._changeSelectedCheckbox(e.target);
        };

        this._observer = new _flattenedNodesObserver.FlattenedNodesObserver(this, function (info) {
          var addedCheckboxes = _this._filterCheckboxes(info.addedNodes);

          addedCheckboxes.forEach(function (checkbox) {
            checkbox.addEventListener('checked-changed', checkedChangedListener);

            if (_this.disabled) {
              checkbox.disabled = true;
            }

            if (checkbox.checked) {
              _this._addCheckboxToValue(checkbox.value);
            } else if (_this.value.indexOf(checkbox.value) > -1) {
              checkbox.checked = true;
            }
          });

          _this._filterCheckboxes(info.removedNodes).forEach(function (checkbox) {
            checkbox.removeEventListener('checked-changed', checkedChangedListener);

            if (checkbox.checked) {
              _this._removeCheckboxFromValue(checkbox.value);
            }
          });

          _this._setOrToggleHasHelperAttribute();

          var hasValue = function hasValue(checkbox) {
            var value = checkbox.value;
            return checkbox.hasAttribute('value') || value && value !== 'on';
          };

          if (!addedCheckboxes.every(hasValue)) {
            console.warn('Please add value attribute to all checkboxes in checkbox group');
          }
        });
      }
      /**
       * Returns true if `value` is valid.
       * `<iron-form>` uses this to check the validity or all its elements.
       *
       * @return {boolean} True if the value is valid.
       */

    }, {
      key: "validate",
      value: function validate() {
        this.invalid = this.required && this.value.length === 0;
        return !this.invalid;
      }
      /** @private */

    }, {
      key: "_checkboxes",
      get: function get() {
        return this._filterCheckboxes(this.querySelectorAll('*'));
      }
      /** @private */

    }, {
      key: "_filterCheckboxes",
      value: function _filterCheckboxes(nodes) {
        return Array.from(nodes).filter(function (child) {
          return babelHelpers.instanceof(child, _vaadinCheckbox.CheckboxElement);
        });
      }
      /** @private */

    }, {
      key: "_disabledChanged",
      value: function _disabledChanged(disabled) {
        this.setAttribute('aria-disabled', disabled);

        this._checkboxes.forEach(function (checkbox) {
          return checkbox.disabled = disabled;
        });
      }
      /**
       * @param {string} value
       * @protected
       */

    }, {
      key: "_addCheckboxToValue",
      value: function _addCheckboxToValue(value) {
        if (this.value.indexOf(value) === -1) {
          this.value = this.value.concat(value);
        }
      }
      /**
       * @param {string} value
       * @protected
       */

    }, {
      key: "_removeCheckboxFromValue",
      value: function _removeCheckboxFromValue(value) {
        this.value = this.value.filter(function (v) {
          return v !== value;
        });
      }
      /**
       * @param {CheckboxElement} checkbox
       * @protected
       */

    }, {
      key: "_changeSelectedCheckbox",
      value: function _changeSelectedCheckbox(checkbox) {
        if (this._updatingValue) {
          return;
        }

        if (checkbox.checked) {
          this._addCheckboxToValue(checkbox.value);
        } else {
          this._removeCheckboxFromValue(checkbox.value);
        }
      }
      /** @private */

    }, {
      key: "_updateValue",
      value: function _updateValue(value, splices) {
        // setting initial value to empty array, skip validation
        if (value.length === 0 && this._oldValue === undefined) {
          return;
        }

        if (value.length) {
          this.setAttribute('has-value', '');
        } else {
          this.removeAttribute('has-value');
        }

        this._oldValue = value; // set a flag to avoid updating loop

        this._updatingValue = true; // reflect the value array to checkboxes

        this._checkboxes.forEach(function (checkbox) {
          checkbox.checked = value.indexOf(checkbox.value) > -1;
        });

        this._updatingValue = false;
        this.validate();
      }
      /** @private */

    }, {
      key: "_labelChanged",
      value: function _labelChanged(label) {
        this._setOrToggleAttribute('has-label', !!label);
      }
      /** @private */

    }, {
      key: "_errorMessageChanged",
      value: function _errorMessageChanged(errorMessage) {
        this._setOrToggleAttribute('has-error-message', !!errorMessage);
      }
      /** @private */

    }, {
      key: "_helperTextChanged",
      value: function _helperTextChanged(helperText) {
        this._setOrToggleAttribute('has-helper', !!helperText);
      }
      /** @private */

    }, {
      key: "_setOrToggleAttribute",
      value: function _setOrToggleAttribute(name, value) {
        if (!name) {
          return;
        }

        if (value) {
          this.setAttribute(name, typeof value === 'boolean' ? '' : value);
        } else {
          this.removeAttribute(name);
        }
      }
      /** @private */

    }, {
      key: "_getErrorMessageAriaHidden",
      value: function _getErrorMessageAriaHidden(invalid, errorMessage) {
        return (!errorMessage || !invalid).toString();
      }
      /**
       * @return {boolean}
       * @protected
       */

    }, {
      key: "_containsFocus",
      value: function _containsFocus() {
        var root = this.getRootNode(); // Safari 9 needs polyfilled `_activeElement` to return correct node

        var activeElement = root._activeElement !== undefined ? root._activeElement : root.activeElement;
        return this.contains(activeElement);
      }
      /**
       * @param {boolean} focused
       * @protected
       */

    }, {
      key: "_setFocused",
      value: function _setFocused(focused) {
        if (focused) {
          this.setAttribute('focused', '');
        } else {
          this.removeAttribute('focused');
        }
      }
      /** @private */

    }, {
      key: "_setOrToggleHasHelperAttribute",
      value: function _setOrToggleHasHelperAttribute() {
        var slottedNodes = this.shadowRoot.querySelector("[name=\"helper\"]").assignedNodes(); // Only has slotted helper if not a text node
        // Text nodes are added by the helperText prop and not the helper slot
        // The filter is added due to shady DOM triggering this slotchange event on helperText prop change

        this._hasSlottedHelper = slottedNodes.filter(function (node) {
          return node.nodeType !== 3;
        }).length > 0;

        this._setOrToggleAttribute('has-helper', this._hasSlottedHelper ? 'slotted' : !!this.helperText);
      }
      /** @private */

    }, {
      key: "_getHelperTextAriaHidden",
      value: function _getHelperTextAriaHidden(helperText, hasSlottedHelper) {
        return (!(helperText || hasSlottedHelper)).toString();
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _htmlTag.html)(_templateObject_a33b54e0942811ecb1937969798b231a || (_templateObject_a33b54e0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: inline-flex;\n\n        /* Prevent horizontal overflow in IE 11 instead of wrapping checkboxes */\n        max-width: 100%;\n      }\n\n      :host::before {\n        content: \"\\2003\";\n        width: 0;\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      .vaadin-group-field-container {\n        display: flex;\n        flex-direction: column;\n\n        /* Prevent horizontal overflow in IE 11 instead of wrapping checkboxes */\n        width: 100%;\n      }\n\n      [part=\"label\"]:empty {\n        display: none;\n      }\n    </style>\n\n    <div class=\"vaadin-group-field-container\">\n      <label part=\"label\">[[label]]</label>\n\n      <div part=\"group-field\">\n        <slot id=\"slot\"></slot>\n      </div>\n\n      <div part=\"helper-text\" aria-live=\"assertive\" aria-hidden$=\"[[_getHelperTextAriaHidden(helperText, _hasSlottedHelper)]]\">\n        <slot name=\"helper\">[[helperText]]</slot>\n      </div>\n\n      <div part=\"error-message\" aria-live=\"assertive\" aria-hidden$=\"[[_getErrorMessageAriaHidden(invalid, errorMessage)]]\">[[errorMessage]]</div>\n\n    </div>\n"], ["\n    <style>\n      :host {\n        display: inline-flex;\n\n        /* Prevent horizontal overflow in IE 11 instead of wrapping checkboxes */\n        max-width: 100%;\n      }\n\n      :host::before {\n        content: \"\\\\2003\";\n        width: 0;\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      .vaadin-group-field-container {\n        display: flex;\n        flex-direction: column;\n\n        /* Prevent horizontal overflow in IE 11 instead of wrapping checkboxes */\n        width: 100%;\n      }\n\n      [part=\"label\"]:empty {\n        display: none;\n      }\n    </style>\n\n    <div class=\"vaadin-group-field-container\">\n      <label part=\"label\">[[label]]</label>\n\n      <div part=\"group-field\">\n        <slot id=\"slot\"></slot>\n      </div>\n\n      <div part=\"helper-text\" aria-live=\"assertive\" aria-hidden\\$=\"[[_getHelperTextAriaHidden(helperText, _hasSlottedHelper)]]\">\n        <slot name=\"helper\">[[helperText]]</slot>\n      </div>\n\n      <div part=\"error-message\" aria-live=\"assertive\" aria-hidden\\$=\"[[_getErrorMessageAriaHidden(invalid, errorMessage)]]\">[[errorMessage]]</div>\n\n    </div>\n"])));
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-checkbox-group';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * The current disabled state of the checkbox group. True if group and all internal checkboxes are disabled.
           */
          disabled: {
            type: Boolean,
            reflectToAttribute: true,
            observer: '_disabledChanged'
          },

          /**
           * String used for the label element.
           */
          label: {
            type: String,
            value: '',
            observer: '_labelChanged'
          },

          /**
           * Value of the checkbox group.
           * Note: toggling the checkboxes modifies the value by creating new
           * array each time, to override Polymer dirty-checking for arrays.
           * You can still use Polymer array mutation methods to update the value.
           * @type {!Array<!string>}
           */
          value: {
            type: Array,
            value: function value() {
              return [];
            },
            notify: true
          },

          /**
           * Error to show when the input value is invalid.
           * @attr {string} error-message
           */
          errorMessage: {
            type: String,
            value: '',
            observer: '_errorMessageChanged'
          },

          /**
           * String used for the helper text.
           * @attr {string} helper-text
           * @type {string | null}
           */
          helperText: {
            type: String,
            value: '',
            observer: '_helperTextChanged'
          },

          /**
           * Specifies that the user must fill in a value.
           */
          required: {
            type: Boolean,
            reflectToAttribute: true
          },

          /**
           * This property is set to true when the control value is invalid.
           * @type {boolean}
           */
          invalid: {
            type: Boolean,
            reflectToAttribute: true,
            notify: true,
            value: false
          },

          /** @private */
          _hasSlottedHelper: Boolean
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ['_updateValue(value, value.splices)'];
      }
    }]);
    return CheckboxGroupElement;
  }((0, _vaadinThemableMixin.ThemableMixin)((0, _vaadinDirMixin.DirMixin)(_polymerElement.PolymerElement)));

  _exports.CheckboxGroupElement = CheckboxGroupElement;
  customElements.define(CheckboxGroupElement.is, CheckboxGroupElement);
});