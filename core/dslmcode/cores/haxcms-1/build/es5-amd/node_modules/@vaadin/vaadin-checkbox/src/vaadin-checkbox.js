define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/mixins/gesture-event-listeners.js", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "../../vaadin-control-state-mixin/vaadin-control-state-mixin.js", "../../vaadin-element-mixin/vaadin-element-mixin.js", "../../../@polymer/polymer/lib/utils/html-tag.js"], function (_exports, _polymerElement, _gestureEventListeners, _vaadinThemableMixin, _vaadinControlStateMixin, _vaadinElementMixin, _htmlTag) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.CheckboxElement = void 0;

  var _templateObject_a340fa30942811ecb1937969798b231a;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `<vaadin-checkbox>` is a Web Component for customized checkboxes.
   *
   * ```html
   * <vaadin-checkbox>
   *   Make my profile visible
   * </vaadin-checkbox>
   * ```
   *
   * ### Styling
   *
   * The following shadow DOM parts are available for styling:
   *
   * Part name         | Description
   * ------------------|----------------
   * `checkbox`        | The wrapper element for the native <input type="checkbox">
   * `label`           | The wrapper element in which the component's children, namely the label, is slotted
   *
   * The following state attributes are available for styling:
   *
   * Attribute    | Description | Part name
   * -------------|-------------|--------------
   * `active`     | Set when the checkbox is pressed down, either with mouse, touch or the keyboard. | `:host`
   * `disabled`   | Set when the checkbox is disabled. | `:host`
   * `focus-ring` | Set when the checkbox is focused using the keyboard. | `:host`
   * `focused`    | Set when the checkbox is focused. | `:host`
   * `indeterminate` | Set when the checkbox is in indeterminate mode. | `:host`
   * `checked` | Set when the checkbox is checked. | `:host`
   * `empty` | Set when there is no label provided. | `label`
   *
   * See [ThemableMixin â€“ how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)
   *
   * @extends PolymerElement
   * @mixes ElementMixin
   * @mixes ControlStateMixin
   * @mixes ThemableMixin
   * @mixes GestureEventListeners
   * @demo demo/index.html
   */
  var CheckboxElement = /*#__PURE__*/function (_ElementMixin) {
    babelHelpers.inherits(CheckboxElement, _ElementMixin);

    var _super = _createSuper(CheckboxElement);

    function CheckboxElement() {
      var _this;

      babelHelpers.classCallCheck(this, CheckboxElement);
      _this = _super.call(this);
      /**
       * @type {string}
       * Name of the element.
       */

      _this.name;
      return _this;
    }

    babelHelpers.createClass(CheckboxElement, [{
      key: "name",
      get: function get() {
        return this.checked ? this._storedName : '';
      },
      set: function set(name) {
        this._storedName = name;
      }
    }, {
      key: "ready",
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(CheckboxElement.prototype), "ready", this).call(this);
        this.setAttribute('role', 'checkbox');
        this._nativeCheckbox = this.shadowRoot.querySelector('input[type="checkbox"]');
        this.addEventListener('click', this._handleClick.bind(this));

        this._addActiveListeners();

        var attrName = this.getAttribute('name');

        if (attrName) {
          this.name = attrName;
        }

        this.shadowRoot.querySelector('[part~="label"]').querySelector('slot').addEventListener('slotchange', this._updateLabelAttribute.bind(this));

        this._updateLabelAttribute();
      }
      /** @private */

    }, {
      key: "_updateLabelAttribute",
      value: function _updateLabelAttribute() {
        var label = this.shadowRoot.querySelector('[part~="label"]');
        var assignedNodes = label.firstElementChild.assignedNodes();

        if (this._isAssignedNodesEmpty(assignedNodes)) {
          label.setAttribute('empty', '');
        } else {
          label.removeAttribute('empty');
        }
      }
      /** @private */

    }, {
      key: "_isAssignedNodesEmpty",
      value: function _isAssignedNodesEmpty(nodes) {
        // The assigned nodes considered to be empty if there is no slotted content or only one empty text node
        return nodes.length === 0 || nodes.length == 1 && nodes[0].nodeType == Node.TEXT_NODE && nodes[0].textContent.trim() === '';
      }
      /** @private */

    }, {
      key: "_checkedChanged",
      value: function _checkedChanged(checked) {
        if (this.indeterminate) {
          this.setAttribute('aria-checked', 'mixed');
        } else {
          this.setAttribute('aria-checked', Boolean(checked));
        }
      }
      /** @private */

    }, {
      key: "_indeterminateChanged",
      value: function _indeterminateChanged(indeterminate) {
        if (indeterminate) {
          this.setAttribute('aria-checked', 'mixed');
        } else {
          this.setAttribute('aria-checked', this.checked);
        }
      }
      /** @private */

    }, {
      key: "_addActiveListeners",
      value: function _addActiveListeners() {
        var _this2 = this;

        // DOWN
        this._addEventListenerToNode(this, 'down', function (e) {
          if (_this2.__interactionsAllowed(e)) {
            _this2.setAttribute('active', '');
          }
        }); // UP


        this._addEventListenerToNode(this, 'up', function () {
          return _this2.removeAttribute('active');
        }); // KEYDOWN


        this.addEventListener('keydown', function (e) {
          if (_this2.__interactionsAllowed(e) && e.keyCode === 32) {
            e.preventDefault();

            _this2.setAttribute('active', '');
          }
        }); // KEYUP

        this.addEventListener('keyup', function (e) {
          if (_this2.__interactionsAllowed(e) && e.keyCode === 32) {
            e.preventDefault();

            _this2._toggleChecked();

            _this2.removeAttribute('active');

            if (_this2.indeterminate) {
              _this2.indeterminate = false;
            }
          }
        });
      }
      /**
       * @return {!HTMLInputElement}
       * @protected
       */

    }, {
      key: "focusElement",
      get: function get() {
        return this.shadowRoot.querySelector('input');
      }
      /**
       * True if users' interactions (mouse or keyboard)
       * should toggle the checkbox
       */

    }, {
      key: "__interactionsAllowed",
      value: function __interactionsAllowed(e) {
        if (this.disabled) {
          return false;
        } // https://github.com/vaadin/vaadin-checkbox/issues/63


        if (e.target.localName === 'a') {
          return false;
        }

        return true;
      }
      /** @private */

    }, {
      key: "_handleClick",
      value: function _handleClick(e) {
        if (this.__interactionsAllowed(e)) {
          if (!this.indeterminate) {
            if (e.composedPath()[0] !== this._nativeCheckbox) {
              e.preventDefault();

              this._toggleChecked();
            }
          } else {
            /*
             * Required for IE 11 and Edge.
             * See issue here: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7344418/
             */
            this.indeterminate = false;
            e.preventDefault();

            this._toggleChecked();
          }
        }
      }
      /** @protected */

    }, {
      key: "_toggleChecked",
      value: function _toggleChecked() {
        this.checked = !this.checked;
        this.dispatchEvent(new CustomEvent('change', {
          composed: false,
          bubbles: true
        }));
      }
      /**
       * Fired when the user commits a value change.
       *
       * @event change
       */

    }], [{
      key: "template",
      get: function get() {
        return (0, _htmlTag.html)(_templateObject_a340fa30942811ecb1937969798b231a || (_templateObject_a340fa30942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      label {\n        display: inline-flex;\n        align-items: baseline;\n        outline: none;\n      }\n\n      [part=\"checkbox\"] {\n        position: relative;\n        display: inline-block;\n        flex: none;\n      }\n\n      input[type=\"checkbox\"] {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        width: 100%;\n        height: 100%;\n        opacity: 0;\n        cursor: inherit;\n        margin: 0;\n      }\n\n      :host([disabled]) {\n        -webkit-tap-highlight-color: transparent;\n      }\n    </style>\n\n    <label>\n      <span part=\"checkbox\">\n        <input type=\"checkbox\" checked=\"{{checked::change}}\" disabled$=\"[[disabled]]\" indeterminate=\"{{indeterminate::change}}\" role=\"presentation\" tabindex=\"-1\">\n      </span>\n\n      <span part=\"label\">\n        <slot></slot>\n      </span>\n    </label>\n"], ["\n    <style>\n      :host {\n        display: inline-block;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      label {\n        display: inline-flex;\n        align-items: baseline;\n        outline: none;\n      }\n\n      [part=\"checkbox\"] {\n        position: relative;\n        display: inline-block;\n        flex: none;\n      }\n\n      input[type=\"checkbox\"] {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        width: 100%;\n        height: 100%;\n        opacity: 0;\n        cursor: inherit;\n        margin: 0;\n      }\n\n      :host([disabled]) {\n        -webkit-tap-highlight-color: transparent;\n      }\n    </style>\n\n    <label>\n      <span part=\"checkbox\">\n        <input type=\"checkbox\" checked=\"{{checked::change}}\" disabled\\$=\"[[disabled]]\" indeterminate=\"{{indeterminate::change}}\" role=\"presentation\" tabindex=\"-1\">\n      </span>\n\n      <span part=\"label\">\n        <slot></slot>\n      </span>\n    </label>\n"])));
      }
    }, {
      key: "is",
      get: function get() {
        return 'vaadin-checkbox';
      }
    }, {
      key: "version",
      get: function get() {
        return '2.5.0';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * True if the checkbox is checked.
           * @type {boolean}
           */
          checked: {
            type: Boolean,
            value: false,
            notify: true,
            observer: '_checkedChanged',
            reflectToAttribute: true
          },

          /**
           * Indeterminate state of the checkbox when it's neither checked nor unchecked, but undetermined.
           * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Indeterminate_state_checkboxes
           * @type {boolean}
           */
          indeterminate: {
            type: Boolean,
            notify: true,
            observer: '_indeterminateChanged',
            reflectToAttribute: true,
            value: false
          },

          /**
           * The value given to the data submitted with the checkbox's name to the server when the control is inside a form.
           */
          value: {
            type: String,
            value: 'on'
          },

          /** @private */
          _nativeCheckbox: {
            type: Object
          }
        };
      }
    }]);
    return CheckboxElement;
  }((0, _vaadinElementMixin.ElementMixin)((0, _vaadinControlStateMixin.ControlStateMixin)((0, _vaadinThemableMixin.ThemableMixin)((0, _gestureEventListeners.GestureEventListeners)(_polymerElement.PolymerElement)))));

  _exports.CheckboxElement = CheckboxElement;
  customElements.define(CheckboxElement.is, CheckboxElement);
});