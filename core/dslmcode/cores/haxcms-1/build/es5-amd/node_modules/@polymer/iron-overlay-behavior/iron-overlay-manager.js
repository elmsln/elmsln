define(["exports", "../polymer/polymer-legacy.js", "./iron-overlay-backdrop.js", "../iron-a11y-keys-behavior/iron-a11y-keys-behavior.js", "../polymer/lib/legacy/polymer.dom.js", "../polymer/lib/utils/gestures.js"], function (_exports, _polymerLegacy, _ironOverlayBackdrop, _ironA11yKeysBehavior, _polymerDom, gestures) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.IronOverlayManagerClass = _exports.IronOverlayManager = void 0;
  gestures = _interopRequireWildcard(gestures);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  /**
  @license
  Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at
  http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
  http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
  found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
  part of the polymer project is also subject to an additional IP rights grant
  found at http://polymer.github.io/PATENTS.txt
  */

  /**
   * @package
   */
  var IronOverlayManagerClass = /*#__PURE__*/function () {
    function IronOverlayManagerClass() {
      babelHelpers.classCallCheck(this, IronOverlayManagerClass);

      /**
       * Used to keep track of the opened overlays.
       * @private {!Array<!Element>}
       */
      this._overlays = [];
      /**
       * iframes have a default z-index of 100,
       * so this default should be at least that.
       * @private {number}
       */

      this._minimumZ = 101;
      /**
       * Memoized backdrop element.
       * @private {Element|null}
       */

      this._backdropElement = null; // Enable document-wide tap recognizer.
      // NOTE: Use useCapture=true to avoid accidentally prevention of the closing
      // of an overlay via event.stopPropagation(). The only way to prevent
      // closing of an overlay should be through its APIs.
      // NOTE: enable tap on <html> to workaround Polymer/polymer#4459
      // Pass no-op function because MSEdge 15 doesn't handle null as 2nd argument
      // https://github.com/Microsoft/ChakraCore/issues/3863

      gestures.addListener(document.documentElement, 'tap', function () {});
      document.addEventListener('tap', this._onCaptureClick.bind(this), true);
      document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
      document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);
    }
    /**
     * The shared backdrop element.
     * @return {!Element} backdropElement
     */


    babelHelpers.createClass(IronOverlayManagerClass, [{
      key: "backdropElement",
      get: function get() {
        if (!this._backdropElement) {
          this._backdropElement = document.createElement('iron-overlay-backdrop');
        }

        return this._backdropElement;
      }
      /**
       * The deepest active element.
       * @return {!Element} activeElement the active element
       */

    }, {
      key: "deepActiveElement",
      get: function get() {
        var active = document.activeElement; // document.activeElement can be null
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
        // In IE 11, it can also be an object when operating in iframes.
        // In these cases, default it to document.body.

        if (!active || babelHelpers.instanceof(active, Element) === false) {
          active = document.body;
        }

        while (active.root && (0, _polymerDom.dom)(active.root).activeElement) {
          active = (0, _polymerDom.dom)(active.root).activeElement;
        }

        return active;
      }
      /**
       * Brings the overlay at the specified index to the front.
       * @param {number} i
       * @private
       */

    }, {
      key: "_bringOverlayAtIndexToFront",
      value: function _bringOverlayAtIndexToFront(i) {
        var overlay = this._overlays[i];

        if (!overlay) {
          return;
        }

        var lastI = this._overlays.length - 1;
        var currentOverlay = this._overlays[lastI]; // Ensure always-on-top overlay stays on top.

        if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
          lastI--;
        } // If already the top element, return.


        if (i >= lastI) {
          return;
        } // Update z-index to be on top.


        var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);

        if (this._getZ(overlay) <= minimumZ) {
          this._applyOverlayZ(overlay, minimumZ);
        } // Shift other overlays behind the new on top.


        while (i < lastI) {
          this._overlays[i] = this._overlays[i + 1];
          i++;
        }

        this._overlays[lastI] = overlay;
      }
      /**
       * Adds the overlay and updates its z-index if it's opened, or removes it if
       * it's closed. Also updates the backdrop z-index.
       * @param {!Element} overlay
       */

    }, {
      key: "addOrRemoveOverlay",
      value: function addOrRemoveOverlay(overlay) {
        if (overlay.opened) {
          this.addOverlay(overlay);
        } else {
          this.removeOverlay(overlay);
        }
      }
      /**
       * Tracks overlays for z-index and focus management.
       * Ensures the last added overlay with always-on-top remains on top.
       * @param {!Element} overlay
       */

    }, {
      key: "addOverlay",
      value: function addOverlay(overlay) {
        var i = this._overlays.indexOf(overlay);

        if (i >= 0) {
          this._bringOverlayAtIndexToFront(i);

          this.trackBackdrop();
          return;
        }

        var insertionIndex = this._overlays.length;
        var currentOverlay = this._overlays[insertionIndex - 1];
        var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);

        var newZ = this._getZ(overlay); // Ensure always-on-top overlay stays on top.


        if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
          // This bumps the z-index of +2.
          this._applyOverlayZ(currentOverlay, minimumZ);

          insertionIndex--; // Update minimumZ to match previous overlay's z-index.

          var previousOverlay = this._overlays[insertionIndex - 1];
          minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
        } // Update z-index and insert overlay.


        if (newZ <= minimumZ) {
          this._applyOverlayZ(overlay, minimumZ);
        }

        this._overlays.splice(insertionIndex, 0, overlay);

        this.trackBackdrop();
      }
      /**
       * @param {!Element} overlay
       */

    }, {
      key: "removeOverlay",
      value: function removeOverlay(overlay) {
        var i = this._overlays.indexOf(overlay);

        if (i === -1) {
          return;
        }

        this._overlays.splice(i, 1);

        this.trackBackdrop();
      }
      /**
       * Returns the current overlay.
       * @return {!Element|undefined}
       */

    }, {
      key: "currentOverlay",
      value: function currentOverlay() {
        var i = this._overlays.length - 1;
        return this._overlays[i];
      }
      /**
       * Returns the current overlay z-index.
       * @return {number}
       */

    }, {
      key: "currentOverlayZ",
      value: function currentOverlayZ() {
        return this._getZ(this.currentOverlay());
      }
      /**
       * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
       * This does not effect the z-index of any existing overlays.
       * @param {number} minimumZ
       */

    }, {
      key: "ensureMinimumZ",
      value: function ensureMinimumZ(minimumZ) {
        this._minimumZ = Math.max(this._minimumZ, minimumZ);
      }
    }, {
      key: "focusOverlay",
      value: function focusOverlay() {
        var current =
        /** @type {?} */
        this.currentOverlay();

        if (current) {
          current._applyFocus();
        }
      }
      /**
       * Updates the backdrop z-index.
       */

    }, {
      key: "trackBackdrop",
      value: function trackBackdrop() {
        var overlay = this._overlayWithBackdrop(); // Avoid creating the backdrop if there is no overlay with backdrop.


        if (!overlay && !this._backdropElement) {
          return;
        }

        this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
        this.backdropElement.opened = !!overlay; // Property observers are not fired until element is attached
        // in Polymer 2.x, so we ensure element is attached if needed.
        // https://github.com/Polymer/polymer/issues/4526

        this.backdropElement.prepare();
      }
      /**
       * @return {!Array<!Element>}
       */

    }, {
      key: "getBackdrops",
      value: function getBackdrops() {
        var backdrops = [];

        for (var i = 0; i < this._overlays.length; i++) {
          if (this._overlays[i].withBackdrop) {
            backdrops.push(this._overlays[i]);
          }
        }

        return backdrops;
      }
      /**
       * Returns the z-index for the backdrop.
       * @return {number}
       */

    }, {
      key: "backdropZ",
      value: function backdropZ() {
        return this._getZ(this._overlayWithBackdrop()) - 1;
      }
      /**
       * Returns the top opened overlay that has a backdrop.
       * @return {!Element|undefined}
       * @private
       */

    }, {
      key: "_overlayWithBackdrop",
      value: function _overlayWithBackdrop() {
        for (var i = this._overlays.length - 1; i >= 0; i--) {
          if (this._overlays[i].withBackdrop) {
            return this._overlays[i];
          }
        }
      }
      /**
       * Calculates the minimum z-index for the overlay.
       * @param {Element=} overlay
       * @private
       */

    }, {
      key: "_getZ",
      value: function _getZ(overlay) {
        var z = this._minimumZ;

        if (overlay) {
          var z1 = Number(overlay.style.zIndex || window.getComputedStyle(overlay).zIndex); // Check if is a number
          // Number.isNaN not supported in IE 10+

          if (z1 === z1) {
            z = z1;
          }
        }

        return z;
      }
      /**
       * @param {!Element} element
       * @param {number|string} z
       * @private
       */

    }, {
      key: "_setZ",
      value: function _setZ(element, z) {
        element.style.zIndex = z;
      }
      /**
       * @param {!Element} overlay
       * @param {number} aboveZ
       * @private
       */

    }, {
      key: "_applyOverlayZ",
      value: function _applyOverlayZ(overlay, aboveZ) {
        this._setZ(overlay, aboveZ + 2);
      }
      /**
       * Returns the deepest overlay in the path.
       * @param {!Array<!Element>=} path
       * @return {!Element|undefined}
       * @suppress {missingProperties}
       * @private
       */

    }, {
      key: "_overlayInPath",
      value: function _overlayInPath(path) {
        path = path || [];

        for (var i = 0; i < path.length; i++) {
          if (path[i]._manager === this) {
            return path[i];
          }
        }
      }
      /**
       * Ensures the click event is delegated to the right overlay.
       * @param {!Event} event
       * @private
       */

    }, {
      key: "_onCaptureClick",
      value: function _onCaptureClick(event) {
        var i = this._overlays.length - 1;
        if (i === -1) return;
        var path =
        /** @type {!Array<!EventTarget>} */
        (0, _polymerDom.dom)(event).path;
        var overlay; // Check if clicked outside of overlay.

        while ((overlay =
        /** @type {?} */
        this._overlays[i]) && this._overlayInPath(path) !== overlay) {
          overlay._onCaptureClick(event);

          if (overlay.allowClickThrough) {
            i--;
          } else {
            break;
          }
        }
      }
      /**
       * Ensures the focus event is delegated to the right overlay.
       * @param {!Event} event
       * @private
       */

    }, {
      key: "_onCaptureFocus",
      value: function _onCaptureFocus(event) {
        var overlay =
        /** @type {?} */
        this.currentOverlay();

        if (overlay) {
          overlay._onCaptureFocus(event);
        }
      }
      /**
       * Ensures TAB and ESC keyboard events are delegated to the right overlay.
       * @param {!Event} event
       * @private
       */

    }, {
      key: "_onCaptureKeyDown",
      value: function _onCaptureKeyDown(event) {
        var overlay =
        /** @type {?} */
        this.currentOverlay();

        if (overlay) {
          if (_ironA11yKeysBehavior.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'esc')) {
            overlay._onCaptureEsc(event);
          } else if (_ironA11yKeysBehavior.IronA11yKeysBehavior.keyboardEventMatchesKeys(event, 'tab')) {
            overlay._onCaptureTab(event);
          }
        }
      }
      /**
       * Returns if the overlay1 should be behind overlay2.
       * @param {!Element} overlay1
       * @param {!Element} overlay2
       * @return {boolean}
       * @suppress {missingProperties}
       * @private
       */

    }, {
      key: "_shouldBeBehindOverlay",
      value: function _shouldBeBehindOverlay(overlay1, overlay2) {
        return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;
      }
    }]);
    return IronOverlayManagerClass;
  }();

  _exports.IronOverlayManagerClass = IronOverlayManagerClass;
  ;
  var IronOverlayManager = new IronOverlayManagerClass();
  _exports.IronOverlayManager = IronOverlayManager;
});