define(["../../polymer/polymer-legacy.js", "../../iron-flex-layout/iron-flex-layout.js", "../../polymer/lib/legacy/polymer-fn.js", "../../polymer/lib/legacy/polymer.dom.js", "../../polymer/lib/utils/html-tag.js", "../app-layout-behavior/app-layout-behavior.js"], function (_polymerLegacy, _ironFlexLayout, _polymerFn, _polymerDom, _htmlTag, _appLayoutBehavior) {
  "use strict";

  var _templateObject_1fe6b9e0942811ecb1937969798b231a;

  /**
  app-header-layout is a wrapper element that positions an app-header and other
  content. This element uses the document scroll by default, but it can also
  define its own scrolling region.
  
  Using the document scroll:
  
  ```html
  <app-header-layout>
    <app-header slot="header" fixed condenses effects="waterfall">
      <app-toolbar>
        <div main-title>App name</div>
      </app-toolbar>
    </app-header>
    <div>
      main content
    </div>
  </app-header-layout>
  ```
  
  Using an own scrolling region:
  
  ```html
  <app-header-layout has-scrolling-region style="width: 300px; height: 400px;">
    <app-header slot="header" fixed condenses effects="waterfall">
      <app-toolbar>
        <div main-title>App name</div>
      </app-toolbar>
    </app-header>
    <div>
      main content
    </div>
  </app-header-layout>
  ```
  
  Add the `fullbleed` attribute to app-header-layout to make it fit the size of
  its container:
  
  ```html
  <app-header-layout fullbleed>
   ...
  </app-header-layout>
  ```
  
  @element app-header-layout
  @demo app-header-layout/demo/simple.html Simple Demo
  @demo app-header-layout/demo/scrolling-region.html Scrolling Region
  @demo app-header-layout/demo/music.html Music Demo
  @demo app-header-layout/demo/footer.html Footer Demo
  */
  (0, _polymerFn.Polymer)({
    /** @override */
    _template: (0, _htmlTag.html)(_templateObject_1fe6b9e0942811ecb1937969798b231a || (_templateObject_1fe6b9e0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: block;\n        /**\n         * Force app-header-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\n         * This could be done using `isolation: isolate`, but that's not well supported\n         * across browsers.\n         */\n        position: relative;\n        z-index: 0;\n      }\n\n      #wrapper ::slotted([slot=header]) {\n        @apply --layout-fixed-top;\n        z-index: 1;\n      }\n\n      #wrapper.initializing ::slotted([slot=header]) {\n        position: relative;\n      }\n\n      :host([has-scrolling-region]) {\n        height: 100%;\n      }\n\n      :host([has-scrolling-region]) #wrapper ::slotted([slot=header]) {\n        position: absolute;\n      }\n\n      :host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]) {\n        position: relative;\n      }\n\n      :host([has-scrolling-region]) #wrapper #contentContainer {\n        @apply --layout-fit;\n        overflow-y: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\n        position: relative;\n      }\n\n      :host([fullbleed]) {\n        @apply --layout-vertical;\n        @apply --layout-fit;\n      }\n\n      :host([fullbleed]) #wrapper,\n      :host([fullbleed]) #wrapper #contentContainer {\n        @apply --layout-vertical;\n        @apply --layout-flex;\n      }\n\n      #contentContainer {\n        /* Create a stacking context here so that all children appear below the header. */\n        position: relative;\n        z-index: 0;\n      }\n\n      @media print {\n        :host([has-scrolling-region]) #wrapper #contentContainer {\n          overflow-y: visible;\n        }\n      }\n\n    </style>\n\n    <div id=\"wrapper\" class=\"initializing\">\n      <slot id=\"headerSlot\" name=\"header\"></slot>\n\n      <div id=\"contentContainer\">\n        <slot></slot>\n      </div>\n    </div>\n"], ["\n    <style>\n      :host {\n        display: block;\n        /**\n         * Force app-header-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\n         * This could be done using \\`isolation: isolate\\`, but that's not well supported\n         * across browsers.\n         */\n        position: relative;\n        z-index: 0;\n      }\n\n      #wrapper ::slotted([slot=header]) {\n        @apply --layout-fixed-top;\n        z-index: 1;\n      }\n\n      #wrapper.initializing ::slotted([slot=header]) {\n        position: relative;\n      }\n\n      :host([has-scrolling-region]) {\n        height: 100%;\n      }\n\n      :host([has-scrolling-region]) #wrapper ::slotted([slot=header]) {\n        position: absolute;\n      }\n\n      :host([has-scrolling-region]) #wrapper.initializing ::slotted([slot=header]) {\n        position: relative;\n      }\n\n      :host([has-scrolling-region]) #wrapper #contentContainer {\n        @apply --layout-fit;\n        overflow-y: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\n        position: relative;\n      }\n\n      :host([fullbleed]) {\n        @apply --layout-vertical;\n        @apply --layout-fit;\n      }\n\n      :host([fullbleed]) #wrapper,\n      :host([fullbleed]) #wrapper #contentContainer {\n        @apply --layout-vertical;\n        @apply --layout-flex;\n      }\n\n      #contentContainer {\n        /* Create a stacking context here so that all children appear below the header. */\n        position: relative;\n        z-index: 0;\n      }\n\n      @media print {\n        :host([has-scrolling-region]) #wrapper #contentContainer {\n          overflow-y: visible;\n        }\n      }\n\n    </style>\n\n    <div id=\"wrapper\" class=\"initializing\">\n      <slot id=\"headerSlot\" name=\"header\"></slot>\n\n      <div id=\"contentContainer\">\n        <slot></slot>\n      </div>\n    </div>\n"]))),
    is: 'app-header-layout',
    behaviors: [_appLayoutBehavior.AppLayoutBehavior],
    properties: {
      /**
       * If true, the current element will have its own scrolling region.
       * Otherwise, it will use the document scroll to control the header.
       */
      hasScrollingRegion: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    },
    observers: ['resetLayout(isAttached, hasScrollingRegion)'],

    /**
     * A reference to the app-header element.
     *
     * @property header
     */
    get header() {
      return (0, _polymerDom.dom)(this.$.headerSlot).getDistributedNodes()[0];
    },

    _updateLayoutStates: function _updateLayoutStates() {
      var header = this.header;

      if (!this.isAttached || !header) {
        return;
      } // Remove the initializing class, which staticly positions the header and
      // the content until the height of the header can be read.


      this.$.wrapper.classList.remove('initializing'); // Update scroll target.

      header.scrollTarget = this.hasScrollingRegion ? this.$.contentContainer : this.ownerDocument.documentElement; // Get header height here so that style reads are batched together before
      // style writes (i.e. getBoundingClientRect() below).

      var headerHeight = header.offsetHeight; // Update the header position.

      if (!this.hasScrollingRegion) {
        requestAnimationFrame(function () {
          var rect = this.getBoundingClientRect();
          var rightOffset = document.documentElement.clientWidth - rect.right;
          header.style.left = rect.left + 'px';
          header.style.right = rightOffset + 'px';
        }.bind(this));
      } else {
        header.style.left = '';
        header.style.right = '';
      } // Update the content container position.


      var containerStyle = this.$.contentContainer.style;

      if (header.fixed && !header.condenses && this.hasScrollingRegion) {
        // If the header size does not change and we're using a scrolling region,
        // exclude the header area from the scrolling region so that the header
        // doesn't overlap the scrollbar.
        containerStyle.marginTop = headerHeight + 'px';
        containerStyle.paddingTop = '';
      } else {
        containerStyle.paddingTop = headerHeight + 'px';
        containerStyle.marginTop = '';
      }
    }
  });
});