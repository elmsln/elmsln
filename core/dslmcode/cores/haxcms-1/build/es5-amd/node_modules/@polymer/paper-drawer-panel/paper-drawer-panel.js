define(["../polymer/polymer-legacy.js", "../iron-media-query/iron-media-query.js", "../iron-selector/iron-selector.js", "../iron-resizable-behavior/iron-resizable-behavior.js", "../polymer/lib/legacy/polymer-fn.js", "../polymer/lib/legacy/polymer.dom.js", "../polymer/lib/utils/html-tag.js"], function (_polymerLegacy, _ironMediaQuery, _ironSelector, _ironResizableBehavior, _polymerFn, _polymerDom, _htmlTag) {
  "use strict";

  var _templateObject_551678b0809211edaa2833647dc78c6c;

  // this would be the only `paper-drawer-panel` in
  // the whole app that can be in `dragging` state
  var sharedPanel = null;

  function classNames(obj) {
    var classes = [];

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key]) {
        classes.push(key);
      }
    }

    return classes.join(' ');
  }
  /**
  **This element has been deprecated in favor of
  [app-layout](https://github.com/PolymerElements/app-layout).**
  
  Material design: [Navigation
  drawer](https://www.google.com/design/spec/patterns/navigation-drawer.html)
  
  `paper-drawer-panel` contains a drawer panel and a main panel. The drawer
  and the main panel are side-by-side with drawer on the left. When the browser
  window size is smaller than the `responsiveWidth`, `paper-drawer-panel`
  changes to narrow layout. In narrow layout, the drawer will be stacked on top
  of the main panel. The drawer will slide in/out to hide/reveal the main
  panel.
  
  Use the attribute `drawer` to indicate that the element is the drawer panel and
  `main` to indicate that the element is the main panel.
  
  Example:
  
      <paper-drawer-panel>
        <div slot="drawer"> Drawer panel... </div>
        <div slot="main"> Main panel... </div>
      </paper-drawer-panel>
  
  The drawer and the main panels are not scrollable. You can set CSS overflow
  property on the elements to make them scrollable or use `paper-header-panel`.
  
  Example:
  
      <paper-drawer-panel>
        <paper-header-panel slot="drawer">
          <paper-toolbar></paper-toolbar>
          <div> Drawer content... </div>
        </paper-header-panel>
        <paper-header-panel slot="main">
          <paper-toolbar></paper-toolbar>
          <div> Main content... </div>
        </paper-header-panel>
      </paper-drawer-panel>
  
  To position the drawer to the right, add `right-drawer` attribute.
  
      <paper-drawer-panel right-drawer>
        <div slot="drawer"> Drawer panel... </div>
        <div slot="main"> Main panel... </div>
      </paper-drawer-panel>
  
  ### Styling
  
  To change the main container:
  
      paper-drawer-panel {
        --paper-drawer-panel-main-container: {
          background-color: gray;
        };
      }
  
  To change the drawer container when it's in the left side:
  
      paper-drawer-panel {
        --paper-drawer-panel-left-drawer-container: {
          background-color: white;
        };
      }
  
  To change the drawer container when it's in the right side:
  
      paper-drawer-panel {
        --paper-drawer-panel-right-drawer-container: {
          background-color: white;
        };
      }
  
  To customize the scrim:
  
      paper-drawer-panel {
        --paper-drawer-panel-scrim: {
          background-color: red;
        };
      }
  
  The following custom properties and mixins are available for styling:
  
  Custom property | Description | Default
  ----------------|-------------|----------
  `--paper-drawer-panel-scrim-opacity` | Scrim opacity | 1
  `--paper-drawer-panel-drawer-container` | Mixin applied to drawer container | {}
  `--paper-drawer-panel-left-drawer-container` | Mixin applied to container when it's in the left side | {}
  `--paper-drawer-panel-main-container` | Mixin applied to main container | {}
  `--paper-drawer-panel-right-drawer-container` | Mixin applied to container when it's in the right side | {}
  `--paper-drawer-panel-scrim` | Mixin applied to scrim | {}
  
  @group Paper elements
  @element paper-drawer-panel
  @demo demo/index.html
  @hero hero.svg
  */


  (0, _polymerFn.Polymer)({
    _template: (0, _htmlTag.html)(_templateObject_551678b0809211edaa2833647dc78c6c || (_templateObject_551678b0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: block;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        overflow: hidden;\n      }\n\n      #drawer {\n        position: absolute;\n        top: 0;\n        left: 0;\n        height: 100%;\n        background-color: white;\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n        @apply --paper-drawer-panel-drawer-container;\n      }\n\n      .transition-drawer {\n        transition: -webkit-transform ease-in-out 0.3s, width ease-in-out 0.3s, visibility 0.3s;\n        transition: transform ease-in-out 0.3s, width ease-in-out 0.3s, visibility 0.3s;\n      }\n\n      .left-drawer > #drawer {\n        @apply --paper-drawer-panel-left-drawer-container;\n      }\n\n      .right-drawer > #drawer {\n        left: auto;\n        right: 0;\n        @apply --paper-drawer-panel-right-drawer-container;\n      }\n\n      #main {\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        @apply --paper-drawer-panel-main-container;\n      }\n\n      .transition > #main {\n        transition: left ease-in-out 0.3s, padding ease-in-out 0.3s;\n      }\n\n      .right-drawer > #main {\n        left: 0;\n      }\n\n      .right-drawer.transition > #main {\n        transition: right ease-in-out 0.3s, padding ease-in-out 0.3s;\n      }\n\n      #main > ::slotted(*) {\n        height: 100%;\n      }\n\n      #drawer > ::slotted(*) {\n        height: 100%;\n      }\n\n      #scrim {\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        visibility: hidden;\n        opacity: 0;\n        transition: opacity ease-in-out 0.38s, visibility ease-in-out 0.38s;\n        background-color: rgba(0, 0, 0, 0.3);\n        @apply --paper-drawer-panel-scrim;\n      }\n\n      .narrow-layout > #drawer {\n        will-change: transform;\n      }\n\n      .narrow-layout > #drawer.iron-selected {\n        box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.15);\n      }\n\n      .right-drawer.narrow-layout > #drawer.iron-selected {\n        box-shadow: -2px 2px 4px rgba(0, 0, 0, 0.15);\n      }\n\n      .narrow-layout > #drawer > ::slotted(*) {\n        border: 0;\n      }\n\n      .left-drawer.narrow-layout > #drawer:not(.iron-selected) {\n        visibility: hidden;\n        -webkit-transform: translateX(-100%);\n        transform: translateX(-100%);\n      }\n\n      .right-drawer.narrow-layout > #drawer:not(.iron-selected) {\n        left: auto;\n        visibility: hidden;\n        -webkit-transform: translateX(100%);\n        transform: translateX(100%);\n      }\n\n      .left-drawer.dragging > #drawer:not(.iron-selected),\n      .left-drawer.peeking > #drawer:not(.iron-selected),\n      .right-drawer.dragging > #drawer:not(.iron-selected),\n      .right-drawer.peeking > #drawer:not(.iron-selected) {\n        visibility: visible;\n      }\n\n      .narrow-layout > #main {\n        padding: 0;\n      }\n\n      .right-drawer.narrow-layout > #main {\n        left: 0;\n        right: 0;\n      }\n\n      .narrow-layout > #main:not(.iron-selected) > #scrim,\n      .dragging > #main > #scrim {\n        visibility: visible;\n        opacity: var(--paper-drawer-panel-scrim-opacity, 1);\n      }\n\n      .narrow-layout > #main > * {\n        margin: 0;\n        min-height: 100%;\n        left: 0;\n        right: 0;\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n      }\n    </style>\n\n    <iron-media-query id=\"mq\" on-query-matches-changed=\"_onQueryMatchesChanged\" query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\">\n    </iron-media-query>\n\n    <iron-selector attr-for-selected=\"id\" class$=\"[[_computeIronSelectorClass(narrow, _transition, dragging, rightDrawer, peeking)]]\" on-transitionend=\"_onTransitionEnd\" activate-event selected=\"[[selected]]\">\n\n      <div id=\"main\">\n        <slot name=\"main\"></slot>\n        <div id=\"scrim\" on-tap=\"closeDrawer\"></div>\n      </div>\n\n      <div id=\"drawer\">\n        <slot id=\"drawerSlot\" name=\"drawer\"></slot>\n      </div>\n\n    </iron-selector>\n"]))),
    is: 'paper-drawer-panel',
    behaviors: [_ironResizableBehavior.IronResizableBehavior],

    /**
     * Fired when the narrow layout changes.
     *
     * @event paper-responsive-change {{narrow: boolean}} detail -
     *     narrow: true if the panel is in narrow layout.
     */

    /**
     * Fired when the a panel is selected.
     *
     * Listening for this event is an alternative to observing changes in the
     * `selected` attribute. This event is fired both when a panel is selected.
     *
     * @event iron-select {{item: Object}} detail -
     *     item: The panel that the event refers to.
     */

    /**
     * Fired when a panel is deselected.
     *
     * Listening for this event is an alternative to observing changes in the
     * `selected` attribute. This event is fired both when a panel is deselected.
     *
     * @event iron-deselect {{item: Object}} detail -
     *     item: The panel that the event refers to.
     */
    properties: {
      /**
       * The panel to be selected when `paper-drawer-panel` changes to narrow
       * layout.
       */
      defaultSelected: {
        type: String,
        value: 'main'
      },

      /**
       * If true, swipe from the edge is disabled.
       */
      disableEdgeSwipe: {
        type: Boolean,
        value: false
      },

      /**
       * If true, swipe to open/close the drawer is disabled.
       */
      disableSwipe: {
        type: Boolean,
        value: false
      },

      /**
       * Whether the user is dragging the drawer interactively.
       */
      dragging: {
        type: Boolean,
        value: false,
        readOnly: true,
        notify: true
      },

      /**
       * Width of the drawer panel.
       */
      drawerWidth: {
        type: String,
        value: '256px'
      },

      /**
       * The attribute on elements that should toggle the drawer on tap, also
       * elements will automatically be hidden in wide layout.
       */
      drawerToggleAttribute: {
        type: String,
        value: 'paper-drawer-toggle'
      },

      /**
       * How many pixels on the side of the screen are sensitive to edge
       * swipes and peek.
       */
      edgeSwipeSensitivity: {
        type: Number,
        value: 30
      },

      /**
       * If true, ignore `responsiveWidth` setting and force the narrow layout.
       */
      forceNarrow: {
        type: Boolean,
        value: false
      },

      /**
       * Whether the browser has support for the transform CSS property.
       */
      hasTransform: {
        type: Boolean,
        value: function value() {
          return 'transform' in this.style;
        }
      },

      /**
       * Whether the browser has support for the will-change CSS property.
       */
      hasWillChange: {
        type: Boolean,
        value: function value() {
          return 'willChange' in this.style;
        }
      },

      /**
       * Returns true if the panel is in narrow layout.  This is useful if you
       * need to show/hide elements based on the layout.
       */
      narrow: {
        reflectToAttribute: true,
        type: Boolean,
        value: false,
        readOnly: true,
        notify: true
      },

      /**
       * Whether the drawer is peeking out from the edge.
       */
      peeking: {
        type: Boolean,
        value: false,
        readOnly: true,
        notify: true
      },

      /**
       * Max-width when the panel changes to narrow layout.
       */
      responsiveWidth: {
        type: String,
        value: '768px'
      },

      /**
       * If true, position the drawer to the right.
       */
      rightDrawer: {
        type: Boolean,
        value: false
      },

      /**
       * The panel that is being selected. `drawer` for the drawer panel and
       * `main` for the main panel.
       *
       * @type {string|null}
       */
      selected: {
        reflectToAttribute: true,
        notify: true,
        type: String,
        value: null
      },

      /**
       * The CSS selector for the element that should receive focus when the
       * drawer is open. By default, when the drawer opens, it focuses the first
       * tabbable element. That is, the first element that can receive focus.
       *
       * To disable this behavior, you can set `drawerFocusSelector` to `null` or
       * an empty string.
       *
       */
      drawerFocusSelector: {
        type: String,
        value: 'a[href]:not([tabindex="-1"]),' + 'area[href]:not([tabindex="-1"]),' + 'input:not([disabled]):not([tabindex="-1"]),' + 'select:not([disabled]):not([tabindex="-1"]),' + 'textarea:not([disabled]):not([tabindex="-1"]),' + 'button:not([disabled]):not([tabindex="-1"]),' + 'iframe:not([tabindex="-1"]),' + '[tabindex]:not([tabindex="-1"]),' + '[contentEditable=true]:not([tabindex="-1"])'
      },

      /**
       * Whether the transition is enabled.
       */
      _transition: {
        type: Boolean,
        value: false
      }
    },
    listeners: {
      tap: '_onTap',
      track: '_onTrack',
      down: '_downHandler',
      up: '_upHandler'
    },
    observers: ['_forceNarrowChanged(forceNarrow, defaultSelected)', '_toggleFocusListener(selected)', '_setMainStyle(narrow, rightDrawer, drawerWidth)', '_setDrawerStyle(drawerWidth)'],
    ready: function ready() {
      // Avoid transition at the beginning e.g. page loads and enable
      // transitions only after the element is rendered and ready.
      this._transition = true;
      this._boundFocusListener = this._didFocus.bind(this);
      console.warn(this.is, 'is deprecated. Please use app-layout instead!');
    },

    /**
     * Toggles the panel open and closed.
     *
     * @method togglePanel
     */
    togglePanel: function togglePanel() {
      if (this._isMainSelected()) {
        this.openDrawer();
      } else {
        this.closeDrawer();
      }
    },

    /**
     * Opens the drawer.
     *
     * @method openDrawer
     */
    openDrawer: function openDrawer() {
      requestAnimationFrame(function () {
        this.toggleClass('transition-drawer', true, this.$.drawer);
        this.selected = 'drawer';
      }.bind(this));
    },

    /**
     * Closes the drawer.
     *
     * @method closeDrawer
     */
    closeDrawer: function closeDrawer() {
      requestAnimationFrame(function () {
        this.toggleClass('transition-drawer', true, this.$.drawer);
        this.selected = 'main';
      }.bind(this));
    },
    _onTransitionEnd: function _onTransitionEnd(e) {
      var target = (0, _polymerDom.dom)(e).localTarget;

      if (target !== this.$.drawer) {
        // ignore events coming from the light dom
        return;
      }

      if (e.propertyName === 'left' || e.propertyName === 'right') {
        this.notifyResize();
      }

      if (e.propertyName === 'transform') {
        requestAnimationFrame(function () {
          this.toggleClass('transition-drawer', false, this.$.drawer);
        }.bind(this));

        if (this.selected === 'drawer') {
          var focusedChild = this._getAutoFocusedNode();

          focusedChild && focusedChild.focus();
        }
      }
    },
    _computeIronSelectorClass: function _computeIronSelectorClass(narrow, transition, dragging, rightDrawer, peeking) {
      return classNames({
        dragging: dragging,
        'narrow-layout': narrow,
        'right-drawer': rightDrawer,
        'left-drawer': !rightDrawer,
        transition: transition,
        peeking: peeking
      });
    },
    _setDrawerStyle: function _setDrawerStyle(drawerWidth) {
      this.$.drawer.style.width = drawerWidth;
    },
    _setMainStyle: function _setMainStyle(narrow, rightDrawer, drawerWidth) {
      this.$.main.style.left = narrow || rightDrawer ? '0' : drawerWidth;

      if (rightDrawer) {
        this.$.main.style.right = narrow ? '' : drawerWidth;
      }
    },
    _computeMediaQuery: function _computeMediaQuery(forceNarrow, responsiveWidth) {
      return forceNarrow ? '' : '(max-width: ' + responsiveWidth + ')';
    },
    _computeSwipeOverlayHidden: function _computeSwipeOverlayHidden(narrow, disableEdgeSwipe) {
      return !narrow || disableEdgeSwipe;
    },
    _onTrack: function _onTrack(event) {
      if (sharedPanel && this !== sharedPanel) {
        return;
      }

      switch (event.detail.state) {
        case 'start':
          this._trackStart(event);

          break;

        case 'track':
          this._trackX(event);

          break;

        case 'end':
          this._trackEnd(event);

          break;
      }
    },
    _responsiveChange: function _responsiveChange(narrow) {
      this._setNarrow(narrow);

      this.selected = this.narrow ? this.defaultSelected : null;
      this.setScrollDirection(this._swipeAllowed() ? 'y' : 'all');
      this.fire('paper-responsive-change', {
        narrow: this.narrow
      });
    },
    _onQueryMatchesChanged: function _onQueryMatchesChanged(event) {
      this._responsiveChange(event.detail.value);
    },
    _forceNarrowChanged: function _forceNarrowChanged() {
      // set the narrow mode only if we reached the `responsiveWidth`
      this._responsiveChange(this.forceNarrow || this.$.mq.queryMatches);
    },
    _swipeAllowed: function _swipeAllowed() {
      return this.narrow && !this.disableSwipe;
    },
    _isMainSelected: function _isMainSelected() {
      return this.selected === 'main';
    },
    _startEdgePeek: function _startEdgePeek() {
      this.width = this.$.drawer.offsetWidth;

      this._moveDrawer(this._translateXForDeltaX(this.rightDrawer ? -this.edgeSwipeSensitivity : this.edgeSwipeSensitivity));

      this._setPeeking(true);
    },
    _stopEdgePeek: function _stopEdgePeek() {
      if (this.peeking) {
        this._setPeeking(false);

        this._moveDrawer(null);
      }
    },
    _downHandler: function _downHandler(event) {
      if (!this.dragging && this._isMainSelected() && this._isEdgeTouch(event) && !sharedPanel) {
        this._startEdgePeek(); // cancel selection


        event.preventDefault(); // grab this panel

        sharedPanel = this;
      }
    },
    _upHandler: function _upHandler() {
      this._stopEdgePeek(); // release the panel


      sharedPanel = null;
    },
    _onTap: function _onTap(event) {
      var targetElement = (0, _polymerDom.dom)(event).localTarget;
      var isTargetToggleElement = targetElement && this.drawerToggleAttribute && targetElement.hasAttribute(this.drawerToggleAttribute);

      if (isTargetToggleElement) {
        this.togglePanel();
      }
    },
    _isEdgeTouch: function _isEdgeTouch(event) {
      var x = event.detail.x;
      return !this.disableEdgeSwipe && this._swipeAllowed() && (this.rightDrawer ? x >= this.offsetWidth - this.edgeSwipeSensitivity : x <= this.edgeSwipeSensitivity);
    },
    _trackStart: function _trackStart(event) {
      if (this._swipeAllowed()) {
        sharedPanel = this;

        this._setDragging(true);

        if (this._isMainSelected()) {
          this._setDragging(this.peeking || this._isEdgeTouch(event));
        }

        if (this.dragging) {
          this.width = this.$.drawer.offsetWidth;
          this._transition = false;
        }
      }
    },
    _translateXForDeltaX: function _translateXForDeltaX(deltaX) {
      var isMain = this._isMainSelected();

      if (this.rightDrawer) {
        return Math.max(0, isMain ? this.width + deltaX : deltaX);
      } else {
        return Math.min(0, isMain ? deltaX - this.width : deltaX);
      }
    },
    _trackX: function _trackX(event) {
      if (this.dragging) {
        var dx = event.detail.dx;

        if (this.peeking) {
          if (Math.abs(dx) <= this.edgeSwipeSensitivity) {
            // Ignore trackx until we move past the edge peek.
            return;
          }

          this._setPeeking(false);
        }

        this._moveDrawer(this._translateXForDeltaX(dx));
      }
    },
    _trackEnd: function _trackEnd(event) {
      if (this.dragging) {
        var xDirection = event.detail.dx > 0;

        this._setDragging(false);

        this._transition = true;
        sharedPanel = null;

        this._moveDrawer(null);

        if (this.rightDrawer) {
          this[xDirection ? 'closeDrawer' : 'openDrawer']();
        } else {
          this[xDirection ? 'openDrawer' : 'closeDrawer']();
        }
      }
    },
    _transformForTranslateX: function _transformForTranslateX(translateX) {
      if (translateX === null) {
        return '';
      }

      return this.hasWillChange ? 'translateX(' + translateX + 'px)' : 'translate3d(' + translateX + 'px, 0, 0)';
    },
    _moveDrawer: function _moveDrawer(translateX) {
      this.transform(this._transformForTranslateX(translateX), this.$.drawer);
    },
    _getDrawerSlot: function _getDrawerSlot() {
      return (0, _polymerDom.dom)(this.$.drawerSlot).getDistributedNodes()[0];
    },
    _getAutoFocusedNode: function _getAutoFocusedNode() {
      return this.drawerFocusSelector ? (0, _polymerDom.dom)(this._getDrawerSlot()).querySelector(this.drawerFocusSelector) : null;
    },
    _toggleFocusListener: function _toggleFocusListener(selected) {
      if (selected === 'drawer') {
        this.addEventListener('focus', this._boundFocusListener, true);
      } else {
        this.removeEventListener('focus', this._boundFocusListener, true);
      }
    },
    _didFocus: function _didFocus(event) {
      var autoFocusedNode = this._getAutoFocusedNode();

      if (!autoFocusedNode) {
        return;
      }

      var path = (0, _polymerDom.dom)(event).path;
      var focusedChild = path[0];

      var drawerSlot = this._getDrawerSlot();

      var focusedChildCameFromDrawer = path.indexOf(drawerSlot) !== -1;

      if (!focusedChildCameFromDrawer) {
        event.stopPropagation();
        autoFocusedNode.focus();
      }
    },
    _isDrawerClosed: function _isDrawerClosed(narrow, selected) {
      return !narrow || selected !== 'drawer';
    }
  });
});