define(["exports", "../../polymer-element.js", "../utils/mixin.js", "../utils/array-splice.js", "../mixins/element-mixin.js"], function (_exports, _polymerElement, _mixin, _arraySplice, _elementMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ArraySelectorMixin = _exports.ArraySelector = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array such that path changes to the
   * master array (at the host) element or elsewhere via data-binding) are
   * correctly propagated to items in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * @polymer
   * @mixinFunction
   * @appliesMixin ElementMixin
   * @summary Element mixin for recording dynamic associations between item paths in a
   * master `items` array and a `selected` array
   */
  var ArraySelectorMixin = (0, _mixin.dedupingMixin)(function (superClass) {
    /**
     * @constructor
     * @implements {Polymer_ElementMixin}
     * @private
     */
    var elementBase = (0, _elementMixin.ElementMixin)(superClass);
    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_ArraySelectorMixin}
     * @unrestricted
     */

    var ArraySelectorMixin = /*#__PURE__*/function (_elementBase) {
      babelHelpers.inherits(ArraySelectorMixin, _elementBase);

      var _super = _createSuper(ArraySelectorMixin);

      function ArraySelectorMixin() {
        var _this;

        babelHelpers.classCallCheck(this, ArraySelectorMixin);
        _this = _super.call(this);
        _this.__lastItems = null;
        _this.__lastMulti = null;
        _this.__selectedMap = null;
        return _this;
      }

      babelHelpers.createClass(ArraySelectorMixin, [{
        key: "__updateSelection",
        value: function __updateSelection(multi, itemsInfo) {
          var path = itemsInfo.path;

          if (path == JSCompiler_renameProperty('items', this)) {
            // Case 1 - items array changed, so diff against previous array and
            // deselect any removed items and adjust selected indices
            var newItems = itemsInfo.base || [];
            var lastItems = this.__lastItems;
            var lastMulti = this.__lastMulti;

            if (multi !== lastMulti) {
              this.clearSelection();
            }

            if (lastItems) {
              var splices = (0, _arraySplice.calculateSplices)(newItems, lastItems);

              this.__applySplices(splices);
            }

            this.__lastItems = newItems;
            this.__lastMulti = multi;
          } else if (itemsInfo.path == "".concat(JSCompiler_renameProperty('items', this), ".splices")) {
            // Case 2 - got specific splice information describing the array mutation:
            // deselect any removed items and adjust selected indices
            this.__applySplices(itemsInfo.value.indexSplices);
          } else {
            // Case 3 - an array element was changed, so deselect the previous
            // item for that index if it was previously selected
            var part = path.slice("".concat(JSCompiler_renameProperty('items', this), ".").length);
            var idx = parseInt(part, 10);

            if (part.indexOf('.') < 0 && part == idx) {
              this.__deselectChangedIdx(idx);
            }
          }
        }
      }, {
        key: "__applySplices",
        value: function __applySplices(splices) {
          var _this2 = this;

          var selected = this.__selectedMap; // Adjust selected indices and mark removals

          var _loop = function _loop(i) {
            var s = splices[i];
            selected.forEach(function (idx, item) {
              if (idx < s.index) {// no change
              } else if (idx >= s.index + s.removed.length) {
                // adjust index
                selected.set(item, idx + s.addedCount - s.removed.length);
              } else {
                // remove index
                selected.set(item, -1);
              }
            });

            for (var j = 0; j < s.addedCount; j++) {
              var idx = s.index + j;

              if (selected.has(_this2.items[idx])) {
                selected.set(_this2.items[idx], idx);
              }
            }
          };

          for (var i = 0; i < splices.length; i++) {
            _loop(i);
          } // Update linked paths


          this.__updateLinks(); // Remove selected items that were removed from the items array


          var sidx = 0;
          selected.forEach(function (idx, item) {
            if (idx < 0) {
              if (_this2.multi) {
                _this2.splice(JSCompiler_renameProperty('selected', _this2), sidx, 1);
              } else {
                _this2.selected = _this2.selectedItem = null;
              }

              selected.delete(item);
            } else {
              sidx++;
            }
          });
        }
      }, {
        key: "__updateLinks",
        value: function __updateLinks() {
          var _this3 = this;

          this.__dataLinkedPaths = {};

          if (this.multi) {
            var sidx = 0;

            this.__selectedMap.forEach(function (idx) {
              if (idx >= 0) {
                _this3.linkPaths("".concat(JSCompiler_renameProperty('items', _this3), ".").concat(idx), "".concat(JSCompiler_renameProperty('selected', _this3), ".").concat(sidx++));
              }
            });
          } else {
            this.__selectedMap.forEach(function (idx) {
              _this3.linkPaths(JSCompiler_renameProperty('selected', _this3), "".concat(JSCompiler_renameProperty('items', _this3), ".").concat(idx));

              _this3.linkPaths(JSCompiler_renameProperty('selectedItem', _this3), "".concat(JSCompiler_renameProperty('items', _this3), ".").concat(idx));
            });
          }
        }
        /**
         * Clears the selection state.
         * @override
         * @return {void}
         */

      }, {
        key: "clearSelection",
        value: function clearSelection() {
          // Unbind previous selection
          this.__dataLinkedPaths = {}; // The selected map stores 3 pieces of information:
          // key: items array object
          // value: items array index
          // order: selected array index

          this.__selectedMap = new Map(); // Initialize selection

          this.selected = this.multi ? [] : null;
          this.selectedItem = null;
        }
        /**
         * Returns whether the item is currently selected.
         *
         * @override
         * @param {*} item Item from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: "isSelected",
        value: function isSelected(item) {
          return this.__selectedMap.has(item);
        }
        /**
         * Returns whether the item is currently selected.
         *
         * @override
         * @param {number} idx Index from `items` array to test
         * @return {boolean} Whether the item is selected
         */

      }, {
        key: "isIndexSelected",
        value: function isIndexSelected(idx) {
          return this.isSelected(this.items[idx]);
        }
      }, {
        key: "__deselectChangedIdx",
        value: function __deselectChangedIdx(idx) {
          var _this4 = this;

          var sidx = this.__selectedIndexForItemIndex(idx);

          if (sidx >= 0) {
            var i = 0;

            this.__selectedMap.forEach(function (idx, item) {
              if (sidx == i++) {
                _this4.deselect(item);
              }
            });
          }
        }
      }, {
        key: "__selectedIndexForItemIndex",
        value: function __selectedIndexForItemIndex(idx) {
          var selected = this.__dataLinkedPaths["".concat(JSCompiler_renameProperty('items', this), ".").concat(idx)];

          if (selected) {
            return parseInt(selected.slice("".concat(JSCompiler_renameProperty('selected', this), ".").length), 10);
          }
        }
        /**
         * Deselects the given item if it is already selected.
         *
         * @override
         * @param {*} item Item from `items` array to deselect
         * @return {void}
         */

      }, {
        key: "deselect",
        value: function deselect(item) {
          var idx = this.__selectedMap.get(item);

          if (idx >= 0) {
            this.__selectedMap.delete(item);

            var sidx;

            if (this.multi) {
              sidx = this.__selectedIndexForItemIndex(idx);
            }

            this.__updateLinks();

            if (this.multi) {
              this.splice(JSCompiler_renameProperty('selected', this), sidx, 1);
            } else {
              this.selected = this.selectedItem = null;
            }
          }
        }
        /**
         * Deselects the given index if it is already selected.
         *
         * @override
         * @param {number} idx Index from `items` array to deselect
         * @return {void}
         */

      }, {
        key: "deselectIndex",
        value: function deselectIndex(idx) {
          this.deselect(this.items[idx]);
        }
        /**
         * Selects the given item.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @override
         * @param {*} item Item from `items` array to select
         * @return {void}
         */

      }, {
        key: "select",
        value: function select(item) {
          this.selectIndex(this.items.indexOf(item));
        }
        /**
         * Selects the given index.  When `toggle` is true, this will automatically
         * deselect the item if already selected.
         *
         * @override
         * @param {number} idx Index from `items` array to select
         * @return {void}
         */

      }, {
        key: "selectIndex",
        value: function selectIndex(idx) {
          var item = this.items[idx];

          if (!this.isSelected(item)) {
            if (!this.multi) {
              this.__selectedMap.clear();
            }

            this.__selectedMap.set(item, idx);

            this.__updateLinks();

            if (this.multi) {
              this.push(JSCompiler_renameProperty('selected', this), item);
            } else {
              this.selected = this.selectedItem = item;
            }
          } else if (this.toggle) {
            this.deselectIndex(idx);
          }
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * An array containing items from which selection will be made.
             */
            items: {
              type: Array
            },

            /**
             * When `true`, multiple items may be selected at once (in this case,
             * `selected` is an array of currently selected items).  When `false`,
             * only one item may be selected at a time.
             */
            multi: {
              type: Boolean,
              value: false
            },

            /**
             * When `multi` is true, this is an array that contains any selected.
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?Object|?Array<!Object>}
             */
            selected: {
              type: Object,
              notify: true
            },

            /**
             * When `multi` is false, this is the currently selected item, or `null`
             * if no item is selected.
             * @type {?Object}
             */
            selectedItem: {
              type: Object,
              notify: true
            },

            /**
             * When `true`, calling `select` on an item that is already selected
             * will deselect the item.
             */
            toggle: {
              type: Boolean,
              value: false
            }
          };
        }
      }, {
        key: "observers",
        get: function get() {
          return ['__updateSelection(multi, items.*)'];
        }
      }]);
      return ArraySelectorMixin;
    }(elementBase);

    return ArraySelectorMixin;
  }); // export mixin

  _exports.ArraySelectorMixin = ArraySelectorMixin;

  /**
   * @constructor
   * @extends {PolymerElement}
   * @implements {Polymer_ArraySelectorMixin}
   * @private
   */
  var baseArraySelector = ArraySelectorMixin(_polymerElement.PolymerElement);
  /**
   * Element implementing the `ArraySelector` mixin, which records
   * dynamic associations between item paths in a master `items` array and a
   * `selected` array such that path changes to the master array (at the host)
   * element or elsewhere via data-binding) are correctly propagated to items
   * in the selected array and vice-versa.
   *
   * The `items` property accepts an array of user data, and via the
   * `select(item)` and `deselect(item)` API, updates the `selected` property
   * which may be bound to other parts of the application, and any changes to
   * sub-fields of `selected` item(s) will be kept in sync with items in the
   * `items` array.  When `multi` is false, `selected` is a property
   * representing the last selected item.  When `multi` is true, `selected`
   * is an array of multiply selected items.
   *
   * Example:
   *
   * ```js
   * import {PolymerElement} from '@polymer/polymer';
   * import '@polymer/polymer/lib/elements/array-selector.js';
   *
   * class EmployeeList extends PolymerElement {
   *   static get _template() {
   *     return html`
   *         <div> Employee list: </div>
   *         <dom-repeat id="employeeList" items="{{employees}}">
   *           <template>
   *             <div>First name: <span>{{item.first}}</span></div>
   *               <div>Last name: <span>{{item.last}}</span></div>
   *               <button on-click="toggleSelection">Select</button>
   *           </template>
   *         </dom-repeat>
   *
   *         <array-selector id="selector"
   *                         items="{{employees}}"
   *                         selected="{{selected}}"
   *                         multi toggle></array-selector>
   *
   *         <div> Selected employees: </div>
   *         <dom-repeat items="{{selected}}">
   *           <template>
   *             <div>First name: <span>{{item.first}}</span></div>
   *             <div>Last name: <span>{{item.last}}</span></div>
   *           </template>
   *         </dom-repeat>`;
   *   }
   *   static get is() { return 'employee-list'; }
   *   static get properties() {
   *     return {
   *       employees: {
   *         value() {
   *           return [
   *             {first: 'Bob', last: 'Smith'},
   *             {first: 'Sally', last: 'Johnson'},
   *             ...
   *           ];
   *         }
   *       }
   *     };
   *   }
   *   toggleSelection(e) {
   *     const item = this.$.employeeList.itemForElement(e.target);
   *     this.$.selector.select(item);
   *   }
   * }
   * ```
   *
   * @polymer
   * @customElement
   * @extends {baseArraySelector}
   * @appliesMixin ArraySelectorMixin
   * @summary Custom element that links paths between an input `items` array and
   *   an output `selected` item or array based on calls to its selection API.
   */

  var ArraySelector = /*#__PURE__*/function (_baseArraySelector) {
    babelHelpers.inherits(ArraySelector, _baseArraySelector);

    var _super2 = _createSuper(ArraySelector);

    function ArraySelector() {
      babelHelpers.classCallCheck(this, ArraySelector);
      return _super2.apply(this, arguments);
    }

    babelHelpers.createClass(ArraySelector, null, [{
      key: "is",
      get: // Not needed to find template; can be removed once the analyzer
      // can find the tag name from customElements.define call
      function get() {
        return 'array-selector';
      }
    }, {
      key: "template",
      get: function get() {
        return null;
      }
    }]);
    return ArraySelector;
  }(baseArraySelector);

  _exports.ArraySelector = ArraySelector;
  customElements.define(ArraySelector.is, ArraySelector);
});