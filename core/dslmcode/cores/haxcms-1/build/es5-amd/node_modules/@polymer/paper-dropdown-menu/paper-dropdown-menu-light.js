define(["../polymer/polymer-legacy.js", "../iron-a11y-keys-behavior/iron-a11y-keys-behavior.js", "../iron-icon/iron-icon.js", "../paper-menu-button/paper-menu-button.js", "../paper-styles/default-theme.js", "./paper-dropdown-menu-icons.js", "./paper-dropdown-menu-shared-styles.js", "../iron-behaviors/iron-button-state.js", "../iron-behaviors/iron-control-state.js", "../iron-form-element-behavior/iron-form-element-behavior.js", "../iron-validatable-behavior/iron-validatable-behavior.js", "../paper-behaviors/paper-ripple-behavior.js", "../polymer/lib/legacy/legacy-element-mixin.js", "../polymer/lib/legacy/polymer-fn.js", "../polymer/lib/legacy/polymer.dom.js", "../polymer/lib/utils/gestures.js", "../polymer/lib/utils/html-tag.js", "../polymer/lib/utils/wrap.js"], function (_polymerLegacy, _ironA11yKeysBehavior, _ironIcon, _paperMenuButton, _defaultTheme, _paperDropdownMenuIcons, _paperDropdownMenuSharedStyles, _ironButtonState, _ironControlState, _ironFormElementBehavior, _ironValidatableBehavior, _paperRippleBehavior, _legacyElementMixin, _polymerFn, _polymerDom, gestures, _htmlTag, _wrap) {
  "use strict";

  gestures = _interopRequireWildcard(gestures);

  var _templateObject_037ba400942811ecb1937969798b231a;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  // LegacyElementMixin dedupes and this is the base class for elements created
  // with the `Polymer` function, so this is only a cache lookup.
  // https://github.com/Polymer/polymer/blob/640bc80ac7177b761d46b2fa9c455c318f2b85c6/lib/legacy/class.js#L533-L534
  var LegacyPolymerElementBase = (0, _legacyElementMixin.LegacyElementMixin)(HTMLElement);
  /**
  Material design: [Dropdown
  menus](https://www.google.com/design/spec/components/buttons.html#buttons-dropdown-buttons)
  
  This is a faster, lighter version of `paper-dropdown-menu`, that does not
  use a `<paper-input>` internally. Use this element if you're concerned about
  the performance of this element, i.e., if you plan on using many dropdowns on
  the same page. Note that this element has a slightly different styling API
  than `paper-dropdown-menu`.
  
  `paper-dropdown-menu-light` is similar to a native browser select element.
  `paper-dropdown-menu-light` works with selectable content. The currently
  selected item is displayed in the control. If no item is selected, the `label`
  is displayed instead.
  
  Example:
  
      <paper-dropdown-menu-light label="Your favourite pastry">
        <paper-listbox slot="dropdown-content">
          <paper-item>Croissant</paper-item>
          <paper-item>Donut</paper-item>
          <paper-item>Financier</paper-item>
          <paper-item>Madeleine</paper-item>
        </paper-listbox>
      </paper-dropdown-menu-light>
  
  This example renders a dropdown menu with 4 options.
  
  The child element with the slot `dropdown-content` is used as the dropdown
  menu. This can be a [`paper-listbox`](paper-listbox), or any other or
  element that acts like an [`iron-selector`](iron-selector).
  
  Specifically, the menu child must fire an
  [`iron-select`](iron-selector#event-iron-select) event when one of its
  children is selected, and an
  [`iron-deselect`](iron-selector#event-iron-deselect) event when a child is
  deselected. The selected or deselected item must be passed as the event's
  `detail.item` property.
  
  Applications can listen for the `iron-select` and `iron-deselect` events
  to react when options are selected and deselected.
  
  ### Styling
  
  The following custom properties and mixins are also available for styling:
  
  Custom property | Description | Default
  ----------------|-------------|----------
  `--paper-dropdown-menu` | A mixin that is applied to the element host | `{}`
  `--paper-dropdown-menu-disabled` | A mixin that is applied to the element host when disabled | `{}`
  `--paper-dropdown-menu-ripple` | A mixin that is applied to the internal ripple | `{}`
  `--paper-dropdown-menu-button` | A mixin that is applied to the internal menu button | `{}`
  `--paper-dropdown-menu-icon` | A mixin that is applied to the internal icon | `{}`
  `--paper-dropdown-menu-disabled-opacity` | The opacity of the dropdown when disabled  | `0.33`
  `--paper-dropdown-menu-color` | The color of the input/label/underline when the dropdown is unfocused | `--primary-text-color`
  `--paper-dropdown-menu-focus-color` | The color of the label/underline when the dropdown is focused  | `--primary-color`
  `--paper-dropdown-error-color` | The color of the label/underline when the dropdown is invalid  | `--error-color`
  `--paper-dropdown-menu-label` | Mixin applied to the label | `{}`
  `--paper-dropdown-menu-input` | Mixin applied to the input | `{}`
  `--paper-dropdown-menu-underline-focus` | Mixin applied to the focus underline | `{}`
  
  Note that in this element, the underline is just the bottom border of the
  "input". To style it:
  
      <style is=custom-style>
        paper-dropdown-menu-light.custom {
          --paper-dropdown-menu-input: {
            border-bottom: 2px dashed lavender;
          };
      </style>
  
  @element paper-dropdown-menu-light
  @demo demo/index.html
  */

  (0, _polymerFn.Polymer)({
    /** @override */
    _template: (0, _htmlTag.html)(_templateObject_037ba400942811ecb1937969798b231a || (_templateObject_037ba400942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n    <style include=\"paper-dropdown-menu-shared-styles\">\n      :host {\n        width: 200px;  /* Default size of an <input> */\n      }\n\n      /**\n       * All of these styles below are for styling the fake-input display\n       */\n      [slot=\"dropdown-trigger\"] {\n        box-sizing: border-box;\n        position: relative;\n        width: 100%;\n        padding: 16px 0 8px 0;\n      }\n\n      [slot=\"dropdown-trigger\"]:focus {\n        outline: none;\n      }\n\n      :host([disabled]) [slot=\"dropdown-trigger\"] {\n        pointer-events: none;\n        opacity: var(--paper-dropdown-menu-disabled-opacity, 0.33);\n      }\n\n      :host([no-label-float]) [slot=\"dropdown-trigger\"] {\n        padding-top: 8px;   /* If there's no label, we need less space up top. */\n      }\n\n      #input {\n        @apply --paper-font-subhead;\n        @apply --paper-font-common-nowrap;\n        line-height: 1.5;\n        border-bottom: 1px solid var(--paper-dropdown-menu-color, var(--secondary-text-color));\n        color: var(--paper-dropdown-menu-color, var(--primary-text-color));\n        width: 100%;\n        box-sizing: border-box;\n        padding: 12px 20px 0 0;   /* Right padding so that text doesn't overlap the icon */\n        outline: none;\n        @apply --paper-dropdown-menu-input;\n      }\n\n      #input:dir(rtl) {\n        padding-right: 0px;\n        padding-left: 20px;\n      }\n\n      :host([disabled]) #input {\n        border-bottom: 1px dashed var(--paper-dropdown-menu-color, var(--secondary-text-color));\n      }\n\n      :host([invalid]) #input {\n        border-bottom: 2px solid var(--paper-dropdown-error-color, var(--error-color));\n      }\n\n      :host([no-label-float]) #input {\n        padding-top: 0;   /* If there's no label, we need less space up top. */\n      }\n\n      label {\n        @apply --paper-font-subhead;\n        @apply --paper-font-common-nowrap;\n        display: block;\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        /**\n         * The container has a 16px top padding, and there's 12px of padding\n         * between the input and the label (from the input's padding-top)\n         */\n        top: 28px;\n        box-sizing: border-box;\n        width: 100%;\n        padding-right: 20px;    /* Right padding so that text doesn't overlap the icon */\n        text-align: left;\n        transition-duration: .2s;\n        transition-timing-function: cubic-bezier(.4,0,.2,1);\n        color: var(--paper-dropdown-menu-color, var(--secondary-text-color));\n        @apply --paper-dropdown-menu-label;\n      }\n\n      label:dir(rtl) {\n        padding-right: 0px;\n        padding-left: 20px;\n        text-align: right;\n      }\n\n      :host([no-label-float]) label {\n        top: 8px;\n        /* Since the label doesn't need to float, remove the animation duration\n        which slows down visibility changes (i.e. when a selection is made) */\n        transition-duration: 0s;\n      }\n\n      label.label-is-floating {\n        font-size: 12px;\n        top: 8px;\n      }\n\n      label.label-is-hidden {\n        visibility: hidden;\n      }\n\n      :host([focused]) label.label-is-floating {\n        color: var(--paper-dropdown-menu-focus-color, var(--primary-color));\n      }\n\n      :host([invalid]) label.label-is-floating {\n        color: var(--paper-dropdown-error-color, var(--error-color));\n      }\n\n      /**\n       * Sets up the focused underline. It's initially hidden, and becomes\n       * visible when it's focused.\n       */\n      label:after {\n        background-color: var(--paper-dropdown-menu-focus-color, var(--primary-color));\n        bottom: 7px;    /* The container has an 8px bottom padding */\n        content: '';\n        height: 2px;\n        left: 45%;\n        position: absolute;\n        transition-duration: .2s;\n        transition-timing-function: cubic-bezier(.4,0,.2,1);\n        visibility: hidden;\n        width: 8px;\n        z-index: 10;\n        @apply --paper-dropdown-menu-underline-focus;\n      }\n\n      :host([invalid]) label:after {\n        background-color: var(--paper-dropdown-error-color, var(--error-color));\n      }\n\n      :host([no-label-float]) label:after {\n        bottom: 7px;    /* The container has a 8px bottom padding */\n      }\n\n      :host([focused]:not([disabled])) label:after {\n        left: 0;\n        visibility: visible;\n        width: 100%;\n      }\n\n      iron-icon {\n        position: absolute;\n        right: 0px;\n        bottom: 8px;    /* The container has an 8px bottom padding */\n        @apply --paper-font-subhead;\n        color: var(--disabled-text-color);\n        @apply --paper-dropdown-menu-icon;\n      }\n\n      iron-icon:dir(rtl) {\n        left: 0;\n        right: auto;\n      }\n\n      :host([no-label-float]) iron-icon {\n        margin-top: 0px;\n      }\n\n      .error {\n        display: inline-block;\n        visibility: hidden;\n        color: var(--paper-dropdown-error-color, var(--error-color));\n        @apply --paper-font-caption;\n        position: absolute;\n        left:0;\n        right:0;\n        bottom: -12px;\n      }\n\n      :host([invalid]) .error {\n        visibility: visible;\n      }\n    </style>\n\n    <paper-menu-button id=\"menuButton\" vertical-align=\"[[verticalAlign]]\" horizontal-align=\"[[horizontalAlign]]\" vertical-offset=\"[[_computeMenuVerticalOffset(noLabelFloat, verticalOffset)]]\" disabled=\"[[disabled]]\" no-animations=\"[[noAnimations]]\" on-iron-select=\"_onIronSelect\" on-iron-deselect=\"_onIronDeselect\" opened=\"{{opened}}\" close-on-activate allow-outside-scroll=\"[[allowOutsideScroll]]\">\n      <!-- support hybrid mode: user might be using paper-menu-button 1.x which distributes via <content> -->\n      <div id=\"dropdown-trigger\" class=\"dropdown-trigger\" slot=\"dropdown-trigger\" role=\"button\" tabindex=\"0\" aria-haspopup=\"listbox\">\n        <label class$=\"[[_computeLabelClass(noLabelFloat,alwaysFloatLabel,hasContent)]]\">\n          [[label]]\n        </label>\n        <div id=\"input\" tabindex=\"-1\">&nbsp;</div>\n        <iron-icon icon=\"paper-dropdown-menu:arrow-drop-down\"></iron-icon>\n        <span class=\"error\">[[errorMessage]]</span>\n      </div>\n      <slot id=\"content\" name=\"dropdown-content\" slot=\"dropdown-content\"></slot>\n    </paper-menu-button>\n"]))),
    is: 'paper-dropdown-menu-light',
    behaviors: [_ironButtonState.IronButtonState, _ironControlState.IronControlState, _paperRippleBehavior.PaperRippleBehavior, _ironFormElementBehavior.IronFormElementBehavior, _ironValidatableBehavior.IronValidatableBehavior],
    properties: {
      /**
       * The derived "label" of the currently selected item. This value
       * is the `label` property on the selected item if set, or else the
       * trimmed text content of the selected item.
       */
      selectedItemLabel: {
        type: String,
        notify: true,
        readOnly: true
      },

      /**
       * The last selected item. An item is selected if the dropdown menu has
       * a child with class `dropdown-content`, and that child triggers an
       * `iron-select` event with the selected `item` in the `detail`.
       *
       * @type {?Object}
       */
      selectedItem: {
        type: Object,
        notify: true,
        readOnly: true
      },

      /**
       * The value for this element that will be used when submitting in
       * a form. It reflects the value of `selectedItemLabel`. If set directly,
       * it will not update the `selectedItemLabel` value.
       */
      value: {
        type: String,
        notify: true,
        observer: '_valueChanged'
      },

      /**
       * The label for the dropdown.
       */
      label: {
        type: String
      },

      /**
       * The placeholder for the dropdown.
       */
      placeholder: {
        type: String
      },

      /**
       * True if the dropdown is open. Otherwise, false.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        observer: '_openedChanged'
      },

      /**
       * By default, the dropdown will constrain scrolling on the page
       * to itself when opened.
       * Set to true in order to prevent scroll from being constrained
       * to the dropdown when it opens.
       */
      allowOutsideScroll: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable the floating label. Bind this to the
       * `<paper-input-container>`'s `noLabelFloat` property.
       */
      noLabelFloat: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      /**
       * Set to true to always float the label. Bind this to the
       * `<paper-input-container>`'s `alwaysFloatLabel` property.
       */
      alwaysFloatLabel: {
        type: Boolean,
        value: false
      },

      /**
       * Set to true to disable animations when opening and closing the
       * dropdown.
       */
      noAnimations: {
        type: Boolean,
        value: false
      },

      /**
       * The orientation against which to align the menu dropdown
       * horizontally relative to the dropdown trigger.
       */
      horizontalAlign: {
        type: String,
        value: 'right'
      },

      /**
       * The orientation against which to align the menu dropdown
       * vertically relative to the dropdown trigger.
       */
      verticalAlign: {
        type: String,
        value: 'top'
      },

      /**
       * Overrides the vertical offset computed in
       * _computeMenuVerticalOffset.
       */
      verticalOffset: Number,
      hasContent: {
        type: Boolean,
        readOnly: true
      }
    },
    listeners: {
      'tap': '_onTap'
    },

    /**
     * @type {!Object}
     */
    keyBindings: {
      'up down': 'open',
      'esc': 'close'
    },
    observers: ['_selectedItemChanged(selectedItem)'],

    /**
     * Override `_attachDom` so that we can pass `delegatesFocus`. The overridden
     * implementation of `_attachDom` specifically skips the steps performed here
     * if the node already hosts a shadow root:
     * https://github.com/Polymer/polymer/blob/640bc80ac7177b761d46b2fa9c455c318f2b85c6/lib/mixins/element-mixin.js#L691-L694
     * @override
     */
    _attachDom: function _attachDom(dom) {
      var wrappedThis = (0, _wrap.wrap)(this);
      wrappedThis.attachShadow({
        mode: 'open',
        delegatesFocus: true,
        shadyUpgradeFragment: dom
      });
      wrappedThis.shadowRoot.appendChild(dom);
      return LegacyPolymerElementBase.prototype._attachDom.call(this, dom);
    },

    /** @override */
    focus: function focus() {
      // When using Shady DOM and in browsers that don't support
      // `delegatesFocus`, attempting to focus this element with the browser's
      // native `HTMLElement#focus` will cause focus to be lost because this
      // element isn't focusable in those situations. To work around this, the
      // element in the shadow root that this element intends to delegate focus
      // to is manually focused instead.
      this.$['dropdown-trigger'].focus();
    },

    /** @override */
    attached: function attached() {
      // NOTE(cdata): Due to timing, a preselected value in a `IronSelectable`
      // child will cause an `iron-select` event to fire while the element is
      // still in a `DocumentFragment`. This has the effect of causing
      // handlers not to fire. So, we double check this value on attached:
      var contentElement = this.contentElement;

      if (contentElement && contentElement.selectedItem) {
        this._setSelectedItem(contentElement.selectedItem);
      }
    },

    /**
     * The content element that is contained by the dropdown menu, if any.
     */
    get contentElement() {
      // Polymer 2.x returns slot.assignedNodes which can contain text nodes.
      var nodes = (0, _polymerDom.dom)(this.$.content).getDistributedNodes();

      for (var i = 0, l = nodes.length; i < l; i++) {
        if (nodes[i].nodeType === Node.ELEMENT_NODE) {
          return nodes[i];
        }
      }
    },

    /**
     * Show the dropdown content.
     */
    open: function open() {
      this.$.menuButton.open();
    },

    /**
     * Hide the dropdown content.
     */
    close: function close() {
      this.$.menuButton.close();
    },

    /**
     * A handler that is called when `iron-select` is fired.
     *
     * @param {CustomEvent} event An `iron-select` event.
     */
    _onIronSelect: function _onIronSelect(event) {
      this._setSelectedItem(event.detail.item);
    },

    /**
     * A handler that is called when `iron-deselect` is fired.
     *
     * @param {CustomEvent} event An `iron-deselect` event.
     */
    _onIronDeselect: function _onIronDeselect(event) {
      this._setSelectedItem(null);
    },

    /**
     * A handler that is called when the dropdown is tapped.
     *
     * @param {CustomEvent} event A tap event.
     */
    _onTap: function _onTap(event) {
      if (gestures.findOriginalTarget(event) === this) {
        this.open();
      }
    },

    /**
     * Compute the label for the dropdown given a selected item.
     *
     * @param {Element} selectedItem A selected Element item, with an
     * optional `label` property.
     */
    _selectedItemChanged: function _selectedItemChanged(selectedItem) {
      var value = '';

      if (!selectedItem) {
        value = '';
      } else {
        value = selectedItem.label || selectedItem.getAttribute('label') || selectedItem.textContent.trim();
      }

      this.value = value;

      this._setSelectedItemLabel(value);
    },

    /**
     * Compute the vertical offset of the menu based on the value of
     * `noLabelFloat`.
     *
     * @param {boolean} noLabelFloat True if the label should not float
     * @param {number=} opt_verticalOffset Optional offset from the user
     * above the input, otherwise false.
     */
    _computeMenuVerticalOffset: function _computeMenuVerticalOffset(noLabelFloat, opt_verticalOffset) {
      // Override offset if it's passed from the user.
      if (opt_verticalOffset) {
        return opt_verticalOffset;
      } // NOTE(cdata): These numbers are somewhat magical because they are
      // derived from the metrics of elements internal to `paper-input`'s
      // template. The metrics will change depending on whether or not the
      // input has a floating label.


      return noLabelFloat ? -4 : 8;
    },

    /**
     * Returns false if the element is required and does not have a selection,
     * and true otherwise.
     * @param {*=} _value Ignored.
     * @return {boolean} true if `required` is false, or if `required` is true
     * and the element has a valid selection.
     */
    _getValidity: function _getValidity(_value) {
      return this.disabled || !this.required || this.required && !!this.value;
    },
    _openedChanged: function _openedChanged() {
      var openState = this.opened ? 'true' : 'false';
      var e = this.contentElement;

      if (e) {
        e.setAttribute('aria-expanded', openState);
      }
    },
    _computeLabelClass: function _computeLabelClass(noLabelFloat, alwaysFloatLabel, hasContent) {
      var cls = '';

      if (noLabelFloat === true) {
        return hasContent ? 'label-is-hidden' : '';
      }

      if (hasContent || alwaysFloatLabel === true) {
        cls += ' label-is-floating';
      }

      return cls;
    },
    _valueChanged: function _valueChanged() {
      // Only update if it's actually different.
      if (this.$.input && this.$.input.textContent !== this.value) {
        this.$.input.textContent = this.value;
      }

      this._setHasContent(!!this.value);

      if (!this.hasContent) {
        // If there is no content then reset to '&nbsp', which is required
        // for the input height to be correct. Uses 'xa0' instead of '&nbsp' to
        // avoid innerHTML.
        this.$.input.textContent = '\xa0';
      }
    }
  });
});