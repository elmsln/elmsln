define(["../polymer/polymer-legacy.js", "../iron-flex-layout/iron-flex-layout.js", "../iron-behaviors/iron-control-state.js", "../iron-validatable-behavior/iron-validatable-behavior.js", "../polymer/lib/legacy/polymer-fn.js", "../polymer/lib/legacy/polymer.dom.js", "../polymer/lib/utils/html-tag.js"], function (_polymerLegacy, _ironFlexLayout, _ironControlState, _ironValidatableBehavior, _polymerFn, _polymerDom, _htmlTag) {
  "use strict";

  var _templateObject_99fc33e08e0011ed99ce491205e67b1d;

  /**
  `iron-autogrow-textarea` is an element containing a textarea that grows in
  height as more lines of input are entered. Unless an explicit height or the
  `maxRows` property is set, it will never scroll.
  
  Example:
  
      <iron-autogrow-textarea></iron-autogrow-textarea>
  
  ### Styling
  
  The following custom properties and mixins are available for styling:
  
  Custom property | Description | Default
  ----------------|-------------|----------
  `--iron-autogrow-textarea` | Mixin applied to the textarea | `{}`
  `--iron-autogrow-textarea-placeholder` | Mixin applied to the textarea placeholder | `{}`
  
  @demo demo/index.html
  */
  (0, _polymerFn.Polymer)({
    /** @override */
    _template: (0, _htmlTag.html)(_templateObject_99fc33e08e0011ed99ce491205e67b1d || (_templateObject_99fc33e08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n        width: 400px;\n        border: 1px solid;\n        padding: 2px;\n        -moz-appearance: textarea;\n        -webkit-appearance: textarea;\n        overflow: hidden;\n      }\n\n      .mirror-text {\n        visibility: hidden;\n        word-wrap: break-word;\n        @apply --iron-autogrow-textarea;\n      }\n\n      .fit {\n        @apply --layout-fit;\n      }\n\n      textarea {\n        position: relative;\n        outline: none;\n        border: none;\n        resize: none;\n        background: inherit;\n        color: inherit;\n        /* see comments in template */\n        width: 100%;\n        height: 100%;\n        font-size: inherit;\n        font-family: inherit;\n        line-height: inherit;\n        text-align: inherit;\n        @apply --iron-autogrow-textarea;\n      }\n\n      textarea::-webkit-input-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea:-moz-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea::-moz-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n\n      textarea:-ms-input-placeholder {\n        @apply --iron-autogrow-textarea-placeholder;\n      }\n    </style>\n\n    <!-- the mirror sizes the input/textarea so it grows with typing -->\n    <!-- use &#160; instead &nbsp; of to allow this element to be used in XHTML -->\n    <div id=\"mirror\" class=\"mirror-text\" aria-hidden=\"true\">&nbsp;</div>\n\n    <!-- size the input/textarea with a div, because the textarea has intrinsic size in ff -->\n    <div class=\"textarea-container fit\">\n      <textarea id=\"textarea\" name$=\"[[name]]\" aria-label$=\"[[label]]\" autocomplete$=\"[[autocomplete]]\" autofocus$=\"[[autofocus]]\" autocapitalize$=\"[[autocapitalize]]\" inputmode$=\"[[inputmode]]\" placeholder$=\"[[placeholder]]\" readonly$=\"[[readonly]]\" required$=\"[[required]]\" disabled$=\"[[disabled]]\" rows$=\"[[rows]]\" minlength$=\"[[minlength]]\" maxlength$=\"[[maxlength]]\"></textarea>\n    </div>\n"]))),
    is: 'iron-autogrow-textarea',
    behaviors: [_ironValidatableBehavior.IronValidatableBehavior, _ironControlState.IronControlState],
    properties: {
      /**
       * Use this property instead of `bind-value` for two-way data binding.
       * @type {string|number}
       */
      value: {
        observer: '_valueChanged',
        type: String,
        notify: true
      },

      /**
       * This property is deprecated, and just mirrors `value`. Use `value`
       * instead.
       * @type {string|number}
       */
      bindValue: {
        observer: '_bindValueChanged',
        type: String,
        notify: true
      },

      /**
       * The initial number of rows.
       *
       * @attribute rows
       * @type number
       * @default 1
       */
      rows: {
        type: Number,
        value: 1,
        observer: '_updateCached'
      },

      /**
       * The maximum number of rows this element can grow to until it
       * scrolls. 0 means no maximum.
       *
       * @attribute maxRows
       * @type number
       * @default 0
       */
      maxRows: {
        type: Number,
        value: 0,
        observer: '_updateCached'
      },

      /**
       * Bound to the textarea's `autocomplete` attribute.
       */
      autocomplete: {
        type: String,
        value: 'off'
      },

      /**
       * Bound to the textarea's `autofocus` attribute.
       *
       * @type {!boolean}
       */
      autofocus: {
        type: Boolean,
        value: false
      },

      /**
       * Bound to the textarea's `autocapitalize` attribute.
       */
      autocapitalize: {
        type: String,
        value: 'none'
      },

      /**
       * Bound to the textarea's `inputmode` attribute.
       */
      inputmode: {
        type: String
      },

      /**
       * Bound to the textarea's `placeholder` attribute.
       */
      placeholder: {
        type: String
      },

      /**
       * Bound to the textarea's `readonly` attribute.
       */
      readonly: {
        type: String
      },

      /**
       * Set to true to mark the textarea as required.
       */
      required: {
        type: Boolean
      },

      /**
       * The minimum length of the input value.
       */
      minlength: {
        type: Number
      },

      /**
       * The maximum length of the input value.
       */
      maxlength: {
        type: Number
      },

      /**
       * Bound to the textarea's `aria-label` attribute.
       */
      label: {
        type: String
      }
    },
    listeners: {
      'input': '_onInput'
    },

    /**
     * Returns the underlying textarea.
     * @return {!HTMLTextAreaElement}
     */
    get textarea() {
      return (
        /** @type {!HTMLTextAreaElement} */
        this.$.textarea
      );
    },

    /**
     * Returns textarea's selection start.
     * @return {number}
     */
    get selectionStart() {
      return this.$.textarea.selectionStart;
    },

    /**
     * Returns textarea's selection end.
     * @return {number}
     */
    get selectionEnd() {
      return this.$.textarea.selectionEnd;
    },

    /**
     * Sets the textarea's selection start.
     */
    set selectionStart(value) {
      this.$.textarea.selectionStart = value;
    },

    /**
     * Sets the textarea's selection end.
     */
    set selectionEnd(value) {
      this.$.textarea.selectionEnd = value;
    },

    /** @override */
    attached: function attached() {
      /* iOS has an arbitrary left margin of 3px that isn't present
       * in any other browser, and means that the paper-textarea's cursor
       * overlaps the label.
       * See https://github.com/PolymerElements/paper-input/issues/468.
       */
      var IS_IOS = navigator.userAgent.match(/iP(?:[oa]d|hone)/) && !navigator.userAgent.match(/OS 1[3456789]/);

      if (IS_IOS) {
        this.$.textarea.style.marginLeft = '-3px';
      }
    },

    /**
     * Returns true if `value` is valid. The validator provided in `validator`
     * will be used first, if it exists; otherwise, the `textarea`'s validity
     * is used.
     * @return {boolean} True if the value is valid.
     */
    validate: function validate() {
      // Use the nested input's native validity.
      var valid = this.$.textarea.validity.valid; // Only do extra checking if the browser thought this was valid.

      if (valid) {
        // Empty, required input is invalid
        if (this.required && this.value === '') {
          valid = false;
        } else if (this.hasValidator()) {
          valid = _ironValidatableBehavior.IronValidatableBehavior.validate.call(this, this.value);
        }
      }

      this.invalid = !valid;
      this.fire('iron-input-validate');
      return valid;
    },
    _bindValueChanged: function _bindValueChanged(bindValue) {
      this.value = bindValue;
    },
    _valueChanged: function _valueChanged(value) {
      var textarea = this.textarea;

      if (!textarea) {
        return;
      } // If the bindValue changed manually, then we need to also update
      // the underlying textarea's value. Otherwise this change was probably
      // generated from the _onInput handler, and the two values are already
      // the same.


      if (textarea.value !== value) {
        textarea.value = !(value || value === 0) ? '' : value;
      }

      this.bindValue = value;
      this.$.mirror.innerHTML = this._valueForMirror(); // Manually notify because we don't want to notify until after setting
      // value.

      this.fire('bind-value-changed', {
        value: this.bindValue
      });
    },
    _onInput: function _onInput(event) {
      var eventPath = (0, _polymerDom.dom)(event).path;
      this.value = eventPath ? eventPath[0].value : event.target.value;
    },
    _constrain: function _constrain(tokens) {
      var _tokens;

      tokens = tokens || ['']; // Enforce the min and max heights for a multiline input to avoid
      // measurement

      if (this.maxRows > 0 && tokens.length > this.maxRows) {
        _tokens = tokens.slice(0, this.maxRows);
      } else {
        _tokens = tokens.slice(0);
      }

      while (this.rows > 0 && _tokens.length < this.rows) {
        _tokens.push('');
      } // Use &#160; instead &nbsp; of to allow this element to be used in XHTML.


      return _tokens.join('<br/>') + '&#160;';
    },
    _valueForMirror: function _valueForMirror() {
      var input = this.textarea;

      if (!input) {
        return;
      }

      this.tokens = input && input.value ? input.value.replace(/&/gm, '&amp;').replace(/"/gm, '&quot;').replace(/'/gm, '&#39;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;').split('\n') : [''];
      return this._constrain(this.tokens);
    },
    _updateCached: function _updateCached() {
      this.$.mirror.innerHTML = this._constrain(this.tokens);
    }
  });
});