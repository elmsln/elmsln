define(["exports", "./boot.js", "./wrap.js"], function (_exports, _boot, _wrap) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.scopeSubtree = scopeSubtree;

  /**
  @license
  Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  var ShadyDOM = window.ShadyDOM;
  var ShadyCSS = window.ShadyCSS;
  /**
   * Return true if node scope is correct.
   *
   * @param {!Element} node Node to check scope
   * @param {!Node} scope Scope reference
   * @return {boolean} True if node is in scope
   */

  function sameScope(node, scope) {
    return (0, _wrap.wrap)(node).getRootNode() === scope;
  }
  /**
   * Ensure that elements in a ShadowDOM container are scoped correctly.
   * This function is only needed when ShadyDOM is used and unpatched DOM APIs are used in third party code.
   * This can happen in noPatch mode or when specialized APIs like ranges or tables are used to mutate DOM.
   *
   * @param  {!Element} container Container element to scope
   * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container
   * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.
   */


  function scopeSubtree(container) {
    var shouldObserve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    // If using native ShadowDOM, abort
    if (!ShadyDOM || !ShadyCSS) {
      return null;
    } // ShadyCSS handles DOM mutations when ShadyDOM does not handle scoping itself


    if (!ShadyDOM['handlesDynamicScoping']) {
      return null;
    }

    var ScopingShim = ShadyCSS['ScopingShim']; // if ScopingShim is not available, abort

    if (!ScopingShim) {
      return null;
    } // capture correct scope for container


    var containerScope = ScopingShim['scopeForNode'](container);
    var root = (0, _wrap.wrap)(container).getRootNode();

    var scopify = function scopify(node) {
      if (!sameScope(node, root)) {
        return;
      } // NOTE: native qSA does not honor scoped DOM, but it is faster, and the same behavior as Polymer v1


      var elements = Array.from(ShadyDOM['nativeMethods']['querySelectorAll'].call(node, '*'));
      elements.push(node);

      for (var i = 0; i < elements.length; i++) {
        var el = elements[i];

        if (!sameScope(el, root)) {
          continue;
        }

        var currentScope = ScopingShim['currentScopeForNode'](el);

        if (currentScope !== containerScope) {
          if (currentScope !== '') {
            ScopingShim['unscopeNode'](el, currentScope);
          }

          ScopingShim['scopeNode'](el, containerScope);
        }
      }
    }; // scope everything in container


    scopify(container);

    if (shouldObserve) {
      var mo = new MutationObserver(function (mxns) {
        for (var i = 0; i < mxns.length; i++) {
          var mxn = mxns[i];

          for (var j = 0; j < mxn.addedNodes.length; j++) {
            var addedNode = mxn.addedNodes[j];

            if (addedNode.nodeType === Node.ELEMENT_NODE) {
              scopify(addedNode);
            }
          }
        }
      });
      mo.observe(container, {
        childList: true,
        subtree: true
      });
      return mo;
    } else {
      return null;
    }
  }
});