define(["../polymer/polymer-legacy.js", "../iron-flex-layout/iron-flex-layout.js", "../paper-styles/default-theme.js", "../paper-dialog-behavior/paper-dialog-behavior.js", "../polymer/lib/legacy/polymer-fn.js", "../polymer/lib/utils/html-tag.js"], function (_polymerLegacy, _ironFlexLayout, _defaultTheme, _paperDialogBehavior, _polymerFn, _htmlTag) {
  "use strict";

  var _templateObject_0350c370942811ecb1937969798b231a;

  /**
  Material design:
  [Dialogs](https://www.google.com/design/spec/components/dialogs.html)
  
  `paper-dialog-scrollable` implements a scrolling area used in a Material Design
  dialog. It shows a divider at the top and/or bottom indicating more content,
  depending on scroll position. Use this together with elements implementing
  `Polymer.PaperDialogBehavior`.
  
      <paper-dialog-impl>
        <h2>Header</h2>
        <paper-dialog-scrollable>
          Lorem ipsum...
        </paper-dialog-scrollable>
        <div class="buttons">
          <paper-button>OK</paper-button>
        </div>
      </paper-dialog-impl>
  
  It shows a top divider after scrolling if it is not the first child in its
  parent container, indicating there is more content above. It shows a bottom
  divider if it is scrollable and it is not the last child in its parent
  container, indicating there is more content below. The bottom divider is hidden
  if it is scrolled to the bottom.
  
  If `paper-dialog-scrollable` is not a direct child of the element implementing
  `Polymer.PaperDialogBehavior`, remember to set the `dialogElement`:
  
      <paper-dialog-impl id="myDialog">
        <h2>Header</h2>
        <div class="my-content-wrapper">
          <h4>Sub-header</h4>
          <paper-dialog-scrollable>
            Lorem ipsum...
          </paper-dialog-scrollable>
        </div>
        <div class="buttons">
          <paper-button>OK</paper-button>
        </div>
      </paper-dialog-impl>
  
      <script>
        var scrollable =
  Polymer.dom(myDialog).querySelector('paper-dialog-scrollable');
        scrollable.dialogElement = myDialog;
      </script>
  
  ### Styling
  The following custom properties and mixins are available for styling:
  
  Custom property | Description | Default
  ----------------|-------------|----------
  `--paper-dialog-scrollable` | Mixin for the scrollable content | {}
  
  @group Paper Elements
  @element paper-dialog-scrollable
  @demo demo/index.html
  @hero hero.svg
  */
  (0, _polymerFn.Polymer)({
    _template: (0, _htmlTag.html)(_templateObject_0350c370942811ecb1937969798b231a || (_templateObject_0350c370942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n    <style>\n\n      :host {\n        display: block;\n        @apply --layout-relative;\n      }\n\n      :host(.is-scrolled:not(:first-child))::before {\n        content: '';\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        height: 1px;\n        background: var(--divider-color);\n      }\n\n      :host(.can-scroll:not(.scrolled-to-bottom):not(:last-child))::after {\n        content: '';\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        height: 1px;\n        background: var(--divider-color);\n      }\n\n      .scrollable {\n        padding: 0 24px;\n\n        @apply --layout-scroll;\n        @apply --paper-dialog-scrollable;\n      }\n\n      .fit {\n        @apply --layout-fit;\n      }\n    </style>\n\n    <div id=\"scrollable\" class=\"scrollable\" on-scroll=\"updateScrollState\">\n      <slot></slot>\n    </div>\n"]))),
    is: 'paper-dialog-scrollable',
    properties: {
      /**
       * The dialog element that implements `Polymer.PaperDialogBehavior`
       * containing this element.
       * @type {?Node}
       */
      dialogElement: {
        type: Object
      }
    },

    /**
     * Returns the scrolling element.
     */
    get scrollTarget() {
      return this.$.scrollable;
    },

    ready: function ready() {
      this._ensureTarget();

      this.classList.add('no-padding');
    },
    attached: function attached() {
      this._ensureTarget();

      requestAnimationFrame(this.updateScrollState.bind(this));
    },
    updateScrollState: function updateScrollState() {
      this.toggleClass('is-scrolled', this.scrollTarget.scrollTop > 0);
      this.toggleClass('can-scroll', this.scrollTarget.offsetHeight < this.scrollTarget.scrollHeight);
      this.toggleClass('scrolled-to-bottom', this.scrollTarget.scrollTop + this.scrollTarget.offsetHeight >= this.scrollTarget.scrollHeight);
    },
    _ensureTarget: function _ensureTarget() {
      // Read parentElement instead of parentNode in order to skip shadowRoots.
      this.dialogElement = this.dialogElement || this.parentElement; // Check if dialog implements paper-dialog-behavior. If not, fit
      // scrollTarget to host.

      if (this.dialogElement && this.dialogElement.behaviors && this.dialogElement.behaviors.indexOf(_paperDialogBehavior.PaperDialogBehaviorImpl) >= 0) {
        this.dialogElement.sizingTarget = this.scrollTarget;
        this.scrollTarget.classList.remove('fit');
      } else if (this.dialogElement) {
        this.scrollTarget.classList.add('fit');
      }
    }
  });
});