define(["exports", "./boot.js"], function (_exports, _boot) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.afterNextRender = afterNextRender;
  _exports.beforeNextRender = beforeNextRender;
  _exports.flush = flush;

  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  /**
   * Module for scheduling flushable pre-render and post-render tasks.
   *
   * @summary Module for scheduling flushable pre-render and post-render tasks.
   */
  var scheduled = false;
  var beforeRenderQueue = [];
  var afterRenderQueue = [];

  function schedule() {
    scheduled = true; // before next render

    requestAnimationFrame(function () {
      scheduled = false;
      flushQueue(beforeRenderQueue); // after the render

      setTimeout(function () {
        runQueue(afterRenderQueue);
      });
    });
  }

  function flushQueue(queue) {
    while (queue.length) {
      callMethod(queue.shift());
    }
  }

  function runQueue(queue) {
    for (var i = 0, l = queue.length; i < l; i++) {
      callMethod(queue.shift());
    }
  }

  function callMethod(info) {
    var context = info[0];
    var callback = info[1];
    var args = info[2];

    try {
      callback.apply(context, args);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }
  /**
   * Flushes all `beforeNextRender` tasks, followed by all `afterNextRender`
   * tasks.
   *
   * @return {void}
   */


  function flush() {
    while (beforeRenderQueue.length || afterRenderQueue.length) {
      flushQueue(beforeRenderQueue);
      flushQueue(afterRenderQueue);
    }

    scheduled = false;
  }
  /**
   * Enqueues a callback which will be run before the next render, at
   * `requestAnimationFrame` timing.
   *
   * This method is useful for enqueuing work that requires DOM measurement,
   * since measurement may not be reliable in custom element callbacks before
   * the first render, as well as for batching measurement tasks in general.
   *
   * Tasks in this queue may be flushed by calling `flush()`.
   *
   * @param {*} context Context object the callback function will be bound to
   * @param {function(...*):void} callback Callback function
   * @param {!Array=} args An array of arguments to call the callback function with
   * @return {void}
   */


  function beforeNextRender(context, callback, args) {
    if (!scheduled) {
      schedule();
    }

    beforeRenderQueue.push([context, callback, args]);
  }
  /**
   * Enqueues a callback which will be run after the next render, equivalent
   * to one task (`setTimeout`) after the next `requestAnimationFrame`.
   *
   * This method is useful for tuning the first-render performance of an
   * element or application by deferring non-critical work until after the
   * first paint.  Typical non-render-critical work may include adding UI
   * event listeners and aria attributes.
   *
   * @param {*} context Context object the callback function will be bound to
   * @param {function(...*):void} callback Callback function
   * @param {!Array=} args An array of arguments to call the callback function with
   * @return {void}
   */


  function afterNextRender(context, callback, args) {
    if (!scheduled) {
      schedule();
    }

    afterRenderQueue.push([context, callback, args]);
  }
});