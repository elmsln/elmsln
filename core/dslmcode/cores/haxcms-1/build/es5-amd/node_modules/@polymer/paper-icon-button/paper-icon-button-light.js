define(["../polymer/polymer-legacy.js", "../paper-behaviors/paper-ripple-behavior.js", "../polymer/lib/legacy/polymer-fn.js", "../polymer/lib/utils/html-tag.js", "../polymer/lib/utils/render-status.js"], function (_polymerLegacy, _paperRippleBehavior, _polymerFn, _htmlTag, _renderStatus) {
  "use strict";

  var _templateObject_03a5e850942811ecb1937969798b231a;

  /**
  This is a lighter version of `paper-icon-button`. Its goal is performance, not
  developer ergonomics, so as a result it has fewer features than
  `paper-icon-button` itself. To use it, you must distribute a `button` containing
  the `iron-icon` you want to use:
  
  <script type="module">
    import '@polymer/iron-icon/iron-icon.js';
    import '@polymer/paper-icon-button/paper-icon-button-light.js';
    import '@polymer/iron-icons/iron-icons.js';
  </script>
  
  <paper-icon-button-light>
    <button title="heart">
      <iron-icon icon="favorite"></iron-icon>
    </button>
  </paper-icon-button-light>
  
  Note that this button is assumed to be distributed at the startup of
  `paper-icon-button-light`. Dynamically adding a `button` to this element is
  not supported.
  
  The `title`/`disabled` etc. attributes go on the distributed button, not on the
  wrapper.
  
  The following custom properties and mixins are also available for styling:
  Custom property | Description | Default
  ----------------|-------------|----------
  `--paper-icon-button-light-ripple` | Mixin applied to the paper ripple | `{}`
  
  @group Paper Elements
  @element paper-icon-button-light
  @demo demo/paper-icon-button-light.html
  */
  (0, _polymerFn.Polymer)({
    is: 'paper-icon-button-light',
    _template: (0, _htmlTag.html)(_templateObject_03a5e850942811ecb1937969798b231a || (_templateObject_03a5e850942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n        width: 24px;\n        height: 24px;\n      }\n\n      paper-ripple {\n        opacity: 0.6;\n        color: currentColor;\n        @apply --paper-icon-button-light-ripple;\n      }\n\n      :host > ::slotted(button) {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        background: none;\n        border: none;\n        outline: none;\n        vertical-align: middle;\n        color: inherit;\n        cursor: pointer;\n        /* NOTE: Both values are needed, since some phones require the value to be `transparent`. */\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n        -webkit-tap-highlight-color: transparent;\n      }\n      :host > ::slotted(button[disabled]) {\n        color: #9b9b9b;\n        pointer-events: none;\n        cursor: auto;\n      }\n    </style>\n    <slot></slot>\n  "], ["\n    <style>\n      :host {\n        display: inline-block;\n        position: relative;\n        width: 24px;\n        height: 24px;\n      }\n\n      paper-ripple {\n        opacity: 0.6;\n        color: currentColor;\n        @apply --paper-icon-button-light-ripple;\n      }\n\n      :host > ::slotted(button) {\n        position: relative;\n        width: 100%;\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        background: none;\n        border: none;\n        outline: none;\n        vertical-align: middle;\n        color: inherit;\n        cursor: pointer;\n        /* NOTE: Both values are needed, since some phones require the value to be \\`transparent\\`. */\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n        -webkit-tap-highlight-color: transparent;\n      }\n      :host > ::slotted(button[disabled]) {\n        color: #9b9b9b;\n        pointer-events: none;\n        cursor: auto;\n      }\n    </style>\n    <slot></slot>\n  "]))),
    behaviors: [_paperRippleBehavior.PaperRippleBehavior],
    registered: function registered() {
      this._template.setAttribute('strip-whitespace', '');
    },
    ready: function ready() {
      var _this = this;

      (0, _renderStatus.afterNextRender)(this, function () {
        // Add lazy host listeners
        _this.addEventListener('down', _this._rippleDown.bind(_this));

        _this.addEventListener('up', _this._rippleUp.bind(_this)); // Assume the button has already been distributed.


        var button = _this.getEffectiveChildren()[0];

        _this._rippleContainer = button; // We need to set the focus/blur listeners on the distributed button,
        // not the host, since the host isn't focusable.

        button.addEventListener('focus', _this._rippleDown.bind(_this));
        button.addEventListener('blur', _this._rippleUp.bind(_this));
      });
    },
    _rippleDown: function _rippleDown() {
      this.getRipple().uiDownAction();
    },
    _rippleUp: function _rippleUp() {
      this.getRipple().uiUpAction();
    },

    /**
     * @param {...*} var_args
     */
    ensureRipple: function ensureRipple(var_args) {
      var lastRipple = this._ripple;

      _paperRippleBehavior.PaperRippleBehavior.ensureRipple.apply(this, arguments);

      if (this._ripple && this._ripple !== lastRipple) {
        this._ripple.center = true;

        this._ripple.classList.add('circle');
      }
    }
  });
});