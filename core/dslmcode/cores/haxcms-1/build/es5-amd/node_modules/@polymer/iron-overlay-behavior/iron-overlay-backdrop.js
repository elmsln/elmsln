define(["../polymer/polymer-legacy.js", "../polymer/lib/legacy/polymer-fn.js", "../polymer/lib/legacy/polymer.dom.js", "../polymer/lib/utils/html-tag.js"], function (_polymerLegacy, _polymerFn, _polymerDom, _htmlTag) {
  "use strict";

  var _templateObject_6dbc2220809211edaa2833647dc78c6c;

  /*
  `iron-overlay-backdrop` is a backdrop used by `Polymer.IronOverlayBehavior`. It
  should be a singleton.
  
  ### Styling
  
  The following custom properties and mixins are available for styling.
  
  Custom property | Description | Default
  -------------------------------------------|------------------------|---------
  `--iron-overlay-backdrop-background-color` | Backdrop background color | #000
  `--iron-overlay-backdrop-opacity`          | Backdrop opacity | 0.6
  `--iron-overlay-backdrop`                  | Mixin applied to `iron-overlay-backdrop`.                      | {}
  `--iron-overlay-backdrop-opened`           | Mixin applied to `iron-overlay-backdrop` when it is displayed | {}
  */
  (0, _polymerFn.Polymer)({
    /** @override */
    _template: (0, _htmlTag.html)(_templateObject_6dbc2220809211edaa2833647dc78c6c || (_templateObject_6dbc2220809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: var(--iron-overlay-backdrop-background-color, #000);\n        opacity: 0;\n        transition: opacity 0.2s;\n        pointer-events: none;\n        @apply --iron-overlay-backdrop;\n      }\n\n      :host(.opened) {\n        opacity: var(--iron-overlay-backdrop-opacity, 0.6);\n        pointer-events: auto;\n        @apply --iron-overlay-backdrop-opened;\n      }\n    </style>\n\n    <slot></slot>\n"]))),
    is: 'iron-overlay-backdrop',
    properties: {
      /**
       * Returns true if the backdrop is opened.
       */
      opened: {
        reflectToAttribute: true,
        type: Boolean,
        value: false,
        observer: '_openedChanged'
      }
    },
    listeners: {
      'transitionend': '_onTransitionend'
    },

    /** @override */
    created: function created() {
      // Used to cancel previous requestAnimationFrame calls when opened changes.
      this.__openedRaf = null;
    },

    /** @override */
    attached: function attached() {
      this.opened && this._openedChanged(this.opened);
    },

    /**
     * Appends the backdrop to document body if needed.
     */
    prepare: function prepare() {
      if (this.opened && !this.parentNode) {
        (0, _polymerDom.dom)(document.body).appendChild(this);
      }
    },

    /**
     * Shows the backdrop.
     */
    open: function open() {
      this.opened = true;
    },

    /**
     * Hides the backdrop.
     */
    close: function close() {
      this.opened = false;
    },

    /**
     * Removes the backdrop from document body if needed.
     */
    complete: function complete() {
      if (!this.opened && this.parentNode === document.body) {
        (0, _polymerDom.dom)(this.parentNode).removeChild(this);
      }
    },
    _onTransitionend: function _onTransitionend(event) {
      if (event && event.target === this) {
        this.complete();
      }
    },

    /**
     * @param {boolean} opened
     * @private
     */
    _openedChanged: function _openedChanged(opened) {
      if (opened) {
        // Auto-attach.
        this.prepare();
      } else {
        // Animation might be disabled via the mixin or opacity custom property.
        // If it is disabled in other ways, it's up to the user to call complete.
        var cs = window.getComputedStyle(this);

        if (cs.transitionDuration === '0s' || cs.opacity == 0) {
          this.complete();
        }
      }

      if (!this.isAttached) {
        return;
      } // Always cancel previous requestAnimationFrame.


      if (this.__openedRaf) {
        window.cancelAnimationFrame(this.__openedRaf);
        this.__openedRaf = null;
      } // Force relayout to ensure proper transitions.


      this.scrollTop = this.scrollTop;
      this.__openedRaf = window.requestAnimationFrame(function () {
        this.__openedRaf = null;
        this.toggleClass('opened', this.opened);
      }.bind(this));
    }
  });
});