define(["../polymer/polymer-legacy.js", "../iron-flex-layout/iron-flex-layout.js", "../iron-icon/iron-icon.js", "../paper-icon-button/paper-icon-button.js", "../paper-styles/color.js", "./paper-tabs-icons.js", "./paper-tab.js", "../iron-menu-behavior/iron-menu-behavior.js", "../iron-menu-behavior/iron-menubar-behavior.js", "../iron-resizable-behavior/iron-resizable-behavior.js", "../polymer/lib/legacy/polymer-fn.js", "../polymer/lib/legacy/polymer.dom.js", "../polymer/lib/utils/html-tag.js"], function (_polymerLegacy, _ironFlexLayout, _ironIcon, _paperIconButton, _color, _paperTabsIcons, _paperTab, _ironMenuBehavior, _ironMenubarBehavior, _ironResizableBehavior, _polymerFn, _polymerDom, _htmlTag) {
  "use strict";

  var _templateObject_57704730809211edaa2833647dc78c6c;

  /**
  Material design: [Tabs](https://www.google.com/design/spec/components/tabs.html)
  
  `paper-tabs` makes it easy to explore and switch between different views or
  functional aspects of an app, or to browse categorized data sets.
  
  Use `selected` property to get or set the selected tab.
  
  Example:
  
      <paper-tabs selected="0">
        <paper-tab>TAB 1</paper-tab>
        <paper-tab>TAB 2</paper-tab>
        <paper-tab>TAB 3</paper-tab>
      </paper-tabs>
  
  See <a href="?active=paper-tab">paper-tab</a> for more information about
  `paper-tab`.
  
  A common usage for `paper-tabs` is to use it along with `iron-pages` to switch
  between different views.
  
      <paper-tabs selected="{{selected}}">
        <paper-tab>Tab 1</paper-tab>
        <paper-tab>Tab 2</paper-tab>
        <paper-tab>Tab 3</paper-tab>
      </paper-tabs>
  
      <iron-pages selected="{{selected}}">
        <div>Page 1</div>
        <div>Page 2</div>
        <div>Page 3</div>
      </iron-pages>
  
  To use links in tabs, add `link` attribute to `paper-tab` and put an `<a>`
  element in `paper-tab` with a `tabindex` of -1.
  
  Example:
  
  <pre><code>
  &lt;style is="custom-style">
    .link {
      &#64;apply --layout-horizontal;
      &#64;apply --layout-center-center;
    }
  &lt;/style>
  
  &lt;paper-tabs selected="0">
    &lt;paper-tab link>
      &lt;a href="#link1" class="link" tabindex="-1">TAB ONE&lt;/a>
    &lt;/paper-tab>
    &lt;paper-tab link>
      &lt;a href="#link2" class="link" tabindex="-1">TAB TWO&lt;/a>
    &lt;/paper-tab>
    &lt;paper-tab link>
      &lt;a href="#link3" class="link" tabindex="-1">TAB THREE&lt;/a>
    &lt;/paper-tab>
  &lt;/paper-tabs>
  </code></pre>
  
  ### Styling
  
  The following custom properties and mixins are available for styling:
  
  Custom property | Description | Default
  ----------------|-------------|----------
  `--paper-tabs-selection-bar-color` | Color for the selection bar | `--paper-yellow-a100`
  `--paper-tabs-selection-bar` | Mixin applied to the selection bar | `{}`
  `--paper-tabs` | Mixin applied to the tabs | `{}`
  `--paper-tabs-content` | Mixin applied to the content container of tabs | `{}`
  `--paper-tabs-container` | Mixin applied to the layout container of tabs | `{}`
  
  @demo demo/index.html
  */
  (0, _polymerFn.Polymer)({
    _template: (0, _htmlTag.html)(_templateObject_57704730809211edaa2833647dc78c6c || (_templateObject_57704730809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        @apply --layout;\n        @apply --layout-center;\n\n        height: 48px;\n        font-size: 14px;\n        font-weight: 500;\n        overflow: hidden;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        -webkit-user-select: none;\n        user-select: none;\n\n        /* NOTE: Both values are needed, since some phones require the value to be `transparent`. */\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n        -webkit-tap-highlight-color: transparent;\n\n        @apply --paper-tabs;\n      }\n\n      :host(:dir(rtl)) {\n        @apply --layout-horizontal-reverse;\n      }\n\n      #tabsContainer {\n        position: relative;\n        height: 100%;\n        white-space: nowrap;\n        overflow: hidden;\n        @apply --layout-flex-auto;\n        @apply --paper-tabs-container;\n      }\n\n      #tabsContent {\n        height: 100%;\n        -moz-flex-basis: auto;\n        -ms-flex-basis: auto;\n        flex-basis: auto;\n        @apply --paper-tabs-content;\n      }\n\n      #tabsContent.scrollable {\n        position: absolute;\n        white-space: nowrap;\n      }\n\n      #tabsContent:not(.scrollable),\n      #tabsContent.scrollable.fit-container {\n        @apply --layout-horizontal;\n      }\n\n      #tabsContent.scrollable.fit-container {\n        min-width: 100%;\n      }\n\n      #tabsContent.scrollable.fit-container > ::slotted(*) {\n        /* IE - prevent tabs from compressing when they should scroll. */\n        -ms-flex: 1 0 auto;\n        -webkit-flex: 1 0 auto;\n        flex: 1 0 auto;\n      }\n\n      .hidden {\n        display: none;\n      }\n\n      .not-visible {\n        opacity: 0;\n        cursor: default;\n      }\n\n      paper-icon-button {\n        width: 48px;\n        height: 48px;\n        padding: 12px;\n        margin: 0 4px;\n      }\n\n      #selectionBar {\n        position: absolute;\n        height: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        border-bottom: 2px solid var(--paper-tabs-selection-bar-color, var(--paper-yellow-a100));\n          -webkit-transform: scale(0);\n        transform: scale(0);\n          -webkit-transform-origin: left center;\n        transform-origin: left center;\n          transition: -webkit-transform;\n        transition: transform;\n\n        @apply --paper-tabs-selection-bar;\n      }\n\n      #selectionBar.align-bottom {\n        top: 0;\n        bottom: auto;\n      }\n\n      #selectionBar.expand {\n        transition-duration: 0.15s;\n        transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);\n      }\n\n      #selectionBar.contract {\n        transition-duration: 0.18s;\n        transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);\n      }\n\n      #tabsContent > ::slotted(:not(#selectionBar)) {\n        height: 100%;\n      }\n    </style>\n\n    <paper-icon-button icon=\"paper-tabs:chevron-left\" class$=\"[[_computeScrollButtonClass(_leftHidden, scrollable, hideScrollButtons)]]\" on-up=\"_onScrollButtonUp\" on-down=\"_onLeftScrollButtonDown\" tabindex=\"-1\"></paper-icon-button>\n\n    <div id=\"tabsContainer\" on-track=\"_scroll\" on-down=\"_down\">\n      <div id=\"tabsContent\" class$=\"[[_computeTabsContentClass(scrollable, fitContainer)]]\">\n        <div id=\"selectionBar\" class$=\"[[_computeSelectionBarClass(noBar, alignBottom)]]\" on-transitionend=\"_onBarTransitionEnd\"></div>\n        <slot></slot>\n      </div>\n    </div>\n\n    <paper-icon-button icon=\"paper-tabs:chevron-right\" class$=\"[[_computeScrollButtonClass(_rightHidden, scrollable, hideScrollButtons)]]\" on-up=\"_onScrollButtonUp\" on-down=\"_onRightScrollButtonDown\" tabindex=\"-1\"></paper-icon-button>\n"], ["\n    <style>\n      :host {\n        @apply --layout;\n        @apply --layout-center;\n\n        height: 48px;\n        font-size: 14px;\n        font-weight: 500;\n        overflow: hidden;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        -webkit-user-select: none;\n        user-select: none;\n\n        /* NOTE: Both values are needed, since some phones require the value to be \\`transparent\\`. */\n        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n        -webkit-tap-highlight-color: transparent;\n\n        @apply --paper-tabs;\n      }\n\n      :host(:dir(rtl)) {\n        @apply --layout-horizontal-reverse;\n      }\n\n      #tabsContainer {\n        position: relative;\n        height: 100%;\n        white-space: nowrap;\n        overflow: hidden;\n        @apply --layout-flex-auto;\n        @apply --paper-tabs-container;\n      }\n\n      #tabsContent {\n        height: 100%;\n        -moz-flex-basis: auto;\n        -ms-flex-basis: auto;\n        flex-basis: auto;\n        @apply --paper-tabs-content;\n      }\n\n      #tabsContent.scrollable {\n        position: absolute;\n        white-space: nowrap;\n      }\n\n      #tabsContent:not(.scrollable),\n      #tabsContent.scrollable.fit-container {\n        @apply --layout-horizontal;\n      }\n\n      #tabsContent.scrollable.fit-container {\n        min-width: 100%;\n      }\n\n      #tabsContent.scrollable.fit-container > ::slotted(*) {\n        /* IE - prevent tabs from compressing when they should scroll. */\n        -ms-flex: 1 0 auto;\n        -webkit-flex: 1 0 auto;\n        flex: 1 0 auto;\n      }\n\n      .hidden {\n        display: none;\n      }\n\n      .not-visible {\n        opacity: 0;\n        cursor: default;\n      }\n\n      paper-icon-button {\n        width: 48px;\n        height: 48px;\n        padding: 12px;\n        margin: 0 4px;\n      }\n\n      #selectionBar {\n        position: absolute;\n        height: 0;\n        bottom: 0;\n        left: 0;\n        right: 0;\n        border-bottom: 2px solid var(--paper-tabs-selection-bar-color, var(--paper-yellow-a100));\n          -webkit-transform: scale(0);\n        transform: scale(0);\n          -webkit-transform-origin: left center;\n        transform-origin: left center;\n          transition: -webkit-transform;\n        transition: transform;\n\n        @apply --paper-tabs-selection-bar;\n      }\n\n      #selectionBar.align-bottom {\n        top: 0;\n        bottom: auto;\n      }\n\n      #selectionBar.expand {\n        transition-duration: 0.15s;\n        transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);\n      }\n\n      #selectionBar.contract {\n        transition-duration: 0.18s;\n        transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);\n      }\n\n      #tabsContent > ::slotted(:not(#selectionBar)) {\n        height: 100%;\n      }\n    </style>\n\n    <paper-icon-button icon=\"paper-tabs:chevron-left\" class$=\"[[_computeScrollButtonClass(_leftHidden, scrollable, hideScrollButtons)]]\" on-up=\"_onScrollButtonUp\" on-down=\"_onLeftScrollButtonDown\" tabindex=\"-1\"></paper-icon-button>\n\n    <div id=\"tabsContainer\" on-track=\"_scroll\" on-down=\"_down\">\n      <div id=\"tabsContent\" class$=\"[[_computeTabsContentClass(scrollable, fitContainer)]]\">\n        <div id=\"selectionBar\" class$=\"[[_computeSelectionBarClass(noBar, alignBottom)]]\" on-transitionend=\"_onBarTransitionEnd\"></div>\n        <slot></slot>\n      </div>\n    </div>\n\n    <paper-icon-button icon=\"paper-tabs:chevron-right\" class$=\"[[_computeScrollButtonClass(_rightHidden, scrollable, hideScrollButtons)]]\" on-up=\"_onScrollButtonUp\" on-down=\"_onRightScrollButtonDown\" tabindex=\"-1\"></paper-icon-button>\n"]))),
    is: 'paper-tabs',
    behaviors: [_ironResizableBehavior.IronResizableBehavior, _ironMenubarBehavior.IronMenubarBehavior],
    properties: {
      /**
       * If true, ink ripple effect is disabled. When this property is changed,
       * all descendant `<paper-tab>` elements have their `noink` property
       * changed to the new value as well.
       */
      noink: {
        type: Boolean,
        value: false,
        observer: '_noinkChanged'
      },

      /**
       * If true, the bottom bar to indicate the selected tab will not be shown.
       */
      noBar: {
        type: Boolean,
        value: false
      },

      /**
       * If true, the slide effect for the bottom bar is disabled.
       */
      noSlide: {
        type: Boolean,
        value: false
      },

      /**
       * If true, tabs are scrollable and the tab width is based on the label
       * width.
       */
      scrollable: {
        type: Boolean,
        value: false
      },

      /**
       * If true, tabs expand to fit their container. This currently only applies
       * when scrollable is true.
       */
      fitContainer: {
        type: Boolean,
        value: false
      },

      /**
       * If true, dragging on the tabs to scroll is disabled.
       */
      disableDrag: {
        type: Boolean,
        value: false
      },

      /**
       * If true, scroll buttons (left/right arrow) will be hidden for scrollable
       * tabs.
       */
      hideScrollButtons: {
        type: Boolean,
        value: false
      },

      /**
       * If true, the tabs are aligned to bottom (the selection bar appears at the
       * top).
       */
      alignBottom: {
        type: Boolean,
        value: false
      },
      selectable: {
        type: String,
        value: 'paper-tab'
      },

      /**
       * If true, tabs are automatically selected when focused using the
       * keyboard.
       */
      autoselect: {
        type: Boolean,
        value: false
      },

      /**
       * The delay (in milliseconds) between when the user stops interacting
       * with the tabs through the keyboard and when the focused item is
       * automatically selected (if `autoselect` is true).
       */
      autoselectDelay: {
        type: Number,
        value: 0
      },
      _step: {
        type: Number,
        value: 10
      },
      _holdDelay: {
        type: Number,
        value: 1
      },
      _leftHidden: {
        type: Boolean,
        value: false
      },
      _rightHidden: {
        type: Boolean,
        value: false
      },
      _previousTab: {
        type: Object
      }
    },

    /** @private */
    hostAttributes: {
      role: 'tablist'
    },
    listeners: {
      'iron-resize': '_onTabSizingChanged',
      'iron-items-changed': '_onTabSizingChanged',
      'iron-select': '_onIronSelect',
      'iron-deselect': '_onIronDeselect'
    },

    /**
     * @type {!Object}
     */
    keyBindings: {
      'left:keyup right:keyup': '_onArrowKeyup'
    },
    created: function created() {
      this._holdJob = null;
      this._pendingActivationItem = undefined;
      this._pendingActivationTimeout = undefined;
      this._bindDelayedActivationHandler = this._delayedActivationHandler.bind(this);
      this.addEventListener('blur', this._onBlurCapture.bind(this), true);
    },
    ready: function ready() {
      this.setScrollDirection('y', this.$.tabsContainer);
    },
    detached: function detached() {
      this._cancelPendingActivation();
    },
    _noinkChanged: function _noinkChanged(noink) {
      var childTabs = (0, _polymerDom.dom)(this).querySelectorAll('paper-tab');
      childTabs.forEach(noink ? this._setNoinkAttribute : this._removeNoinkAttribute);
    },
    _setNoinkAttribute: function _setNoinkAttribute(element) {
      element.setAttribute('noink', '');
    },
    _removeNoinkAttribute: function _removeNoinkAttribute(element) {
      element.removeAttribute('noink');
    },
    _computeScrollButtonClass: function _computeScrollButtonClass(hideThisButton, scrollable, hideScrollButtons) {
      if (!scrollable || hideScrollButtons) {
        return 'hidden';
      }

      if (hideThisButton) {
        return 'not-visible';
      }

      return '';
    },
    _computeTabsContentClass: function _computeTabsContentClass(scrollable, fitContainer) {
      return scrollable ? 'scrollable' + (fitContainer ? ' fit-container' : '') : ' fit-container';
    },
    _computeSelectionBarClass: function _computeSelectionBarClass(noBar, alignBottom) {
      if (noBar) {
        return 'hidden';
      } else if (alignBottom) {
        return 'align-bottom';
      }

      return '';
    },
    // TODO(cdata): Add `track` response back in when gesture lands.
    _onTabSizingChanged: function _onTabSizingChanged() {
      this.debounce('_onTabSizingChanged', function () {
        this._scroll();

        this._tabChanged(this.selectedItem);
      }, 10);
    },
    _onIronSelect: function _onIronSelect(event) {
      this._tabChanged(event.detail.item, this._previousTab);

      this._previousTab = event.detail.item;
      this.cancelDebouncer('tab-changed');
    },
    _onIronDeselect: function _onIronDeselect(event) {
      this.debounce('tab-changed', function () {
        this._tabChanged(null, this._previousTab);

        this._previousTab = null; // See polymer/polymer#1305
      }, 1);
    },
    _activateHandler: function _activateHandler() {
      // Cancel item activations scheduled by keyboard events when any other
      // action causes an item to be activated (e.g. clicks).
      this._cancelPendingActivation();

      _ironMenuBehavior.IronMenuBehaviorImpl._activateHandler.apply(this, arguments);
    },

    /**
     * Activates an item after a delay (in milliseconds).
     */
    _scheduleActivation: function _scheduleActivation(item, delay) {
      this._pendingActivationItem = item;
      this._pendingActivationTimeout = this.async(this._bindDelayedActivationHandler, delay);
    },

    /**
     * Activates the last item given to `_scheduleActivation`.
     */
    _delayedActivationHandler: function _delayedActivationHandler() {
      var item = this._pendingActivationItem;
      this._pendingActivationItem = undefined;
      this._pendingActivationTimeout = undefined;
      item.fire(this.activateEvent, null, {
        bubbles: true,
        cancelable: true
      });
    },

    /**
     * Cancels a previously scheduled item activation made with
     * `_scheduleActivation`.
     */
    _cancelPendingActivation: function _cancelPendingActivation() {
      if (this._pendingActivationTimeout !== undefined) {
        this.cancelAsync(this._pendingActivationTimeout);
        this._pendingActivationItem = undefined;
        this._pendingActivationTimeout = undefined;
      }
    },
    _onArrowKeyup: function _onArrowKeyup(event) {
      if (this.autoselect) {
        this._scheduleActivation(this.focusedItem, this.autoselectDelay);
      }
    },
    _onBlurCapture: function _onBlurCapture(event) {
      // Cancel a scheduled item activation (if any) when that item is
      // blurred.
      if (event.target === this._pendingActivationItem) {
        this._cancelPendingActivation();
      }
    },

    get _tabContainerScrollSize() {
      return Math.max(0, this.$.tabsContainer.scrollWidth - this.$.tabsContainer.offsetWidth);
    },

    _scroll: function _scroll(e, detail) {
      if (!this.scrollable) {
        return;
      }

      var ddx = detail && -detail.ddx || 0;

      this._affectScroll(ddx);
    },
    _down: function _down(e) {
      // go one beat async to defeat IronMenuBehavior
      // autorefocus-on-no-selection timeout
      this.async(function () {
        if (this._defaultFocusAsync) {
          this.cancelAsync(this._defaultFocusAsync);
          this._defaultFocusAsync = null;
        }
      }, 1);
    },
    _affectScroll: function _affectScroll(dx) {
      this.$.tabsContainer.scrollLeft += dx;
      var scrollLeft = this.$.tabsContainer.scrollLeft;
      this._leftHidden = scrollLeft === 0;
      this._rightHidden = scrollLeft === this._tabContainerScrollSize;
    },
    _onLeftScrollButtonDown: function _onLeftScrollButtonDown() {
      this._scrollToLeft();

      this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
    },
    _onRightScrollButtonDown: function _onRightScrollButtonDown() {
      this._scrollToRight();

      this._holdJob = setInterval(this._scrollToRight.bind(this), this._holdDelay);
    },
    _onScrollButtonUp: function _onScrollButtonUp() {
      clearInterval(this._holdJob);
      this._holdJob = null;
    },
    _scrollToLeft: function _scrollToLeft() {
      this._affectScroll(-this._step);
    },
    _scrollToRight: function _scrollToRight() {
      this._affectScroll(this._step);
    },
    _tabChanged: function _tabChanged(tab, old) {
      if (!tab) {
        // Remove the bar without animation.
        this.$.selectionBar.classList.remove('expand');
        this.$.selectionBar.classList.remove('contract');

        this._positionBar(0, 0);

        return;
      }

      var r = this.$.tabsContent.getBoundingClientRect();
      var w = r.width;
      var tabRect = tab.getBoundingClientRect();
      var tabOffsetLeft = tabRect.left - r.left;
      this._pos = {
        width: this._calcPercent(tabRect.width, w),
        left: this._calcPercent(tabOffsetLeft, w)
      };

      if (this.noSlide || old == null) {
        // Position the bar without animation.
        this.$.selectionBar.classList.remove('expand');
        this.$.selectionBar.classList.remove('contract');

        this._positionBar(this._pos.width, this._pos.left);

        return;
      }

      var oldRect = old.getBoundingClientRect();
      var oldIndex = this.items.indexOf(old);
      var index = this.items.indexOf(tab);
      var m = 5; // bar animation: expand

      this.$.selectionBar.classList.add('expand');
      var moveRight = oldIndex < index;
      var isRTL = this._isRTL;

      if (isRTL) {
        moveRight = !moveRight;
      }

      if (moveRight) {
        this._positionBar(this._calcPercent(tabRect.left + tabRect.width - oldRect.left, w) - m, this._left);
      } else {
        this._positionBar(this._calcPercent(oldRect.left + oldRect.width - tabRect.left, w) - m, this._calcPercent(tabOffsetLeft, w) + m);
      }

      if (this.scrollable) {
        this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
      }
    },
    _scrollToSelectedIfNeeded: function _scrollToSelectedIfNeeded(tabWidth, tabOffsetLeft) {
      var l = tabOffsetLeft - this.$.tabsContainer.scrollLeft;

      if (l < 0) {
        this.$.tabsContainer.scrollLeft += l;
      } else {
        l += tabWidth - this.$.tabsContainer.offsetWidth;

        if (l > 0) {
          this.$.tabsContainer.scrollLeft += l;
        }
      }
    },
    _calcPercent: function _calcPercent(w, w0) {
      return 100 * w / w0;
    },
    _positionBar: function _positionBar(width, left) {
      width = width || 0;
      left = left || 0;
      this._width = width;
      this._left = left;
      this.transform('translateX(' + left + '%) scaleX(' + width / 100 + ')', this.$.selectionBar);
    },
    _onBarTransitionEnd: function _onBarTransitionEnd(e) {
      var cl = this.$.selectionBar.classList; // bar animation: expand -> contract

      if (cl.contains('expand')) {
        cl.remove('expand');
        cl.add('contract');

        this._positionBar(this._pos.width, this._pos.left); // bar animation done

      } else if (cl.contains('contract')) {
        cl.remove('contract');
      }
    }
  });
});