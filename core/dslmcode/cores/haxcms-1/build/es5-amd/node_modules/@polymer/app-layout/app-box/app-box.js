define(["../../polymer/polymer-legacy.js", "../../iron-flex-layout/iron-flex-layout.js", "../../iron-resizable-behavior/iron-resizable-behavior.js", "../../polymer/lib/legacy/polymer-fn.js", "../../polymer/lib/utils/html-tag.js", "../app-scroll-effects/app-scroll-effects-behavior.js"], function (_polymerLegacy, _ironFlexLayout, _ironResizableBehavior, _polymerFn, _htmlTag, _appScrollEffectsBehavior) {
  "use strict";

  var _templateObject_714e97b0809211edaa2833647dc78c6c;

  /**
  app-box is a container element that can have scroll effects - visual effects
  based on scroll position. For example, the parallax effect can be used to move
  an image at a slower rate than the foreground.
  
  ```html
  <app-box style="height: 100px;" effects="parallax-background">
    <img slot="background" src="picture.png" style="width: 100%; height: 600px;">
  </app-box>
  ```
  
  Notice the `background` attribute in the `img` element; this attribute specifies
  that that image is used as the background. By adding the background to the light
  dom, you can compose backgrounds that can change dynamically. Alternatively, the
  mixin `--app-box-background-front-layer` allows to style the background. For
  example:
  
  ```css
    .parallaxAppBox {
      --app-box-background-front-layer: {
        background-image: url(picture.png);
      };
    }
  ```
  
  Finally, app-box can have content inside. For example:
  
  ```html
  <app-box effects="parallax-background">
    <h2>Sub title</h2>
  </app-box>
  ```
  
  #### Importing the effects
  
  To use the scroll effects, you must explicitly import them in addition to
  `app-box`:
  
  ```js
  import '@polymer/app-layout/app-scroll-effects/app-scroll-effects.js';
  ```
  
  #### List of effects
  
  * **parallax-background**
  A simple parallax effect that vertically translates the backgrounds based on a
  fraction of the scroll position. For example:
  
  ```css
  app-header {
    --app-header-background-front-layer: {
      background-image: url(...);
    };
  }
  ```
  ```html
  <app-header style="height: 300px;" effects="parallax-background">
    <app-toolbar>App name</app-toolbar>
  </app-header>
  ```
  
  The fraction determines how far the background moves relative to the scroll
  position. This value can be assigned via the `scalar` config value and it is
  typically a value between 0 and 1 inclusive. If `scalar=0`, the background
  doesn't move away from the header.
  
  ## Styling
  
  Mixin | Description | Default
  ----------------|-------------|----------
  `--app-box-background-front-layer` | Applies to the front layer of the background | {}
  
  @element app-box
  @demo app-box/demo/document-scroll.html Document Scroll
  @demo app-box/demo/scrolling-region.html Scrolling Region
  */
  (0, _polymerFn.Polymer)({
    /** @override */
    _template: (0, _htmlTag.html)(_templateObject_714e97b0809211edaa2833647dc78c6c || (_templateObject_714e97b0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        position: relative;\n        display: block;\n      }\n\n      #background {\n        @apply --layout-fit;\n        overflow: hidden;\n        height: 100%;\n      }\n\n      #backgroundFrontLayer {\n        min-height: 100%;\n        pointer-events: none;\n        background-size: cover;\n        @apply --app-box-background-front-layer;\n      }\n\n      #contentContainer {\n        position: relative;\n        width: 100%;\n        height: 100%;\n      }\n\n      :host([disabled]),\n      :host([disabled]) #backgroundFrontLayer {\n        transition: none !important;\n      }\n    </style>\n\n    <div id=\"background\">\n      <div id=\"backgroundFrontLayer\">\n        <slot name=\"background\"></slot>\n      </div>\n    </div>\n    <div id=\"contentContainer\">\n      <slot></slot>\n    </div>\n"]))),
    is: 'app-box',
    behaviors: [_appScrollEffectsBehavior.AppScrollEffectsBehavior, _ironResizableBehavior.IronResizableBehavior],
    listeners: {
      'iron-resize': '_resizeHandler'
    },

    /**
     * The current scroll progress.
     *
     * @type {number}
     */
    _progress: 0,

    /** @override */
    attached: function attached() {
      this.resetLayout();
    },
    _debounceRaf: function _debounceRaf(fn) {
      var self = this;

      if (this._raf) {
        window.cancelAnimationFrame(this._raf);
      }

      this._raf = window.requestAnimationFrame(function () {
        self._raf = null;
        fn.call(self);
      });
    },

    /**
     * Resets the layout. This method is automatically called when the element is
     * attached to the DOM.
     *
     * @method resetLayout
     */
    resetLayout: function resetLayout() {
      this._debounceRaf(function () {
        // noop if the box isn't in the rendered tree
        if (this.offsetWidth === 0 && this.offsetHeight === 0) {
          return;
        }

        var scrollTop = this._clampedScrollTop;
        var savedDisabled = this.disabled;
        this.disabled = true;
        this._elementTop = this._getElementTop();
        this._elementHeight = this.offsetHeight;
        this._cachedScrollTargetHeight = this._scrollTargetHeight;

        this._setUpEffect();

        this._updateScrollState(scrollTop);

        this.disabled = savedDisabled;
      });
    },
    _getElementTop: function _getElementTop() {
      var currentNode = this;
      var top = 0;

      while (currentNode && currentNode !== this.scrollTarget) {
        top += currentNode.offsetTop;
        currentNode = currentNode.offsetParent;
      }

      return top;
    },
    _updateScrollState: function _updateScrollState(scrollTop) {
      if (this.isOnScreen()) {
        var viewportTop = this._elementTop - scrollTop;
        this._progress = 1 - (viewportTop + this._elementHeight) / this._cachedScrollTargetHeight;

        this._runEffects(this._progress, scrollTop);
      }
    },

    /**
     * Returns true if this app-box is on the screen.
     * That is, visible in the current viewport.
     *
     * @method isOnScreen
     * @return {boolean}
     */
    isOnScreen: function isOnScreen() {
      return this._elementTop < this._scrollTop + this._cachedScrollTargetHeight && this._elementTop + this._elementHeight > this._scrollTop;
    },
    _resizeHandler: function _resizeHandler() {
      this.resetLayout();
    },
    _getDOMRef: function _getDOMRef(id) {
      if (id === 'background') {
        return this.$.background;
      }

      if (id === 'backgroundFrontLayer') {
        return this.$.backgroundFrontLayer;
      }
    },

    /**
     * Returns an object containing the progress value of the scroll effects.
     *
     * @method getScrollState
     * @return {Object}
     */
    getScrollState: function getScrollState() {
      return {
        progress: this._progress
      };
    }
  });
});