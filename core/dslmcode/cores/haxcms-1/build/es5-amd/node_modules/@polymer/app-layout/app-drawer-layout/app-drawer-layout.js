define(["../../polymer/polymer-legacy.js", "../../iron-media-query/iron-media-query.js", "../../polymer/lib/legacy/polymer-fn.js", "../../polymer/lib/legacy/polymer.dom.js", "../../polymer/lib/utils/html-tag.js", "../../polymer/lib/utils/render-status.js", "../app-layout-behavior/app-layout-behavior.js"], function (_polymerLegacy, _ironMediaQuery, _polymerFn, _polymerDom, _htmlTag, _renderStatus, _appLayoutBehavior) {
  "use strict";

  var _templateObject_96f77f608e0011ed99ce491205e67b1d;

  /**
  app-drawer-layout is a wrapper element that positions an app-drawer and other
  content. When the viewport width is smaller than `responsiveWidth`, this element
  changes to narrow layout. In narrow layout, the drawer will be stacked on top of
  the main content. The drawer will slide in/out to hide/reveal the main content.
  
  By default the drawer is aligned to the start, which is left in LTR layouts:
  
  ```html
  <app-drawer-layout>
    <app-drawer slot="drawer">
      drawer content
    </app-drawer>
    <div>
      main content
    </div>
  </app-drawer-layout>
  ```
  
  Align the drawer at the end:
  
  ```html
  <app-drawer-layout>
    <app-drawer slot="drawer" align="end">
       drawer content
    </app-drawer>
    <div>
      main content
    </div>
  </app-drawer-layout>
  ```
  
  With an app-header-layout:
  
  ```html
  <app-drawer-layout>
    <app-drawer slot="drawer">
      drawer-content
    </app-drawer>
    <app-header-layout>
      <app-header slot="header">
        <app-toolbar>
          <div main-title>App name</div>
        </app-toolbar>
      </app-header>
  
      main content
  
    </app-header-layout>
  </app-drawer-layout>
  ```
  
  Add the `drawer-toggle` attribute to elements inside `app-drawer-layout` that
  toggle the drawer on click events:
  
  ```html
  <app-drawer-layout>
    <app-drawer slot="drawer">
      drawer-content
    </app-drawer>
    <app-header-layout>
      <app-header slot="header">
        <app-toolbar>
          <paper-icon-button icon="menu" drawer-toggle></paper-icon-button>
          <div main-title>App name</div>
        </app-toolbar>
      </app-header>
  
      main content
  
    </app-header-layout>
  </app-drawer-layout>
  ```
  
  **NOTE:** With app-layout 2.0, the `drawer-toggle` element needs to be manually
  hidden when app-drawer-layout is not in narrow layout. To add this, add the
  following CSS rule where app-drawer-layout is used:
  
  ```css
  app-drawer-layout:not([narrow]) [drawer-toggle] {
    display: none;
  }
  ```
  
  Add the `fullbleed` attribute to app-drawer-layout to make it fit the size of
  its container:
  
  ```html
  <app-drawer-layout fullbleed>
    <app-drawer slot="drawer">
       drawer content
    </app-drawer>
    <div>
      main content
    </div>
  </app-drawer-layout>
  ```
  
  ### Styling
  
  Custom property                          | Description                          | Default
  -----------------------------------------|--------------------------------------|---------
  `--app-drawer-width`                     | Width of the drawer                  | 256px
  `--app-drawer-layout-content-transition` | Transition for the content container | none
  
  **NOTE:** If you use <app-drawer> with <app-drawer-layout> and specify a value
  for
  `--app-drawer-width`, that value must be accessible by both elements. This can
  be done by defining the value on the `:host` that contains <app-drawer-layout>
  (or `html` if outside a shadow root):
  
  ```css
  :host {
    --app-drawer-width: 300px;
  }
  ```
  
  @element app-drawer-layout
  @demo app-drawer-layout/demo/index.html
  */
  (0, _polymerFn.Polymer)({
    /** @override */
    _template: (0, _htmlTag.html)(_templateObject_96f77f608e0011ed99ce491205e67b1d || (_templateObject_96f77f608e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n    <style>\n      :host {\n        display: block;\n        /**\n         * Force app-drawer-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements.\n         */\n        position: relative;\n        z-index: 0;\n      }\n\n      :host ::slotted([slot=drawer]) {\n        z-index: 1;\n      }\n\n      :host([fullbleed]) {\n        @apply --layout-fit;\n      }\n\n      #contentContainer {\n        /* Create a stacking context here so that all children appear below the header. */\n        position: relative;\n        z-index: 0;\n        height: 100%;\n        transition: var(--app-drawer-layout-content-transition, none);\n      }\n\n      #contentContainer[drawer-position=left] {\n        margin-left: var(--app-drawer-width, 256px);\n      }\n\n      #contentContainer[drawer-position=right] {\n        margin-right: var(--app-drawer-width, 256px);\n      }\n    </style>\n\n    <slot id=\"drawerSlot\" name=\"drawer\"></slot>\n\n    <div id=\"contentContainer\" drawer-position$=\"[[_drawerPosition]]\">\n      <slot></slot>\n    </div>\n\n    <iron-media-query query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\" on-query-matches-changed=\"_onQueryMatchesChanged\"></iron-media-query>\n"], ["\n    <style>\n      :host {\n        display: block;\n        /**\n         * Force app-drawer-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements.\n         */\n        position: relative;\n        z-index: 0;\n      }\n\n      :host ::slotted([slot=drawer]) {\n        z-index: 1;\n      }\n\n      :host([fullbleed]) {\n        @apply --layout-fit;\n      }\n\n      #contentContainer {\n        /* Create a stacking context here so that all children appear below the header. */\n        position: relative;\n        z-index: 0;\n        height: 100%;\n        transition: var(--app-drawer-layout-content-transition, none);\n      }\n\n      #contentContainer[drawer-position=left] {\n        margin-left: var(--app-drawer-width, 256px);\n      }\n\n      #contentContainer[drawer-position=right] {\n        margin-right: var(--app-drawer-width, 256px);\n      }\n    </style>\n\n    <slot id=\"drawerSlot\" name=\"drawer\"></slot>\n\n    <div id=\"contentContainer\" drawer-position\\$=\"[[_drawerPosition]]\">\n      <slot></slot>\n    </div>\n\n    <iron-media-query query=\"[[_computeMediaQuery(forceNarrow, responsiveWidth)]]\" on-query-matches-changed=\"_onQueryMatchesChanged\"></iron-media-query>\n"]))),
    is: 'app-drawer-layout',
    behaviors: [_appLayoutBehavior.AppLayoutBehavior],
    properties: {
      /**
       * If true, ignore `responsiveWidth` setting and force the narrow layout.
       */
      forceNarrow: {
        type: Boolean,
        value: false
      },

      /**
       * If the viewport's width is smaller than this value, the panel will change
       * to narrow layout. In the mode the drawer will be closed.
       */
      responsiveWidth: {
        type: String,
        value: '640px'
      },

      /**
       * Returns true if it is in narrow layout. This is useful if you need to
       * show/hide elements based on the layout.
       */
      narrow: {
        type: Boolean,
        reflectToAttribute: true,
        readOnly: true,
        notify: true
      },

      /**
       * If true, the drawer will initially be opened when in narrow layout mode.
       */
      openedWhenNarrow: {
        type: Boolean,
        value: false
      },
      _drawerPosition: {
        type: String
      }
    },
    listeners: {
      'click': '_clickHandler'
    },
    observers: ['_narrowChanged(narrow)'],

    /**
     * A reference to the app-drawer element.
     *
     * @property drawer
     */
    get drawer() {
      return (0, _polymerDom.dom)(this.$.drawerSlot).getDistributedNodes()[0];
    },

    /** @override */
    attached: function attached() {
      // Disable drawer transitions until after app-drawer-layout sets the initial
      // opened state.
      var drawer = this.drawer;

      if (drawer) {
        drawer.setAttribute('no-transition', '');
      }
    },
    _clickHandler: function _clickHandler(e) {
      var target = (0, _polymerDom.dom)(e).localTarget;

      if (target && target.hasAttribute('drawer-toggle')) {
        var drawer = this.drawer;

        if (drawer && !drawer.persistent) {
          drawer.toggle();
        }
      }
    },
    _updateLayoutStates: function _updateLayoutStates() {
      var drawer = this.drawer;

      if (!this.isAttached || !drawer) {
        return;
      }

      this._drawerPosition = this.narrow ? null : drawer.position;

      if (this._drawerNeedsReset) {
        if (this.narrow) {
          drawer.opened = this.openedWhenNarrow;
          drawer.persistent = false;
        } else {
          drawer.opened = drawer.persistent = true;
        }

        if (drawer.hasAttribute('no-transition')) {
          // Enable drawer transitions after app-drawer-layout sets the initial
          // opened state.
          (0, _renderStatus.afterNextRender)(this, function () {
            drawer.removeAttribute('no-transition');
          });
        }

        this._drawerNeedsReset = false;
      }
    },
    _narrowChanged: function _narrowChanged() {
      this._drawerNeedsReset = true;
      this.resetLayout();
    },
    _onQueryMatchesChanged: function _onQueryMatchesChanged(event) {
      this._setNarrow(event.detail.value);
    },
    _computeMediaQuery: function _computeMediaQuery(forceNarrow, responsiveWidth) {
      return forceNarrow ? '(min-width: 0px)' : '(max-width: ' + responsiveWidth + ')';
    }
  });
});