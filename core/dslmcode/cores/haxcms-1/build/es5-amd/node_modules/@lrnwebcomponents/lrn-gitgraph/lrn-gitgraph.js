define(["exports", "../../@polymer/polymer/polymer-element.js", "./lib/gitgraphjs/src/gitgraph.js"], function (_exports, _polymerElement, _gitgraph) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LrnGitgraph = void 0;

  var _templateObject_6baec5f0809211edaa2833647dc78c6c;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `lrn-gitgraph`
   * @element lrn-gitgraph
   * For each branch in your repo use the following git command:
   *   ```
   *   git log [branch_name] --format='{"refs": "%d", "commit": "%h", "tree": "%t", "parent": "%p", "subject": "%s", "date": "%cd", "author": "%an %ae"},' --reverse
   *   ```
   * @demo demo/index.html
   */
  var LrnGitgraph = /*#__PURE__*/function (_PolymerElement) {
    babelHelpers.inherits(LrnGitgraph, _PolymerElement);

    var _super = _createSuper(LrnGitgraph);

    function LrnGitgraph() {
      babelHelpers.classCallCheck(this, LrnGitgraph);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(LrnGitgraph, [{
      key: "_commitsChanged",
      value: function _commitsChanged(commits) {
        var root = this;

        if (root.config) {
          if (commits.length > 0) {
            var gitgraph = new GitGraph(root.config);
            var tree = [];
            commits.forEach(function (item) {
              if (item.commits) {
                item.commits.forEach(function (commit) {
                  commit["branch"] = item.branch;
                  tree.push(commit);
                });
              }
            }); // remove duplicate commits

            console.log("befor", tree);
            tree = root._treeRemoveDuplicates(tree); // sort by date

            tree = tree.sort(function (a, b) {
              return new Date(b.date) - new Date(a.date);
            }); // reverse the tree so the newest oldest is first

            tree.reverse(); // identify forks

            var branches = [];
            tree.forEach(function (item, i) {
              // if the branch doesn't exist create it
              if (typeof branches[item.branch] === "undefined") {
                branches[item.branch] = gitgraph.branch(item.branch);
              } // make the commit


              branches[item.branch].commit({
                sha1: item.commit,
                message: item.subject,
                author: item.author,
                tag: item.refs
              });
            });
          }
        }
      }
    }, {
      key: "_treeRemoveDuplicates",
      value: function _treeRemoveDuplicates(tree) {
        var htTree = [];
        var htCommits = [];
        tree.forEach(function (t) {
          if (!htCommits.includes(t.commit)) {
            htTree.push(t);
            htCommits.push(t.commit);
          }
        });
        return htTree;
      }
    }, {
      key: "ready",
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(LrnGitgraph.prototype), "ready", this).call(this);
        var root = this;
        var config = {
          template: root.template,
          // could be: "blackarrow" or "metro" or `myTemplate` (custom Template object)
          reverseArrow: false,
          // to make arrows point to ancestors, if displayed
          orientation: root.orientation,
          element: root.shadowRoot.querySelector("#gitGraph")
        };

        if (root.mode !== "") {
          config.mode = root.mode;
        }

        root.config = config;
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_6baec5f0809211edaa2833647dc78c6c || (_templateObject_6baec5f0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          display: block;\n          overflow-x: scroll;\n        }\n      </style>\n      <canvas id=\"gitGraph\"></canvas>\n    "])));
      }
    }, {
      key: "tag",
      get: function get() {
        return "lrn-gitgraph";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          commits: {
            type: Array,
            value: []
          },
          template: {
            type: String,
            value: "blackarrow"
          },
          orientation: {
            type: String,
            value: "horizontal"
          },
          mode: {
            type: String,
            value: ""
          },
          reverseArrow: {
            type: Boolean,
            value: false
          },

          /**
           * @type {{template: String, reverseArrow: Boolean, orientation: String, element: Object}}
           */
          config: {
            type: Object
          }
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ["_commitsChanged(commits)"];
      }
    }]);
    return LrnGitgraph;
  }(_polymerElement.PolymerElement);

  _exports.LrnGitgraph = LrnGitgraph;
  customElements.define(LrnGitgraph.tag, LrnGitgraph);
});