define(["exports", "../../@polymer/polymer/polymer-element.js", "../../@polymer/iron-a11y-keys-behavior/iron-a11y-keys-behavior.js", "../../@polymer/polymer/lib/legacy/class.js", "../simple-progress/simple-progress.js", "../simple-icon/simple-icon.js", "../simple-icon/lib/simple-icons.js", "../simple-icon/lib/simple-icon-button.js", "../hax-iconset/lib/simple-hax-iconset.js", "../simple-colors/lib/simple-colors-polymer.js", "../schema-behaviors/schema-behaviors.js"], function (_exports, _polymerElement, _ironA11yKeysBehavior, _class, _simpleProgress, _simpleIcon, _simpleIcons, _simpleIconButton, _simpleHaxIconset, _simpleColorsPolymer, _schemaBehaviors) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PaperAudioPlayer = void 0;

  var _templateObject_20ae4fa0942811ecb1937969798b231a;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
  A custom audio player with material paper style and clean design.
  
  Example:
  
      <paper-audio-player src="audio.mp3"></paper-audio-player>
  
  ### Styling the player:
  
  This player has an accent color, and you have two option to modify it:
  
  - **Option 1**: Using the *color property* on element. This one is handy if you need to modify the color dynamically.
  
  
      <paper-audio-player color="#F05C38" src="audio.mp3"></paper-audio-player>
  
  
  - **Option 2**: Using the *custom CSS property*:
  
  
  
      paper-audio-player {
         --paper-audio-player-color: #e91e63;
      }
  
  The following mixins are available for styling:
  
  Custom property                             | Description                                 | Default
  --------------------------------------------|---------------------------------------------|----------
  --paper-audio-player-color                  | Color of the element                        | blueviolet
  
  @element paper-audio-player
  * @demo demo/index.html
  */
  var PaperAudioPlayer = /*#__PURE__*/function (_mixinBehaviors) {
    babelHelpers.inherits(PaperAudioPlayer, _mixinBehaviors);

    var _super = _createSuper(PaperAudioPlayer);

    function PaperAudioPlayer() {
      babelHelpers.classCallCheck(this, PaperAudioPlayer);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(PaperAudioPlayer, [{
      key: "connectedCallback",
      value:
      /**
       * attached life cycle
       */
      function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(PaperAudioPlayer.prototype), "connectedCallback", this).call(this);
        this.shadowRoot.querySelector("#audio").addEventListener("loadedmetadata", this._onCanPlay.bind(this));
        this.shadowRoot.querySelector("#audio").addEventListener("playing", this._onPlaying.bind(this));
        this.shadowRoot.querySelector("#audio").addEventListener("pause", this._onPause.bind(this));
        this.shadowRoot.querySelector("#audio").addEventListener("ended", this._onEnd.bind(this));
        this.shadowRoot.querySelector("#audio").addEventListener("error", this._onError.bind(this));
        this.setAttribute("tabindex", "0");
        this.setAttribute("role", "application");
        this.setAttribute("aria-label", "Audio Player");
        this.setAttribute("aria-describedby", "title");
      }
      /**
       * detached life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(PaperAudioPlayer.prototype), "disconnectedCallback", this).call(this);
        this.shadowRoot.querySelector("#audio").removeEventListener("loadedmetadata", this._onCanPlay.bind(this));
        this.shadowRoot.querySelector("#audio").removeEventListener("playing", this._onPlaying.bind(this));
        this.shadowRoot.querySelector("#audio").removeEventListener("pause", this._onPause.bind(this));
        this.shadowRoot.querySelector("#audio").removeEventListener("ended", this._onEnd.bind(this));
        this.shadowRoot.querySelector("#audio").removeEventListener("error", this._onError.bind(this));
      }
      /**
       * ready life cycle
       */

    }, {
      key: "ready",
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(PaperAudioPlayer.prototype), "ready", this).call(this);
        var player = this; // create Player defaults

        player.canBePlayed = false;
        player.isPlaying = false;
        player.ended = false;
        player.error = false;
        player.shadowRoot.querySelector("#audio").currentTime = player.timeOffset; // apply the audio start time property
      } // Play/Pause controls

    }, {
      key: "playPause",
      value: function playPause(e) {
        if (!!e) e.preventDefault();
        var player = this;

        if (player.canBePlayed) {
          if (player.isPlaying) {
            player._pause();
          } else {
            player._play();
          }
        } else if (player.preload === "none") {
          // If player can't be played, because audio wasn't pre-loaded
          // due to the preload="none" property set,
          // load the audio file at this point and start playing it immediately
          player.shadowRoot.querySelector("#audio").load();

          player._play();
        }
      }
    }, {
      key: "_play",
      value: function _play() {
        var player = this;
        player.shadowRoot.querySelector("#audio").play();
      }
    }, {
      key: "_pause",
      value: function _pause() {
        var player = this;
        player.shadowRoot.querySelector("#audio").pause();
      } //
      // Restart audio

    }, {
      key: "restart",
      value: function restart(e) {
        if (!!e) e.preventDefault();
        var player = this;
        player.shadowRoot.querySelector("#audio").currentTime = 0;
        if (!player.isPlaying) player._play();
      } // when audio file can be played in user's browser

    }, {
      key: "_onCanPlay",
      value: function _onCanPlay() {
        var player = this;
        player.canBePlayed = true;
        player.timeLeft = player.shadowRoot.querySelector("#audio").duration; // If player has a Time Offset specified
        // style the progress bar and title accordingly

        if (player.timeOffset > 0) {
          var percentagePlayed = player.timeOffset / player.shadowRoot.querySelector("#audio").duration;

          player._updateVisualProgress(percentagePlayed);
        } // If player has auto-play attribute set,
        // it ignores preload="none" property and starts playing on load.
        // This behavior corresponds to the native audio element behavior.


        if (player.autoPlay) player._play();
      } // when Player starts playing

    }, {
      key: "_onPlaying",
      value: function _onPlaying() {
        var player = this;
        player.ended = false;
        player.isPlaying = true;
        player.shadowRoot.querySelector("#replay").style = ""; // remove Replay inline styling

        player._startProgressTimer();
      } // Skip or reverse by pre-defined intervals

    }, {
      key: "_skipReverseByInterval",
      value: function _skipReverseByInterval(e) {
        if (!!e) e.preventDefault();
        var player = this,
            newTime = 0;

        switch (e.detail.key) {
          case "up":
            if (player.largeSkip < player.timeLeft) newTime = player.currentTime + player.largeSkip;
            break;

          case "down":
            if (player.currentTime - player.largeSkip > 0) newTime = player.currentTime - player.largeSkip;
            break;

          case "right":
            if (player.smallSkip < player.timeLeft) newTime = player.currentTime + player.smallSkip;
            break;

          default:
            if (player.currentTime - player.smallSkip > 0) newTime = player.currentTime - player.smallSkip;
        }

        player._updatePlayPosition(newTime);

        if (!player.isPlaying) player._play();
      } // starts Timer

    }, {
      key: "_startProgressTimer",
      value: function _startProgressTimer() {
        var player = this;
        player.timer = {};

        if (player.timer.sliderUpdateInterval) {
          clearInterval(player.timer.sliderUpdateInterval);
        }

        player.timer.sliderUpdateInterval = setInterval(function () {
          if (player.isPlaying) {
            player.currentTime = player.shadowRoot.querySelector("#audio").currentTime;
            player.timeLeft = player.shadowRoot.querySelector("#audio").duration - player.currentTime;
            var percentagePlayed = player.currentTime / player.shadowRoot.querySelector("#audio").duration;

            player._updateVisualProgress(percentagePlayed);
          } else {
            clearInterval(player.timer.sliderUpdateInterval);
          }
        }, 60);
      } // when Player is paused

    }, {
      key: "_onPause",
      value: function _onPause() {
        var player = this;
        player.isPlaying = false;
      } // when Player ended playing an audio file

    }, {
      key: "_onEnd",
      value: function _onEnd() {
        var player = this;
        player.ended = true;
        player.isPlaying = false;
        player.shadowRoot.querySelector("#replay").style.opacity = 1; // display Replay icon
      } // on file load error

    }, {
      key: "_onError",
      value: function _onError() {
        var player = this;
        player.classList.add("cantplay");
        player.title = "Sorry, can't play track: " + player.title;
        player.error = true;
        player.setAttribute("aria-invalid", "true");
      } // to convert seconds to 'm:ss' format

    }, {
      key: "_convertSecToMin",
      value: function _convertSecToMin(seconds) {
        if (seconds === 0) return "";
        var minutes = Math.floor(seconds / 60);
        var secondsToCalc = Math.floor(seconds % 60) + "";
        return minutes + ":" + (secondsToCalc.length < 2 ? "0" + secondsToCalc : secondsToCalc);
      } //
      // When user clicks somewhere on the progress bar

    }, {
      key: "_onDown",
      value: function _onDown(e) {
        e.preventDefault();
        var player = this;

        if (player.canBePlayed) {
          player._updateProgressBar(e);

          if (!player.isPlaying) {
            player._play();
          } // When preload="none" is being used,
          // player should first try to load the audio,
          // and when it's successfully loaded, recalculate the progress bar

        } else if (player.preload === "none") {
          player.shadowRoot.querySelector("#audio").load();
          player.shadowRoot.querySelector("#audio").addEventListener("loadedmetadata", function () {
            player._updateProgressBar(e);

            if (!player.isPlaying) {
              player._play();
            }
          }, false);
        }
      } //
      // Helper function
      // that recalculates the progress bar position
      // based on the event.click position

    }, {
      key: "_updateProgressBar",
      value: function _updateProgressBar(e) {
        var player = this;
        var x = e.detail.x - player.shadowRoot.querySelector("#center").getBoundingClientRect().left;
        var r = x / player.shadowRoot.querySelector("#center").getBoundingClientRect().width * player.shadowRoot.querySelector("#audio").duration;

        this._updatePlayPosition(r);
      } //
      // Helper function
      // updates the current time based on a time variable

    }, {
      key: "_updatePlayPosition",
      value: function _updatePlayPosition(newTime) {
        var player = this;
        player.currentTime = player.shadowRoot.querySelector("#audio").currentTime = newTime;
        var percentagePlayed = player.currentTime / player.shadowRoot.querySelector("#audio").duration;

        player._updateVisualProgress(percentagePlayed);
      } //
      // Helper function
      // updates the progress bar based on a percentage played

    }, {
      key: "_updateVisualProgress",
      value: function _updateVisualProgress(percentagePlayed) {
        var player = this;
        player.shadowRoot.querySelector("#progress").style.transform = "scaleX(" + percentagePlayed + ")";
        player.shadowRoot.querySelector("#progress2").style.width = percentagePlayed * 100 + "%";
        player.shadowRoot.querySelector("#title2").style.width = 1 / percentagePlayed * 100 + "%";
      } //
      // If src is changed when track is playing,
      // pause the track and start playing a new src

    }, {
      key: "_srcChanged",
      value: function _srcChanged(newValue, oldValue) {
        var player = this;

        if (player.isPlaying) {
          player._pause();

          player._play();
        }
      } //
      // If color property is changed,
      // update all the nodes with the new accent color

    }, {
      key: "_changeColor",
      value: function _changeColor(newValue) {
        var player = this;
        player.shadowRoot.querySelector("#left").style.backgroundColor = newValue;
        player.shadowRoot.querySelector("#title").style.color = newValue;
        player.shadowRoot.querySelector("#duration").style.color = newValue;
        player.shadowRoot.querySelector("#progress").style.backgroundColor = newValue;
        player.shadowRoot.querySelector("#replay").style.color = newValue;
      }
    }, {
      key: "_hidePlayIcon",
      value: function _hidePlayIcon(isPlaying, canBePlayed) {
        return isPlaying ? true : !(canBePlayed || this.preload === "none");
      }
    }, {
      key: "_setPreload",
      value: function _setPreload(autoplay, preload) {
        return autoplay ? "auto" : preload;
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_20ae4fa0942811ecb1937969798b231a || (_templateObject_20ae4fa0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"simple-colors-shared-styles-polymer\">\n        :host {\n          display: block;\n          box-sizing: border-box;\n          font-family: var(\n            --paper-audio-player-font-family,\n            \"Roboto\",\n            \"Noto\",\n            sans-serif\n          );\n          --paper-audio-player-color: var(\n            --simple-colors-default-theme-accent-9\n          );\n          --paper-audio-player-text-color: var(\n            --simple-colors-default-theme-grey-1\n          );\n          --paper-audio-player-shadow: var(\n            --simple-colors-default-theme-grey-2\n          );\n          --paper-audio-player-background: var(\n            --simple-colors-default-theme-grey-1\n          );\n          background-color: var(--paper-audio-player-background);\n        }\n        #wrapper {\n          position: relative;\n          cursor: pointer;\n          height: 50px;\n          box-shadow: 0 1px 2px var(--paper-audio-player-shadow);\n        }\n        #left,\n        #center {\n          border-right: 1px solid var(--paper-audio-player-shadow);\n        }\n        #left,\n        #right {\n          height: 50px;\n          width: 50px;\n          position: relative;\n        }\n\n        #left {\n          opacity: 0.8;\n          background-color: var(--paper-audio-player-color);\n          transition: opacity 0.25s;\n        }\n        #left:focus,\n        #left:hover {\n          opacity: 1;\n        }\n\n        #right {\n          background-color: var(--paper-audio-player-background);\n        }\n\n        simple-icon-button,\n        simple-icon {\n          color: var(--paper-audio-player-text-color);\n        }\n\n        #duration,\n        #title,\n        #progress2 {\n          text-align: center;\n          line-height: 50px;\n        }\n\n        #duration {\n          font-size: 11px;\n          color: var(--paper-audio-player-color);\n        }\n\n        simple-icon-button,\n        simple-icon {\n          margin: auto;\n        }\n\n        #replay {\n          opacity: 0;\n          color: var(--paper-audio-player-color);\n        }\n\n        #title,\n        #progress2 {\n          pointer-events: none;\n          font-size: 15px;\n        }\n\n        #title {\n          z-index: 2;\n          color: var(--paper-audio-player-color);\n        }\n\n        #progress2 {\n          width: 0px;\n          z-index: 5;\n          color: var(--paper-audio-player-text-color);\n          overflow: hidden;\n        }\n\n        #center {\n          position: relative;\n          overflow: hidden;\n          background-color: var(--paper-audio-player-background);\n        }\n\n        #progress {\n          width: 100%;\n          transform-origin: left;\n          transform: scaleX(0);\n          background-color: var(--paper-audio-player-color);\n        }\n\n        /* On hover */\n\n        :host(:not(.cantplay)) #right:hover #replay {\n          opacity: 1;\n        }\n\n        #right:hover #duration {\n          opacity: 0;\n        }\n\n        #left:hover #play,\n        #left:hover #pause {\n          transform: scale3d(1.1, 1.1, 1.1);\n          -ms-transform: scale3d(1.1, 1.1, 1.1);\n          -webkit-transform: scale3d(1.1, 1.1, 1.1);\n        }\n\n        /* On Error */\n\n        :host(.cantplay) #title {\n          font-size: 12px;\n        }\n\n        :host(.cantplay) #wrapper {\n          cursor: default;\n        }\n\n        :host(.cantplay) #play {\n          opacity: 0;\n        }\n\n        /* Flexbox Helpers */\n\n        .layout-horizontal {\n          display: flex;\n          display: -webkit-flex;\n          display: -ms-flexbox;\n          -ms-flex-direction: row;\n          -webkit-flex-direction: row;\n          flex-direction: row;\n        }\n\n        .flex {\n          -ms-flex: 1;\n          -webkit-flex: 1;\n          flex: 1;\n        }\n\n        .fit {\n          position: absolute;\n          top: 0;\n          right: 0;\n          bottom: 0;\n          left: 0;\n        }\n\n        .self-start {\n          -ms-align-self: flex-start;\n          -webkit-align-self: flex-start;\n          align-self: flex-start;\n        }\n\n        .self-end {\n          -ms-align-self: flex-end;\n          -webkit-align-self: flex-end;\n          align-self: flex-end;\n        }\n      </style>\n      <div id=\"wrapper\" class=\"layout-horizontal\">\n        <div id=\"left\" class=\"self-start\" on-click=\"playPause\">\n          <!-- Icon -->\n          <simple-icon-button\n            id=\"play\"\n            icon=\"paper-audio-icons:play-arrow\"\n            class=\"fit\"\n            hidden$=\"[[ _hidePlayIcon(isPlaying, canBePlayed) ]]\"\n            role=\"button\"\n            aria-label=\"Play Audio\"\n            tabindex=\"-1\"\n          ></simple-icon-button>\n          <simple-icon-button\n            id=\"pause\"\n            icon=\"paper-audio-icons:pause\"\n            class=\"fit\"\n            hidden$=\"[[ !isPlaying ]]\"\n            role=\"button\"\n            aria-label=\"Pause Audio\"\n            tabindex=\"-1\"\n          ></simple-icon-button>\n          <simple-icon\n            id=\"error\"\n            icon=\"paper-audio-icons:error-outline\"\n            class=\"fit\"\n            hidden$=\"[[ !error ]]\"\n          ></simple-icon>\n        </div>\n        <div id=\"center\" class=\"flex\" on-down=\"_onDown\">\n          <!-- Title -->\n          <div id=\"title\" class=\"fit\" role=\"alert\">[[title]]</div>\n          <!-- Audio HTML5 element -->\n          <audio\n            id=\"audio\"\n            src$=\"[[src]]\"\n            preload$=\"[[ _setPreload(autoPlay, preload) ]]\"\n          ></audio>\n          <!-- Progress bar -->\n          <div id=\"progress\" class=\"fit\"></div>\n          <!-- Secondary white title -->\n          <div id=\"progress2\" class=\"fit\">\n            <div id=\"title2\" aria-hidden=\"true\">[[title]]</div>\n          </div>\n        </div>\n        <div id=\"right\" class=\"self-end\" on-click=\"restart\">\n          <!-- Duration -->\n          <div id=\"duration\" class=\"fit\" hidden$=\"[[ended]]\">\n            <span class=\"fit\" role=\"timer\" aria-label=\"Audio Track Length\"\n              >[[ _convertSecToMin(timeLeft) ]]</span\n            >\n          </div>\n          <!-- Icon -->\n          <simple-icon-button\n            id=\"replay\"\n            class=\"fit\"\n            icon=\"paper-audio-icons:replay\"\n            tabindex=\"-1\"\n            role=\"button\"\n            aria-label=\"Replay Audio\"\n          ></simple-icon-button>\n        </div>\n      </div>\n    "])));
      }
    }, {
      key: "tag",
      get: function get() {
        return "paper-audio-player";
      } // Define public properties

    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(PaperAudioPlayer), "properties", this)), {}, {
          src: {
            type: String,
            observer: "_srcChanged"
          },
          title: {
            type: String,
            value: "Click to play this audio file"
          },
          autoPlay: {
            type: Boolean,
            value: false
          },
          preload: {
            type: String,
            value: "auto"
          },
          currentTime: {
            type: Number,
            value: 0,
            notify: true
          },
          timeLeft: {
            type: Number,
            value: 0
          },
          smallSkip: {
            type: Number,
            value: 15
          },
          largeSkip: {
            type: Number,
            value: 60
          },
          error: {
            type: Boolean
          },
          timeOffset: {
            type: Number,
            value: 0
          }
        });
      }
    }, {
      key: "keyBindings",
      get: function get() {
        return {
          space: "playPause",
          enter: "playPause",
          left: "_skipReverseByInterval",
          right: "_skipReverseByInterval",
          down: "_skipReverseByInterval",
          up: "_skipReverseByInterval"
        };
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return {
          canScale: true,
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Mini Audio player",
            description: "A very small audio player good for MP3s.",
            icon: "image:music-note",
            color: "green",
            groups: ["Audio", "Media"],
            handles: [{
              type: "audio",
              source: "src",
              title: "title",
              color: "color"
            }],
            meta: {
              author: "ELMS:LN"
            }
          },
          settings: {
            configure: [{
              property: "src",
              title: "Source",
              description: "The URL for this audio file.",
              inputMethod: "haxupload",
              icon: "link",
              required: true,
              validationType: "url"
            }, {
              property: "title",
              title: "Title",
              description: "Title of this sound track.",
              inputMethod: "textfield",
              icon: "av:video-label",
              required: false,
              validationType: "text"
            }, {
              property: "accentColor",
              title: "Accent color",
              description: "Select the accent color use",
              inputMethod: "colorpicker",
              icon: "editor:format-color-fill"
            }, {
              property: "dark",
              title: "Dark",
              description: "Use dark theme",
              inputMethod: "boolean",
              icon: "invert-colors"
            }],
            advanced: []
          }
        };
      }
    }]);
    return PaperAudioPlayer;
  }((0, _class.mixinBehaviors)([_ironA11yKeysBehavior.IronA11yKeysBehavior], (0, _schemaBehaviors.SchemaBehaviors)(_simpleColorsPolymer.SimpleColorsPolymer)));

  _exports.PaperAudioPlayer = PaperAudioPlayer;
  window.customElements.define(PaperAudioPlayer.tag, PaperAudioPlayer);
});