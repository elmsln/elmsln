define(["exports", "../../lit/index.js", "../simple-fields/lib/simple-fields-field.js", "../simple-icon/lib/simple-icon-lite.js", "../simple-icon/lib/simple-icons.js", "../simple-tooltip/simple-tooltip.js", "./lib/simple-search-content.js", "./lib/simple-search-match.js"], function (_exports, _index, _simpleFieldsField, _simpleIconLite, _simpleIcons, _simpleTooltip, _simpleSearchContent, _simpleSearchMatch) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SimpleSearch = void 0;

  var _templateObject_220ef110942811ecb1937969798b231a, _templateObject2_220ef110942811ecb1937969798b231a;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `simple-search`
   * @element simple-search
   * a button used in simple-search
   * 
  ### Styling
  
  `<simple-search>` provides the following custom properties
  for styling:
  
  Custom property | Description | Default
  ----------------|-------------|----------
  `--simple-search-button-color` | text color for button | #111
  `--simple-search-button-bg-color` | background-color for button | #eee
  `--simple-search-button-border-color` | border-color for button | #ccc
  `--simple-search-button-disabled-color` | background-color for disabled seach button | #999
  `--simple-search-button-disabled-bg-color` | text color for disabled seach button | #eee
  `--simple-search-button-disabled-border-color` | border-color for disabled seach button | #ccc
  `--simple-search-button-hover-color` | text color for button when hovered or focused | #000
  `--simple-search-button-hover-bg-color` | background-color for button when hovered or focused | #fff
  `--simple-search-button-hover-border-color` | border-color for button when hovered or focused | #ddd
  `--simple-search-input-placeholder-color` | text-color for search input's placeholder | #222
  `--simple-search-container-padding` | search input's padding | unset
  `--simple-search-margin` | search input's margin | unset
   *
  
   * @demo ./demo/index.html
   * @demo ./demo/selector.html Searching by CSS selectors
   *
   */
  var SimpleSearch = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(SimpleSearch, _LitElement);

    var _super = _createSuper(SimpleSearch);

    function SimpleSearch() {
      var _this;

      babelHelpers.classCallCheck(this, SimpleSearch);
      _this = _super.call(this);
      _this.alwaysFloatLabel = false;
      _this.caseSensitive = null;
      _this.controls = null;
      _this.nextButtonIcon = "arrow-forward";
      _this.nextButtonLabel = "next result";
      _this.noLabelFloat = false;
      _this.prevButtonIcon = "arrow-back";
      _this.prevButtonLabel = "previous result";
      _this.resultCount = 0;
      _this.resultPointer = 0;
      _this.searchInputIcon = "search";
      _this.searchInputLabel = "search";
      _this.searchTerms = [];
      _this.target = null;
      _this.selector = null;
      _this.__hideNext = true;
      _this.__hidePrev = true;
      return _this;
    }

    babelHelpers.createClass(SimpleSearch, [{
      key: "render",
      value: // render function
      function render() {
        return (0, _index.html)(_templateObject_220ef110942811ecb1937969798b231a || (_templateObject_220ef110942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral([" <simple-fields-field\n        id=\"input\"\n        label=\"", "\"\n        ?inline=\"", "\"\n        @value-changed=\"", "\"\n      >\n        <simple-icon-lite\n          icon=\"", "\"\n          slot=\"", "\"\n        ></simple-icon-lite>\n      </simple-fields-field>\n      <div id=\"xofy\" ?shrink-hide=\"", "\">\n        ", "\n      </div>\n      <div id=\"searchnav\" ?shrink-hide=\"", "\">\n        <button\n          id=\"prev\"\n          aria-label=\"", "\"\n          role=\"button\"\n          controls=\"", "\"\n          tabindex=\"0\"\n          ?disabled=\"", "\"\n          @click=\"", "\"\n        >\n          <simple-icon-lite icon=\"", "\"></simple-icon-lite>\n        </button>\n        <simple-tooltip for=\"prev\">", "</simple-tooltip>\n        <button\n          id=\"next\"\n          aria-label=\"", "\"\n          role=\"button\"\n          controls=\"", "\"\n          tabindex=\"0\"\n          ?disabled=\"", "\"\n          @click=\"", "\"\n        >\n          <simple-icon-lite icon=\"", "\"></simple-icon-lite>\n        </button>\n        <simple-tooltip for=\"next\">", "</simple-tooltip>\n      </div>"])), this.searchInputLabel, this.inline || this.noLabelFloat, this._handleChange, this.searchInputIcon, this.inline ? "label-prefix" : "prefix", this._hasNoSearch(this.searchTerms), this._getResultsSpan(this.resultPointer, this.resultCount), this._hasNoSearch(this.searchTerms), this.prevButtonLabel, this.controls, this.__hidePrev, this._navigateResults, this.prevButtonIcon, this.prevButtonLabel, this.nextButtonLabel, this.controls, this.__hideNext, this._navigateResults, this.nextButtonIcon, this.nextButtonLabel);
      } // properties available to the custom element for data binding

    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        changedProperties.forEach(function (oldValue, propName) {
          if (propName === "resultPointer" || propName === "resultCount") _this2._getNavDisabled(_this2.resultPointer, _this2.resultCount);
        });
      }
      /**
       * are there any results to navigate?
       */

    }, {
      key: "_handleChange",
      value: function _handleChange(e) {
        var _this3 = this;

        var selector = this.selector ? " ".concat(this.selector) : "",
            selections = this.controls ? this.getRootNode().querySelectorAll("#".concat(this.controls).concat(selector)) : null;

        this._getSearchText();

        this.resultCount = 0;
        this.resultPointer = 0;
        selections.forEach(function (selection) {
          _this3._searchSelection(selection);
        });
        /**
         * Fires when search changes (detail = { search: this, content: event })
         *
         * @event simple-search
         */

        this.dispatchEvent(new CustomEvent("simple-search", {
          detail: {
            search: this,
            content: e
          }
        }));
      }
    }, {
      key: "_searchSelection",
      value: function _searchSelection(selection) {
        if (selection && selection.innerHTML) selection.innerHTML = this.findMatches(selection.innerHTML);
      }
      /**
       * are there any results to navigate?
       *
       * @param {array} array of search terms
       * @returns {boolean} whether or not there are search terms
       */

    }, {
      key: "_hasNoSearch",
      value: function _hasNoSearch(terms) {
        return terms.length < 1;
      }
      /**
       * get results span text
       *
       * @param {boolean} whether or not there are search terms
       * @param {number} the current search result's position
       * @param {number} the total number of search results
       * @returns {string} "y results" or "x/y" text
       */

    }, {
      key: "_getResultsSpan",
      value: function _getResultsSpan(pointer, count) {
        return count > 0 && pointer > 0 ? pointer + "/" + count : count > 0 ? count : "0";
      }
      /**
       * navigate results
       */

    }, {
      key: "_navigateResults",
      value: function _navigateResults(e) {
        var increment = e.currentTarget.id === "next" ? 1 : -1;

        if (this.resultPointer + increment > 0 && this.resultPointer + increment <= this.resultCount) {
          this.resultPointer += increment;
          this.dispatchEvent(new CustomEvent("goto-result", {
            detail: this.resultPointer
          }));
        }
      }
    }, {
      key: "_getNavDisabled",
      value: function _getNavDisabled(pointer, count) {
        this.__hidePrev = this._isNavButtonDisabled(pointer, count, -1);
        this.__hideNext = this._isNavButtonDisabled(pointer, count);
      }
      /**
       * navigate results
       */

    }, {
      key: "_isNavButtonDisabled",
      value: function _isNavButtonDisabled(pointer, count) {
        var inc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        return !count || count === 0 || pointer + inc <= 0 || pointer + inc > count;
      }
      /**
       * gets the tab-index of cues based on whether or not interactive cues are disabled
       *
       * @param {string} a string of search text
       */

    }, {
      key: "_getSearchText",
      value: function _getSearchText() {
        var find = this.shadowRoot.querySelector("#input").value,
            temp = new Array();

        if (find !== undefined && find !== null) {
          temp = find.split(/[\"\']/gm);

          for (var i = 0; i < temp.length; i++) {
            temp[i] = temp[i].trim();
            if (temp[i] === "") temp.splice(i, 1);
          }
        } //this.searchTerms = [];


        this.searchTerms = temp.slice(0);
      }
      /**
       * search a string of content for any terms and return an array of results.
       * For example if I searched for the with
       * `findMatches("The quick brown fox jumps over the lazy dog.")`,
       * the array would be:
       * ```[
       *   {
       *     "matched": true,
       *     "matchNumber": 1,
       *     "text": "The",
       *     "searchObject": root
       *   },{
       *     "matched": false,
       *     "text": " quick brown fox jumps over ",
       *     "searchObject": root
       *   },{
       *     "matched": true,
       *     "matchNumber": 2,
       *     "text": "the",
       *     "searchObject": root
       *   },{
       *     "matched": false,
       *     "text": " lazy dog.",
       *     "searchObject": root
       *   }
       * ]```
       *
       * or `findMatches("The quick brown fox jumps over the lazy dog.",true)`,
       * the array would be:
       * ```[
       *   {
       *     "matched": false,
       *     "text": "The quick brown fox jumps over ",
       *     "searchObject": root
       *   },{
       *     "matched": true,
       *     "matchNumber": 1,
       *     "text": "the",
       *     "searchObject": root
       *   },{
       *     "matched": false,
       *     "text": " lazy dog.",
       *     "searchObject": root
       *   }
       * ]```
       *
       * @param {array} an array of search terms
       * @returns {array} an array of search results
       */

    }, {
      key: "findMatches",
      value: function findMatches(results) {
        var _this4 = this;

        this.resultPointer = 0;
        results = results.replace(/<\/?simple-search-match[^>]*>/g, "");
        this.searchTerms.forEach(function (term) {
          var modifier = _this4.caseSensitive ? "gm" : "gim",
              regex = new RegExp("\\b(" + term + ")\\b", modifier),
              replacer = function replacer(match) {
            _this4.resultCount++;
            return "<simple-search-match tabindex=\"0\" match-number=\"".concat(_this4.resultCount, "\">").concat(match, "</simple-search-match>");
          };

          results = results.replace(regex, replacer);
        });
        return results;
      }
    }], [{
      key: "styles",
      get: //styles function
      function get() {
        return [(0, _index.css)(_templateObject2_220ef110942811ecb1937969798b231a || (_templateObject2_220ef110942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: flex;\n          align-items: flex-end;\n          justify-content: space-between;\n          width: 100%;\n          background-color: var(\n            --simple-search-input-background-color,\n            transparent\n          );\n        }\n\n        #input {\n          flex-grow: 2;\n          margin-right: 4px;\n          padding: var(--simple-search-padding, unset);\n          margin: var(--simple-search-margin, unset);\n          color: var(--simple-search-input-text-color, #000);\n          --simple-fields-color: var(--simple-search-input-text-color, #000);\n          --simple-fields-container-color: var(\n            --simple-search-input-placeholder-color,\n            #222\n          );\n          --simple-fields-background-color: var(\n            --simple-fields-input-background-color,\n            transparent\n          );\n          --simple-icon-color: var(\n            --simple-search-input-placeholder-color,\n            #222\n          );\n        }\n\n        #xofy {\n          margin: 8px;\n        }\n\n        button {\n          margin: 8px 0 8px;\n          border-style: solid;\n          border-width: 1px;\n          border-color: var(--simple-search-button-border-color, #ccc);\n          color: var(--simple-search-button-color, #111);\n          background-color: var(--simple-search-button-bg-color, #eee);\n          border-color: var(--simple-search-button-border-color, #ccc);\n        }\n\n        button:not([disabled]):focus,\n        button:not([disabled]):hover {\n          cursor: pointer;\n          color: var(--simple-search-button-hover-color, #000);\n          background-color: var(--simple-search-button-hover-bg-color, #fff);\n          border-color: var(--simple-search-button-hover-border-color, #ddd);\n        }\n\n        button[disabled] {\n          cursor: not-allowed;\n          color: var(--simple-search-button-disabled-color, #999);\n          background-color: var(--simple-search-button-disabled-bg-color, #eee);\n          border-color: var(--simple-search-button-disabled-border-color, #ccc);\n        }\n\n        button:not([controls]) {\n          display: none;\n        }\n\n        #searchnav {\n          flex: 1 0 auto;\n        }\n\n        #searchnav button {\n          display: inline;\n          flex: 1 0 auto;\n        }\n\n        *[shrink-hide] {\n          display: none;\n        }\n      "])))];
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(SimpleSearch), "properties", this)), {}, {
          /**
           * @deprecated always float the label
           */
          alwaysFloatLabel: {
            attribute: "always-float-label",
            type: Boolean
          },

          /**
           * Is the search case-sensitive
           */
          caseSensitive: {
            attribute: "case-sensitive",
            type: Boolean
          },

          /**
           * The id of the container element that the navigation buttons control
           */
          controls: {
            attribute: "controls",
            type: String
          },

          /**
           * displays with label inline
           */
          inline: {
            attribute: "inline",
            type: Boolean
          },

          /**
           * label for next result icon
           */
          nextButtonIcon: {
            attribute: "next-button-icon",
            type: String
          },

          /**
           * label for next result button
           */
          nextButtonLabel: {
            attribute: "next-button-label",
            type: String
          },

          /**
           * @deprecated never float the label
           */
          noLabelFloat: {
            attribute: "no-label-float",
            type: Boolean
          },

          /**
           * label for previous result icon
           */
          prevButtonIcon: {
            attribute: "prev-button-icon",
            type: String
          },

          /**
           * label for previous result button
           */
          prevButtonLabel: {
            attribute: "prev-button-label",
            type: String
          },

          /**
           * Number of results.
           */
          resultCount: {
            attribute: "result-count",
            type: Number
          },

          /**
           * Which result are we currently on?
           */
          resultPointer: {
            attribute: "result-pointer",
            type: Number
          },

          /**
           * limits search to within target's elements that match a selectgor
           */
          selector: {
            attribute: "selector",
            type: String
          },

          /**
           * label for search icon
           */
          searchInputIcon: {
            attribute: "search-input-icon",
            type: String
          },

          /**
           * label for search input
           */
          searchInputLabel: {
            attribute: "search-input-label",
            type: String
          },

          /**
           * an array of search terms
           */
          searchTerms: {
            attribute: "search-terms",
            type: Array
          },

          /**
           * If set, search will be automated and restricted to this object.
           */
          target: {
            type: Object
          },

          /**
           * Hide next button
           */
          __hideNext: {
            type: Boolean
          },

          /**
           * Hide prev button
           */
          __hidePrev: {
            type: Boolean
          }
        });
      }
    }, {
      key: "tag",
      get: function get() {
        return "simple-search";
      }
    }]);
    return SimpleSearch;
  }(_index.LitElement);

  _exports.SimpleSearch = SimpleSearch;
  customElements.define(SimpleSearch.tag, SimpleSearch);
});