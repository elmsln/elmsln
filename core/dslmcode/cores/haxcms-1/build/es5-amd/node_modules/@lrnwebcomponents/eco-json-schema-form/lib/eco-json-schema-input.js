define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/iron-flex-layout/iron-flex-layout-classes.js", "../../../@polymer/app-localize-behavior/app-localize-behavior.js", "../../../@polymer/polymer/lib/legacy/class.js", "../../../@polymer/paper-input/paper-input.js", "../../../@polymer/paper-styles/typography.js"], function (_exports, _polymerElement, _ironFlexLayoutClasses, _appLocalizeBehavior, _class, _paperInput, _typography) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.EcoJsonSchemaInput = void 0;

  var _templateObject_9d352600809211edaa2833647dc78c6c;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
  `eco-json-schema-input` takes in a JSON schema of type number and string and
  contains a `paper-input`, exposing a `value` property that represents the schema.
  
  Validation is handled for strings and number/integers by mapping JSON schema
  validation keywords to `paper-input` attributes; form elements will automatically
  try and validate themselves as users provide input:
  
  Please see the `eco-json-schema-object` documentation for further information.
  
  @group eco Elements
  @element eco-json-schema-input
  * @demo demo/index.html
  */
  var EcoJsonSchemaInput = /*#__PURE__*/function (_mixinBehaviors) {
    babelHelpers.inherits(EcoJsonSchemaInput, _mixinBehaviors);

    var _super = _createSuper(EcoJsonSchemaInput);

    function EcoJsonSchemaInput() {
      babelHelpers.classCallCheck(this, EcoJsonSchemaInput);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(EcoJsonSchemaInput, [{
      key: "_schemaChanged",
      value: function _schemaChanged() {
        var schema = this.schema;
        var inputEl = this.shadowRoot.querySelector("#input");

        if (schema.required) {
          inputEl.required = true;
        }

        if (this._isSchemaNumber(schema.type)) {
          inputEl.type = "number";

          if (schema.multipleOf) {
            inputEl.step = schema.multipleOf;
          }

          if (!isNaN(schema.maximum)) {
            if (schema.exclusiveMaximum) {
              inputEl.max = schema.maximum - (schema.multipleOf || 1);
            } else {
              inputEl.max = schema.maximum;
            }
          }

          if (!isNaN(schema.minimum)) {
            if (schema.exclusiveMinimum) {
              inputEl.min = schema.minimum + (schema.multipleOf || 1);
            } else {
              inputEl.min = schema.minimum;
            }
          }
        }

        if (this._isSchemaString(schema.type)) {
          if (schema.format === "date-time") {
            inputEl.type = "datetime-local";
            inputEl.alwaysFloatLabel = true; // label doesn't float when value not set
          } else if (schema.format === "date") {
            inputEl.type = "date";
          } else if (schema.format === "email") {
            inputEl.type = "email";
          } else if (schema.format === "hostname") {
            inputEl.type = "text";
          } else if (schema.format === "ipv4") {
            inputEl.type = "text";
          } else if (schema.format === "ipv6") {
            inputEl.type = "text";
          } else if (schema.format === "uri") {
            inputEl.type = "url";
          } else {
            inputEl.type = "text";
          }
          /*
            if (schema.maxLength || schema.minLength) {
              inputEl.charCounter = true;
            }
           */


          if (schema.maxLength) {
            inputEl.maxlength = schema.maxLength;
          }

          if (schema.minLength) {
            inputEl.minlength = schema.minLength;
          }

          if (schema.pattern) {
            inputEl.pattern = schema.pattern;
          }
        }

        if (schema.component && schema.component.properties) {
          Object.keys(schema.component.properties).forEach(function (prop) {
            inputEl[prop] = schema.component.properties[prop];
          });
        }

        inputEl.alwaysFloatLabel = true; // label doesn't float when value not set

        if (schema.title) {
          inputEl.label = schema.title;
        }
      }
    }, {
      key: "_errorChanged",
      value: function _errorChanged() {
        if (this.error) {
          this.shadowRoot.querySelector("#input").errorMessage = this.error;
          this.shadowRoot.querySelector("#input").invalid = true;
        } else {
          this.shadowRoot.querySelector("#input").invalid = false;
          this.shadowRoot.querySelector("#input").errorMessage = null;
        }
      }
    }, {
      key: "_isSchemaValue",
      value: function _isSchemaValue(type) {
        return this._isSchemaBoolean(type) || this._isSchemaNumber(type) || this._isSchemaString(type);
      }
    }, {
      key: "_isSchemaBoolean",
      value: function _isSchemaBoolean(type) {
        if (Array.isArray(type)) {
          return type.indexOf("boolean") !== -1;
        } else {
          return type === "boolean";
        }
      }
    }, {
      key: "_isSchemaNumber",
      value: function _isSchemaNumber(type) {
        if (Array.isArray(type)) {
          return type.indexOf("number") !== -1 || type.indexOf("integer") !== -1;
        } else {
          return type === "number" || type === "integer";
        }
      }
    }, {
      key: "_isSchemaString",
      value: function _isSchemaString(type) {
        if (Array.isArray(type)) {
          return type.indexOf("string") !== -1;
        } else {
          return type === "string";
        }
      }
    }, {
      key: "_isSchemaObject",
      value: function _isSchemaObject(type) {
        return type === "object";
      }
    }, {
      key: "_isSchemaArray",
      value: function _isSchemaArray(type) {
        return type === "array";
      }
    }], [{
      key: "tag",
      get: function get() {
        return "eco-json-schema-input";
      }
    }, {
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_9d352600809211edaa2833647dc78c6c || (_templateObject_9d352600809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n      <custom-style>\n        <style is=\"custom-style\" include=\"iron-flex iron-flex-alignment\">\n          :host ([hidden]) {\n            display: none;\n          }\n        </style>\n      </custom-style>\n      <paper-input\n        id=\"input\"\n        class=\"flex\"\n        value=\"{{value}}\"\n        auto-validate\n      ></paper-input>\n    "])));
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          language: {
            value: "en"
          },
          resources: {
            value: function value() {
              return {};
            }
          },
          schema: {
            type: Object,
            observer: "_schemaChanged"
          },
          value: {
            type: String,
            notify: true,
            value: function value() {
              return "";
            }
          },
          error: {
            type: String,
            observer: "_errorChanged",
            value: null
          }
        };
      }
    }]);
    return EcoJsonSchemaInput;
  }((0, _class.mixinBehaviors)([_appLocalizeBehavior.AppLocalizeBehavior], _polymerElement.PolymerElement));

  _exports.EcoJsonSchemaInput = EcoJsonSchemaInput;
  customElements.define(EcoJsonSchemaInput.tag, EcoJsonSchemaInput);
});