define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.cellBehaviors = _exports.displayBehaviors = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Copyright 2018 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `editable-table-behaviors`
   * A set of common behaviors for editable-table web components.
   *
   * @polymer
   * @mixinFunction
   * @element editable-table-behaviors
   */

  /**
   * behaviors needed to display the table in either mode
   */
  var displayBehaviors = function displayBehaviors(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);

      var _super = _createSuper(_class);

      function _class() {
        babelHelpers.classCallCheck(this, _class);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(_class, [{
        key: "CSVtoArray",

        /**
         * converts csv string to array
         * @param {string} text the CSV string
         * @returns {array} a multidimensional table array
         * Mix of solutions from https://stackoverflow.com/questions/8493195/how-can-i-parse-a-csv-string-with-javascript-which-contains-comma-in-data
         */
        value: function CSVtoArray(text) {
          var p = "",
              row = [""],
              ret = [row],
              i = 0,
              r = 0,
              s = !0,
              l;

          for (l in text) {
            l = text[l];

            if ('"' === l) {
              if (s && l === p) row[i] += l;
              s = !s;
            } else if ("," === l && s) l = row[++i] = "";else if ("\n" === l && s) {
              if ("\r" === p) row[i] = row[i].slice(0, -1);
              row = ret[++r] = [l = ""];
              i = 0;
            } else row[i] += l;

            p = l;
          }

          return ret;
        }
        /**
         * Return table data as plain CSV
         * @returns {string} for the CSV
         */

      }, {
        key: "getTableCSV",
        value: function getTableCSV() {
          var _this = this;

          return this.data.map(function (row) {
            return row.map(function (cell) {
              cell = _this._replaceBlankCell(cell);
              return _this._isNumeric(cell) ? cell.replace(/,/g, "") : "\"".concat(cell.replace(/"/g, '""'), "\"");
            }).join(",");
          }).join("\n");
        }
        /**
         * return HTML object of table data
         * @returns {object} HTML object for managed table
         */

      }, {
        key: "getTableHTMLNode",
        value: function getTableHTMLNode() {
          var n = document.createElement("editable-table-display"); // replicate values that we had previously so they get reflected back into the DOM

          var props = this.getTableProperties();

          for (var i in props) {
            n[i] = props[i];
          }

          n.innerHTML = this.getTableHTML();
          return n;
        }
        /**
         * Return table as plain HTML
         * @returns {string} the HTML for the table
         */

      }, {
        key: "getTableHTML",
        value: function getTableHTML() {
          var _this2 = this;

          var headers = [],
              body = [],
              footer = [];

          var getTR = function getTR(tr) {
            var open = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "td";
            var close = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "td";
            var th = _this2.rowHeader ? tr.slice(0, 1) : [],
                td = _this2.rowHeader ? tr.slice(1) : tr;
            return "\n\t\t<tr>".concat(th.map(function (cell) {
              return "\n\t\t\t<th scope=\"row\">".concat(_this2._replaceBlankCell(cell), "</th>");
            }).join("")).concat(td.map(function (cell) {
              return "\n\t\t\t<".concat(open, ">").concat(_this2._replaceBlankCell(cell), "</").concat(close, ">");
            }).join(""), "\n\t\t</tr>");
          };

          if (this.thead) {
            headers = this.thead.map(function (tr) {
              return getTR(tr, "th scope=\"col\"", "th");
            });
          }

          if (this.tbody) {
            body = this.tbody.map(function (tr) {
              return getTR(tr);
            });
          }

          if (this.tfoot) {
            footer = this.tfoot.map(function (tr) {
              return getTR(tr);
            });
          }

          var props = this.getTableProperties();
          var attr = "";
          ["bordered", "striped", "condensed"].forEach(function (i) {
            if (props[i]) {
              attr += "".concat(i, " ");
            }
          });
          return ["<table ".concat(attr, ">"), this.caption !== "" && this.caption !== null && this.caption !== "null" ? "\n\t<caption>\n\t\t".concat(this.caption, "\n\t</caption>") : "", headers.length > 0 ? "\n\t<thead>".concat(headers.join(""), "\n\t</thead>") : "", body.length > 0 ? "\n\t<tbody>".concat(body.join(""), "\n\t</tbody>") : "", footer.length > 0 ? "\n\t<tfoot>".concat(footer.join(""), "\n\t</tfoot>") : "", "\n</table>"].join("");
        }
        /**
         * Return table data and configuration
         * @returns {object} an object with all the table data and configurations
         */

      }, {
        key: "getTableProperties",
        value: function getTableProperties() {
          var data = {
            bordered: !this.hideBordered ? this.bordered : null,
            caption: this.caption,
            columnHeader: this.columnHeader,
            condensed: !this.hideCondensed ? this.condensed : null,
            data: this.data,
            filter: !this.hideFilter ? this.filter : null,
            footer: this.footer,
            rowHeader: this.rowHeader,
            responsive: !this.hideResponsive ? this.responsive : null,
            sort: !this.hideSort ? this.sort : null,
            striped: !this.hideStriped ? this.striped : null,
            summary: this.summary
          };
          return data;
        }
        /**
         * imports table HTML as data
         * @param {HTMLElement} table the table element
         */

      }, {
        key: "importHTML",
        value: function importHTML(table) {
          var data = [].slice.call(table.querySelectorAll("tr")).map(function (row) {
            return [].slice.call(row.querySelectorAll("th,td")).map(function (cell) {
              return typeof cell.innerHTML === "string" ? cell.innerHTML.trim() : cell.innerHTML;
            });
          });
          if (data.length > 0 && data[0].length > 0) this.set("data", data);
          this.columnHeader = this.columnHeader || table.querySelectorAll("thead").length > 0;
          this.rowHeader = this.rowHeader || table.querySelectorAll("tbody th").length > 0;
          this.footer = this.footer || table.querySelectorAll("tfoot").length > 0;
          this.caption = this.caption !== null ? this.caption : table.querySelectorAll("caption").length > 0 ? table.querySelector("caption").innerHTML.trim() : null;
        }
        /**
         * Convert from csv text to an array in the table function
         */

      }, {
        key: "_loadExternalData",
        value: function _loadExternalData(e) {
          var data = this.CSVtoArray(this.csvData);
          if (data.length > 0 && data[0].length > 0) this.set("data", data);
        }
        /**
         * Gets the rows in `<tbody>`
         * @param {array} data the table data as an array
         * @param {boolean} columnHeader does the table have a column header
         * @param {boolean} footer does the table have a footer
         * @returns {array} the `<tbody>` data
         */

      }, {
        key: "_getTbody",
        value: function _getTbody(data, columnHeader, footer) {
          if (data !== undefined && data !== null && data.length > 0 && data[0].length > 0) {
            var ch = columnHeader ? 1 : 0,
                ft = footer ? data.length - 1 : data.length;
            return data.slice(ch, ft);
          }
        }
        /**
         * Gets the rows in `<tbody>`
         * @param {array} data the table data as an array
         * @param {boolean} columnHeader does the table have a column header
         * @param {boolean} footer does the table have a footer
         * @returns {array} the `<tbody>` data
         */

      }, {
        key: "_getTfoot",
        value: function _getTfoot(data, footer) {
          return data.length > 0 && data[0].length > 0 && footer ? data.slice(data.length - 1) : [];
        }
        /**
         * Gets the columns in `<thead>`
         * @param {array} data the table data as an array
         * @param {boolean} columnHeader does the table have a column header
         * @returns {array} the `<thead>`data
         */

      }, {
        key: "_getThead",
        value: function _getThead(data, columnHeader) {
          return data.length > 0 && data[0].length > 0 && columnHeader ? data.slice(0, 1) : [];
        }
        /**
         * replaces a blank cell with "-" for accessibility
         * @param {string} cell the cell contents
         * @returns {string} the cell contents or "-" if empty
         */

      }, {
        key: "_replaceBlankCell",
        value: function _replaceBlankCell(cell) {
          return String(cell).trim() === "" ? "-" : cell;
        }
        /**
         * Sets a cell's numeric style
         * @param {string} cell the cell contents
         * @returns {boolean} whether cell contents are numeric
         */

      }, {
        key: "_isNumeric",
        value: function _isNumeric(cell) {
          return cell !== null && !isNaN(cell.trim().replace(/\$/g, ""));
        }
      }], [{
        key: "properties",
        get: function get() {
          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)), {}, {
            /**
             * Add borders to table and table cells.
             */
            bordered: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true
            },

            /**
             * a table caption
             */
            caption: {
              type: String,
              value: null,
              notify: true
            },

            /**
             * Display the first row as a column header.
             */
            columnHeader: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true
            },

            /**
             * Raw data pulled in from the csv file.
             */
            csvData: {
              type: String,
              value: ""
            },

            /**
             * Condense height of table cells.
             */
            condensed: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true
            },

            /**
             * raw data
             */
            data: {
              type: Array,
              value: [],
              notify: true,
              observer: "_dataChanged"
            },

            /**
             * Location of the CSV file.
             */
            dataCsv: {
              type: String
            },

            /**
             * Enable filtering by cell value.
             */
            filter: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true
            },

            /**
             * Display the last row as a column footer.
             */
            footer: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true
            },

            /**
             * Display the first column as a row header.
             */
            rowHeader: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true
            },

            /**
             * When table is wider than screens,
             * users will select a column to display
             * instead of scrolling across the table.
             */
            responsive: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true
            },

            /**
             * Enable sorting by column header.
             */
            sort: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true
            },

            /**
             * Add alternating row striping.
             */
            striped: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              notify: true
            },

            /**
             * Columns in <thead>
             */
            thead: {
              type: Array,
              computed: "_getThead(data,columnHeader)"
            },

            /**
             * Rows in <tbody>
             */
            tbody: {
              type: Array,
              computed: "_getTbody(data,columnHeader,footer)"
            },

            /**
             * Rows in <tfoot>
             */
            tfoot: {
              type: Array,
              computed: "_getTfoot(data,footer)"
            }
          });
        }
      }]);
      return _class;
    }(SuperClass);
  };
  /**
   * behaviors needed for table cells, row headers, and columns
   */


  _exports.displayBehaviors = displayBehaviors;

  var cellBehaviors = function cellBehaviors(SuperClass) {
    return /*#__PURE__*/function (_SuperClass2) {
      babelHelpers.inherits(_class2, _SuperClass2);

      var _super2 = _createSuper(_class2);

      function _class2() {
        babelHelpers.classCallCheck(this, _class2);
        return _super2.apply(this, arguments);
      }

      babelHelpers.createClass(_class2, [{
        key: "_getLabel",

        /**
         * Get the row or column label
         * @param {number} index of the row or column
         * @param  {boolean} whenther it's a row
         * @returns {string} a row number or a column letter
         */
        value: function _getLabel(index, row) {
          if (row) {
            return index + 1;
          } else {
            var numerals = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""),
                results = this._getLetter(index).split("-").reverse(),
                label = "";

            for (var i = 0; i < results.length; i++) {
              if (results[i] !== "") label += numerals[results[i]];
            }

            return label;
          }
        }
        /**
         * Converts index to a letter.
         * @param {number} index of the row or column
         * @returns {string} a column letter
         */

      }, {
        key: "_getLetter",
        value: function _getLetter(index) {
          var place = Math.floor(index / 26),
              multiplier = 26 * place,
              remainder = index - multiplier,
              letters = "";
          letters += remainder + "-";

          if (place > 0 && place < 26) {
            letters += place - 1 + "-";
          } else if (place >= 26) {
            letters += this._getLetter(place - 1);
          }

          return letters;
        }
      }]);
      return _class2;
    }(SuperClass);
  };

  _exports.cellBehaviors = cellBehaviors;
});