define(["exports", "../../../lit/index.js", "../../utils/utils.js", "./hax-store.js", "./hax-upload-field.js"], function (_exports, _index, _utils, _haxStore, _haxUploadField) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxTrayUpload = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var HaxTrayUpload = /*#__PURE__*/function (_HaxUploadField) {
    babelHelpers.inherits(HaxTrayUpload, _HaxUploadField);

    var _super = _createSuper(HaxTrayUpload);

    /**
     * HTMLElement
     */
    function HaxTrayUpload() {
      var _this;

      babelHelpers.classCallCheck(this, HaxTrayUpload);
      _this = _super.call(this);
      _this.__winEvents = {
        "hax-app-picker-selection": "_haxAppPickerSelection",
        "place-holder-file-drop": "_placeHolderFileDrop"
      };
      return _this;
    }

    babelHelpers.createClass(HaxTrayUpload, [{
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxTrayUpload.prototype), "updated", this)) babelHelpers.get(babelHelpers.getPrototypeOf(HaxTrayUpload.prototype), "updated", this).call(this, changedProperties);
        changedProperties.forEach(function (oldValue, propName) {
          if (propName === "t") _this2.label = _this2.t.uploadMedia;
        });
      }
      /**
       * Respond to successful file upload, now inject url into url field and
       * do a gizmo guess from there!
       */

    }, {
      key: "_fileUploadResponse",
      value: function _fileUploadResponse(e) {
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxTrayUpload.prototype), "_fileUploadResponse", this).call(this, e); // @todo put in logic to support the response actually
        // just outright returning a haxElement. This is rare
        // but if the HAX developer has control over the endpoint
        // then they could get HAX to streamline some workflows
        // or by-pass the gizmo selection step to improve UX
        // for end users even further. Examples could be a media
        // management system that has remote rendering (cms-token)
        // or a highly specific endpoint that we know we can only
        // present in one way effectively Box / Google doc viewer.

        this.newAssetConfigure();
      }
    }, {
      key: "_canUpload",
      value: function _canUpload() {
        return !this.__allowUpload;
      }
      /**
       * Configure asset after upload or URL passed in.
       */

    }, {
      key: "newAssetConfigure",
      value: function newAssetConfigure() {
        var values = {
          source: this.shadowRoot.querySelector("#url").value,
          title: this.shadowRoot.querySelector("#url").value
        };

        _haxStore.HAXStore.insertLogicFromValues(values, this);
      }
      /**
       * A file event was detected from a drag and drop in the interface, most likely
       * from a place-holder tag
       */

    }, {
      key: "_placeHolderFileDrop",
      value: function _placeHolderFileDrop(e) {
        // reference the active place holder element since place holders are
        // the only things possible for seeing these
        _haxStore.HAXStore.activePlaceHolder = e.detail.placeHolderElement; // ! I can't believe this actually works. This takes the event
        // ! that was a drop event else where on the page and then repoints
        // ! it to simulate the drop event using the same event structure that
        // ! would have happened if they had used this element in the first place

        this.shadowRoot.querySelector("#fileupload")._onDrop(e.detail);
      }
    }], [{
      key: "tag",
      get:
      /**
       * Convention we use
       */
      function get() {
        return "hax-tray-upload";
      }
    }]);
    return HaxTrayUpload;
  }(_haxUploadField.HaxUploadField);

  _exports.HaxTrayUpload = HaxTrayUpload;
  customElements.define(HaxTrayUpload.tag, HaxTrayUpload);
});