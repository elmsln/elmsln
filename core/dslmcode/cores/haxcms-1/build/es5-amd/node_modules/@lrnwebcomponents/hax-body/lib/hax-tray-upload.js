define(["exports", "require", "../../../lit-element/lit-element.js", "../../utils/utils.js", "../../../@polymer/polymer/lib/elements/custom-style.js"], function (_exports, _require, _litElement, _utils, _customStyle) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxTrayUpload = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject2_8a8c7510accf11ea9f8e253ae0e7846d() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <custom-style>\n        <style>\n          @import url(\"https://fonts.googleapis.com/css?family=Noto+Serif\");\n          vaadin-upload {\n              color: #ffffff;\n              display: block;\n            }\n            --vaadin-upload-buttons-primary: {\n              display: block;\n              width: 100%;\n              flex: unset;\n              -webkit-flex: unset;\n            }\n            --vaadin-upload-button-add: {\n              color: #000000;\n              display: block;\n              flex: unset;\n              -webkit-flex: unset;\n              text-align: center;\n            }\n            --vaadin-upload-drop-label: {\n              color: #ffffff;\n              display: block;\n              padding: 8px;\n            }\n            --vaadin-upload-drop-label-dragover: {\n              color: #ffffff;\n            }\n            --vaadin-upload-file-list: {\n              padding: 8px;\n              margin: 0;\n              color: #ffffff;\n            }\n            --vaadin-upload-file: {\n              color: #ffffff;\n            }\n          }\n        </style>\n      </custom-style>\n      <div class=\"add-area-content-wrapper\">\n        <div class=\"add-url-area\">\n          <simple-fields-field\n            id=\"url\"\n            label=\"URL\"\n            type=\"url\"\n            auto-validate=\"\"\n          ></simple-fields-field>\n          <div class=\"url-description\">\n            Add an existing resource / link\n          </div>\n        </div>\n        <div class=\"add-upload-area\">\n          <vaadin-upload\n            @upload-before=\"", "\"\n            @upload-response=\"", "\"\n            form-data-name=\"file-upload\"\n            id=\"fileupload\"\n          ></vaadin-upload>\n        </div>\n        <paper-button @click=\"", "\" id=\"newassetconfigure\"\n          >Configure</paper-button\n        >\n      </div>\n    "]);

    _templateObject2_8a8c7510accf11ea9f8e253ae0e7846d = function _templateObject2_8a8c7510accf11ea9f8e253ae0e7846d() {
      return data;
    };

    return data;
  }

  function _templateObject_8a8c7510accf11ea9f8e253ae0e7846d() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          font-family: var(--simple-fields-font-family, sans-serif);\n          line-height: var(--simple-fields-line-height, 22px);\n          color: var(--simple-fields-color, black);\n          background-color: var(--simple-fields-background-color, #fff);\n        }\n        vaadin-upload {\n          --lumo-font-family: var(--simple-fields-font-family, sans-serif);\n          --lumo-error-color: var(--simple-fields-error-color, #dd2c00);\n          --lumo-primary-font-color: var(--simple-fields-color, black);\n          --lumo-base-color: var(--simple-fields-background-color, #fff);\n          --lumo-primary-contrast-color: var(\n            --simple-fields-background-color,\n            #fff\n          );\n          --lumo-primary-color: var(--simple-fields-color, black);\n          --lumo-dark-primary-color: ar(--simple-fields-color, black);\n          --lumo-light-primary-color: var(--simple-fields-color, black);\n          --lumo-primary-text-color: var(--simple-fields-color, black);\n          --lumo-body-text-color: var(--simple-fields-color, black);\n          --lumo-header-text-color: var(--simple-fields-color, black);\n          --lumo-secondary-text-color: var(--simple-fields-color, black);\n          --lumo-disabled-text-color: var(--simple-fields-border-color, #999);\n          color: var(--simple-fields-color, black);\n          background-color: var(--simple-fields-background-color, #fff);\n          padding: 16px !important;\n          text-align: center;\n        }\n        vaadin-upload[dragover] {\n          border-color: var(\n            --hax-tray-panel-accent,\n            var(--hax-contextual-action-hover-color)\n          );\n        }\n        vaadin-upload-file {\n          --disabled-text-color: var(--simple-fields-border-color, #999);\n        }\n        paper-button {\n          text-transform: none;\n          margin: 8px 0;\n          color: var(--simple-colors-default-theme-grey-12, #000);\n          background-color: var(--simple-colors-default-theme-grey-2, #eee);\n          border: 1px solid var(--simple-colors-default-theme-grey-3, #dddddd);\n          display: block;\n          text-align: center;\n        }\n        paper-button:active,\n        paper-button:focus,\n        paper-button:hover {\n          color: var(\n            --hax-tray-panel-accent-text,\n            var(--simple-colors-default-theme-grey-1, #fff)\n          );\n          background-color: var(\n            --hax-tray-panel-accent,\n            var(--hax-contextual-action-hover-color)\n          );\n          border-color: var(\n            --hax-tray-panel-accent,\n            var(--hax-contextual-action-hover-color)\n          );\n          transition: all 0.5ms ease-in-out;\n        }\n        .add-area-content-wrapper {\n          padding: 0 4px;\n        }\n        .add-url-area,\n        .add-upload-area {\n          margin: 0;\n        }\n        .url-description {\n          letter-spacing: 1px;\n        }\n      "]);

    _templateObject_8a8c7510accf11ea9f8e253ae0e7846d = function _templateObject_8a8c7510accf11ea9f8e253ae0e7846d() {
      return data;
    };

    return data;
  }

  var HaxTrayUpload =
  /*#__PURE__*/
  function (_winEventsElement) {
    babelHelpers.inherits(HaxTrayUpload, _winEventsElement);
    babelHelpers.createClass(HaxTrayUpload, null, [{
      key: "styles",
      get: function get() {
        return [(0, _litElement.css)(_templateObject_8a8c7510accf11ea9f8e253ae0e7846d())];
      }
      /**
       * Convention we use
       */

    }, {
      key: "tag",
      get: function get() {
        return "hax-tray-upload";
      }
      /**
       * HTMLElement
       */

    }]);

    function HaxTrayUpload() {
      var _this;

      babelHelpers.classCallCheck(this, HaxTrayUpload);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxTrayUpload).call(this));
      _this.__winEvents = {
        "hax-app-picker-selection": "_haxAppPickerSelection",
        "place-holder-file-drop": "_placeHolderFileDrop"
      };
      setTimeout(function () {
        new Promise(function (res, rej) {
          return _require.default(["../../../@polymer/paper-button/paper-button.js"], res, rej);
        });
        new Promise(function (res, rej) {
          return _require.default(["../../simple-fields/lib/simple-fields-field.js"], res, rej);
        });
        new Promise(function (res, rej) {
          return _require.default(["../../../@vaadin/vaadin-upload/vaadin-upload.js"], res, rej);
        });
      }, 0);
      return _this;
    }
    /**
     * LitElement render
     */


    babelHelpers.createClass(HaxTrayUpload, [{
      key: "render",
      value: function render() {
        return (0, _litElement.html)(_templateObject2_8a8c7510accf11ea9f8e253ae0e7846d(), this._fileAboutToUpload, this._fileUploadResponse, this.newAssetConfigure);
      }
      /**
       * Configure asset after upload or URL passed in.
       */

    }, {
      key: "newAssetConfigure",
      value: function newAssetConfigure() {
        var values = {
          source: this.shadowRoot.querySelector("#url").value,
          title: this.shadowRoot.querySelector("#url").value
        }; // we have no clue what this is.. let's try and guess..

        var type = window.HaxStore.guessGizmoType(values);
        var haxElements = window.HaxStore.guessGizmo(type, values, false, true); // see if we got anything

        if (haxElements.length > 0) {
          if (haxElements.length === 1) {
            if (babelHelpers.typeof(haxElements[0].tag) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              this.dispatchEvent(new CustomEvent("hax-insert-content", {
                bubbles: true,
                cancelable: true,
                composed: true,
                detail: haxElements[0]
              }));
            }
          } else {
            // hand off to hax-app-picker to deal with the rest of this
            window.HaxStore.instance.haxAppPicker.presentOptions(haxElements, type, "Pick how to present the " + type, "gizmo");
          }
        } else {
          window.HaxStore.toast("Sorry, HAX doesn't know how to handle that type of link yet.");
        }
      }
      /**
       * A file event was detected from a drag and drop in the interface, most likely
       * from a place-holder tag
       */

    }, {
      key: "_placeHolderFileDrop",
      value: function _placeHolderFileDrop(e) {
        // reference the active place holder element since place holders are
        // the only things possible for seeing these
        window.HaxStore.instance.activePlaceHolder = e.detail.placeHolderElement; // ! I can't believe this actually works. This takes the event
        // ! that was a drop event else where on the page and then repoints
        // ! it to simulate the drop event using the same event structure that
        // ! would have happened if they had used this element in the first place

        this.shadowRoot.querySelector("#fileupload")._onDrop(e.detail);
      }
      /**
       * Respond to successful file upload, now inject url into url field and
       * do a gizmo guess from there!
       */

    }, {
      key: "_fileUploadResponse",
      value: function _fileUploadResponse(e) {
        this.editExistingNode = true; // convert response to object

        var response = JSON.parse(e.detail.xhr.response); // access the app that did the upload

        var map = this.__appUsed.connection.operations.add.resultMap;
        var data = {};
        var item = {}; // look for the items element to draw our data from at its root

        if (babelHelpers.typeof(this._resolveObjectPath(map.item, response)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          data = this._resolveObjectPath(map.item, response);
        }

        item.type = map.defaultGizmoType; // pull in prop matches

        for (var prop in map.gizmo) {
          item[prop] = this._resolveObjectPath(map.gizmo[prop], data);
        } // another sanity check, if we don't have a url but have a source bind that too


        if (babelHelpers.typeof(item.url) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(item.source) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          item.url = item.source;
        } // gizmo type is also supported in the mapping element itself
        // Think an asset management backend as opposed to a specific
        // type of asset like video. If the item coming across can
        // effectively check what kind of gizmo is required for it
        // to work then we need to support that asset declaring the
        // gizmo type needed


        if (babelHelpers.typeof(map.gizmo.type) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          item.type = this._resolveObjectPath(map.gizmo.type, data);
        }

        this.shadowRoot.querySelector("#url").value = item.url; // @todo put in logic to support the response actually
        // just outright returning a haxElement. This is rare
        // but if the HAX developer has control over the endpoint
        // then they could get HAX to streamline some workflows
        // or by-pass the gizmo selection step to improve UX
        // for end users even further. Examples could be a media
        // management system that has remote rendering (cms-token)
        // or a highly specific endpoint that we know we can only
        // present in one way effectively Box / Google doc viewer.

        this.newAssetConfigure();
      }
      /**
       * Respond to uploading a file
       */

    }, {
      key: "_fileAboutToUpload",
      value: function _fileAboutToUpload(e) {
        if (!this.__allowUpload) {
          // cancel the event so we can jump in
          e.preventDefault();
          e.stopPropagation(); // look for a match as to what gizmo types it supports

          var values = {
            source: e.detail.file.name,
            type: e.detail.file.type
          }; // we have no clue what this is.. let's try and guess..

          var type = window.HaxStore.guessGizmoType(values); // find targets that support this type

          var targets = window.HaxStore.getHaxAppStoreTargets(type); // make sure we have targets

          if (targets.length === 1) {
            this._haxAppPickerSelection({
              detail: targets[0]
            });
          } else if (targets.length !== 0) {
            window.HaxStore.instance.haxAppPicker.presentOptions(targets, type, "Where would you like to upload this " + type + "?", "app");
          } else {
            window.HaxStore.toast("Sorry, you don't have a storage location that can handle " + type + " uploads!", 5000);
          }
        } else {
          this.__allowUpload = false;
        }
      }
      /**
       * Event for an app being selected from a picker
       * This happens when multiple upload targets support the given type
       */

    }, {
      key: "_haxAppPickerSelection",
      value: function _haxAppPickerSelection(e) {
        // details for where to upload the file
        var connection = e.detail.connection;
        this.__appUsed = e.detail;
        this.shadowRoot.querySelector("#fileupload").method = connection.operations.add.method;
        var requestEndPoint = connection.protocol + "://" + connection.url; // ensure we build a url correctly

        if (requestEndPoint.substr(requestEndPoint.length - 1) != "/") {
          requestEndPoint += "/";
        } // support local end point modification


        if (babelHelpers.typeof(connection.operations.add.endPoint) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          requestEndPoint += connection.operations.add.endPoint;
        } // implementation specific tweaks to talk to things like HAXcms and other CMSs
        // that have per load token based authentication


        if (window.HaxStore.instance.connectionRewrites.appendUploadEndPoint != null) {
          requestEndPoint += "?" + window.HaxStore.instance.connectionRewrites.appendUploadEndPoint;
        }

        if (window.HaxStore.instance.connectionRewrites.appendJwt != null) {
          requestEndPoint += "&" + window.HaxStore.instance.connectionRewrites.appendJwt + "=" + localStorage.getItem(window.HaxStore.instance.connectionRewrites.appendJwt);
        }

        this.shadowRoot.querySelector("#fileupload").headers = connection.headers;
        this.shadowRoot.querySelector("#fileupload").target = requestEndPoint; // invoke file uploading...

        this.__allowUpload = true;
        this.shadowRoot.querySelector("#fileupload").uploadFiles();
      }
      /**
       * Helper to take a multi-dimensional object and convert
       * it's reference into the real value. This allows for variable input defined
       * in a string to actually hit the deeper part of an object structure.
       */

    }, {
      key: "_resolveObjectPath",
      value: function _resolveObjectPath(path, obj) {
        return path.split(".").reduce(function (prev, curr) {
          return prev ? prev[curr] : null;
        }, obj || self);
      }
    }]);
    return HaxTrayUpload;
  }((0, _utils.winEventsElement)(_litElement.LitElement));

  _exports.HaxTrayUpload = HaxTrayUpload;
  window.customElements.define(HaxTrayUpload.tag, HaxTrayUpload);
});