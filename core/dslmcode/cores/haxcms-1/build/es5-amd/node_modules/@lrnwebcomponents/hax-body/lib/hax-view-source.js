define(["exports", "require", "../../../lit/index.js", "../../dl-behavior/dl-behavior.js", "../../utils/utils.js", "./hax-store.js", "./hax-toolbar.js", "./hax-ui-styles.js", "../../../mobx/dist/mobx.esm.js", "../../i18n-manager/lib/I18NMixin.js", "../../file-system-broker/lib/docx-file-system-broker.js"], function (_exports, _require, _index, _dlBehavior, _utils, _haxStore, _haxToolbar, _haxUiStyles, _mobxEsm, _I18NMixin2, _docxFileSystemBroker) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxViewSource = void 0;
  _require = _interopRequireWildcard(_require);

  var _templateObject_650100d0942811ecb1937969798b231a, _templateObject2_650100d0942811ecb1937969798b231a;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `hax-eview-source`
   * @element hax-eview-source
   * `Export dialog with all export options and settings provided.`
   */
  var HaxViewSource = /*#__PURE__*/function (_I18NMixin) {
    babelHelpers.inherits(HaxViewSource, _I18NMixin);

    var _super = _createSuper(HaxViewSource);

    function HaxViewSource() {
      var _this$t;

      var _this;

      babelHelpers.classCallCheck(this, HaxViewSource);
      _this = _super.call(this);
      _this.t = (_this$t = {
        updatePage: "Update",
        updatePageTooltip: "Update Page HTML",
        copyHTML: "Copy",
        copyHTMLTooltip: "Copy HTML to clipboard",
        downloadHTML: "Download",
        downloadHTMLTooltip: "Download HTML format",
        downloadDOCX: "Download DOCX",
        downloadDOCXTooltip: "Download .docx format",
        cleanFormatting: "Clean",
        cleanFormattingTooltip: "Clean HTML Formatting"
      }, babelHelpers.defineProperty(_this$t, "cleanFormatting", "Clean"), babelHelpers.defineProperty(_this$t, "schema", "Schema"), babelHelpers.defineProperty(_this$t, "schemaTooltip", "HAX Schema"), babelHelpers.defineProperty(_this$t, "refresh", "Refresh"), babelHelpers.defineProperty(_this$t, "refreshTooltip", "Refresh HTML source"), babelHelpers.defineProperty(_this$t, "importDOCX", "Import DOCX"), babelHelpers.defineProperty(_this$t, "importDOCXTooltip", "Import .docx content into body"), babelHelpers.defineProperty(_this$t, "fileImported", "File imported"), _this$t);

      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        namespace: "hax"
      });

      _this.fileTypes = {
        CSV: "text/csv",
        JSON: "text/json",
        PDF: "application/pdf",
        TXT: "text/plain",
        HTML: "text/html"
      };
      (0, _mobxEsm.autorun)(function () {
        _this.globalPreferences = (0, _mobxEsm.toJS)(_haxStore.HAXStore.globalPreferences);
        _this.haxUiTheme = (_this.globalPreferences || {}).haxUiTheme || "hax";
      });
      return _this;
    }

    babelHelpers.createClass(HaxViewSource, [{
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_650100d0942811ecb1937969798b231a || (_templateObject_650100d0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n      <div id=\"wrapper\">\n        <div id=\"spacer\"></div>\n        <textarea id=\"hiddentextarea\" hidden></textarea>\n        <code-editor\n          id=\"textarea\"\n          theme=\"", "\"\n          language=\"html\"\n          font-size=\"13\"\n          word-wrap\n        ></code-editor>\n      </div>\n      <hax-toolbar always-expanded>\n        <hax-tray-button\n          label=\"", "\"\n          tooltip=\"", "\"\n          icon=\"icons:refresh\"\n          @click=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          label=\"", "\"\n          tooltip=\"", "\"\n          icon=\"editor:insert-drive-file\"\n          @click=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          @click=\"", "\"\n          icon=\"editor:format-clear\"\n          label=\"", "\"\n          tooltip=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          @click=\"", "\"\n          icon=\"icons:content-copy\"\n          label=\"", "\"\n          tooltip=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          label=\"", "\"\n          tooltip=\"", "\"\n          icon=\"icons:file-download\"\n          @click=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          label=\"", "\"\n          tooltip=\"", "\"\n          icon=\"editor:insert-drive-file\"\n          @click=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          @click=\"", "\"\n          label=\"", "\"\n          tooltip=\"", "\"\n          icon=\"icons:file-upload\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          @click=\"", "\"\n          label=\"", "\"\n          tooltip=\"", "\"\n          icon=\"hax:code-json\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n      </hax-toolbar>\n    "])), this.haxUiTheme == "hax" ? "vs" : this.haxUiTheme == "haxdark" ? "vs-dark" : "auto", this.t.refresh, this.t.refreshTooltip, this.refreshHTMLEditor.bind(this), this.t.updatePage, this.t.updatePageTooltip, this.importContent.bind(this), this.scrubContent.bind(this), this.t.cleanFormatting, this.t.cleanFormattingTooltip, this.selectBody.bind(this), this.t.copyHTML, this.t.copyHTMLTooltip, this.t.downloadHTML, this.t.downloadHTMLTooltip, this.download.bind(this), this.t.downloadDOCX, this.t.downloadDOCXTooltip, this.downloadDOCX.bind(this), this.importDOCX.bind(this), this.t.importDOCX, this.t.importDOCXTooltip, this.htmlToHaxElements.bind(this), this.t.schema, this.t.schemaTooltip);
      }
    }, {
      key: "refreshHTMLEditor",
      value: // ability to refresh source view; possible something else in the system updated it
      // after we loaded
      function refreshHTMLEditor(e) {
        this.updateEditor();
      }
    }, {
      key: "importDOCX",
      value: function importDOCX(e) {
        // import and then go for it
        new Promise(function (res, rej) {
          return _require.default(["../../file-system-broker/lib/docx-file-system-broker.js"], res, rej);
        }).then( /*#__PURE__*/function () {
          var _ref = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
            var broker, file;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    broker = window.FileSystemBroker.requestAvailability();
                    _context.next = 3;
                    return broker.loadFile("docx");

                  case 3:
                    file = _context.sent;
                    // returns a Promise via event call when it's ready
                    window.DOCXFileSystemBroker.requestAvailability().fileToHTML(file, "hax-view-source");

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }());
      } // this will get called at a later time bc of the Promise involved

    }, {
      key: "insertDOCXFileContents",
      value: function insertDOCXFileContents(e) {
        // sanity check
        if (e.detail.name === "hax-view-source") {
          var div = document.createElement("div");
          div.innerHTML = e.detail.value;
          var slot = false;

          if (_haxStore.HAXStore.activeNode.hasAttribute("slot")) {
            slot = _haxStore.HAXStore.activeNode.getAttribute("slot");
          }

          for (var i = div.children.length - 1; i > 0; i--) {
            if (slot) {
              div.children[i].setAttribute("slot", slot);
            }

            _haxStore.HAXStore.activeNode.parentNode.insertBefore(div.children[i], _haxStore.HAXStore.activeNode.nextSibling);
          }

          _haxStore.HAXStore.toast(this.t.fileImported);

          this.close();
        }
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxViewSource.prototype), "connectedCallback", this).call(this);
        window.addEventListener("docx-file-system-data", this.insertDOCXFileContents.bind(this));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("docx-file-system-data", this.insertDOCXFileContents.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxViewSource.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * Download file.
       */

    }, {
      key: "download",
      value: function download(e) {
        var data = this.contentToFile(false);
        this.downloadFromData(data, "html", "my-new-code");

        _haxStore.HAXStore.toast("HTML content downloaded");

        this.close();
      }
      /**
       * Download DOCX.
       */

    }, {
      key: "downloadDOCX",
      value: function () {
        var _downloadDOCX = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(e) {
          var body;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return _haxStore.HAXStore.activeHaxBody.haxToContent();

                case 2:
                  body = _context2.sent;
                  window.DOCXFileSystemBroker.requestAvailability().HTMLToDOCX(body, document.title);

                  _haxStore.HAXStore.toast("docx file downloaded");

                  this.close();

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function downloadDOCX(_x2) {
          return _downloadDOCX.apply(this, arguments);
        }

        return downloadDOCX;
      }()
      /**
       * Download file.
       */

    }, {
      key: "downloadfull",
      value: function downloadfull(e) {
        var data = this.contentToFile(true);
        this.downloadFromData(data, "html", "my-new-webpage");

        _haxStore.HAXStore.toast("Working offline copy downloaded");

        this.close();
      }
      /**
       * Import content into body area.
       */

    }, {
      key: "importContent",
      value: function importContent(e) {
        // import contents of this text area into the activeHaxBody
        var htmlBody = this.shadowRoot.querySelector("#textarea").value;

        _haxStore.HAXStore.activeHaxBody.importContent(htmlBody);

        _haxStore.HAXStore.haxTray.trayDetail = "";
      }
      /**
       * Scrub and then import content as if pasted from Word / GDocs
       */

    }, {
      key: "scrubContent",
      value: function scrubContent(e) {
        // import contents of this text area into the activeHaxBody
        var htmlBody = this.shadowRoot.querySelector("#textarea").value;

        _haxStore.HAXStore.toast("Scrubbed, Content updated");

        _haxStore.HAXStore.activeHaxBody.importContent((0, _utils.stripMSWord)(htmlBody));

        this.close();
      }
      /**
       * update content of the editor area
       */

    }, {
      key: "openSource",
      value: function openSource() {
        var _this2 = this;

        // import at this time so we can delay as long as possible
        // from needing to pull in monaco
        new Promise(function (res, rej) {
          return _require.default(["../../code-editor/code-editor.js"], res, rej);
        }).then(function () {
          _this2.updateEditor();
        });
      }
      /**
       * selectBody
       */

    }, {
      key: "selectBody",
      value: function selectBody(e) {
        var hiddenarea = this.shadowRoot.querySelector("#hiddentextarea");
        hiddenarea.value = this.shadowRoot.querySelector("#textarea").value;
        hiddenarea.removeAttribute("hidden");
        hiddenarea.focus();
        hiddenarea.select();
        document.execCommand("copy");
        hiddenarea.setAttribute("hidden", "hidden");

        _haxStore.HAXStore.toast(this.t.copiedToClipboard); //this.close();

      }
      /**
       * HTML to HAX Elements
       */

    }, {
      key: "htmlToHaxElements",
      value: function () {
        var _htmlToHaxElements = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(e) {
          var elements, str, val, hiddenarea;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return _haxStore.HAXStore.htmlToHaxElements(this.shadowRoot.querySelector("#textarea").value);

                case 2:
                  elements = _context3.sent;
                  str = JSON.stringify(elements, null, 2);
                  val = this.shadowRoot.querySelector("#textarea").value;
                  hiddenarea = this.shadowRoot.querySelector("#hiddentextarea");
                  hiddenarea.removeAttribute("hidden");
                  hiddenarea.value = str;
                  hiddenarea.focus();
                  hiddenarea.select();
                  document.execCommand("copy");
                  hiddenarea.value = val;
                  hiddenarea.setAttribute("hidden", "hidden");

                  _haxStore.HAXStore.toast(this.t.copiedToClipboard);

                  this.close();

                case 15:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function htmlToHaxElements(_x3) {
          return _htmlToHaxElements.apply(this, arguments);
        }

        return htmlToHaxElements;
      }()
    }, {
      key: "close",
      value: function close() {
        _haxStore.HAXStore.haxTray.trayDetail = "";
      }
    }, {
      key: "firstUpdated",
      value: function () {
        var _firstUpdated = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(changedProperties) {
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxViewSource.prototype), "firstUpdated", this)) {
                    babelHelpers.get(babelHelpers.getPrototypeOf(HaxViewSource.prototype), "firstUpdated", this).call(this, changedProperties); // fire an event that this is a core piece of the system

                    this.dispatchEvent(new CustomEvent("hax-register-core-piece", {
                      bubbles: true,
                      cancelable: true,
                      composed: true,
                      detail: {
                        piece: "haxViewSource",
                        object: this
                      }
                    }));
                  }

                case 1:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function firstUpdated(_x4) {
          return _firstUpdated.apply(this, arguments);
        }

        return firstUpdated;
      }()
    }, {
      key: "updateEditor",
      value: function updateEditor() {
        var _this3 = this;

        if (_haxStore.HAXStore.activeHaxBody && this.shadowRoot && this.shadowRoot.querySelector("#textarea")) {
          this.shadowRoot.querySelector("#textarea").editorValue = "";
          setTimeout( /*#__PURE__*/babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
            return regeneratorRuntime.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.t0 = _utils.formatHTML;
                    _context5.next = 3;
                    return _haxStore.HAXStore.activeHaxBody.haxToContent();

                  case 3:
                    _context5.t1 = _context5.sent;
                    _this3.shadowRoot.querySelector("#textarea").editorValue = (0, _context5.t0)(_context5.t1);

                  case 5:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5);
          })), 0);
        }
      }
      /**
       * Output entire thing as a file.
       */

    }, {
      key: "contentToFile",
      value: function () {
        var _contentToFile = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(full) {
          var body, content;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return _haxStore.HAXStore.activeHaxBody.haxToContent();

                case 2:
                  body = _context6.sent;
                  content = body; // if you want full HTML headers or not

                  if (full) {
                    content = "\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"utf-8\" />\n            <meta\n              name=\"viewport\"\n              content=\"width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes\"\n            />\n            <title>hax-body demo</title>\n            <script>window.WCGlobalCDNPath=\"https://cdn.webcomponents.psu.edu/cdn/\"; </script> <script src=\"https://cdn.webcomponents.psu.edu/cdn/build.js\"></script> \n            <style>\n              body {\n                padding: 32px;\n              }\n            </style>\n          </head>\n          <body>\n          ".concat(body, "\n          </body>\n        </html>\n      ");
                  }

                  return _context6.abrupt("return", content);

                case 6:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        function contentToFile(_x5) {
          return _contentToFile.apply(this, arguments);
        }

        return contentToFile;
      }()
    }], [{
      key: "styles",
      get: function get() {
        return [].concat(babelHelpers.toConsumableArray(_haxUiStyles.HaxComponentStyles), [(0, _index.css)(_templateObject2_650100d0942811ecb1937969798b231a || (_templateObject2_650100d0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n        :host,\n        #wrapper {\n          margin: 0;\n          padding: 0;\n          display: flex;\n          flex-direction: column;\n          align-items: stretch;\n          position: relative;\n          flex: 1 1 100%;\n        }\n        #spacer {\n          flex: 1 1 100%;\n          z-index: -1;\n        }\n        #textarea {\n          position: absolute;\n          top: 0;\n          bottom: 0;\n          margin: 0;\n          padding: 0;\n        }\n        hax-toolbar {\n          flex: 0 0 auto;\n          background-color: var(--hax-ui-background-color);\n        }\n        hax-toolbar::part(buttons) {\n          display: flex;\n          justify-content: center;\n          align-items: stretch;\n          margin: 0 auto;\n        }\n        hax-tray-button {\n          flex: 1 1 auto;\n        }\n        /** This is mobile layout for controls */\n        @media screen and (max-width: 800px) {\n          hax-tray-button {\n            flex: 0 1 auto;\n          }\n        }\n      "])))]);
      }
    }, {
      key: "tag",
      get: function get() {
        return "hax-view-source";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(HaxViewSource), "properties", this)), {}, {
          /**
           * Global preferences for HAX overall
           */
          globalPreferences: {
            type: Object
          },
          theme: {
            type: String
          }
        });
      }
    }]);
    return HaxViewSource;
  }((0, _I18NMixin2.I18NMixin)((0, _dlBehavior.MtzFileDownloadBehaviors)(_index.LitElement)));

  _exports.HaxViewSource = HaxViewSource;
  window.customElements.define(HaxViewSource.tag, HaxViewSource);
});