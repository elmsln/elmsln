define(["exports", "../../lit/index.js"], function (_exports, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SimpleTooltip = void 0;

  var _templateObject_ad2942a08e0011ed99ce491205e67b1d, _templateObject2_ad2942a08e0011ed99ce491205e67b1d;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
    * `simple-tooltip`
    * `a simple tooltip forked from paper-tooltip with the same api minus apply removal`
       ### Styling
       The following custom properties and mixins are available for styling:
   
       Custom property | Description | Default
       ----------------|-------------|----------
       `--simple-tooltip-background` | The background color of the tooltip | `#616161`
       `--simple-tooltip-opacity` | The opacity of the tooltip | `0.9`
       `--simple-tooltip-text-color` | The text color of the tooltip | `white`
       `--simple-tooltip-delay-in` | Delay before tooltip starts to fade in | `500`
       `--simple-tooltip-delay-out` | Delay before tooltip starts to fade out | `0`
       `--simple-tooltip-duration-in` | Timing for animation when showing tooltip | `500`
       `--simple-tooltip-duration-out` | Timing for animation when hiding tooltip | `0`
    * @demo demo/index.html
    * @element simple-tooltip
    */
  var SimpleTooltip = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(SimpleTooltip, _LitElement);

    var _super = _createSuper(SimpleTooltip);

    /**
     * HTMLElement
     */
    function SimpleTooltip() {
      var _this;

      babelHelpers.classCallCheck(this, SimpleTooltip);
      _this = _super.call(this);
      _this.manualMode = false;
      _this.position = "bottom";
      _this.fitToVisibleBounds = false;
      _this.offset = 14;
      _this.marginTop = 14;
      _this.animationEntry = "";
      _this.animationExit = "";
      _this.animationConfig = {
        entry: [{
          name: "fade-in-animation",
          node: babelHelpers.assertThisInitialized(_this),
          timing: {
            delay: 0
          }
        }],
        exit: [{
          name: "fade-out-animation",
          node: babelHelpers.assertThisInitialized(_this)
        }]
      };
      setTimeout(function () {
        _this.addEventListener("webkitAnimationEnd", _this._onAnimationEnd.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("mouseenter", _this.hide.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      return _this;
    }
    /**
     * Returns the target element that this tooltip is anchored to. It is
     * either the element given by the `for` attribute, or the immediate parent
     * of the tooltip.
     *
     * @type {Node}
     */


    babelHelpers.createClass(SimpleTooltip, [{
      key: "render",
      value: // render function
      function render() {
        return (0, _index.html)(_templateObject_ad2942a08e0011ed99ce491205e67b1d || (_templateObject_ad2942a08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral([" <div\n      id=\"tooltip\"\n      class=\"hidden\"\n      @animationend=\"", "\"\n    >\n      <slot></slot>\n    </div>"])), this._onAnimationEnd);
      } // properties available to the custom element for data binding

    }, {
      key: "target",
      get: function get() {
        var parentNode = this.parentNode; // If the parentNode is a document fragment, then we need to use the host.

        var ownerRoot = this.getRootNode();
        var target;

        if (this.for) {
          target = ownerRoot.querySelector("#" + this.for);
        } else {
          target = parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE ? ownerRoot.host : parentNode;
        }

        return target;
      }
      /**
       * @return {void}
       * @override
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        if (!this.manualMode) {
          this._removeListeners();
        }

        babelHelpers.get(babelHelpers.getPrototypeOf(SimpleTooltip.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * @deprecated Use show and hide instead.
       * @param {string} type Either `entry` or `exit`
       */

    }, {
      key: "playAnimation",
      value: function playAnimation(type) {
        if (type === "entry") {
          this.show();
        } else if (type === "exit") {
          this.hide();
        }
      }
      /**
       * Cancels the animation and either fully shows or fully hides tooltip
       */

    }, {
      key: "cancelAnimation",
      value: function cancelAnimation() {
        // Short-cut and cancel all animations and hide
        this.shadowRoot.querySelector("#tooltip").classList.add("cancel-animation");
      }
      /**
       * Shows the tooltip programatically
       * @return {void}
       */

    }, {
      key: "show",
      value: function show() {
        // If the tooltip is already showing, there's nothing to do.
        if (this._showing) return;

        if (this.textContent.trim() === "") {
          // Check if effective children are also empty
          var allChildrenEmpty = true;
          var effectiveChildren = this.children;

          for (var i = 0; i < effectiveChildren.length; i++) {
            if (effectiveChildren[i].textContent.trim() !== "") {
              allChildrenEmpty = false;
              break;
            }
          }

          if (allChildrenEmpty) {
            return;
          }
        }

        this._showing = true;
        this.shadowRoot.querySelector("#tooltip").classList.remove("hidden");
        this.shadowRoot.querySelector("#tooltip").classList.remove("cancel-animation");
        this.shadowRoot.querySelector("#tooltip").classList.remove(this._getAnimationType("exit"));
        this.updatePosition();
        this._animationPlaying = true;
        this.shadowRoot.querySelector("#tooltip").classList.add(this._getAnimationType("entry"));
      }
      /**
       * Hides the tooltip programatically
       * @return {void}
       */

    }, {
      key: "hide",
      value: function hide() {
        var _this2 = this;

        // If the tooltip is already hidden, there's nothing to do.
        if (!this._showing) {
          return;
        } // If the entry animation is still playing, don't try to play the exit
        // animation since this will reset the opacity to 1. Just end the animation.


        if (this._animationPlaying) {
          this._showing = false;

          this._cancelAnimation();

          return;
        } else {
          // Play Exit Animation
          this._onAnimationFinish();
        }

        this._showing = false;
        this._animationPlaying = true; // force hide if we are open too long
        // helps older platforms and the monster known as Safari

        clearTimeout(this.__debounceCancel);
        this.__debounceCancel = setTimeout(function () {
          _this2._cancelAnimation();
        }, 5000);
      }
      /**
       * @return {void}
       */

    }, {
      key: "updatePosition",
      value: function updatePosition() {
        if (!this._target || !this.offsetParent) return;
        var offset = this.offset; // If a marginTop has been provided by the user (pre 1.0.3), use it.

        if (this.marginTop != 14 && this.offset == 14) offset = this.marginTop;
        var parentRect = this.offsetParent.getBoundingClientRect();

        var targetRect = this._target.getBoundingClientRect();

        var thisRect = this.getBoundingClientRect();
        var horizontalCenterOffset = (targetRect.width - thisRect.width) / 2;
        var verticalCenterOffset = (targetRect.height - thisRect.height) / 2;
        var targetLeft = targetRect.left - parentRect.left;
        var targetTop = targetRect.top - parentRect.top;
        var tooltipLeft, tooltipTop;

        switch (this.position) {
          case "top":
            tooltipLeft = targetLeft + horizontalCenterOffset;
            tooltipTop = targetTop - thisRect.height - offset;
            break;

          case "bottom":
            tooltipLeft = targetLeft + horizontalCenterOffset;
            tooltipTop = targetTop + targetRect.height + offset;
            break;

          case "left":
            tooltipLeft = targetLeft - thisRect.width - offset;
            tooltipTop = targetTop + verticalCenterOffset;
            break;

          case "right":
            tooltipLeft = targetLeft + targetRect.width + offset;
            tooltipTop = targetTop + verticalCenterOffset;
            break;
        } // TODO(noms): This should use IronFitBehavior if possible.


        if (this.fitToVisibleBounds) {
          // Clip the left/right side
          if (parentRect.left + tooltipLeft + thisRect.width > window.innerWidth) {
            this.style.right = "0px";
            this.style.left = "auto";
          } else {
            this.style.left = Math.max(0, tooltipLeft) + "px";
            this.style.right = "auto";
          } // Clip the top/bottom side.


          if (parentRect.top + tooltipTop + thisRect.height > window.innerHeight) {
            this.style.bottom = parentRect.height - targetTop + offset + "px";
            this.style.top = "auto";
          } else {
            this.style.top = Math.max(-parentRect.top, tooltipTop) + "px";
            this.style.bottom = "auto";
          }
        } else {
          this.style.left = tooltipLeft + "px";
          this.style.top = tooltipTop + "px";
        }
      }
    }, {
      key: "_addListeners",
      value: function _addListeners() {
        if (this._target) {
          this._target.addEventListener("mouseenter", this.show.bind(this));

          this._target.addEventListener("focus", this.show.bind(this));

          this._target.addEventListener("mouseleave", this.hide.bind(this));

          this._target.addEventListener("blur", this.hide.bind(this));

          this._target.addEventListener("tap", this.hide.bind(this));
        }
      }
    }, {
      key: "_findTarget",
      value: function _findTarget() {
        if (!this.manualMode) this._removeListeners();
        this._target = this.target;
        if (!this.manualMode) this._addListeners();
      }
    }, {
      key: "_manualModeChanged",
      value: function _manualModeChanged() {
        if (this.manualMode) this._removeListeners();else this._addListeners();
      }
    }, {
      key: "_cancelAnimation",
      value: function _cancelAnimation() {
        // Short-cut and cancel all animations and hide
        this.shadowRoot.querySelector("#tooltip").classList.remove(this._getAnimationType("entry"));
        this.shadowRoot.querySelector("#tooltip").classList.remove(this._getAnimationType("exit"));
        this.shadowRoot.querySelector("#tooltip").classList.remove("cancel-animation");
        this.shadowRoot.querySelector("#tooltip").classList.add("hidden");
      }
    }, {
      key: "_onAnimationFinish",
      value: function _onAnimationFinish() {
        if (this._showing) {
          this.shadowRoot.querySelector("#tooltip").classList.remove(this._getAnimationType("entry"));
          this.shadowRoot.querySelector("#tooltip").classList.remove("cancel-animation");
          this.shadowRoot.querySelector("#tooltip").classList.add(this._getAnimationType("exit"));
        }
      }
    }, {
      key: "_onAnimationEnd",
      value: function _onAnimationEnd() {
        // If no longer showing add class hidden to completely hide tooltip
        this._animationPlaying = false;

        if (!this._showing) {
          this.shadowRoot.querySelector("#tooltip").classList.remove(this._getAnimationType("exit"));
          this.shadowRoot.querySelector("#tooltip").classList.add("hidden");
        }
      }
    }, {
      key: "_getAnimationType",
      value: function _getAnimationType(type) {
        // These properties have priority over animationConfig values
        if (type === "entry" && this.animationEntry !== "") {
          return this.animationEntry;
        }

        if (type === "exit" && this.animationExit !== "") {
          return this.animationExit;
        } // If no results then return the legacy value from animationConfig


        if (this.animationConfig[type] && typeof this.animationConfig[type][0].name === "string") {
          // Checking Timing and Update if necessary - Legacy for animationConfig
          if (this.animationConfig[type][0].timing && this.animationConfig[type][0].timing.delay && this.animationConfig[type][0].timing.delay !== 0) {
            var timingDelay = this.animationConfig[type][0].timing.delay; // Has Timing Change - Update CSS

            if (type === "entry") {
              document.documentElement.style.setProperty("--simple-tooltip-delay-in", timingDelay + "ms");
            } else if (type === "exit") {
              document.documentElement.style.setProperty("--simple-tooltip-delay-out", timingDelay + "ms");
            }
          }

          return this.animationConfig[type][0].name;
        }
      }
    }, {
      key: "_removeListeners",
      value: function _removeListeners() {
        if (this._target) {
          this._target.removeEventListener("mouseover", this.show.bind(this));

          this._target.removeEventListener("focusin", this.show.bind(this));

          this._target.removeEventListener("mouseout", this.hide.bind(this));

          this._target.removeEventListener("focusout", this.hide.bind(this));

          this._target.removeEventListener("click", this.hide.bind(this));
        }
      }
      /**
       * LitElement ready
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        this.setAttribute("role", "tooltip");
        this.setAttribute("tabindex", -1);

        this._findTarget();
      }
      /**
       * LitElement life cycle - property changed
       */

    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this3 = this;

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "for") {
            _this3._findTarget(_this3[propName], oldValue);
          }

          if (propName == "manualMode") {
            _this3._manualModeChanged(_this3[propName], oldValue);
          }

          if (propName == "animationDelay") {
            _this3._delayChange(_this3[propName], oldValue);
          }
        });
      }
    }, {
      key: "_delayChange",
      value: function _delayChange(newValue) {
        // Only Update delay if different value set
        if (newValue !== 500) {
          document.documentElement.style.setProperty("--simple-tooltip-delay-in", newValue + "ms");
        }
      }
    }], [{
      key: "styles",
      get: //styles function
      function get() {
        return [(0, _index.css)(_templateObject2_ad2942a08e0011ed99ce491205e67b1d || (_templateObject2_ad2942a08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          position: absolute;\n          outline: none;\n          z-index: 1002;\n          -moz-user-select: none;\n          -ms-user-select: none;\n          -webkit-user-select: none;\n          user-select: none;\n          cursor: default;\n        }\n\n        #tooltip {\n          display: block;\n          outline: none;\n          font-size: var(--simple-tooltip-font-size, 10px);\n          line-height: 1;\n          background-color: var(--simple-tooltip-background, #616161);\n          color: var(--simple-tooltip-text-color, white);\n          padding: 8px;\n          border-radius: var(--simple-tooltip-border-radius, 2px);\n          width: var(--simple-tooltip-width);\n        }\n\n        @keyframes keyFrameScaleUp {\n          0% {\n            transform: scale(0);\n          }\n\n          100% {\n            transform: scale(1);\n          }\n        }\n\n        @keyframes keyFrameScaleDown {\n          0% {\n            transform: scale(1);\n          }\n\n          100% {\n            transform: scale(0);\n          }\n        }\n\n        @keyframes keyFrameFadeInOpacity {\n          0% {\n            opacity: 0;\n          }\n\n          100% {\n            opacity: var(--simple-tooltip-opacity, 0.9);\n          }\n        }\n\n        @keyframes keyFrameFadeOutOpacity {\n          0% {\n            opacity: var(--simple-tooltip-opacity, 0.9);\n          }\n\n          100% {\n            opacity: 0;\n          }\n        }\n\n        @keyframes keyFrameSlideDownIn {\n          0% {\n            transform: translateY(-2000px);\n            opacity: 0;\n          }\n\n          10% {\n            opacity: 0.2;\n          }\n\n          100% {\n            transform: translateY(0);\n            opacity: var(--simple-tooltip-opacity, 0.9);\n          }\n        }\n\n        @keyframes keyFrameSlideDownOut {\n          0% {\n            transform: translateY(0);\n            opacity: var(--simple-tooltip-opacity, 0.9);\n          }\n\n          10% {\n            opacity: 0.2;\n          }\n\n          100% {\n            transform: translateY(-2000px);\n            opacity: 0;\n          }\n        }\n\n        .fade-in-animation {\n          opacity: 0;\n          animation-delay: var(--simple-tooltip-delay-in, 500ms);\n          animation-name: keyFrameFadeInOpacity;\n          animation-iteration-count: 1;\n          animation-timing-function: ease-in;\n          animation-duration: var(--simple-tooltip-duration-in, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .fade-out-animation {\n          opacity: var(--simple-tooltip-opacity, 0.9);\n          animation-delay: var(--simple-tooltip-delay-out, 0ms);\n          animation-name: keyFrameFadeOutOpacity;\n          animation-iteration-count: 1;\n          animation-timing-function: ease-in;\n          animation-duration: var(--simple-tooltip-duration-out, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .scale-up-animation {\n          transform: scale(0);\n          opacity: var(--simple-tooltip-opacity, 0.9);\n          animation-delay: var(--simple-tooltip-delay-in, 500ms);\n          animation-name: keyFrameScaleUp;\n          animation-iteration-count: 1;\n          animation-timing-function: ease-in;\n          animation-duration: var(--simple-tooltip-duration-in, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .scale-down-animation {\n          transform: scale(1);\n          opacity: var(--simple-tooltip-opacity, 0.9);\n          animation-delay: var(--simple-tooltip-delay-out, 500ms);\n          animation-name: keyFrameScaleDown;\n          animation-iteration-count: 1;\n          animation-timing-function: ease-in;\n          animation-duration: var(--simple-tooltip-duration-out, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .slide-down-animation {\n          transform: translateY(-2000px);\n          opacity: 0;\n          animation-delay: var(--simple-tooltip-delay-out, 500ms);\n          animation-name: keyFrameSlideDownIn;\n          animation-iteration-count: 1;\n          animation-timing-function: cubic-bezier(0, 0, 0.2, 1);\n          animation-duration: var(--simple-tooltip-duration-out, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .slide-down-animation-out {\n          transform: translateY(0);\n          opacity: var(--simple-tooltip-opacity, 0.9);\n          animation-delay: var(--simple-tooltip-delay-out, 500ms);\n          animation-name: keyFrameSlideDownOut;\n          animation-iteration-count: 1;\n          animation-timing-function: cubic-bezier(0.4, 0, 1, 1);\n          animation-duration: var(--simple-tooltip-duration-out, 500ms);\n          animation-fill-mode: forwards;\n        }\n\n        .cancel-animation {\n          animation-delay: -30s !important;\n        }\n\n        .hidden {\n          position: absolute;\n          left: -10000px;\n          top: auto;\n          width: 1px;\n          height: 1px;\n          overflow: hidden;\n        }\n      "])))];
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(SimpleTooltip), "properties", this)), {}, {
          /**
           * The id of the element that the tooltip is anchored to. This element
           * must be a sibling of the tooltip. If this property is not set,
           * then the tooltip will be centered to the parent node containing it.
           */
          for: {
            type: String
          },

          /**
           * Set this to true if you want to manually control when the tooltip
           * is shown or hidden.
           */
          manualMode: {
            type: Boolean,
            attribute: "manual-mode"
          },

          /**
           * Positions the tooltip to the top, right, bottom, left of its content.
           */
          position: {
            type: String
          },

          /**
           * If true, no parts of the tooltip will ever be shown offscreen.
           */
          fitToVisibleBounds: {
            type: Boolean,
            attribute: "fit-to-visible-bounds"
          },

          /**
           * The spacing between the top of the tooltip and the element it is
           * anchored to.
           */
          offset: {
            type: Number
          },

          /**
           * This property is deprecated, but left over so that it doesn't
           * break exiting code. Please use `offset` instead. If both `offset` and
           * `marginTop` are provided, `marginTop` will be ignored.
           * @deprecated since version 1.0.3
           */
          marginTop: {
            type: Number,
            attribute: "margin-top"
          },

          /**
           * The delay that will be applied before the `entry` animation is
           * played when showing the tooltip.
           */
          animationDelay: {
            type: Number,
            attribute: "animation-delay"
          },

          /**
           * The animation that will be played on entry.  This replaces the
           * deprecated animationConfig.  Entries here will override the
           * animationConfig settings.  You can enter your own animation
           * by setting it to the css class name.
           */
          animationEntry: {
            type: String,
            attribute: "animation-entry"
          },

          /**
           * The animation that will be played on exit.  This replaces the
           * deprecated animationConfig.  Entries here will override the
           * animationConfig settings.  You can enter your own animation
           * by setting it to the css class name.
           */
          animationExit: {
            type: String,
            attribute: "animation-exit"
          },
          _showing: {
            type: Boolean
          }
        });
      }
      /**
       * Convention we use
       */

    }, {
      key: "tag",
      get: function get() {
        return "simple-tooltip";
      }
    }]);
    return SimpleTooltip;
  }(_index.LitElement);

  _exports.SimpleTooltip = SimpleTooltip;
  customElements.define(SimpleTooltip.tag, SimpleTooltip);
});