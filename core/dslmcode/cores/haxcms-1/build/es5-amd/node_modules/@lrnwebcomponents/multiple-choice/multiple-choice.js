define(["exports", "meta", "require", "../../lit/index.js", "../schema-behaviors/schema-behaviors.js", "../simple-colors/simple-colors.js", "./lib/multiple-choice-response.js", "../simple-icon/simple-icon.js", "../simple-icon/lib/simple-icons.js", "../simple-fields/lib/simple-fields-field.js", "../simple-toolbar/lib/simple-toolbar-button.js", "../simple-toast/simple-toast.js"], function (_exports, meta, _require, _index, _schemaBehaviors, _simpleColors, _multipleChoiceResponse, _simpleIcon, _simpleIcons, _simpleFieldsField, _simpleToolbarButton, _simpleToast) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.MultipleChoice = void 0;
  meta = _interopRequireWildcard(meta);
  _require = _interopRequireWildcard(_require);

  var _templateObject_201236b0942811ecb1937969798b231a, _templateObject2_201236b0942811ecb1937969798b231a, _templateObject3_201236b0942811ecb1937969798b231a, _templateObject4_201236b0942811ecb1937969798b231a, _templateObject5_201236b0942811ecb1937969798b231a;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `multiple-choice`
   * `Ask the user a question from a set of possible answers.`
   * @demo demo/index.html
   * @element multiple-choice
   */
  var MultipleChoice = /*#__PURE__*/function (_SchemaBehaviors) {
    babelHelpers.inherits(MultipleChoice, _SchemaBehaviors);

    var _super = _createSuper(MultipleChoice);

    function MultipleChoice() {
      var _this;

      babelHelpers.classCallCheck(this, MultipleChoice);
      _this = _super.call(this);
      _this.__ctr = 0;
      _this.randomize = false;
      _this.hideButtons = false;
      _this.disabled = false;
      _this.singleOption = false;
      _this.checkLabel = "Check Answer";
      _this.resetLabel = "Reset";
      _this.question = "";
      _this.answers = [];
      _this.displayedAnswers = [];
      _this.editMode = false;
      _this.correctText = "Great job!";
      _this.correctIcon = "icons:thumb-up";
      _this.incorrectText = "Better luck next time!";
      _this.incorrectIcon = "icons:thumb-down";
      _this.quizName = "default";

      _this.addEventListener("value-changed", _this._handleChange);

      return _this;
    }

    babelHelpers.createClass(MultipleChoice, [{
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice.prototype), "updated", this)) babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice.prototype), "updated", this).call(this, changedProperties);
        changedProperties.forEach(function (oldValue, propName) {
          var notifiedProps = ["answers", "displayedAnswers"];

          if (notifiedProps.includes(propName)) {
            // notify
            var eventName = "".concat(propName.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase(), "-changed");

            _this2.dispatchEvent(new CustomEvent(eventName, {
              detail: {
                value: _this2[propName]
              }
            }));
          }

          if (propName == "answers" && _this2.answers && _this2.answers.length > 0) {
            _this2.answers.forEach(function (answer) {
              return _objectSpread(_objectSpread({}, answer), {}, {
                answerId: answer.answerId || _this2._getSlotanswerId(),
                text: answer.text || answer.value || answer.label,
                value: answer.value || answer.label
              });
            });

            _this2._setSlottedAnswers();

            _this2.displayedAnswers = babelHelpers.toConsumableArray(_this2._computeDisplayedAnswers(_this2.answers, _this2.randomize));
          }

          if (propName == "singleOption" && !!_this2.singleOption && JSON.parse(_this2.correctAnswers || "[]").length > 1) _this2.answers = babelHelpers.toConsumableArray(_this2.answers[0]);
          if (propName == "correctText") _this2._setSlottedText(_this2.correctText, "correct-feedback");
          if (propName == "incorrectText") _this2._setSlottedText(_this2.incorrectText, "incorrect-feedback");
          if (propName == "title") _this2._setSlottedText(_this2.title, "question"); //only recheck slots editMode is turned off

          if (propName == "editMode" && !_this2.editMode) _this2._handleSlotChange();
        });
      }
    }, {
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_201236b0942811ecb1937969798b231a || (_templateObject_201236b0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n      <confetti-container id=\"confetti\">\n        <meta property=\"oer:assessing\" content=\"", "\" />\n        <h3 id=\"question\" property=\"oer:name\"><slot name=\"question\"></slot></h3>\n        ", "\n      </confetti-container>\n    "])), this.relatedResource, this.editMode ? (0, _index.html)(_templateObject2_201236b0942811ecb1937969798b231a || (_templateObject2_201236b0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral([" <div id=\"editMode\">\n              <slot name=\"question\"></slot>\n              <slot></slot>\n              <p class=\"feedback\">\n                <simple-icon\n                  icon=\"", "\"\n                  accent-color=\"green\"\n                  dark\n                ></simple-icon>\n                <slot name=\"correct-feedback\"></slot>\n              </p>\n              <p class=\"feedback\">\n                <simple-icon\n                  icon=\"", "\"\n                  accent-color=\"red\"\n                  dark\n                ></simple-icon>\n                <slot name=\"incorrect-feedback\"></slot>\n              </p>\n            </div>"])), this.correctIcon, this.incorrectIcon) : (0, _index.html)(_templateObject3_201236b0942811ecb1937969798b231a || (_templateObject3_201236b0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n              <simple-fields-field\n                id=\"multiple-choice-question\"\n                aria-labelledby=\"question\"\n                block-options\n                ?disabled=\"", "\"\n                ?inline=\"", "\"\n                type=\"", "\"\n                .itemsList=\"", "\"\n                .value=\"", "\"\n                name=\"answers\"\n                @value-changed=\"", "\"\n              ></simple-fields-field>\n              ", "\n            "])), this.disabled, false, this.inputType, this.displayedAnswers, this.userGuess || [], this.checkedEvent, !this.hideButtons ? (0, _index.html)(_templateObject4_201236b0942811ecb1937969798b231a || (_templateObject4_201236b0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n                    <div id=\"buttons\">\n                      <simple-toolbar-button\n                        id=\"check\"\n                        ?disabled=\"", "\"\n                        @click=\"", "\"\n                        label=\"", "\"\n                      >\n                      </simple-toolbar-button>\n                      <simple-toolbar-button\n                        id=\"reset\"\n                        ?disabled=\"", "\"\n                        @click=\"", "\"\n                        label=\"", "\"\n                      >\n                      </simple-toolbar-button>\n                    </div>\n                  "])), this.disabled, this._verifyAnswers, this.checkLabel, this.disabled, this.resetAnswers, this.resetLabel) : ""));
      }
    }, {
      key: "checkedEvent",
      value: function checkedEvent(e) {
        this.userGuess = e.detail.value || [];
      }
    }, {
      key: "resetAnswers",
      value:
      /**
       * Reset user answers and shuffle the board again.
       */
      function resetAnswers(e) {
        _simpleToast.SimpleToastStore.hide();

        this.displayedAnswers = [];
        this.userGuess = [];
        var answers = JSON.parse(JSON.stringify(this.answers));
        this.answers = babelHelpers.toConsumableArray(answers);
      }
    }, {
      key: "inputType",
      get: function get() {
        var correct = this.correctAnswers.split(),
            type = correct.length < 2 && this.singleOption ? "radio" : "checkbox";
        Array.from(this.querySelectorAll("multiple-choice-response")).forEach(function (field) {
          return field.type = type;
        });
        return type;
      }
      /**
       * if the current answers are correct
       * @returns {boolean}
       * @readonly
       * @memberof MultipleChoice
       */

    }, {
      key: "isCorrect",
      get: function get() {
        // see that they got them all right
        var guess = this.userGuess || [];
        if (typeof guess === "string") guess = [guess];
        return this.correctAnswers === JSON.stringify(guess.sort());
      }
      /**
       * gets a JSON object of alphabetized correct answers
       * @returns {string}
       * @readonly
       * @memberof MultipleChoice
       */

    }, {
      key: "correctAnswers",
      get: function get() {
        return JSON.stringify(this.displayedAnswers.filter(function (answer) {
          return !!answer.correct;
        }).map(function (answer) {
          return answer.value || answer.label;
        }).sort());
      }
      /**
       * handles single option radio behavior when a response is checked as correct in edit mode
       * @param {event} e
       * @returns
       */

    }, {
      key: "_handleChange",
      value: function _handleChange(e) {
        if (!this.editMode || !this.singleOption || !e.detail || !e.detail.value) return;
        var parentNode = !!e.detail && !!e.detail.parentNode && !!e.detail.parentNode.host && e.detail.parentNode.host.tagName === "MULTIPLE-CHOICE-RESPONSE" ? e.detail.parentNode.host : undefined;
        if (!!parentNode) Array.from(this.querySelectorAll("multiple-choice-response")).forEach(function (response) {
          if (response !== parentNode) response.correct = false;
        });
      }
      /**
       * Verify the answers of the user based on their saying
       * that they want to see how they did.
       */

    }, {
      key: "_verifyAnswers",
      value: function _verifyAnswers(e) {
        var _this3 = this;

        _simpleToast.SimpleToastStore.hide();

        var gotRight = this.isCorrect;
        var si = document.createElement("simple-icon");
        this.__toastColor = "grey";
        si.dark = true; // see if they got this correct based on their answers

        if (gotRight) {
          si.accentColor = "green";
          this.__toastIcon = this.correctIcon;
          this.__toastText = this.correctText; // make it fun... and performant!

          new Promise(function (res, rej) {
            return _require.default(["./lib/confetti-container.js"], res, rej);
          }).then(function (module) {
            setTimeout(function () {
              _this3.shadowRoot.querySelector("#confetti").setAttribute("popped", "");
            }, 0);
          });
        } else {
          this.__toastIcon = this.incorrectIcon;
          this.__toastText = this.incorrectText;
          si.accentColor = "red";
        }

        si.icon = this.__toastIcon;
        si.style.marginLeft = "16px";

        _simpleToast.SimpleToastStore.showSimpleToast({
          detail: {
            duration: 3000,
            text: this.__toastText,
            slot: si,
            dark: !si.dark,
            accentColor: this.__toastColor
          }
        }); // start of data passing, this is a prototype atm


        var eventData = {
          activityDisplay: "answered",
          objectName: this.quizName,
          resultSuccess: gotRight
        };
        this.dispatchEvent(new CustomEvent("user-engagement", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: eventData
        }));
      }
      /**
       * Figure out the order of the answers which will be displayed
       */

    }, {
      key: "_computeDisplayedAnswers",
      value: function _computeDisplayedAnswers(answers, randomize) {
        // if we are editing via HAX, don't randomize the answers
        // as we are actively editing the content and this is amazingly jarring
        if (babelHelpers.typeof(answers) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && answers != null && answers.length > 0 && randomize && !this._haxstate) {
          var random = answers;
          var currentIndex = random.length,
              temporaryValue,
              randomIndex; // While there remain elements to shuffle...

          while (0 !== currentIndex) {
            // Pick a remaining element...
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1; // And swap it with the current element.

            temporaryValue = random[currentIndex];
            random[currentIndex] = random[randomIndex];
            random[randomIndex] = temporaryValue;
          } // @todo apply a random sort to the answers array


          return random;
        } else {
          return answers;
        }
      }
      /**
       * haxProperties integration via file reference
       */

    }, {
      key: "_getSlottedAnswers",
      value:
      /**
       * converts answers in slots to an array
       *
       * @returns {array}
       * @memberof MultipleChoice
       */
      function _getSlottedAnswers() {
        var _this4 = this;

        var others = "[slot=correct-feedback][slot=incorrect-feedback],[slot=question]",
            slots = Array.from(this.querySelectorAll("multiple-choice-response,input,ul>li,ol>li")).filter(function (node) {
          return !node.closest(others);
        });
        var answers = [];
        slots.forEach(function (slot) {
          return answers.push(_this4._getSlottedAnswer(slot));
        });
        Array.from(this.querySelectorAll("ul")).forEach(function (node) {
          if (!node.closest(others)) node.remove();
        });
        return answers;
      }
      /**
       * converts an answer in a slot to an object
       *
       * @returns {object}
       * @memberof MultipleChoice
       */

    }, {
      key: "_getSlottedAnswer",
      value: function _getSlottedAnswer(slot) {
        var answer = {
          answerId: this._getSlotanswerId(slot),
          value: (slot.value || slot.innerHTML).trim(),
          text: (slot.value || slot.innerHTML).trim(),
          correct: slot.tagName !== "INPUT" && slot.tagName !== "LI" ? !!slot.correct : slot.getAttribute("correct") === null ? false : true
        }; //handle legacy slottes content

        if (slot.tagName === "INPUT" || slot.tagName === "LI") {
          slot.remove();

          this._setSlottedAnswer(answer);
        }

        return answer;
      }
    }, {
      key: "_getSlotanswerId",
      value: function _getSlotanswerId(slot) {
        var id = "mc-".concat(Date.now(), "-").concat(this.__ctr++);
        if (!!slot && !slot.answerId) slot.answerId = id;
        return !!slot ? slot.answerId : id;
      }
      /**
       * makes sure each answer object is represented by slotted content
       *
       * @param {object} answer object representing a single answer
       * @memberof MultipleChoice
       */

    }, {
      key: "_setSlottedAnswer",
      value: function _setSlottedAnswer(answer) {
        var slots = Array.from(this.querySelectorAll("multiple-choice-response")).filter(function (response) {
          return (answer.label || answer.value || "").trim === (response.innerHTML || "").trim();
        }),
            slot = slots[0]; //if no slotted response matches query, make one

        if (!slot) {
          slot = document.createElement("multiple-choice-response");
          slot.innerHTML = answer.label || answer.value;
          this.appendChild(slot);
        } //update reposnse with answer data


        slot.answerId = this._getSlotanswerId(slot);
        slot.correct = answer.correct;
        slot.type = this.inputType;
      }
      /**
       * makes sure all answrs in array are represented by slotted content
       *
       * @param {array}  array array of objects representing answers data
       * @memberof MultipleChoice
       */

    }, {
      key: "_setSlottedAnswers",
      value: function _setSlottedAnswers() {
        var _this5 = this;

        if (this.answers.length > 0) {
          var answers = this.answers.map(function (answer) {
            return answer.answerId;
          }),
              slots = {}; //remove any slotted responses that are no longer in answers array

          Array.from(this.querySelectorAll("multiple-choice-response,input")).map(function (slot) {
            var id = _this5._getSlotanswerId(slot);

            slots[id] = slot;
            if (!answers.includes(id)) slot.remove();
          }); //update slotted reponses from answers array

          this.answers.forEach(function (answer) {
            var slot = slots[answer.answerId];

            if (!slot) {
              _this5._setSlottedAnswer(answer);
            } else {
              slot.innerHTML = answer.text;
            }
          });
        }
      }
      /**
       * converts properties to actual slots
       *
       * @param {string} text text to be added to a slot
       * @param {string} slotName name of slot
       * @param {boolean} [prepend=false] whether this slot should added at the beginning
       * @returns {string} text
       * @memberof MultipleChoice
       */

    }, {
      key: "_setSlottedText",
      value: function _setSlottedText(text, slotName) {
        var prepend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        //only make a new node if one doesn't exist
        if (!["question", "correct-feedback", "incorrect-feedback"].includes(slotName) || !this.querySelector("[slot=".concat(slotName, "]"))) {
          var p = document.createElement("p");
          p.slot = slotName;
          p.innerHTML = text;

          if (prepend) {
            this.insertBefore(p, this.firstChild);
          } else {
            this.appendChild(p);
          } // otherwise update the exsiting one

        } else {
          this.querySelector("[slot=".concat(slotName, "]")).innerHTML = text;
        }
      }
      /**
       *
       *
       * @param {string} slotName name of slot
       * @param {string} propName name of property that gets updated
       * @memberof MultipleChoice
       */

    }, {
      key: "_getSlottedText",
      value: function _getSlottedText(propName, slotName) {
        var selector = "[slot=".concat(slotName, "]"),
            query = this.querySelector(selector),
            text = query && query.innerHTML ? query.innerHTML.trim() : undefined;
        if (!this[propName] || this[propName].trim() !== text) this[propName] = text;
      }
      /**
       * updates properties based on slots
       * on first update and in switching form editMode
       *
       * @param {boolean} [init=false] called from firstUpdated()
       * @memberof MultipleChoice
       */

    }, {
      key: "_handleSlotChange",
      value: function _handleSlotChange() {
        var _this6 = this;

        var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        this.answers = this._getSlottedAnswers(); //update all the other proerties from slots

        var others = {
          title: "question",
          correctText: "correct-feedback",
          incorrectText: "incorrect-feedback"
        };
        Object.keys(others).forEach(function (key) {
          //when first updating if a property is already set, just add a slot
          if (!_this6.querySelector("[slot=".concat(others[key], "]")) && init) {
            _this6._setSlottedText(_this6[key], others[key], key == "question"); //otherwise set property based on what's in slot

          } else {
            _this6._getSlottedText(key, others[key]);
          }
        });
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice.prototype), "firstUpdated", this).call(this, changedProperties);
        }

        this.setAttribute("typeof", "oer:Assessment"); // check lightdom on setup for answers to be read in
        // this only happens on initial paint

        if (this.children.length > 0) {
          this._handleSlotChange(true);
        } else {
          this._setSlottedAnswers();

          this._setSlottedText(this.correctText, "correct-feedback");

          this._setSlottedText(this.incorrectText, "incorrect-feedback");

          this._setSlottedText(this.title, "question", true);
        }
      }
    }], [{
      key: "styles",
      get:
      /**
       * LitElement constructable styles enhancement
       */
      function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice), "styles", this)), [(0, _index.css)(_templateObject5_201236b0942811ecb1937969798b231a || (_templateObject5_201236b0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          min-width: 160px;\n          padding: 16px;\n          margin-bottom: 16px;\n          border: 1px solid var(--simple-colors-default-theme-grey-8);\n          border-radius: 3px;\n          color: var(--simple-colors-default-theme-grey-12);\n          --simple-toolbar-button-border-color: var(\n            --simple-colors-default-theme-grey-4\n          );\n          --simple-fields-field-color: var(\n            --simple-colors-default-theme-grey-12\n          );\n          --simple-fields-field-ink-color: var(\n            --simple-colors-default-theme-grey-12\n          );\n          --simple-fields-field-checked-color: var(\n            --simple-colors-default-theme-accent-8\n          );\n          --simple-fields-field-checked-ink-color: var(\n            --simple-colors-default-theme-accent-8\n          );\n          --simple-fields-field-checkmark-color: var(\n            --simple-colors-default-theme-grey-1\n          );\n          --simple-fields-field-label-color: var(\n            --simple-colors-default-theme-grey-12\n          );\n          --simple-fields-field-error-color: var(\n            --simple-colors-default-theme-red-8\n          );\n          --simple-fields-border-bottom-size: 0px;\n          --simple-fields-border-bottom-focus-size: 0px;\n        }\n\n        :host button {\n          background-color: var(--simple-colors-default-theme-grey-1);\n          color: var(--simple-colors-default-theme-grey-12);\n        }\n        :host button:hover,\n        :host button:focus,\n        :host button:active {\n          cursor: pointer;\n          background-color: var(--simple-colors-default-theme-grey-2);\n          color: var(--simple-colors-default-theme-grey-12);\n        }\n        ul {\n          list-style: none;\n          padding: 0;\n          margin: 0;\n        }\n        ul li {\n          padding: 0;\n        }\n        simple-icon {\n          display: inline-flex;\n        }\n        h3 {\n          margin-top: 0;\n        }\n        #buttons {\n          display: flex;\n          align-items: center;\n          justify-content: flex-end;\n        }\n        #check {\n          margin-right: 8px;\n        }\n        .feedback {\n          background-color: black;\n          color: white;\n          display: flex;\n          align-items: center;\n          justify-content: flex-start;\n          padding: 8px;\n          border-radius: 3px;\n        }\n        .feedback simple-icon {\n          margin-right: 8px;\n        }\n        ::slotted([slot=\"question\"]) {\n          margin: 0;\n        }\n        .feedback,\n        ::slotted(multiple-choice-response),\n        ::slotted([slot=\"correct-feedback\"]),\n        ::slotted([slot=\"incorrect-feedback\"]) {\n          font-size: var(--simple-fields-font-size, 16px);\n          text-align: var(--simple-fields-text-align);\n          font-family: var(--simple-fields-font-family, sans-serif);\n          line-height: var(--simple-fields-line-height, 22px);\n        }\n      "])))]);
      }
    }, {
      key: "tag",
      get: function get() {
        return "multiple-choice";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(MultipleChoice), "properties", this)), {}, {
          /**
           * Support disabling interaction with the entire board
           */
          disabled: {
            type: Boolean
          },

          /**
           * Simple option, otherwise allow multiple via checkbox
           */
          singleOption: {
            type: Boolean,
            attribute: "single-option"
          },

          /**
           * Text of the label to check your answer
           */
          checkLabel: {
            type: String,
            attribute: "check-label"
          },

          /**
           * Text of the reset button
           */
          resetLabel: {
            type: String,
            attribute: "reset-label"
          },

          /**
           * Related Resource ID
           */
          relatedResource: {
            type: String,
            attribute: "related-resource"
          },

          /**
           * Question to ask
           */
          question: {
            type: String
          },

          /**
           * Array of possible answers
           */
          answers: {
            type: Array
          },

          /**
           * Displayed Answer set.
           */
          displayedAnswers: {
            type: Array
          },

          /**
           * Correct answer text to display
           */
          correctText: {
            type: String,
            attribute: "correct-text"
          },

          /**
           * Incorrect answer text to display
           */
          incorrectText: {
            type: String,
            attribute: "incorrect-text"
          },

          /**
           * Correct answer text to display
           */
          correctIcon: {
            type: String,
            attribute: "correct-icon"
          },

          /**
           * Incorrect answer text to display
           */
          incorrectIcon: {
            type: String,
            attribute: "incorrect-icon"
          },

          /**
           * Name of the quiz - hardcoded for now from HTML
           */
          quizName: {
            type: String,
            attribute: "quiz-name"
          },

          /**
           * Randomize the display of the answers
           */
          randomize: {
            type: Boolean,
            reflect: true
          },

          /**
           * flag to hide buttons
           */
          hideButtons: {
            type: Boolean,
            attribute: "hide-buttons"
          },

          /**
           * flag to hide buttons
           */
          editMode: {
            type: Boolean,
            attribute: "edit-mode",
            reflect: true
          },
          userGuess: {
            type: Array
          }
        });
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return new URL("./lib/".concat(this.tag, ".haxProperties.json"), meta.url).href;
      }
    }]);
    return MultipleChoice;
  }((0, _schemaBehaviors.SchemaBehaviors)((0, _simpleColors.SimpleColorsSuper)(_index.LitElement)));

  _exports.MultipleChoice = MultipleChoice;
  window.customElements.define(MultipleChoice.tag, MultipleChoice);
});