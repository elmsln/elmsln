define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/iron-ajax/iron-ajax.js", "../../../@polymer/iron-form-element-behavior/iron-form-element-behavior.js", "../../../@polymer/app-layout/app-layout.js", "../../../@polymer/app-layout/app-toolbar/app-toolbar.js", "../../simple-toast/simple-toast.js", "../../simple-modal/simple-modal.js", "../../../@polymer/paper-input/paper-input.js", "../../../@polymer/paper-listbox/paper-listbox.js", "../../lrnsys-button/lrnsys-button.js", "../../grafitto-filter/grafitto-filter.js", "../../simple-fields/lib/simple-fields-container.js", "../lrnsys-comment.js"], function (_exports, _polymerElement, _ironAjax, _ironFormElementBehavior, _appLayout, _appToolbar, _simpleToast, _simpleModal, _paperInput, _paperListbox, _lrnsysButton, _grafittoFilter, _simpleFieldsContainer, _lrnsysComment) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LrnsysCommentList = void 0;

  var _templateObject_d8de39a08e0011ed99ce491205e67b1d;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `lrnsys-comment-list`
   * @element lrnsys-comment-list
   * `A listing and event handling for comments.`
   * @demo demo/index.html
   */
  var LrnsysCommentList = /*#__PURE__*/function (_PolymerElement) {
    babelHelpers.inherits(LrnsysCommentList, _PolymerElement);

    var _super = _createSuper(LrnsysCommentList);

    function LrnsysCommentList() {
      var _this;

      babelHelpers.classCallCheck(this, LrnsysCommentList);
      _this = _super.call(this);
      window.SimpleModal.requestAvailability();
      setTimeout(function () {
        _this.addEventListener("comment-save", _this.handleSave.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("comment-editing", _this.handleEditing.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("comment-reply", _this.handleReply.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("comment-like", _this.handleLike.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("comment-delete-dialog", _this.handleDeleteDialog.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      return _this;
    }
    /**
     * @todo not sure we need to do anything post like button
     */


    babelHelpers.createClass(LrnsysCommentList, [{
      key: "connectedCallback",
      value:
      /**
       * attached life cycle
       */
      function connectedCallback() {
        var _this2 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(LrnsysCommentList.prototype), "connectedCallback", this).call(this);
        this.shadowRoot.querySelector("#filtercomments").addEventListener("value-changed", function (e) {
          _this2.shadowRoot.querySelector("#filteredcomments").like = e.target.value;
        });
      }
      /**
       * detached life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        var _this3 = this;

        this.shadowRoot.querySelector("#filtercomments").removeEventListener("value-changed", function (e) {
          _this3.shadowRoot.querySelector("#filteredcomments").like = e.target.value;
        });
        babelHelpers.get(babelHelpers.getPrototypeOf(LrnsysCommentList.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * Generate the ops URL based on the active comment
       */

    }, {
      key: "_computeCommentOpsUrl",
      value: function _computeCommentOpsUrl(activeComment, commentOpsBase, csrfToken) {
        if (babelHelpers.typeof(activeComment) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          return commentOpsBase + "/" + activeComment.id + "?token=" + csrfToken;
        }
      }
      /**
       * Handle liking a comment.
       */

    }, {
      key: "handleLike",
      value: function handleLike(e) {
        this.activeComment = e.detail.comment;
        this.shadowRoot.querySelector("#ajaxlikerequest").generateRequest();
      }
    }, {
      key: "_handleLikeResponse",
      value: function _handleLikeResponse(e) {}
      /**
       * Handle a delete dialog to confirm.
       */

    }, {
      key: "handleDeleteDialog",
      value: function handleDeleteDialog(e) {
        this.activeComment = e.detail.comment; // content of dialog

        var c = document.createElement("p");
        var t = document.createTextNode("Are you sure you want to delete your comment? This cannot be undone.");
        c.appendChild(t); // buttons

        var b = document.createElement("div");
        b.classList.add("buttons"); // close button

        var pb = document.createElement("button");
        pb.setAttribute("dialog-dismiss", "dialog-dismiss");
        pb.style.padding = "16px";
        pb.style.margin = "16px";
        t = document.createTextNode("Keep comment");
        pb.appendChild(t); // confirm button

        var pb2 = document.createElement("button");
        pb2.setAttribute("dialog-confirm", "dialog-confirm");
        pb2.setAttribute("autofocus", "autofocus");
        pb2.addEventListener("click", this._handleDeleteConfirm.bind(this));
        pb2.style.color = "white";
        pb2.style.backgroundColor = "red";
        pb2.style.padding = "16px";
        pb2.style.margin = "16px";
        t = document.createTextNode("Delete the comment");
        pb2.appendChild(t); // append buttons

        b.appendChild(pb2);
        b.appendChild(pb);
        var evt = new CustomEvent("simple-modal-show", {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            title: "Delete comment",
            elements: {
              content: c,
              buttons: b
            },
            styles: {
              "--simple-modal-width": "15vw",
              "--simple-modal-max-width": "15vw",
              "--simple-modal-z-index": "100000000",
              "--simple-modal-min-height": "10vh"
            },
            invokedBy: e.detail.target,
            clone: false
          }
        });
        this.dispatchEvent(evt);
      }
      /**
       * Handle editing response
       */

    }, {
      key: "handleEditing",
      value: function handleEditing(e) {
        var evt = new CustomEvent("simple-toast-show", {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            text: "Be awesome to each other",
            duration: 4000
          }
        });
        this.dispatchEvent(evt);
      }
      /**
       * Handle a reply event bubbling up from a comment we've printed
       * via our template in this element. This allows the higher element
       * to create new lower ones which can invoke more lower ones from
       * up above.
       */

    }, {
      key: "handleTopReply",
      value: function handleTopReply(e) {
        // ensure nothing is set as active for when this goes out the door
        this.set("newComment", []);
        this.set("activeComment", []);
        this.shadowRoot.querySelector("#ajaxcreatestub").generateRequest();
      }
      /**
       * Handle a reply event bubbling up from a comment we've printed
       * via our template in this element. This allows the higher element
       * to create new lower ones which can invoke more lower ones from
       * up above.
       */

    }, {
      key: "handleReply",
      value: function handleReply(e) {
        this.set("newComment", []);
        this.activeComment = e.detail.comment; // shift where the response will go

        this.shadowRoot.querySelector("#ajaxcreatestub").generateRequest();
      }
      /**
       * Update the UI to reflect the new comment based on returned data
       * added to the end since it's a new comment.
       */

    }, {
      key: "_updateReply",
      value: function _updateReply(e) {
        var comment = this.activeComment;
        var comments = this.comments.data; // normalize response

        this.newComment = this.newComment.data; // see if we have any comments at all

        if (comments.length == 0) {
          // top level replys need to get added to the end of the array
          comments.push(this.newComment);
        } // see if this is top level
        else if (babelHelpers.typeof(comment.id) == (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            // top level replys need to get added to the end of the array
            comments.push(this.newComment);
          } else {
            for (var index = 0; index < comments.length; index++) {
              if (comments[index].id == comment.id) {
                comments.splice(index + 1, 0, this.newComment);
              }
            }
          }

        this.activeComment = this.newComment; // force tree to notice element updated

        this.set("comments.data", []);
        this.set("comments.data", comments);
        this.notifyPath("comments.data");
      }
      /**
       * Handle a delete event bubbling up from a comment we've printed.
       */

    }, {
      key: "_handleDeleteConfirm",
      value: function _handleDeleteConfirm(e) {
        this.shadowRoot.querySelector("#ajaxdeleterequest").generateRequest();
      }
    }, {
      key: "_handleDeleteResponse",
      value: function _handleDeleteResponse(e) {
        var comment = this.activeComment;
        var comments = this.comments.data;

        for (var index = 0; index < comments.length; index++) {
          if (comments[index].id == comment.id) {
            comments.splice(index, 1); // nulify the active comment since it's been removed

            this.set("activeComment", []); // force tree to notice element updated

            this.set("comments.data", []);
            this.set("comments.data", comments);
            this.notifyPath("comments.data"); // force tree to notice element updated

            var evt = new CustomEvent("simple-toast-show", {
              bubbles: true,
              composed: true,
              cancelable: true,
              detail: {
                text: "Comment deleted",
                duration: 4000
              }
            });
            this.dispatchEvent(evt); // bail early

            return true;
          }
        }
      }
      /**
       * Handle saving a comment.
       */

    }, {
      key: "handleSave",
      value: function handleSave(e) {
        this.activeComment = e.detail.comment;
        this.shadowRoot.querySelector("#ajaxupdaterequest").generateRequest();
      }
    }, {
      key: "_handleUpdateResponse",
      value: function _handleUpdateResponse(e) {
        var evt = new CustomEvent("simple-toast-show", {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            text: "Comment saved!",
            duration: 4000
          }
        });
        this.dispatchEvent(evt);
      }
      /**
       * Simple way to convert from object to array.
       */

    }, {
      key: "_toArray",
      value: function _toArray(obj) {
        if (obj == null) {
          return [];
        }

        return Object.keys(obj).map(function (key) {
          return obj[key];
        });
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_d8de39a08e0011ed99ce491205e67b1d || (_templateObject_d8de39a08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          display: block;\n        }\n        app-toolbar {\n          padding: 0;\n        }\n        app-toolbar > *:not(:last-child) {\n          margin-right: 10px;\n        }\n        lrnsys-button {\n          font-size: 12px;\n        }\n        .comment-button {\n          --lrnsys-button-height: unset;\n        }\n        .comment-button::part(lrnsys-button-inner-div) {\n          padding: 0;\n        }\n      </style>\n      <!-- Load all comments on load of element -->\n      <iron-ajax\n        auto\n        url=\"[[sourcePath]]\"\n        handle-as=\"json\"\n        method=\"[[opsRequestMethod.list]]\"\n        last-response=\"{{comments}}\"\n      ></iron-ajax>\n      <!-- Create stub-comment -->\n      <iron-ajax\n        id=\"ajaxcreatestub\"\n        url=\"[[createStubUrl]]\"\n        method=\"[[opsRequestMethod.create]]\"\n        body=\"[[activeComment.id]]\"\n        on-response=\"_updateReply\"\n        handle-as=\"json\"\n        last-response=\"{{newComment}}\"\n      ></iron-ajax>\n      <!-- Update comment -->\n      <iron-ajax\n        id=\"ajaxupdaterequest\"\n        url=\"[[reqUrl]]\"\n        method=\"[[opsRequestMethod.update]]\"\n        body=\"[[activeComment]]\"\n        content-type=\"application/json\"\n        handle-as=\"json\"\n        on-response=\"_handleUpdateResponse\"\n      ></iron-ajax>\n      <!-- Delete comment -->\n      <iron-ajax\n        id=\"ajaxdeleterequest\"\n        url=\"[[reqUrl]]\"\n        method=\"[[opsRequestMethod.delete]]\"\n        body=\"[[activeComment]]\"\n        content-type=\"application/json\"\n        handle-as=\"json\"\n        on-response=\"_handleDeleteResponse\"\n      ></iron-ajax>\n      <!-- Like comment -->\n      <iron-ajax\n        id=\"ajaxlikerequest\"\n        url=\"[[reqUrl]]\"\n        method=\"[[opsRequestMethod.like]]\"\n        body=\"[[activeComment]]\"\n        content-type=\"application/json\"\n        handle-as=\"json\"\n        on-response=\"_handleLikeResponse\"\n      ></iron-ajax>\n      <app-toolbar>\n        <lrnsys-button\n          icon=\"add\"\n          class=\"comment-button\"\n          raised\n          on-click=\"handleTopReply\"\n          id=\"leavecomment\"\n          hover-class=\"blue white-text\"\n          label=\"Add Comment\"\n        ></lrnsys-button>\n        <paper-input\n          label=\"Filter comments by text\"\n          id=\"filtercomments\"\n          aria-controls=\"filteredcomments\"\n          value=\"\"\n          always-float-label=\"\"\n        ></paper-input>\n      </app-toolbar>\n      <grafitto-filter\n        id=\"filteredcomments\"\n        items$=\"[[_toArray(comments.data)]]\"\n        where=\"attributes.body\"\n        as=\"filtered\"\n        like=\"\"\n      >\n        <template>\n          <template\n            is=\"dom-repeat\"\n            id=\"commentlist\"\n            items=\"[[filtered]]\"\n            as=\"item\"\n          >\n            <lrnsys-comment\n              comment=\"{{item}}\"\n              hover-class=\"blue white-text\"\n            ></lrnsys-comment>\n          </template>\n        </template>\n      </grafitto-filter>\n    "])));
      }
    }, {
      key: "tag",
      get: function get() {
        return "lrnsys-comment-list";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * CSRF Token
           */
          csrfToken: {
            type: String
          },

          /**
           * Request methods
           */
          opsRequestMethod: {
            type: Object,
            value: {
              list: "GET",
              create: "POST",
              update: "PUT",
              delete: "DELETE",
              like: "PATCH"
            }
          },

          /**
           * Comment currently in scope
           */
          activeComment: {
            type: Object,
            notify: true
          },

          /**
           * New stub comment from backend.
           */
          newComment: {
            type: Object,
            notify: true
          },

          /**
           * An object containing all comments to render in the list
           */
          comments: {
            type: Object,
            notify: true
          },

          /**
           * Source to pull the comments from
           */
          sourcePath: {
            type: String,
            notify: true
          },

          /**
           * Base for ops calls
           */
          commentOpsBase: {
            type: String,
            notify: true
          },

          /**
           * Source to get stub comments from
           */
          createStubUrl: {
            type: String,
            notify: true
          },

          /**
           * Source for CRUD ops against individual comments.
           */
          reqUrl: {
            type: String,
            notify: true,
            computed: "_computeCommentOpsUrl(activeComment, commentOpsBase, csrfToken)"
          }
        };
      }
    }]);
    return LrnsysCommentList;
  }(_polymerElement.PolymerElement);

  _exports.LrnsysCommentList = LrnsysCommentList;
  customElements.define(LrnsysCommentList.tag, LrnsysCommentList);
});