define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.mtzMarkedControlLineBehaviorImpl = void 0;

  var mtzMarkedControlLineBehaviorImpl = function mtzMarkedControlLineBehaviorImpl(SuperClass) {
    return (
      /*#__PURE__*/
      function (_SuperClass) {
        babelHelpers.inherits(_class, _SuperClass);

        function _class() {
          babelHelpers.classCallCheck(this, _class);
          return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(_class).apply(this, arguments));
        }

        babelHelpers.createClass(_class, [{
          key: "_handleCommand",

          /**
           * Toggles a syntax prefix at the start of selected lines
           * @param {MouseEvent|KeyboardEvent} event
           * @protected
           */
          value: function _handleCommand(event) {
            var _this = this;

            event.preventDefault();
            event.stopPropagation();
            var editor = this.__editor;
            var selection = editor.getSelection();
            var lines = editor.getLines(); // Grab the newline char

            var newlineChar = lines.length > 1 ? lines[1].match(/(\n|\r\n)/)[0] : ""; // Grab lines within the selection

            var selectedLines = [];
            var accumulator = 0;
            lines.every(function (line) {
              // Accumulate line
              accumulator += line.length; // Check if selection start is not within the line, skip to next line

              if (accumulator + 1 < selection.start) {
                return true;
              } // Line is part of selection or contains selection start, so let's grab it


              selectedLines.push({
                start: accumulator - line.length,
                end: accumulator,
                length: line.length,
                text: line.trimLeft()
              }); // Stop grabbing lines if we reach the end of the selection

              return accumulator < selection.end;
            }); // Check the first line for syntax

            var firstLine = selectedLines[0];
            var removeSyntax = firstLine.text.startsWith(this.syntaxPrefix);
            var offset = 0; // Toggle syntax on each line

            selectedLines.forEach(function (line) {
              // if the syntax exists remove it from any lines containing it
              if (removeSyntax && line.text.startsWith(_this.syntaxPrefix)) {
                line.text = line.text.slice(_this.syntaxPrefix.length, line.end);
              } else if (!removeSyntax) {
                line.text = "".concat(_this.syntaxPrefix).concat(line.text);
              } // Accumulate number of characters modified in the textarea


              offset += _this.syntaxPrefix.length;
            }); // Selected all the lines affected

            var lastLine = selectedLines[selectedLines.length - 1];
            editor.setSelection(firstLine.start, lastLine.end); // If single line, add newline

            if (selectedLines.length === 1 && selectedLines[0].start > 0) {
              firstLine.text = "".concat(newlineChar).concat(firstLine.text);
              firstLine.start += newlineChar.length;
            } // Replace all selected lines with modified content


            editor.replaceSelection(selectedLines.map(function (line) {
              return line.text;
            }).join(newlineChar)); // Re-select the new content on the lines

            editor.setSelection(firstLine.start, lastLine.end + (!removeSyntax ? 1 : -1) * offset);
            editor.getTextarea().focus();
          }
        }], [{
          key: "properties",
          get: function get() {
            var props = {
              syntaxPrefix: String // Must implement

            };

            if (babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)) {
              props = Object.assign(props, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this));
            }

            return props;
          }
        }]);
        return _class;
      }(SuperClass)
    );
  };

  _exports.mtzMarkedControlLineBehaviorImpl = mtzMarkedControlLineBehaviorImpl;
});