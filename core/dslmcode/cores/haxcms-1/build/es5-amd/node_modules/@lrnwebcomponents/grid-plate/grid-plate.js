define(["exports", "require", "../../lit-element/lit-element.js", "../responsive-utility/responsive-utility.js"], function (_exports, _require, _litElement, _responsiveUtility) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.GridPlate = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject3_f44a548001c111eba2339b0c52070e79() {
    var data = babelHelpers.taggedTemplateLiteral(["\n            <div class=\"button-holding-pen\">\n              <paper-icon-button\n                class=\"direction\"\n                icon=\"hax:arrow-all\"\n                title=\"Drag\"\n                draggable=\"true\"\n                id=\"drag\"\n                @dragstart=\"", "\"\n                @dragend=\"", "\"\n              >\n              </paper-icon-button>\n              <paper-icon-button\n                class=\"direction\"\n                icon=\"hardware:keyboard-arrow-up\"\n                title=\"Move up\"\n                id=\"up\"\n                @click=\"", "\"\n              >\n              </paper-icon-button>\n              <paper-icon-button\n                class=\"direction\"\n                icon=\"hardware:keyboard-arrow-right\"\n                title=\"Move right\"\n                id=\"right\"\n                @click=\"", "\"\n              >\n              </paper-icon-button>\n              <paper-icon-button\n                class=\"direction\"\n                icon=\"hardware:keyboard-arrow-down\"\n                title=\"Move down\"\n                id=\"down\"\n                @click=\"", "\"\n              >\n              </paper-icon-button>\n              <paper-icon-button\n                class=\"direction\"\n                icon=\"hardware:keyboard-arrow-left\"\n                title=\"Move left\"\n                id=\"left\"\n                @click=\"", "\"\n              >\n              </paper-icon-button>\n            </div>\n          "]);

    _templateObject3_f44a548001c111eba2339b0c52070e79 = function _templateObject3_f44a548001c111eba2339b0c52070e79() {
      return data;
    };

    return data;
  }

  function _templateObject2_f44a548001c111eba2339b0c52070e79() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      ", "\n      <div class=\"row\">\n        <div\n          class=\"column\"\n          id=\"col1\"\n          data-label=\"column 1\"\n          .style=\"", "\"\n        >\n          <slot name=\"col-1\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col2\"\n          data-label=\"column 2\"\n          .style=\"", "\"\n        >\n          <slot name=\"col-2\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col3\"\n          data-label=\"column 3\"\n          .style=\"", "\"\n        >\n          <slot name=\"col-3\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col4\"\n          data-label=\"column 4\"\n          .style=\"", "\"\n        >\n          <slot name=\"col-4\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col5\"\n          data-label=\"column 5\"\n          .style=\"", "\"\n        >\n          <slot name=\"col-5\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col6\"\n          data-label=\"column 6\"\n          .style=\"", "\"\n        >\n          <slot name=\"col-6\"></slot>\n        </div>\n      </div>\n    "]);

    _templateObject2_f44a548001c111eba2339b0c52070e79 = function _templateObject2_f44a548001c111eba2339b0c52070e79() {
      return data;
    };

    return data;
  }

  function _templateObject_f44a548001c111eba2339b0c52070e79() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          --grid-plate-row-margin: 0px;\n          --grid-plate-row-padding: 0px;\n          --grid-plate-item-margin: 15px;\n          --grid-plate-editable-border-color: var(\n            --simple-colors-default-theme-cyan-7,\n            #009dc7\n          );\n          --grid-plate-active-border-color: var(\n            --simple-colors-default-theme-cyan-7,\n            #3b97e3\n          );\n          --grid-plate-target-background-color: var(\n            --simple-colors-default-theme-cyan-2,\n            #9beaff\n          );\n          --grid-plate-possible-target-background-color: transparent;\n          --grid-plate-selected-background-color: #ffffff;\n          --grid-plate-arrow-color: #ffffff;\n          --grid-plate-arrow-color-hover: #000000;\n          --grid-plate-arrow-bg: var(\n            --simple-colors-default-theme-cyan-7,\n            #3b97e3\n          );\n        }\n        :host .row {\n          width: 100%;\n          display: flex;\n          flex-wrap: wrap;\n          justify-content: space-between;\n          align-items: stretch;\n          margin: var(--grid-plate-row-margin);\n          padding: var(--grid-plate-row-padding);\n        }\n        :host .column {\n          width: 100%;\n          flex: 0 0 auto;\n        }\n        :host([edit-mode]) .column {\n          min-height: 150px;\n          transition: 0.2s color linear, 0.2s background-color linear,\n            0.2s outline linear;\n        }\n        :host([edit-mode]) {\n          min-height: 150px;\n        }\n        :host([edit-mode]) .column {\n          outline: 1px solid var(--grid-plate-editable-border-color);\n        }\n        :host .column:empty[style=\"min-height: unset;\"] {\n          display: none;\n          outline: none;\n        }\n        :host([edit-mode]) .column[style=\"min-height: unset;\"]:not(:empty) {\n          display: block;\n          opacity: 0.4;\n        }\n        :host([edit-mode])\n          .column[style=\"min-height: unset;\"]:not(:empty):hover {\n          opacity: 1;\n        }\n        :host([edit-mode])\n          .column[style=\"min-height: unset;\"]:not(:empty):before {\n          margin: var(--grid-plate-item-margin);\n          color: red;\n          font-size: 14px;\n          font-weight: bold;\n          padding: 0px;\n        }\n        :host .column ::slotted(*) {\n          margin: var(--grid-plate-item-margin);\n          padding: var(--grid-plate-item-margin);\n          max-width: calc(100% - 60px);\n          max-width: -webkit-fill-available;\n          transition: 0.2s color linear, 0.2s background-color linear,\n            0.2s outline linear;\n        }\n        :host([edit-mode]) .column ::slotted(img) {\n          display: block;\n        }\n        :host([edit-mode]) .column ::slotted(.grid-plate-active-item) {\n          outline: 1px solid var(--grid-plate-active-border-color);\n          background-color: var(--grid-plate-selected-background-color);\n        }\n        :host([edit-mode]) .column ::slotted(ol.grid-plate-active-item),\n        :host([edit-mode]) .column ::slotted(ul.grid-plate-active-item) {\n          outline-offset: 8px;\n        }\n        :host([edit-mode]) .column ::slotted(*:focus),\n        :host([edit-mode]) .column ::slotted(*:hover),\n        :host([edit-mode]) .column ::slotted(*:active) {\n          outline: 2px solid var(--grid-plate-editable-border-color);\n        }\n        :host([edit-mode]) .column ::slotted(ol:focus),\n        :host([edit-mode]) .column ::slotted(ol:hover),\n        :host([edit-mode]) .column ::slotted(ol:active),\n        :host([edit-mode]) .column ::slotted(ul:focus),\n        :host([edit-mode]) .column ::slotted(ul:hover),\n        :host([edit-mode]) .column ::slotted(ul:active) {\n          outline-offset: 8px;\n        }\n        :host([edit-mode]) .column ::slotted(*.hax-mover):before {\n          outline: 1px solid var(--grid-plate-editable-border-color);\n          background-color: var(--grid-plate-possible-target-background-color);\n          content: \" \";\n          width: 100%;\n          display: block;\n          position: relative;\n          margin: -30px 0 0 0;\n          z-index: 2;\n          height: 30px;\n        }\n        :host([edit-mode]) .column ::slotted(img.hax-mover) {\n          outline: 1px solid var(--grid-plate-editable-border-color);\n          background-color: var(--grid-plate-possible-target-background-color);\n        }\n        :host([edit-mode]) .column.hax-mover {\n          outline: 1px solid var(--grid-plate-editable-border-color);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*.hax-moving) {\n          outline: 1px solid var(--hax-body-active-border-color);\n          background-color: #eeeeee;\n        }\n        :host([edit-mode]) .column.hax-mover {\n          content: \"Double click to create a paragraph here\";\n          background-color: var(--grid-plate-possible-target-background-color);\n        }\n        :host([edit-mode]) .column ::slotted(img.hax-hovered),\n        :host([edit-mode]) .column ::slotted(*.hax-hovered):before {\n          background-color: var(\n            --grid-plate-target-background-color\n          ) !important;\n          outline: solid 2px var(--grid-plate-active-border-color);\n        }\n        :host([edit-mode]) .column.hax-hovered {\n          background-color: var(\n            --grid-plate-target-background-color\n          ) !important;\n          outline: solid 2px var(--grid-plate-active-border-color);\n          z-index: 2;\n        }\n        paper-icon-button {\n          display: none;\n          position: absolute;\n          margin: 0;\n          padding: 0;\n          outline: none;\n          width: 20px;\n          height: 20px;\n          color: var(--grid-plate-arrow-color);\n          opacity: 1;\n          background-color: var(--grid-plate-arrow-bg);\n          border-radius: none;\n          box-sizing: content-box !important;\n          z-index: 2;\n          min-width: unset;\n          transition: 0.2s color linear, 0.2s background-color linear;\n        }\n        paper-icon-button:hover {\n          opacity: 1;\n          visibility: visible;\n          color: var(--grid-plate-arrow-color-hover);\n        }\n        #drag {\n          cursor: move;\n        }\n        paper-icon-button[disabled] {\n          opacity: 0.5;\n        }\n        paper-icon-button[disabled]:focus,\n        paper-icon-button[disabled]:hover {\n          cursor: not-allowed;\n        }\n        paper-icon-button.active {\n          display: block;\n        }\n\n        .button-holding-pen {\n          position: relative;\n        }\n        .button-holding-pen[hidden] {\n          display: none;\n        }\n      "]);

    _templateObject_f44a548001c111eba2339b0c52070e79 = function _templateObject_f44a548001c111eba2339b0c52070e79() {
      return data;
    };

    return data;
  }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  // need to make this an object so that HAX can listen for it correctly
  var GridPlateLayoutOptions = function GridPlateLayoutOptions() {
    babelHelpers.classCallCheck(this, GridPlateLayoutOptions);
    this.resizeTimer = null;
    this.activeItem = null;
    this.layouts = {
      1: {
        columnLayout: "1: full width",
        xs: ["100%"],
        sm: ["100%"],
        md: ["100%"],
        lg: ["100%"],
        xl: ["100%"]
      },
      "1-1": {
        columnLayout: "2: equal width",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["50%", "50%"],
        lg: ["50%", "50%"],
        xl: ["50%", "50%"]
      },
      "2-1": {
        columnLayout: "2: wide & narrow",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["66.6666667%", "33.3333337%"],
        lg: ["66.6666667%", "33.3333337%"],
        xl: ["66.6666667%", "33.3333337%"]
      },
      "1-2": {
        columnLayout: "2: narrow & wide",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["33.3333333%", "66.6666667%"],
        lg: ["33.3333333%", "66.6666667%"],
        xl: ["33.3333333%", "66.6666667%"]
      },
      "3-1": {
        columnLayout: "2: wider & narrower",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["75%", "25%"],
        lg: ["75%", "25%"],
        xl: ["75%", "25%"]
      },
      "1-3": {
        columnLayout: "2: narrower & wider",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["25%", "75%"],
        lg: ["25%", "75%"],
        xl: ["25%", "75%"]
      },
      "1-1-1": {
        columnLayout: "3: equal width",
        xs: ["100%", "100%", "100%"],
        sm: ["100%", "100%", "100%"],
        md: ["33.3333333%", "33.3333333%", "33.3333333%"],
        lg: ["33.3333333%", "33.3333333%", "33.3333333%"],
        xl: ["33.3333333%", "33.3333333%", "33.3333333%"]
      },
      "2-1-1": {
        columnLayout: "3: wide, narrow, and narrow",
        xs: ["100%", "100%", "100%"],
        sm: ["100%", "50%", "50%"],
        md: ["50%", "25%", "25%"],
        lg: ["50%", "25%", "25%"],
        xl: ["50%", "25%", "25%"]
      },
      "1-2-1": {
        columnLayout: "3: narrow, wide, and narrow",
        xs: ["100%", "100%", "100%"],
        sm: ["100%", "100%", "100%"],
        md: ["25%", "50%", "25%"],
        lg: ["25%", "50%", "25%"],
        xl: ["25%", "50%", "25%"]
      },
      "1-1-2": {
        columnLayout: "3: narrow, narrow, and wide",
        xs: ["100%", "100%", "100%"],
        sm: ["50%", "50%", "100%"],
        md: ["25%", "25%", "50%"],
        lg: ["25%", "25%", "50%"],
        xl: ["25%", "25%", "50%"]
      },
      "1-1-1-1": {
        columnLayout: "4: equal width",
        xs: ["100%", "100%", "100%", "100%"],
        sm: ["50%", "50%", "50%", "50%"],
        md: ["25%", "25%", "25%", "25%"],
        lg: ["25%", "25%", "25%", "25%"],
        xl: ["25%", "25%", "25%", "25%"]
      },
      "1-1-1-1-1": {
        columnLayout: "5: equal width",
        xs: ["100%", "100%", "100%", "100%", "100%"],
        sm: ["50%", "50%", "50%", "50%", "50%"],
        md: ["20%", "20%", "20%", "20%", "20%"],
        lg: ["20%", "20%", "20%", "20%", "20%"],
        xl: ["20%", "20%", "20%", "20%", "20%"]
      },
      "1-1-1-1-1-1": {
        columnLayout: "6: equal width",
        xs: ["100%", "100%", "100%", "100%", "100%", "100%"],
        sm: ["50%", "50%", "50%", "50%", "50%", "50%"],
        md: ["33.3333333%", "33.3333333%", "33.3333333%", "33.3333333%", "33.3333333%", "33.3333333%"],
        lg: ["16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%"],
        xl: ["16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%"]
      }
    };
    this.options = {};
    var layoutFlip = Object.keys(this.layouts); // loop through all the supplied layouts to get the HAX layout options & descriptions

    for (var i = 1; i < layoutFlip.length; i++) {
      this.options[layoutFlip[i]] = this.layouts[layoutFlip[i]].columnLayout;
    }
  };
  /**
   * `grid-plate`
   * `A grid plate based on a layout that manipulates it.`
   * @demo demo/index.html
   * @element grid-plate
   */


  var GridPlate = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(GridPlate, _LitElement);

    var _super = _createSuper(GridPlate);

    babelHelpers.createClass(GridPlate, null, [{
      key: "styles",

      /**
       * LitElement render styles
       */
      get: function get() {
        return [(0, _litElement.css)(_templateObject_f44a548001c111eba2339b0c52070e79())];
      }
    }]);

    function GridPlate() {
      var _this;

      babelHelpers.classCallCheck(this, GridPlate);
      _this = _super.call(this);
      _this.droppable = false;
      _this.ignoreHax = false;
      _this.hideOps = false;
      _this.breakpointSm = 900;
      _this.breakpointMd = 1200;
      _this.breakpointLg = 1500;
      _this.breakpointXl = 1800;
      _this.columns = 6;
      _this.disableResponsive = false;
      _this.editMode = false;

      if (window.HaxStore && window.HaxStore.instance) {
        _this.editMode = window.HaxStore.instance.editMode;
      }

      _this.layout = "1-1";
      _this.layouts = new GridPlateLayoutOptions().layouts;
      _this.responsiveSize = "xs";
      setTimeout(function () {
        new Promise(function (res, rej) {
          return _require.default(["../../@polymer/paper-icon-button/paper-icon-button.js"], res, rej);
        });
        new Promise(function (res, rej) {
          return _require.default(["../../@polymer/iron-icons/hardware-icons.js"], res, rej);
        });
        new Promise(function (res, rej) {
          return _require.default(["../hax-iconset/hax-iconset.js"], res, rej);
        });

        _this.addEventListener("focusin", _this._focusIn.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("dragenter", _this.dragEnterGrid.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      window.ResponsiveUtility.requestAvailability();
      return _this;
    }
    /**
     * LitElement render
     */


    babelHelpers.createClass(GridPlate, [{
      key: "render",
      value: function render() {
        return (0, _litElement.html)(_templateObject2_f44a548001c111eba2339b0c52070e79(), !this.hideOps ? (0, _litElement.html)(_templateObject3_f44a548001c111eba2339b0c52070e79(), this.dragStart, this.dragEnd, this.moveActiveElement, this.moveActiveElement, this.moveActiveElement, this.moveActiveElement) : "", this._getColumnWidth(0, this.__columnWidths), this._getColumnWidth(1, this.__columnWidths), this._getColumnWidth(2, this.__columnWidths), this._getColumnWidth(3, this.__columnWidths), this._getColumnWidth(4, this.__columnWidths), this._getColumnWidth(5, this.__columnWidths));
      }
    }, {
      key: "validateElementSlot",

      /**
       * Validate the slot name
       */
      value: function validateElementSlot(node) {
        return ["col-1", "col-2", "col-3", "col-4", "col-5", "col-6"].includes(node.getAttribute("slot"));
      }
      /**
       * HTMLElement
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this2 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(GridPlate.prototype), "connectedCallback", this).call(this);
        this.observer = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            // only need to apply this when we're in editMode
            // this implies something was added dynamically or drag and drop
            // from outside this element or dragging between grid plates
            // so we need to disconnect the handlers from here and pick them
            // up in the new plate
            if (_this2.editMode) {
              mutation.addedNodes.forEach(function (node) {
                if (node.tagName) {
                  // verify this has a slot set otherwise we need to set one on the fly
                  // otherwise this won't show up. This could be incorrectly formed HTML
                  // DOM that was pushed in via an outside system or edge cases of things
                  // dropping in without a slot set in anyway
                  // validate slot name, otherwise force it to col-1
                  if (node.getAttribute("slot") == null || !_this2.validateElementSlot(node)) {
                    if (_this2.__slot) {
                      node.setAttribute("slot", _this2.__slot);
                      _this2.__slot = null;
                    } else {
                      node.setAttribute("slot", "col-1");
                    }
                  } // event timeout is to help w/ between grid plate drops


                  setTimeout(function () {
                    node.addEventListener("drop", _this2.dropEvent.bind(_this2));
                    node.addEventListener("dragenter", _this2.dragEnter.bind(_this2));
                    node.addEventListener("dragleave", _this2.dragLeave.bind(_this2));
                    node.addEventListener("dragend", _this2.dragEnd.bind(_this2));
                    node.addEventListener("dragover", function (e) {
                      e.preventDefault();
                    }); // UX normalization

                    if (node.tagName === "IMG") {
                      node.setAttribute("draggable", false);
                    } // ensure they can be focused


                    node.setAttribute("tabindex", 0);
                  }, 50);
                }
              });
              mutation.removedNodes.forEach(function (node) {
                if (node.tagName) {
                  node.removeEventListener("drop", _this2.dropEvent.bind(_this2));
                  node.removeEventListener("dragenter", _this2.dragEnter.bind(_this2));
                  node.removeEventListener("dragleave", _this2.dragLeave.bind(_this2));
                  node.removeEventListener("dragover", function (e) {
                    e.preventDefault();
                  });

                  if (node.tagName === "IMG") {
                    node.removeAttribute("draggable");
                  } // ensure they can be focused


                  node.removeAttribute("tabindex");
                }
              });
            }
          });
        });
        this.observer.observe(this, {
          childList: true
        }); // capture keydown events

        window.addEventListener("keydown", this._onKeyDown.bind(this)); // listen for HAX if it's around

        window.addEventListener("hax-store-property-updated", this._haxStorePropertyUpdated.bind(this)); // dom loaded, resize to be safe

        window.addEventListener("load", this.resize.bind(this)); // if we resize, listen and react

        window.addEventListener("resize", this.resizeListener.bind(this));
      }
    }, {
      key: "resizeListener",
      value: function resizeListener(e) {
        var _this3 = this;

        if (this.activeItem) {
          clearTimeout(this.resizeTimer);
          this.resizeTimer = setTimeout(function () {
            _this3.positionArrows(_this3.activeItem);
          }, 50);
        }
      }
    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(e) {
        if (this.editMode && this.getAttribute("contenteditable")) {
          switch (e.key) {
            case "Enter":
              // support HAX text operations should take priority
              if (window.HaxStore && window.HaxStore.instance && window.HaxStore.instance.isTextElement(this.activeItem)) {
                this.__slot = this.activeItem.getAttribute("slot");
                return true;
              }

              if (!this.hideOps) {
                this.shadowRoot.querySelector("#right").focus();
              }

              break;
            // clear active

            case "Escape":
              this.activeItem = null;
              break;
          }
        }
      }
      /**
       * life cycle
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        window.dispatchEvent(new CustomEvent("responsive-element", {
          detail: {
            element: this,
            attribute: "responsive-size",
            relativeToParent: false,
            sm: this.breakpointSm,
            md: this.breakpointMd,
            lg: this.breakpointLg,
            xl: this.breakpointXl
          }
        })); // apply handlers to the columns themselves

        for (var j = 1; j <= this.columns; j++) {
          if (this.shadowRoot.querySelector("#col" + j) !== undefined) {
            var col = this.shadowRoot.querySelector("#col" + j);
            col.addEventListener("drop", this.dropEvent.bind(this));
            col.addEventListener("dragenter", this.dragEnter.bind(this));
            col.addEventListener("dragleave", this.dragLeave.bind(this));
            col.addEventListener("dragover", function (e) {
              e.preventDefault();
            });
          }
        }

        this.__columnWidths = this._getColumnWidths(this.responsiveSize, this.layout, this.layouts, this.disableResponsive);
      }
      /**
       * life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("keydown", this._onKeyDown.bind(this)); // listen for HAX if it's around

        window.removeEventListener("hax-store-property-updated", this._haxStorePropertyUpdated.bind(this));
        window.removeEventListener("load", this.resize.bind(this));
        window.removeEventListener("resize", this.resizeListener.bind(this)); // clean up mutation observer

        this.observer.disconnect();
        babelHelpers.get(babelHelpers.getPrototypeOf(GridPlate.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this4 = this;

        changedProperties.forEach(function (oldValue, propName) {
          // if any of these changed, update col widths
          if (["responsiveSize", "layout", "layouts", "disableResponsive"].includes(propName)) {
            _this4.__columnWidths = _this4._getColumnWidths(_this4.responsiveSize, _this4.layout, _this4.layouts, _this4.disableResponsive);
          }

          switch (propName) {
            // observer
            case "droppable":
              _this4._droppableChanged(_this4[propName], oldValue);

              break;
            // observer

            case "editMode":
              _this4._editModeChanged(_this4[propName], oldValue);

              _this4.resize();

              break;
            // observer

            case "activeItem":
              _this4._activeItemChanged(_this4[propName], oldValue);

              break;
            // observer, ensure we are sized correctly after widths change

            case "__columnWidths":
              // widths changed because of layout somehow, wait for the resize transition
              // to have processed, then fire a resize event which we are listening for
              // which will then ensure the arrows are positioned correctly
              _this4.resize();

              break;

            case "disableResponsive":
              // fire an event that this is a core piece of the system
              _this4.dispatchEvent(new CustomEvent("disable-responsive-changed", {
                detail: _this4[propName]
              }));

              break;
          }
        });
      }
    }, {
      key: "resize",
      value: function resize() {
        window.dispatchEvent(new Event("resize"));
      }
      /**
       * Implements preProcessHaxInsertContent to clean up output on save
       */

    }, {
      key: "preProcessHaxInsertContent",
      value: function preProcessHaxInsertContent(detail) {
        // ensure this is wiped to avoid issues in building
        delete detail.properties.activeItem;
        return detail;
      }
    }, {
      key: "_droppableChanged",
      value: function _droppableChanged(newValue) {
        if (newValue) {
          this.editMode = true;
        }
      }
      /**
       * Determines if the item can move a set number of slots.
       *
       * @param {object} the item
       * @param {number} -1 for left or +1 for right
       * @returns {boolean} if the item can move a set number of slots
       */

    }, {
      key: "canMoveSlot",
      value: function canMoveSlot(item, before) {
        var dir = before ? -1 : 1,
            max = this.shadowRoot.querySelectorAll(".column").length,
            col = item.getAttribute("slot").split("-"),
            dest = parseInt(col[1]) + dir;
        return dest >= 1 && dest <= max;
      }
      /**
       * Moves an item a set number of slots.
       *
       * @param {object} the item
       * @param {number} -1 for left or +1 for right
       */

    }, {
      key: "moveSlot",
      value: function moveSlot(item, before) {
        var dir = before ? -1 : 1,
            col = item.getAttribute("slot").split("-"),
            dest = parseInt(col[1]) + dir;
        item.setAttribute("slot", "col-" + dest);
      }
      /**
       * Determines if the item can move a set number of slots.
       *
       * @param {object} the item
       * @param {boolean} move item before previous? (false for move item after next)
       * @returns {boolean} if the item can move a set number of slots
       */

    }, {
      key: "canMoveOrder",
      value: function canMoveOrder(item, before) {
        var slot = item.getAttribute("slot");
        var nodes = this.shadowRoot.querySelector("slot[name='".concat(slot, "']")).assignedNodes({
          flatten: true
        });
        var target = null,
            position = 0;

        for (var i in nodes) {
          if (item === nodes[i]) {
            position = i;
          }
        }

        if (before && parseInt(position) - 1 >= 0) {
          target = nodes[parseInt(position) - 1];
        } else if (!before && parseInt(position) + 1 <= nodes.length - 1) {
          target = nodes[parseInt(position) + 1];
        }

        return target !== null && babelHelpers.typeof(target) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined));
      }
      /**
       * Moves an item's order within a slot.
       *
       * @param {object} the item
       * @param {boolean} move item before previous? (false for move item after next)
       */

    }, {
      key: "moveOrder",
      value: function moveOrder(item) {
        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var slot = item.getAttribute("slot");
        var nodes = this.shadowRoot.querySelector("slot[name='".concat(slot, "']")).assignedNodes({
          flatten: true
        });
        var target = null,
            position = 0;

        for (var i in nodes) {
          if (item === nodes[i]) {
            position = i;
          }
        }

        if (before) {
          target = nodes[parseInt(position) - 1];
          this.insertBefore(this.activeItem, target);
        } else {
          target = nodes[parseInt(position) + 1];
          this.insertBefore(target, this.activeItem);
        }
      }
      /**
       * Move the active element based on which button got pressed.
       */

    }, {
      key: "moveActiveElement",
      value: function moveActiveElement(e) {
        var local = e.target; // see if this was an up down left or right movement

        switch (local.id) {
          case "up":
            this.moveOrder(this.activeItem, true);
            break;

          case "down":
            this.moveOrder(this.activeItem, false);
            break;

          case "left":
            this.moveSlot(this.activeItem, true);
            break;

          case "right":
            this.moveSlot(this.activeItem, false);
            break;
        } // ensure arrows are correctly positioned after the move


        if (this.activeItem && typeof this.activeItem.focus === "function") {
          this.positionArrows(this.activeItem);
          this.activeItem.focus();
        }

        this.__sortChildren();
      }
      /**
       * Notice changes to what's active and ensure UX associated w/ it is visble
       */

    }, {
      key: "_activeItemChanged",
      value: function _activeItemChanged(newValue, oldValue) {
        // remove anything currently with the active class
        this.querySelectorAll(".grid-plate-active-item").forEach(function (el) {
          el.classList.remove("grid-plate-active-item");
        });

        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue != null) {
          // position arrows
          newValue.classList.add("grid-plate-active-item");
          this.positionArrows(newValue);
        } else if (newValue == null) {
          this.positionArrows(newValue);
        } // if we had a previous value then remove the active item class


        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && oldValue != null) {
          oldValue.blur();
        }
      }
      /**
       * gets the column widths based on selected layout and current responsive width
       *
       * @param {string} a string that describes the current responsive width
       * @param {string} the name of selected layout
       * @param {object} predefined layouts of column sizes and various responsive widths
       * @param {boolean} disable responsive sizing?
       * @returns {object} an object with a layout's column sizes at the current responsive width
       */

    }, {
      key: "_getColumnWidths",
      value: function _getColumnWidths() {
        var responsiveSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "sm";
        var layout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "1-1";
        var layouts = arguments.length > 2 ? arguments[2] : undefined;
        var disableResponsive = arguments.length > 3 ? arguments[3] : undefined;

        if (layouts) {
          var newl = layouts[layout],
              //how old layout names map to the new ones
          oldLayouts = {
            12: "1",
            "8/4": "2-1",
            "6/6": "1-1",
            "4/8": "1-2",
            "4/4/4": "1-1-1",
            "3/3/3/3": "1-1-1-1"
          },
              size = disableResponsive !== false ? "xl" : responsiveSize;
          var oldl = oldLayouts[layout];

          if (newl !== undefined && newl[size] !== undefined) {
            //return the layout
            return layouts[layout][size];
          } else if (layouts[oldl] !== undefined && layouts[oldl][size] !== undefined) {
            //return new layout that maps to old one
            return layouts[oldl][size];
          } else if (babelHelpers.typeof(layouts["1-1"]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            //return 2-column layout
            return layouts["1-1"][size];
          }
        }
      }
      /**
       * gets a given column's current width based on layout and current responsive width
       *
       * @param {number} the index of the column
       * @param {object} an object with a layout's column sizes at the current responsive width
       * @returns {string} a given column's current width based on layout and current responsive width
       */

    }, {
      key: "_getColumnWidth",
      value: function _getColumnWidth(column, __columnWidths) {
        return __columnWidths !== undefined && __columnWidths[column] !== undefined ? "width:" + __columnWidths[column] : "min-height: unset";
      }
      /**
       * gets a given column's current width based on layout and current responsive width
       *
       * @param {string} the name of selected layout
       * @returns {number} the number of columns in this layout
       */

    }, {
      key: "_getColumns",
      value: function _getColumns(__columnWidths) {
        return __columnWidths.length;
      }
      /**
       * Focus / tab / click event normalization
       */

    }, {
      key: "_focusIn",
      value: function _focusIn(e) {
        if (this.editMode) {
          var local = e.target; // only activate if we touch something that's in the slot of the grid plate

          if (local.parentNode === this) {
            this.activeItem = local;
          }
        }
      }
      /**
       * Position the arrows to change directions around something
       */

    }, {
      key: "positionArrows",
      value: function positionArrows(item) {
        var onlyArrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (!this.hideOps) {
          if (item == null) {
            this.shadowRoot.querySelectorAll(".direction").forEach(function (el) {
              if (!onlyArrows) {
                el.classList.remove("active");
              } else {
                if (el.id != "drag") {
                  el.classList.remove("active");
                }
              }
            });
          } else {
            this.shadowRoot.querySelectorAll(".direction").forEach(function (el) {
              el.classList.add("active");
            }); // ensure we disable invalid options contextually
            // test for an element above us

            this.shadowRoot.querySelector("#up").disabled = !this.canMoveOrder(item, true); // test for an element below us

            this.shadowRoot.querySelector("#down").disabled = !this.canMoveOrder(item, false); // test for a column to the left of us

            this.shadowRoot.querySelector("#left").disabled = !this.canMoveSlot(item, true); // test for a column to the right of us

            this.shadowRoot.querySelector("#right").disabled = !this.canMoveSlot(item, false); // get coordinates of the page and active element
            // delay since a transition might move it

            var bodyRect = this.getBoundingClientRect();
            var elemRect = item.getBoundingClientRect();
            var topOffset = elemRect.top - bodyRect.top;
            var leftOffset = elemRect.left - bodyRect.left; // set the arrows to position correctly at all 4 sides

            this.shadowRoot.querySelector("#up").style.top = topOffset - 10 + "px";
            this.shadowRoot.querySelector("#down").style.top = topOffset + elemRect.height - 10 + "px";
            this.shadowRoot.querySelector("#left").style.top = topOffset + elemRect.height / 2 - 10 + "px";
            this.shadowRoot.querySelector("#right").style.top = topOffset + elemRect.height / 2 - 10 + "px";
            this.shadowRoot.querySelector("#drag").style.top = topOffset - 10 + "px";
            this.shadowRoot.querySelector("#drag").style.left = leftOffset - 10 + "px";
            this.shadowRoot.querySelector("#up").style.left = leftOffset + elemRect.width / 2 - 10 + "px";
            this.shadowRoot.querySelector("#down").style.left = leftOffset + elemRect.width / 2 - 10 + "px";
            this.shadowRoot.querySelector("#left").style.left = leftOffset - 10 + "px";
            this.shadowRoot.querySelector("#right").style.left = leftOffset + elemRect.width - 10 + "px";
          }
        }
      }
      /**
       * Notice edit state has changed
       */

    }, {
      key: "_editModeChanged",
      value: function _editModeChanged(newValue, oldValue) {
        // flipping from false to true
        if (newValue && !oldValue) {
          var children = this.children; // walk the children and apply the draggable state needed

          for (var i in children) {
            if (children[i].tagName) {
              children[i].addEventListener("drop", this.dropEvent.bind(this));
              children[i].addEventListener("dragenter", this.dragEnter.bind(this));
              children[i].addEventListener("dragleave", this.dragLeave.bind(this));
              children[i].addEventListener("dragover", function (e) {
                e.preventDefault();
              });

              if (children[i].tagName === "IMG") {
                children[i].setAttribute("draggable", false);
              } // ensure they can be focused


              children[i].setAttribute("tabindex", 0);
            }
          }
        } // flipping from true to false
        else if (!newValue && oldValue) {
            // unset active to clean up state
            this.activeItem = null;
            var _children = this.children; // walk the children and remove the draggable state needed

            for (var i in _children) {
              if (babelHelpers.typeof(_children[i].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                _children[i].removeEventListener("drop", this.dropEvent.bind(this));

                _children[i].removeEventListener("dragenter", this.dragEnter.bind(this));

                _children[i].removeEventListener("dragleave", this.dragLeave.bind(this));

                _children[i].removeEventListener("dragover", function (e) {
                  e.preventDefault();
                });

                if (_children[i].tagName === "IMG") {
                  _children[i].removeAttribute("draggable");
                }

                _children[i].removeAttribute("tabindex");
              }
            }
          }
      }
      /**
       * Activation allowed from outside this grid as far as drop areas
       */

    }, {
      key: "dragEnterGrid",
      value: function dragEnterGrid(e) {
        var children = this.children; // walk the children and apply the draggable state needed

        for (var i in children) {
          if (children[i].classList && children[i] !== this.activeItem) {
            children[i].classList.add("hax-mover");
          }
        }

        for (var j = 1; j <= this.columns; j++) {
          if (this.shadowRoot.querySelector("#col" + j) !== undefined) {
            this.shadowRoot.querySelector("#col" + j).classList.add("hax-mover");
          }
        }
      }
      /**
       * Enter an element, meaning we've over it while dragging
       */

    }, {
      key: "dragEnter",
      value: function dragEnter(e) {
        if (this.editMode) {
          e.preventDefault();

          if (e.target && e.target.classList) {
            e.target.classList.add("hax-hovered");
          }
        }
      }
      /**
       * Leaving an element while dragging.
       */

    }, {
      key: "dragLeave",
      value: function dragLeave(e) {
        if (this.editMode && e.target && e.target.classList) {
          e.target.classList.remove("hax-hovered");
        }
      }
      /**
       * Sort children based on slot name
       */

    }, {
      key: "__sortChildren",
      value: function __sortChildren() {
        var _this5 = this;

        try {
          // select all direct children w/ a slot attribute and convert to an Array
          var children = Array.prototype.reduce.call(this.children, function (acc, e) {
            if (e.slot) {
              acc.push(e);
            }

            return acc;
          }, []); // sort the children by slot id being low to high

          children = children.sort(function (a, b) {
            if (parseInt(a.getAttribute("slot").split("-")[1]) < parseInt(b.getAttribute("slot").split("-")[1])) {
              return -1;
            }

            return 1;
          }); // loop through and append these back into the grid plate.
          // which will put them in the right order

          children.forEach(function (el) {
            // sanity check that we only move things that are a direct child
            if (el.parentNode === _this5) {
              _this5.appendChild(el);
            }
          });
        } catch (error) {
          console.warn(error);
        }
      }
      /**
       * Drop an item onto another
       */

    }, {
      key: "dropEvent",
      value: function dropEvent(e) {
        var _this6 = this;

        if (this.editMode) {
          var target = this.activeItem;

          if (this.__dragTarget) {
            target = this.__dragTarget;
          } // support global hax store target


          if (window.HaxStore && window.HaxStore.ready && window.HaxStore.instance.__dragTarget) {
            target = window.HaxStore.instance.__dragTarget;
            window.HaxStore.instance.__dragTarget = null;
          }

          setTimeout(function () {
            var children = _this6.querySelectorAll(".hax-mover, .hax-hovered, .hax-moving, .grid-plate-active-item"); // walk the children and apply the draggable state needed


            for (var i in children) {
              if (babelHelpers.typeof(children[i].classList) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                children[i].classList.remove("hax-mover", "hax-hovered", "hax-moving");
              }
            }

            for (var j = 1; j <= _this6.columns; j++) {
              if (_this6.shadowRoot.querySelector("#col" + j) !== undefined) {
                _this6.shadowRoot.querySelector("#col" + j).classList.remove("hax-mover", "hax-hovered", "hax-moving");
              }
            } // support hax and dropping back inside grid plate


            if (window.HaxStore && window.HaxStore.ready) {
              var childrenHAX = window.HaxStore.instance.activeHaxBody.children; // walk the children and apply the draggable state needed

              for (var i in childrenHAX) {
                if (childrenHAX[i].classList) {
                  childrenHAX[i].classList.remove("hax-mover", "hax-hovered", "hax-moving");
                }
              }
            } // sort the children by slot to ensure they are in the correct semantic order


            _this6.__sortChildren();
          }, 100); // edge case, something caused this to drag and it tried to do
          // itself into itself

          if (target === this) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            return false;
          }

          var local = e.target; // if we have a slot on what we dropped into then we need to mirror that item
          // and place ourselves below it in the DOM

          if (target && babelHelpers.typeof(local) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && local.getAttribute("slot") != null && local.parentNode && target !== local) {
            target.setAttribute("slot", local.getAttribute("slot"));
            local.parentNode.insertBefore(target, local); // ensure that if we caught this event we process it

            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
          } // special case for dropping on an empty column or between items
          // which could involve a miss on the column
          else if (target && local.tagName === "DIV" && local.classList.contains("column")) {
              var col = local.id.replace("col", "");
              target.setAttribute("slot", "col-" + col);
              this.appendChild(target); // ensure that if we caught this event we process it

              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
            }

          setTimeout(function () {
            // support for hax
            if (window.HaxStore && window.HaxStore.ready && window.HaxStore.instance) {
              if (target && target.parentNode && target.parentNode.tagName === "GRID-PLATE") {
                window.HaxStore.write("activeNode", target, _this6);
                window.HaxStore.write("activeContainerNode", target.parentNode, _this6);
                setTimeout(function () {
                  window.HaxStore.instance.activeHaxBody.positionContextMenus(target, target.parentNode);
                }, 10);
              }
            }

            _this6.positionArrows(null);

            _this6.activeItem = null;
          }, 0);
        }
      }
      /**
       * Start a drag event, this is an element being dragged
       */

    }, {
      key: "dragStart",
      value: function dragStart(e) {
        if (this.editMode) {
          if (window.HaxStore && window.HaxStore.ready) {
            var childrenHAX = window.HaxStore.instance.activeHaxBody.children; // walk the children and apply the draggable state needed

            for (var i in childrenHAX) {
              if (childrenHAX[i].classList) {
                childrenHAX[i].classList.add("hax-mover");
              }
            }

            window.HaxStore.instance.__dragTarget = this.activeItem;
          } else {
            this.__dragTarget = this.activeItem;
          }

          this.activeItem.classList.add("hax-moving");
          e.dataTransfer.dropEffect = "move";
          e.dataTransfer.setDragImage(this.activeItem, 0, 0);
          e.stopPropagation();
          e.stopImmediatePropagation();
          var children = this.children; // walk the children and apply the draggable state needed

          for (var i in children) {
            if (children[i].classList && children[i] !== this.activeItem) {
              children[i].classList.add("hax-mover");
            }
          }

          for (var j = 1; j <= this.columns; j++) {
            if (this.shadowRoot.querySelector("#col" + j) !== undefined) {
              this.shadowRoot.querySelector("#col" + j).classList.add("hax-mover");
            }
          }
        }
      }
      /**
       * When we end dragging ensure we remove the mover class.
       */

    }, {
      key: "dragEnd",
      value: function dragEnd(e) {
        var _this7 = this;

        if (this.editMode) {
          setTimeout(function () {
            var children = _this7.querySelectorAll(".hax-mover, .hax-hovered, .hax-moving, .grid-plate-active-item"); // walk the children and apply the draggable state needed


            for (var i in children) {
              if (babelHelpers.typeof(children[i].classList) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                children[i].classList.remove("hax-mover", "hax-hovered", "hax-moving");
              }
            }

            for (var i in _this7.children) {
              if (babelHelpers.typeof(_this7.children[i].classList) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                _this7.children[i].classList.remove("hax-mover", "hax-hovered", "hax-moving");
              }
            }

            for (var j = 1; j <= _this7.columns; j++) {
              if (_this7.shadowRoot.querySelector("#col" + j) !== undefined) {
                _this7.shadowRoot.querySelector("#col" + j).classList.remove("hax-mover", "hax-hovered", "hax-moving");
              }
            }
          }, 100);
        }
      }
      /**
       * Store updated, sync.
       */

    }, {
      key: "_haxStorePropertyUpdated",
      value: function _haxStorePropertyUpdated(e) {
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property) {
          if (babelHelpers.typeof(e.detail.value) === "object") {
            this[e.detail.property] = null;
          }

          if (e.detail.property === "editMode" && this.ignoreHax) {// do nothing, we were told to ignore hax
          } else {
            // if HAX modified our edit state then hide operations
            this.hideOps = true;
            this[e.detail.property] = e.detail.value;
          }
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "grid-plate";
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return {
          canScale: true,
          canPosition: true,
          canEditSource: false,
          gizmo: {
            title: "Grid layout",
            description: "Simple card in a cool retro design",
            icon: "hax:3/3/3/3",
            color: "grey",
            groups: ["Layout"],
            handles: [],
            meta: {
              author: "ELMS:LN",
              owner: "The Pennsylvania State University"
            }
          },
          settings: {
            quick: [],
            configure: [{
              property: "layout",
              title: "Column Layout",
              description: "Style to present these items (may change for small screens)",
              inputMethod: "select",
              options: new GridPlateLayoutOptions().options
            }, {
              property: "disableResponsive",
              title: "Disable responsive",
              description: "Check box to force layout to stick regardless of screen breakpoins",
              inputMethod: "boolean"
            }],
            advanced: [{
              property: "breakpointSm",
              title: "Small Breakpoint",
              description: "Anything less than this number (in pixels) will render with the smallest version of this layout",
              inputMethod: "textfield",
              validationType: "number"
            }, {
              property: "breakpointMd",
              title: "Medium Breakpoint",
              description: "Anything less than this number (in pixels) will render with the small version of this layout",
              inputMethod: "textfield",
              validationType: "number"
            }, {
              property: "breakpointLg",
              title: "Large Breakpoint",
              description: "Anything less than this number (in pixels) will render with the medium version of this layout.",
              inputMethod: "textfield",
              validationType: "number"
            }, {
              property: "breakpointXl",
              title: "Extra-Large Breakpoint",
              description: "Anything less than this number (in pixels) will render with the large version of this layout. Anything greater than or equal to this number will display with the maximum number of columns for this layout.",
              inputMethod: "textfield",
              validationType: "number"
            }]
          },
          saveOptions: {
            unsetAttributes: ["grid-plate-active-item", "edit-mode", "active-item", "layouts", "columns", "options", "droppable", "ignorehax", "hideops", "activeitem", "responsive-width", "hide-ops"]
          }
        };
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Flag to allow hiding button based operations
           */
          hideOps: {
            type: Boolean,
            attribute: "hide-ops"
          },

          /**
           * allows other systems to trigger editMode in grid plate via property for D&D
           */
          droppable: {
            type: Boolean,
            reflect: true
          },

          /**
           * Flag for when using grid-plate in a system WITH hax yet not wanting to
           * be activated (like a HAXcms / other CMS theme layer)
           */
          ignoreHax: {
            type: Boolean,
            attribute: "ignore-hax"
          },

          /**
           * Custom small breakpoint for the layouts; only updated on attached
           */
          breakpointSm: {
            type: Number,
            attribute: "breakpoint-sm"
          },

          /**
           * Custom medium breakpoint for the layouts; only updated on attached
           */
          breakpointMd: {
            type: Number,
            attribute: "breakpoint-md"
          },

          /**
           * Custom large breakpoint for the layouts; only updated on attached
           */
          breakpointLg: {
            type: Number,
            attribute: "breakpoint-lg"
          },

          /**
           * Custom extra-large breakpoint for the layouts; only updated on attached
           */
          breakpointXl: {
            type: Number,
            attribute: "breakpoint-xl"
          },

          /**
           * number of columns at this layout / responsive size
           */
          columns: {
            type: Number,
            reflect: true
          },

          /**
           * disables responsive layouts for HAX preview
           */
          disableResponsive: {
            type: Boolean,
            attribute: "disable-responsive"
          },

          /**
           * If the grid plate is in a state where its items
           * can be modified as far as order or column placement.
           */
          editMode: {
            reflect: true,
            type: Boolean,
            attribute: "edit-mode"
          },

          /**
           * an object with a layout's column sizes
           * at the current responsive width
           */
          layout: {
            type: String,
            reflect: true
          },

          /**
           * Predefined layouts of column sizes and various responsive widths. 
           * For example:```
          {
          "1-1-1-1": {                         //the name of the layout
          "xs": ["100%","100%","100%","100%] //the responsive width of each column when the grid is extra small
          "sm": ["50%","50%","50%","50%"]    //the responsive width of each column when the grid is small
          "md": ["50%","50%","50%","50%"]    //the responsive width of each column when the grid is medium
          "lg": ["25%","25%","25%","25%"]    //the responsive width of each column when the grid is large
          "xl": ["25%","25%","25%","25%"]    //the responsive width of each column when the grid is extra large
          },
          {...}
          }```
          */
          layouts: {
            type: Object
          },

          /**
           * Responsive size as `xs`, `sm`, `md`, `lg`, or `xl`
           */
          responsiveSize: {
            type: String,
            reflect: true,
            attribute: "responsive-size"
          },

          /**
           * Track active item
           */
          activeItem: {
            type: Object,
            attribute: "active-item"
          },

          /**
           * name of selected layout
           */
          __columnWidths: {
            type: String
          }
        };
      }
    }]);
    return GridPlate;
  }(_litElement.LitElement);

  _exports.GridPlate = GridPlate;
  window.customElements.define(GridPlate.tag, GridPlate);
});