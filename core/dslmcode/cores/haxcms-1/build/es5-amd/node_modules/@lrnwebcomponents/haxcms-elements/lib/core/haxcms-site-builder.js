define(["exports", "meta", "require", "../../../../lit-element/lit-element.js", "../../../../@polymer/polymer/lib/utils/settings.js", "../../../utils/utils.js", "../../../../mobx/lib/mobx.module.js", "./haxcms-site-store.js"], function (_exports, meta, _require, _litElement, _settings, _utils, _mobxModule, _haxcmsSiteStore) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSSiteBuilder = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject2_7518b920bc0e11eaacbc2d10f0d2494d() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n        }\n        :host #slot {\n          background-color: var(--haxcms-color, white);\n          opacity: 0.2;\n          visibility: hidden;\n        }\n        :host([dashboard-opened]) {\n          display: inline-block !important;\n          margin-left: 50vw;\n          height: 100vh;\n          pointer-events: none;\n          opacity: 0.5;\n          width: 100vw;\n        }\n        :host([theme-loaded]) #slot {\n          opacity: 1;\n          visibility: visible;\n        }\n        paper-progress {\n          display: block;\n          width: 100%;\n          position: fixed;\n          top: 0;\n          left: 0;\n          right: 0;\n          background-color: transparent;\n          z-index: 1000;\n          --paper-progress-active-color: var(\n            --haxcms-color,\n            rgba(255, 255, 255, 0.5)\n          );\n          --paper-progress-container-color: transparent;\n        }\n      "]);

    _templateObject2_7518b920bc0e11eaacbc2d10f0d2494d = function _templateObject2_7518b920bc0e11eaacbc2d10f0d2494d() {
      return data;
    };

    return data;
  }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject_7518b920bc0e11eaacbc2d10f0d2494d() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <haxcms-site-router base-uri=\"", "\"></haxcms-site-router>\n      <paper-progress .hidden=\"", "\" indeterminate></paper-progress>\n      <div id=\"slot\"><slot></slot></div>\n      <simple-colors-polymer></simple-colors-polymer>\n    "]);

    _templateObject_7518b920bc0e11eaacbc2d10f0d2494d = function _templateObject_7518b920bc0e11eaacbc2d10f0d2494d() {
      return data;
    };

    return data;
  }

  /**
   * `haxcms-site-builder`
   * `build the site and everything off of this`
   * @microcopy - the mental model for this element
   * - This is a factory element, it doesn't do much on its own visually
   * - it loads a site.json file and then utilizes this data in order to construct
   *   what theme it should load (element) in order to get everything off and running
   */
  var HAXCMSSiteBuilder =
  /*#__PURE__*/
  function (_LitElement) {
    babelHelpers.inherits(HAXCMSSiteBuilder, _LitElement);
    babelHelpers.createClass(HAXCMSSiteBuilder, [{
      key: "render",
      // render function
      value: function render() {
        return (0, _litElement.html)(_templateObject_7518b920bc0e11eaacbc2d10f0d2494d(), this.baseURI, !this.loading);
      }
      /**
       * Simple "two way" data binding from the element below via events
       */

    }, {
      key: "_updateManifest",
      value: function _updateManifest(data) {
        this.manifest = _objectSpread({}, data);
      }
    }, {
      key: "_updateLoading",
      value: function _updateLoading(e) {
        this.loading = e.detail.value;
      }
    }, {
      key: "_updateActiveItemContent",
      value: function _updateActiveItemContent(data) {
        this.activeItemContent = data;
      }
      /**
       * Load Page data
       */

    }, {
      key: "loadPageData",
      value: function () {
        var _loadPageData = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var _this2 = this;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!this.activeItemLocation) {
                    _context.next = 4;
                    break;
                  }

                  this.loading = true;
                  _context.next = 4;
                  return fetch("".concat(this.outlineLocation).concat(this.activeItemLocation).concat(this._timeStamp)).then(function (response) {
                    return response.text();
                  }).then(function (data) {
                    _this2._updateActiveItemContent(data);

                    _this2.loading = false;
                  }).catch(function (err) {
                    _this2.lastErrorChanged(err);
                  });

                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function loadPageData() {
          return _loadPageData.apply(this, arguments);
        }

        return loadPageData;
      }()
      /**
       * Load JSON Outline Schema / site.json format
       */

    }, {
      key: "loadJOSData",
      value: function () {
        var _loadJOSData = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2() {
          var _this3 = this;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!this.file) {
                    _context2.next = 4;
                    break;
                  }

                  this.loading = true;
                  _context2.next = 4;
                  return fetch("".concat(this.outlineLocation).concat(this.file).concat(this._timeStamp)).then(function (response) {
                    return response.json();
                  }).then(function (data) {
                    _this3._updateManifest(data);

                    _this3.loading = false;
                  }).catch(function (err) {
                    _this3.lastErrorChanged(err);
                  });

                case 4:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function loadJOSData() {
          return _loadJOSData.apply(this, arguments);
        }

        return loadJOSData;
      }()
      /**
       * life cycle updated
       */

    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this4 = this;

        changedProperties.forEach(function (oldValue, propName) {
          if (["outlineLocation", "activeItemLocation", "_timeStamp"].includes(propName)) {
            _this4.loadPageData();
          }

          if (["outlineLocation", "file", "_timeStamp"].includes(propName)) {
            _this4.loadJOSData();
          }

          if (propName == "dashboardOpened") {
            _this4._dashboardOpenedChanged(_this4[propName], oldValue);
          } else if (propName == "themeData") {
            _this4._themeChanged(_this4[propName], oldValue);
          } else if (propName == "themeName") {
            _this4._themeNameChanged(_this4[propName], oldValue);
          } else if (propName == "outlineLocation") {
            // fire an to match notify
            _this4.dispatchEvent(new CustomEvent("outline-location-changed", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: _this4[propName]
            }));
          } else if (propName == "manifest") {
            // fire an to match notify
            _this4.dispatchEvent(new CustomEvent("manifest-changed", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: _this4[propName]
            }));

            _this4._manifestChanged(_this4[propName], oldValue);
          } else if (propName == "activeItem") {
            // fire an to match notify
            _this4.dispatchEvent(new CustomEvent("active-item-changed", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: _this4[propName]
            }));

            _this4._activeItemChanged(_this4[propName], oldValue);
          } else if (propName == "activeItemContent") {
            // fire an to match notify
            _this4.dispatchEvent(new CustomEvent("active-item-content-changed", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: _this4[propName]
            }));

            _this4._activeItemContentChanged(_this4[propName], oldValue);
          }
        });
      }
    }, {
      key: "_themeNameChanged",
      value: function _themeNameChanged(newValue) {
        if (newValue) {
          // drop old theme element if there is one
          if (_haxcmsSiteStore.store.themeElement) {
            _haxcmsSiteStore.store.themeElement.remove();
          } // wipe out what we got


          (0, _utils.wipeSlot)(this, "*");
          _haxcmsSiteStore.store.themeElement = document.createElement(newValue);
          this.appendChild(_haxcmsSiteStore.store.themeElement);
        }
      }
      /**
       * Alert there was an internal error in getting the file
       */

    }, {
      key: "lastErrorChanged",
      value: function lastErrorChanged(e) {
        if (e) {
          console.error(e);
          var evt = new CustomEvent("simple-toast-show", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: {
              text: e.detail.value.status + " " + e.detail.value.statusText
            }
          });
          window.dispatchEvent(evt);
        }
      }
      /**
       * ready life cycle
       */

    }], [{
      key: "styles",
      get: function get() {
        return [(0, _litElement.css)(_templateObject2_7518b920bc0e11eaacbc2d10f0d2494d())];
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       */

    }, {
      key: "tag",
      get: function get() {
        return "haxcms-site-builder";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          activeItemLocation: {
            type: String,
            attribute: "active-item-location"
          },
          _timeStamp: {
            type: String
          },
          dashboardOpened: {
            type: Boolean,
            reflect: true,
            attribute: "dashboard-opened"
          },

          /**
           * queryParams
           */
          queryParams: {
            type: Object
          },

          /**
           * Loading status of the page to render.
           */
          loading: {
            type: Boolean,
            reflect: true
          },

          /**
           * support for alternate locations.
           */
          outlineLocation: {
            type: String,
            attribute: "outline-location"
          },

          /**
           * Manifest from file
           */
          manifest: {
            type: Object
          },

          /**
           * Theme, used to boot a design element
           */
          themeData: {
            type: Object
          },

          /**
           * Theme name, which we then use to setup the theme
           */
          themeName: {
            type: String
          },

          /**
           * Imported items so we can allow theme flipping dynamically
           */
          __imported: {
            type: Object
          },

          /**
           * theme loaded to indicate to the theme we have a theme ready to go
           */
          themeLoaded: {
            type: Boolean,
            reflect: true,
            attribute: "theme-loaded"
          },

          /**
           * Active item which is in JSON Outline Schema
           */
          activeItem: {
            type: Object
          },

          /**
           * Active item content
           */
          activeItemContent: {
            type: String
          },

          /**
           * Location of the site.json file
           */
          file: {
            type: String
          },

          /**
           * Injected by HAXcms
           */
          baseURI: {
            type: String,
            attribute: "base-uri"
          }
        };
      }
    }]);

    function HAXCMSSiteBuilder() {
      var _this;

      babelHelpers.classCallCheck(this, HAXCMSSiteBuilder);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HAXCMSSiteBuilder).call(this)); // attempt to set polymer passive gestures globally
      // this decreases logging and improves performance on scrolling

      (0, _settings.setPassiveTouchGestures)(true);
      _this.__disposer = [];
      _this.queryParams = {};
      _this.loading = false;
      _this.__imported = {};
      _this.themeLoaded = false;
      _this._timeStamp = "";
      _this.outlineLocation = "";
      _this.activeItemLocation = "";
      new Promise(function (res, rej) {
        return _require.default(["./haxcms-site-router.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../../@polymer/paper-progress/paper-progress.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../simple-toast/simple-toast.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../simple-colors/lib/simple-colors-polymer.js"], res, rej);
      });
      setTimeout(function () {
        window.addEventListener("hax-store-ready", _this.storeReady.bind(babelHelpers.assertThisInitialized(_this)));
        window.addEventListener("haxcms-trigger-update", _this._triggerUpdatedData.bind(babelHelpers.assertThisInitialized(_this)));
        window.addEventListener("haxcms-trigger-update-node", _this._triggerUpdatedNode.bind(babelHelpers.assertThisInitialized(_this)));
        (0, _mobxModule.autorun)(function (reaction) {
          _this.dashboardOpened = (0, _mobxModule.toJS)(_haxcmsSiteStore.store.dashboardOpened);

          _this.__disposer.push(reaction);
        });
        (0, _mobxModule.autorun)(function (reaction) {
          _this.themeData = (0, _mobxModule.toJS)(_haxcmsSiteStore.store.themeData);

          if (_this.themeData && _this.themeData.element !== _this.themeName) {
            _this.themeName = _this.themeData.element;
          }

          _this.__disposer.push(reaction);
        });
        (0, _mobxModule.autorun)(function (reaction) {
          _this.activeItem = (0, _mobxModule.toJS)(_haxcmsSiteStore.store.activeItem);

          if (_this.activeItem && _this.activeItem.location) {
            _this.activeItemLocation = _this.activeItem.location;
          }

          _this.__disposer.push(reaction);
        });
      }, 0);
      return _this;
    }

    babelHelpers.createClass(HAXCMSSiteBuilder, [{
      key: "_dashboardOpenedChanged",
      value: function _dashboardOpenedChanged(newValue, oldValue) {
        if (newValue) {
          this.setAttribute("aria-hidden", "aria-hidden");
          this.setAttribute("tabindex", "-1");
        } else if (!newValue && oldValue) {
          this.removeAttribute("aria-hidden");
          this.removeAttribute("tabindex");
        }
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this5 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSSiteBuilder.prototype), "connectedCallback", this).call(this);
        this.dispatchEvent(new CustomEvent("haxcms-ready", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: this
        })); // dyanmcially import the editor builder which figures out if we should have one

        new Promise(function (res, rej) {
          return _require.default(["./haxcms-editor-builder.js"], res, rej);
        }).then(function (response) {
          _this5.editorBuilder = document.createElement("haxcms-editor-builder"); // attach editor builder after we've appended to the screen

          document.body.appendChild(_this5.editorBuilder); // get fresh data if not published / demo which is a form of published

          if (_this5.editorBuilder.getContext() !== "published" && _this5.editorBuilder.getContext() !== "demo") {
            _this5._timeStamp = "?" + Math.floor(Date.now() / 1000);
          }
        }).catch(function (error) {
          /* Error handling */
          console.log(error);
        });
        var evt = document.createEvent("UIEvents");
        evt.initUIEvent("resize", true, false, window, 0);
        window.dispatchEvent(evt);
      }
      /**
       * Detached life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        for (var i in this.__disposer) {
          this.__disposer[i].dispose();
        }

        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSSiteBuilder.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "storeReady",
      value: function storeReady(e) {
        // append UI element to body to avoid stack order issues
        if (_haxcmsSiteStore.store.cmsSiteEditor && _haxcmsSiteStore.store.cmsSiteEditor.instance && window.HaxStore.instance.activeHaxBody && _haxcmsSiteStore.store.activeItemContent) {
          window.HaxStore.instance.activeHaxBody.importContent(_haxcmsSiteStore.store.activeItemContent);
        }
      }
      /**
       * React to content being loaded from a page.
       */

    }, {
      key: "_activeItemContentChanged",
      value: function _activeItemContentChanged(newValue, oldValue) {
        var _this6 = this;

        if (newValue) {
          var html = newValue; // only append if not empty

          if (html !== null) {
            (0, _utils.wipeSlot)(_haxcmsSiteStore.store.themeElement, "*");
            html = (0, _utils.encapScript)(newValue); // set in the store

            _haxcmsSiteStore.store.activeItemContent = html; // insert the content as quickly as possible, then work on the dynamic imports

            setTimeout(function () {
              if (_haxcmsSiteStore.store.themeElement.childNodes.length === 0) {
                var frag = document.createRange().createContextualFragment(html);

                _haxcmsSiteStore.store.themeElement.appendChild(frag);

                _this6.dispatchEvent(new CustomEvent("json-outline-schema-active-body-changed", {
                  bubbles: true,
                  composed: true,
                  cancelable: false,
                  detail: html
                }));
              } // if there are, dynamically import them but only if we don't have a global manager


              if (!window.WCAutoload && (0, _utils.varExists)(_this6.manifest, "metadata.node.dynamicElementLoader")) {
                var i;

                (function () {
                  var tagsFound = (0, _utils.findTagsInHTML)(html);

                  var basePath = _this6.pathFromUrl(decodeURIComponent(meta.url));

                  var _loop = function _loop() {
                    var tagName = tagsFound[i];

                    if (_this6.manifest.metadata.node.dynamicElementLoader[tagName] && !window.customElements.get(tagName)) {
                      new Promise(function (res, rej) {
                        return _require.default(["".concat(basePath, "../../../../").concat(_this6.manifest.metadata.node.dynamicElementLoader[tagName])], res, rej);
                      }).then(function (response) {//console.log(tagName + ' dynamic import');
                      }).catch(function (error) {
                        /* Error handling */
                        console.log(error);
                      });
                    }
                  };

                  for (i in tagsFound) {
                    _loop();
                  }
                })();
              } else if (window.WCAutoload) {
                setTimeout(function () {
                  window.WCAutoload.process();
                }, 0);
              }
            }, 5);
          }
        }
      }
      /**
       * Active item updated, let's request the content from it
       */

    }, {
      key: "_activeItemChanged",
      value: function _activeItemChanged(newValue, oldValue) {
        if (this.shadowRoot && newValue && babelHelpers.typeof(newValue.id) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.queryParams.nodeId = newValue.id; // if published, keep it static on request
          // @todo might revisit this in the future

          if (this.editorBuilder && this.editorBuilder.getContext() === "published") {
            this._timeStamp = "";
          } else {
            this._timeStamp = "?" + Math.floor(Date.now() / 1000);
          }
        } // we had something, now we don't. wipe out the content area of the theme
        else if (oldValue && !newValue) {
            // fire event w/ nothing, this is because there is no content
            this.dispatchEvent(new CustomEvent("json-outline-schema-active-body-changed", {
              bubbles: true,
              composed: true,
              cancelable: false,
              detail: null
            }));
          }
      }
      /**
       * got a message that we need to update our json manifest data
       */

    }, {
      key: "_triggerUpdatedData",
      value: function _triggerUpdatedData(e) {
        // get fresh data if not published
        if (this.editorBuilder && this.editorBuilder.getContext() !== "published") {
          this._timeStamp = "?" + Math.floor(Date.now() / 1000);
        }
      }
      /**
       * got a message that we need to update our page content
       */

    }, {
      key: "_triggerUpdatedNode",
      value: function _triggerUpdatedNode(e) {
        // get fresh data if not published
        if (this.editorBuilder && this.editorBuilder.getContext() !== "published" && this.editorBuilder.getContext() !== "demo") {
          this._timeStamp = "?" + Math.floor(Date.now() / 1000);
        } // ensure we don't get a miss on initial load


        if (this.activeItem.location) {
          this.loadPageData();
        }
      }
      /**
       * notice manifest changes and ensure slot is rebuilt.
       */

    }, {
      key: "_manifestChanged",
      value: function _manifestChanged(newValue, oldValue) {
        if (newValue && newValue.metadata && newValue.items) {
          _haxcmsSiteStore.store.loadManifest(newValue, this);
        }
      } // simple path from a url modifier

    }, {
      key: "pathFromUrl",
      value: function pathFromUrl(url) {
        return url.substring(0, url.lastIndexOf("/") + 1);
      }
      /**
       * notice theme changes and ensure slot is rebuilt.
       */

    }, {
      key: "_themeChanged",
      value: function _themeChanged(newValue, oldValue) {
        var _this7 = this;

        if (newValue) {
          this.themeLoaded = false;
          var theme = newValue; // create the 'theme' as a new element
          // weird but definition already here so we should be able
          // to just use this without an import, it's possible..

          if (babelHelpers.typeof(this.__imported[theme.element]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            this.themeLoaded = true;
          } else {
            // global will handle this
            if (window.WCAutoload) {
              this.__imported[theme.element] = theme.element;
              this.themeLoaded = true;
              setTimeout(function () {
                window.WCAutoload.process();
              }, 5);
            } else {
              // import the reference to the item dynamically, if we can
              try {
                new Promise(function (res, rej) {
                  return _require.default([_this7.pathFromUrl(decodeURIComponent(meta.url)) + "../../../../" + newValue.path], res, rej);
                }).then(function (e) {
                  // add it into ourselves so it unpacks and we kick this off!
                  _this7.__imported[theme.element] = theme.element;
                  _this7.themeLoaded = true;
                });
              } catch (err) {
                // error in the event this is a double registration
                // also strange to be able to reach this but technically possible
                this.themeLoaded = true;
              }
            }
          }
        }
      }
    }]);
    return HAXCMSSiteBuilder;
  }(_litElement.LitElement); // this global allows a backdoor into activating the HAXcms editor UI
  // this is only going to be visually enabled but it won't actually
  // be able to talk to the backend correctly bc the JWT won't exist
  // the endpoints are also fictional. also useful for testing purposes


  _exports.HAXCMSSiteBuilder = HAXCMSSiteBuilder;

  window.HAXme = function () {
    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    if (context == null) {
      // fake a demo
      context = "demo"; // fake endpoints

      window.appSettings = {
        login: "dist/dev/login.json",
        logout: "dist/dev/logout.json",
        saveNodePath: "dist/dev/saveNode.json",
        saveManifestPath: "dist/dev/saveManifestPath.json",
        createNodePath: "dist/dev/saveNode.json",
        deleteNodePath: "dist/dev/saveNode.json",
        saveOutlinePath: "dist/dev/saveNode.json",
        publishSitePath: "dist/dev/saveNode.json",
        syncSitePath: "dist/dev/saveNode.json",
        getNodeFieldsPath: "dist/dev/getNodeFieldsPath.json",
        getSiteFieldsPath: "dist/dev/getSiteFieldsPath.json",
        revertSitePath: "dist/dev/saveNode.json",
        getFormToken: "adskjadshjudfu823u823u8fu8fij",
        appStore: {
          url: "dist/dev/appstore.json"
        },
        // add your custom theme here if testing locally and wanting to emulate the theme selector
        // this isn't really nessecary though
        themes: {
          "haxcms-dev-theme": {
            element: "haxcms-dev-theme",
            path: "@lrnwebcomponents/haxcms-elements/lib/haxcms-dev-theme.js",
            name: "Developer theme"
          }
        }
      };
    }

    if (context == "demo") {
      window.__haxCMSContextDemo = true;
    } // apply context


    if (document.body) {
      document.body.getElementsByTagName("haxcms-editor-builder")[0].__appliedContext = false;
      document.body.getElementsByTagName("haxcms-editor-builder")[0].applyContext(context);
    }
  };

  window.customElements.define(HAXCMSSiteBuilder.tag, HAXCMSSiteBuilder);
});