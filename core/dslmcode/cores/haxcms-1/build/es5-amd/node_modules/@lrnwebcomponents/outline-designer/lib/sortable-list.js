define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/mixins/gesture-event-listeners.js", "../../../@polymer/polymer/lib/utils/async.js", "../../../@polymer/polymer/lib/utils/gestures.js"], function (_exports, _polymerElement, _gestureEventListeners, async, Gestures) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SortableList = void 0;
  async = _interopRequireWildcard(async);
  Gestures = _interopRequireWildcard(Gestures);

  var _templateObject_a70b6af04fbd11edb93baf2315d3222f;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `outline-designer`
   * @element outline-designer
   * `tools to modify and visualize JSON Outline Schema for editing`
   *
   * @microcopy - language worth noting:
   *
  
   * @polymer
   * @demo demo/index.html
   */
  var SortableList = /*#__PURE__*/function (_GestureEventListener) {
    babelHelpers.inherits(SortableList, _GestureEventListener);

    var _super = _createSuper(SortableList);

    function SortableList() {
      var _this;

      babelHelpers.classCallCheck(this, SortableList);
      _this = _super.call(this);
      _this._observer = null;
      _this._target = null;
      _this._targetRect = null;
      _this._rects = null;
      _this._onTrack = _this._onTrack.bind(babelHelpers.assertThisInitialized(_this));
      _this._onDragStart = _this._onDragStart.bind(babelHelpers.assertThisInitialized(_this));
      _this._onTransitionEnd = _this._onTransitionEnd.bind(babelHelpers.assertThisInitialized(_this));
      _this._onContextMenu = _this._onContextMenu.bind(babelHelpers.assertThisInitialized(_this));
      _this._onTouchMove = _this._onTouchMove.bind(babelHelpers.assertThisInitialized(_this));
      return _this;
    }

    babelHelpers.createClass(SortableList, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(SortableList.prototype), "connectedCallback", this).call(this);

        this._observeItems();

        this._updateItems();

        this._toggleListeners({
          enable: true
        });
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(SortableList.prototype), "disconnectedCallback", this).call(this);

        this._unobserveItems();

        this._toggleListeners({
          enable: false
        });
      }
    }, {
      key: "_toggleListeners",
      value: function _toggleListeners(_ref) {
        var enable = _ref.enable;
        var m = enable ? "addEventListener" : "removeEventListener";
        this.shadowRoot.querySelector("#items")[m]("dragstart", this._onDragStart);
        this.shadowRoot.querySelector("#items")[m]("transitionend", this._onTransitionEnd);
        this.shadowRoot.querySelector("#items")[m]("contextmenu", this._onContextMenu);
        this.shadowRoot.querySelector("#items")[m]("touchmove", this._onTouchMove);

        if (enable) {
          Gestures.addListener(this, "track", this._onTrack);
        } else {
          Gestures.removeListener(this, "track", this._onTrack);
        }
      }
    }, {
      key: "_onTrack",
      value: function _onTrack(event) {
        switch (event.detail.state) {
          case "start":
            this._trackStart(event);

            break;

          case "track":
            this._track(event);

            break;

          case "end":
            this._trackEnd(event);

            break;
        }
      }
    }, {
      key: "_trackStart",
      value: function _trackStart(event) {
        var _this2 = this;

        if (this.disabled) {
          return;
        }

        this._target = this._itemFromEvent(event);

        if (!this._target) {
          return;
        }

        event.stopPropagation();
        this._rects = this._getItemsRects();
        this._targetRect = this._rects[this.items.indexOf(this._target)];

        this._target.classList.add("item--dragged", "item--pressed");

        if ("vibrate" in navigator) {
          navigator.vibrate(30);
        }

        var rect = this.getBoundingClientRect();
        this.style.height = rect.height + "px";
        this.style.width = rect.width + "px";
        this.items.forEach(function (item, idx) {
          var rect = _this2._rects[idx];
          item.classList.add("item--transform");
          item.style.transition = "none";
          item.__originalWidth = item.style.width;
          item.__originalHeight = item.style.height;
          item.style.width = rect.width + "px";
          item.style.height = rect.height + "px";

          _this2._translate3d(rect.left, rect.top, 1, item);

          setTimeout(function (_) {
            item.style.transition = null;
          }, 20);
        });

        this._setDragging(true);
      }
    }, {
      key: "_track",
      value: function _track(event) {
        var _this3 = this;

        if (!this.dragging) {
          return;
        }

        var left = this._targetRect.left + event.detail.dx;
        var top = this._targetRect.top + event.detail.dy;

        this._translate3d(left, top, 1, this._target);

        var overItem = this._itemFromCoords(event.detail);

        if (overItem && overItem !== this._target) {
          var overItemIndex = this.items.indexOf(overItem);
          var targetIndex = this.items.indexOf(this._target);

          this._moveItemArray(this.items, targetIndex, overItemIndex);

          var _loop = function _loop(i) {
            if (_this3.items[i] !== _this3._target) {
              var rect = _this3._rects[i];
              requestAnimationFrame(function (_) {
                _this3._translate3d(rect.left, rect.top, 1, _this3.items[i]);
              });
            }
          };

          for (var i = 0; i < this.items.length; i++) {
            _loop(i);
          }
        }
      } // The track really ends

    }, {
      key: "_trackEnd",
      value: function _trackEnd(event) {
        if (!this.dragging) {
          return;
        }

        var rect = this._rects[this.items.indexOf(this._target)];

        this._target.classList.remove("item--pressed");

        this._setDragging(false);

        this._translate3d(rect.left, rect.top, 1, this._target);
      }
    }, {
      key: "_onTransitionEnd",
      value: function _onTransitionEnd() {
        if (this.dragging || !this._target) {
          return;
        }

        var fragment = document.createDocumentFragment();
        this.items.forEach(function (item) {
          item.style.transform = "";
          item.style.width = item.__originalWidth;
          item.style.height = item.__originalHeight;
          item.classList.remove("item--transform");
          fragment.appendChild(item);
        });

        if (this.children[0]) {
          this.insertBefore(fragment, this.children[0]);
        } else {
          this.appendChild(fragment);
        }

        this.style.height = "";

        this._target.classList.remove("item--dragged");

        this._rects = null;
        this._targetRect = null;

        this._updateItems();

        this.dispatchEvent(new CustomEvent("sort-finish", {
          composed: true,
          detail: {
            target: this._target
          }
        }));
        this._target = null;
      }
    }, {
      key: "_onDragStart",
      value: function _onDragStart(event) {
        event.preventDefault();
      }
    }, {
      key: "_onContextMenu",
      value: function _onContextMenu(event) {
        if (this.dragging) {
          event.preventDefault();

          this._trackEnd();
        }
      }
    }, {
      key: "_onTouchMove",
      value: function _onTouchMove(event) {
        event.preventDefault();
      }
    }, {
      key: "_updateItems",
      value: function _updateItems() {
        var _this4 = this;

        if (this.dragging) {
          return;
        }

        var items = this.shadowRoot.querySelector("#slot").assignedNodes().filter(function (node) {
          if (node.nodeType === Node.ELEMENT_NODE && (!_this4.sortable || node.matches(_this4.sortable))) {
            return true;
          }
        });

        this._setItems(items);
      }
    }, {
      key: "_itemFromCoords",
      value: function _itemFromCoords(_ref2) {
        var _this5 = this;

        var x = _ref2.x,
            y = _ref2.y;

        if (!this._rects) {
          return;
        }

        var match = null;

        this._rects.forEach(function (rect, i) {
          if (x >= rect.left && x <= rect.left + rect.width && y >= rect.top && y <= rect.top + rect.height) {
            match = _this5.items[i];
          }
        });

        return match;
      }
    }, {
      key: "_itemFromEvent",
      value: function _itemFromEvent(event) {
        var path = event.composedPath();

        for (var i = 0; i < path.length; i++) {
          if (this.items.indexOf(path[i]) > -1) {
            return path[i];
          }
        }
      }
    }, {
      key: "_getItemsRects",
      value: function _getItemsRects() {
        return this.items.map(function (item) {
          return item.getBoundingClientRect();
        });
      }
    }, {
      key: "_observeItems",
      value: function _observeItems() {
        var _this6 = this;

        if (!this._observer) {
          this._observer = new MutationObserver(function (_) {
            _this6._updateItems();
          });

          this._observer.observe(this, {
            childList: true
          });
        }
      }
    }, {
      key: "_unobserveItems",
      value: function _unobserveItems() {
        if (this._observer) {
          this._observer.disconnect();

          this._observer = null;
        }
      }
      /**
       * Move an array item from one position to another.
       * Source: http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
       */

    }, {
      key: "_moveItemArray",
      value: function _moveItemArray(array, oldIndex, newIndex) {
        if (newIndex >= array.length) {
          var k = newIndex - array.length;

          while (k-- + 1) {
            array.push(undefined);
          }
        }

        array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
        return array;
      }
    }, {
      key: "_translate3d",
      value: function _translate3d(x, y, z, el) {
        el.style.transform = "translate3d(".concat(x, "px, ").concat(y, "px, ").concat(z, "px)");
      }
    }], [{
      key: "template",
      get: // render function
      function get() {
        return (0, _polymerElement.html)(_templateObject_a70b6af04fbd11edb93baf2315d3222f || (_templateObject_a70b6af04fbd11edb93baf2315d3222f = babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          display: flex;\n        }\n        #items ::slotted(*) {\n          user-drag: none;\n          user-select: none;\n          -moz-user-select: none;\n          -ms-user-select: none;\n          -webkit-user-drag: none;\n          -webkit-user-select: none;\n          -webkit-tap-highlight-color: rgba(255, 255, 255, 0);\n        }\n        #items ::slotted(.item--transform) {\n          left: 0;\n          margin: 0 !important;\n          position: fixed !important;\n          top: 0;\n          transition: transform 0.2s cubic-bezier(0.333, 0, 0, 1);\n          will-change: transform;\n          z-index: 1;\n        }\n        #items ::slotted(.item--pressed) {\n          transition: none !important;\n        }\n        #items ::slotted(.item--dragged) {\n          -webkit-box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n          filter: brightness(1.1);\n          z-index: 2;\n        }\n      </style>\n      <div id=\"items\"><slot id=\"slot\"></slot></div>\n    "])));
      }
    }, {
      key: "is",
      get: function get() {
        return "sortable-list";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * This is a CSS selector string. If this is set, only items that
           * match the CSS selector are sortable.
           */
          sortable: String,

          /**
           * The list of sortable items.
           */
          items: {
            type: Array,
            notify: true,
            readOnly: true
          },

          /**
           * Returns true when an item is being drag.
           */
          dragging: {
            type: Boolean,
            notify: true,
            readOnly: true,
            reflectToAttribute: true,
            value: false
          },

          /**
           * Disables the draggable if set to true.
           */
          disabled: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          }
        };
      }
    }]);
    return SortableList;
  }((0, _gestureEventListeners.GestureEventListeners)(_polymerElement.PolymerElement));

  _exports.SortableList = SortableList;
  window.customElements.define("sortable-list", SortableList);
});