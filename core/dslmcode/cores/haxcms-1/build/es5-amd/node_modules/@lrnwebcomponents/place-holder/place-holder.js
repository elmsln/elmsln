define(["exports", "../simple-colors/simple-colors.js", "../../lit/index.js", "../simple-icon/simple-icon.js", "../simple-icon/lib/simple-icons.js"], function (_exports, _simpleColors, _index, _simpleIcon, _simpleIcons) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PlaceHolder = void 0;

  var _templateObject_20fdf640942811ecb1937969798b231a, _templateObject2_20fdf640942811ecb1937969798b231a;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `place-holder`
   * @element place-holder
   * Placeholder for a piece of media in the future
   *
   * @demo demo/index.html
   *
   * @microcopy - the mental model for this element
   * - placeholder is a grey block on the page which can respond to drag and drop
   */
  var PlaceHolder = /*#__PURE__*/function (_SimpleColors) {
    babelHelpers.inherits(PlaceHolder, _SimpleColors);

    var _super = _createSuper(PlaceHolder);

    /**
     * HTMLElement
     */
    function PlaceHolder() {
      var _this;

      babelHelpers.classCallCheck(this, PlaceHolder);
      _this = _super.call(this);
      _this.text = "";
      _this.type = "text";
      _this.dragOver = false;
      _this.directions = "Double click or drag and drop file to replace";

      _this.addEventListener("dragover", function (e) {
        this.dragOver = true;
        e.preventDefault();
        e.stopPropagation();
        this.classList.add("dragover");
      });

      _this.addEventListener("dragleave", function (e) {
        this.dragOver = false;
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove("dragover");
      }); // self bind a drop event enough though something else
      // will need to step in and do something with this.
      // We are just making sure that this doesn't redirect the browser.


      _this.addEventListener("drop", function (e) {
        this.dragOver = false;
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        this.classList.remove("dragover"); // this helps ensure that what gets drag and dropped is a file
        // this prevents issues with selecting and dragging text (which triggers drag/drop)
        // as well as compatibility with things that are legit in a draggable state

        try {
          if (e.dataTransfer.items[0].kind === "file") {
            e.placeHolderElement = this; // fire this specialized event up so things like HAX can intercept

            this.dispatchEvent(new CustomEvent("place-holder-file-drop", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: e
            }));
          }
        } catch (e) {}
      });

      _this.addEventListener("dblclick", _this.fireReplaceEvent.bind(babelHelpers.assertThisInitialized(_this)));

      return _this;
    }
    /**
     * HAX
     */


    babelHelpers.createClass(PlaceHolder, [{
      key: "render",
      value:
      /**
       * LitElement render
       */
      function render() {
        return (0, _index.html)(_templateObject_20fdf640942811ecb1937969798b231a || (_templateObject_20fdf640942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n      <div class=\"wrapper\">\n        <simple-icon\n          ?dark=\"", "\"\n          icon=\"", "\"\n          accent-color=\"", "\"\n        ></simple-icon>\n        <div class=\"text\">", "</div>\n        <div class=\"directions\">", "</div>\n      </div>\n    "])), this.dark, this.iconFromType, this.accentColor, this.calcText, this.directions);
      }
    }, {
      key: "updated",
      value:
      /**
       * LitElement properties changed
       */
      function updated(changedProperties) {
        var _this2 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(PlaceHolder.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(PlaceHolder.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (["type"].includes(propName)) {
            _this2.accentColor = _this2._getColorFromType(_this2.type);
          }

          if (["type", "dragOver"].includes(propName)) {
            _this2.iconFromType = _this2._getIconFromType(_this2.type, _this2.dragOver);
          }

          if (["text", "type", "dragOver"].includes(propName)) {
            _this2.calcText = _this2._getCalcText(_this2.text, _this2.type, _this2.dragOver);
          }
        });
      }
      /**
       * Fire an event for things to react to above us
       */

    }, {
      key: "fireReplaceEvent",
      value: function fireReplaceEvent(e) {
        this.dispatchEvent(new CustomEvent("place-holder-replace", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: this.type
        }));
      }
      /**
       * Get the calculated text based on text being empty and type being set.
       */

    }, {
      key: "_getCalcText",
      value: function _getCalcText(text, type, dragOver) {
        if (dragOver) {
          return "Drop file to upload";
        } else if (text === "") {
          return "Placeholder for " + type;
        } else {
          return text;
        }
      }
      /**
       * Generate an color based on the media type selected
       */

    }, {
      key: "_getColorFromType",
      value: function _getColorFromType(type) {
        switch (type) {
          case "document":
            return "green";
            break;

          case "audio":
            return "purple";
            break;

          case "video":
            return "red";
            break;

          case "image":
            return "orange";
            break;

          case "math":
            return "light-blue";
            break;
        }

        return "indigo";
      }
      /**
       * Generate an icon based on the media type selected
       */

    }, {
      key: "_getIconFromType",
      value: function _getIconFromType(type, dragOver) {
        if (!dragOver) {
          switch (type) {
            case "document":
              return "editor:insert-drive-file";
              break;

            case "audio":
              return "av:music-video";
              break;

            case "video":
              return "notification:ondemand-video";
              break;

            case "image":
              return "image:crop-original";
              break;

            case "math":
              return "editor:functions";
              break;

            case "text":
            default:
              return "editor:format-align-left";
              break;
          }
        } else {
          // we are dragging, ignore icon
          return "icons:file-upload";
        }
      }
    }], [{
      key: "styles",
      get:
      /**
       * LitElement render styles
       */
      function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(PlaceHolder), "styles", this)), [(0, _index.css)(_templateObject2_20fdf640942811ecb1937969798b231a || (_templateObject2_20fdf640942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          border: none;\n          transition: 0.2s all linear;\n        }\n        :host([drag-over]) {\n          border: var(--place-holder-drag-over-border, 4px dashed #2196f3);\n        }\n        .wrapper {\n          text-align: center;\n          padding: 16px;\n          color: var(--simple-colors-default-theme-accent-12, #222222);\n          background-color: var(\n            --simple-colors-default-theme-accent-1,\n            #eeeeee\n          );\n        }\n        simple-icon {\n          margin: 0 auto;\n          --simple-icon-width: 50%;\n          --simple-icon-height: 50%;\n          display: block;\n        }\n        .text {\n          line-height: 24px;\n          font-size: 24px;\n        }\n        .directions {\n          line-height: 16px;\n          font-size: 16px;\n          font-style: italic;\n        }\n      "])))]);
      }
    }, {
      key: "tag",
      get: function get() {
        return "place-holder";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(PlaceHolder), "properties", this)), {}, {
          /**
           * calculate an icon based on the type that was used
           */
          iconFromType: {
            type: String
          },

          /**
           * Text place holder for describing this place holder element.
           */
          text: {
            type: String
          },
          directions: {
            type: String
          },

          /**
           * Calculate text based on the type in the event we have no default.
           */
          calcText: {
            type: String
          },

          /**
           * A media type to visualize and also bubble events off of.
           */
          type: {
            type: String
          },

          /**
           * Bind dragging state to a variable so we can apply CSS.
           */
          dragOver: {
            type: Boolean,
            reflect: true,
            attribute: "drag-over"
          }
        });
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return {
          canScale: true,
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Placeholder",
            description: "A place holder that can be converted into the media type that's been selected",
            icon: "hax:placeholder-image",
            color: "grey",
            groups: ["Placeholder", "Content"],
            handles: [],
            meta: {
              author: "ELMS:LN"
            }
          },
          settings: {
            configure: [{
              property: "type",
              title: "Type",
              description: "Type of gizmo that this accepts for replacement.",
              inputMethod: "select",
              options: {
                text: "Text / content",
                document: "Document / file",
                audio: "Audio",
                video: "Video",
                image: "Image",
                math: "Math"
              }
            }, {
              property: "text",
              title: "Text",
              description: "Identify the place holder desired in greater detail",
              inputMethod: "textfield"
            }, {
              property: "accentColor",
              title: "Accent color",
              description: "Useful if used for communicating with team members",
              inputMethod: "colorpicker"
            }, {
              property: "dark",
              title: "Invert colors",
              description: "Useful if used for communicating with team members",
              inputMethod: "boolean"
            }],
            advanced: []
          },
          saveOptions: {
            unsetAttributes: ["icon-from-type", "calc-text", "colors"],
            wipeSlot: true
          }
        };
      }
    }]);
    return PlaceHolder;
  }(_simpleColors.SimpleColors);

  _exports.PlaceHolder = PlaceHolder;
  window.customElements.define(PlaceHolder.tag, PlaceHolder);
});