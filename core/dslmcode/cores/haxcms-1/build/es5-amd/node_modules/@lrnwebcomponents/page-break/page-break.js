define(["exports", "meta", "../../lit/index.js", "../schema-behaviors/schema-behaviors.js", "../intersection-element/lib/IntersectionObserverMixin.js", "../i18n-manager/lib/I18NMixin.js", "../simple-icon/lib/simple-icon-button-lite.js", "../simple-icon/lib/simple-icons.js", "../simple-icon/lib/simple-iconset.js", "./lib/page-break-manager.js"], function (_exports, meta, _index, _schemaBehaviors, _IntersectionObserverMixin, _I18NMixin, _simpleIconButtonLite, _simpleIcons, _simpleIconset, _pageBreakManager) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PageBreak = void 0;
  meta = _interopRequireWildcard(meta);

  var _templateObject_6f4a1520809211edaa2833647dc78c6c, _templateObject2_6f4a1520809211edaa2833647dc78c6c, _templateObject3_6f4a1520809211edaa2833647dc78c6c;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && babelHelpers.instanceof(outerFn.prototype, Generator) ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == babelHelpers.typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `page-break`
   * `a visual break but also helps manage hierarchy`
   *
   * @demo demo/index.html
   * @element page-break
   */
  var PageBreak = /*#__PURE__*/function (_IntersectionObserver) {
    babelHelpers.inherits(PageBreak, _IntersectionObserver);

    var _super = _createSuper(PageBreak);

    function PageBreak() {
      var _this;

      babelHelpers.classCallCheck(this, PageBreak);
      _this = _super.call(this);
      _this.status = "";
      _this.t = {
        newPage: "New page",
        pageBreak: "Page break",
        pageDetails: "Page details",
        clickToUnlock: "Click to unlock",
        noParent: "No parent",
        toggleLock: "Toggle lock",
        togglePublished: "Toggle published"
      };

      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        localesPath: new URL("./locales", meta.url).href,
        locales: ["es"]
      });

      _this.title = _this.t.newPage;
      _this.slug = "";
      _this.published = false;
      _this.target = null;
      _this.locked = false;
      _this.order = null;
      _this.depth = 0;
      _this.itemId = null;
      _this._haxState = false;
      _this.IORemoveOnVisible = false;
      _this.IODelay = 250;
      _this.remoteHeadingobserver = new MutationObserver(function () {
        // lock ensures that title update, then updating hte innerText
        // doesn't generate another mutation record
        if (_this.title != _this.target.innerText) {
          _this.__moUpdate = true;
          _this.title = _this.target.innerText;
        }
      }); // default break type for the vast majority of situations

      _this.breakType = "node";
      return _this;
    }

    babelHelpers.createClass(PageBreak, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this2 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "connectedCallback", this).call(this);

        if (this.breakType === "node") {
          if (this.nextElementSibling && this.nextElementSibling.tagName && ["H1", "H2", "H3", "H4", "H5", "H6"].includes(this.nextElementSibling.tagName)) {
            this.title = this.nextElementSibling.innerText;
            this.target = this.nextElementSibling;
            this.setupTargetData(this.target);
          } else {
            // we are going to inject a title element possibly so pause
            // to make sure there wasn't some timing in rendering before
            // we accidentally inject an element
            setTimeout(function () {
              if (_this2.target === null) {
                if (_this2.nextElementSibling && _this2.nextElementSibling.tagName && ["H1", "H2", "H3", "H4", "H5", "H6"].includes(_this2.nextElementSibling.tagName)) {
                  _this2.title = _this2.nextElementSibling.innerText;
                  _this2.target = _this2.nextElementSibling;

                  _this2.setupTargetData(_this2.target);
                } else {
                  var tagName = _this2.depth === 0 ? "h2" : "h".concat(_this2.depth + 2);
                  var newH = document.createElement(tagName);
                  newH.setAttribute("data-original-level", "H2");
                  newH.innerText = _this2.title;

                  _this2.parentNode.insertBefore(newH, _this2.nextElementSibling); // account for HAX which might mess w/ the tag on insert


                  setTimeout(function () {
                    _this2.setupTargetData(_this2.nextElementSibling);
                  }, 100);
                }
              }
            }, 0);
          }
        }

        window.dispatchEvent(new CustomEvent("page-break-registration", {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this,
            action: "add"
          }
        }));
        window.dispatchEvent(new CustomEvent("page-break-change", {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this
          }
        }));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.dispatchEvent(new CustomEvent("page-break-registration", {
          detail: {
            value: this,
            action: "remove"
          }
        }));
        window.dispatchEvent(new CustomEvent("page-break-change", {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this
          }
        }));
        this.remoteHeadingobserver.disconnect();
        babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "disconnectedCallback", this).call(this);
      } // setup the target data

    }, {
      key: "setupTargetData",
      value: function setupTargetData(newTarget) {
        if (this.target) {
          this.remoteHeadingobserver.disconnect();
        }

        this.target = newTarget; // add a backdoor for hax to have a hook into this

        this._haxSibling = this; // @todo need to add some kind of "if this gets deleted let me know"
        // or a hook that basically blocks this being deleted because it
        // is under control of the page-break tag

        this.remoteHeadingobserver.observe(this.target, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this3 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (propName === "schemaResourceID" && _this3.itemId == null && oldValue !== undefined) {
            _this3.itemId = _this3.schemaResourceID.replace("#", "item-");
          } // when visible, "click" the thing so that it's activated


          if (propName === "elementVisible" && _this3.elementVisible && _this3.itemId && _this3.shadowRoot) {
            setTimeout(function () {
              _pageBreakManager.pageBreakManager.updateVisibleAsActive();
            }, 0);
          } // replicate locked aross elements between here and next page break


          if (_this3.locked && propName === "locked") {
            _pageBreakManager.pageBreakManager.elementsBetween(_this3).forEach(function (el) {
              el.setAttribute("data-hax-lock", "data-hax-lock");
            });
          } // was true, not locked
          else if (!_this3.locked && propName === "locked" && oldValue) {
              _pageBreakManager.pageBreakManager.elementsBetween(_this3).forEach(function (el) {
                el.removeAttribute("data-hax-lock");
              });
            } // update CE menu when these change if it is around


          if (_this3._ceMenu && ["locked", "parent", "published"].includes(propName)) {
            _this3._updateHAXCEMenu();
          } // fire event for reaction so we can update sgtate elsewhere


          if (["title", "parent", "slug"].includes(propName)) {
            window.dispatchEvent(new CustomEvent("page-break-change", {
              composed: true,
              bubbles: true,
              cancelable: true,
              detail: {
                value: _this3
              }
            }));
          } // while the most common, only do these when we have a target


          if (_this3.breakType === "node" && _this3.target) {
            if (propName === "title" && _this3[propName]) {
              // change title text to match title if updated but delay
              // to avoid input spamming as this could generate a lot of change records
              // but don't just set it as it would generate another change record
              if (_this3.__moUpdate) {
                // skips the update of innerText to match
                _this3.__moUpdate = false;
              } else if (_this3.title != _this3.target.innerText) {
                _this3.target.innerText = _this3.title;
              }
            } // the magic a11y rewriter


            if (!_this3._haxState && propName === "depth" && _this3.depth >= 0) {
              _pageBreakManager.pageBreakManager.elementsBetween(_this3, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                var tagNumber = (el.getAttribute("data-original-level") ? new Number(el.getAttribute("data-original-level").replace("H", "")) : new Number(el.tagName.replace("H", ""))) + _this3.depth;
                tagNumber = tagNumber > 6 ? 6 : tagNumber;
                var newH = document.createElement("h".concat(tagNumber));
                newH.setAttribute("data-original-level", el.tagName);

                for (var i = 0, l = el.attributes.length; i < l; ++i) {
                  newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                }

                newH.innerHTML = el.innerHTML;

                _this3.setupTargetData(newH);

                el.parentNode.replaceChild(newH, el);
              });
            } // hax state is a special case bc we want to edit in whats saved
            // not what's interpretted


            if (propName === "_haxState" && oldValue !== undefined) {
              if (_this3._haxState) {
                _pageBreakManager.pageBreakManager.elementsBetween(_this3, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                  if (el.getAttribute("data-original-level")) {
                    var tagNumber = new Number(el.getAttribute("data-original-level").replace("H", ""));
                    var newH = document.createElement("h".concat(tagNumber));

                    for (var i = 0, l = el.attributes.length; i < l; ++i) {
                      newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                    }

                    newH.innerHTML = el.innerHTML;
                    el.parentNode.replaceChild(newH, el);

                    _this3.setupTargetData(newH);
                  }
                });
              } else {
                _pageBreakManager.pageBreakManager.elementsBetween(_this3, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                  var tagNumber = (el.getAttribute("data-original-level") ? new Number(el.getAttribute("data-original-level").replace("H", "")) : new Number(el.tagName.replace("H", ""))) + _this3.depth;
                  tagNumber = tagNumber > 6 ? 6 : tagNumber;
                  var newH = document.createElement("h".concat(tagNumber));
                  newH.setAttribute("data-original-level", el.tagName);

                  for (var i = 0, l = el.attributes.length; i < l; ++i) {
                    newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                  }

                  newH.innerHTML = el.innerHTML;
                  el.parentNode.replaceChild(newH, el);

                  _this3.setupTargetData(newH);
                });
              }
            }
          } // allow for haxcms page style association to allow users to edit the
          // current page's details


          if (propName === "breakType" || propName === "t") {
            var iconPath;

            if (_this3[propName] === "node") {
              iconPath = _simpleIconset.SimpleIconsetStore.getIcon("editor:format-page-break");
              _this3.shadowRoot.querySelector("style").innerHTML = "\n          :host([data-hax-ray]:hover) .mid::before {\n            content: \"".concat(_this3.t.pageBreak, "\";\n          }");
            } else {
              iconPath = _simpleIconset.SimpleIconsetStore.getIcon("hax:page-details");
              _this3.shadowRoot.querySelector("style").innerHTML = "\n          :host([data-hax-ray]:hover) .mid::before {\n            content: \"".concat(_this3.t.pageDetails, "\";\n          }");
            } // set background of the tag itself to the icon based on mode


            _this3.style.backgroundImage = "url(\"".concat(iconPath, "\")");
          }
        });
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "firstUpdated", this).call(this, changedProperties);
        } // align schema ID w/ the ID from itemId on load


        if (this.itemId != null) {
          this.schemaResourceID = this.itemId;
        }
      }
    }, {
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_6f4a1520809211edaa2833647dc78c6c || (_templateObject_6f4a1520809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n      <style></style>\n      <a .href=\"", "\" .name=\"#", "\" class=\"sr-only\"\n        >", "</a\n      >\n      <hr class=\"mid\" />\n      ", "\n    "])), this.slug, this.itemId, this.title, this.locked ? (0, _index.html)(_templateObject2_6f4a1520809211edaa2833647dc78c6c || (_templateObject2_6f4a1520809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["<simple-icon-button-lite\n            @click=\"", "\"\n            icon=\"icons:lock\"\n            title=\"", "\"\n          ></simple-icon-button-lite>"])), this.haxClickLockInPage, this.t.clickToUnlock) : "");
      }
      /**
       * haxProperties integration via file reference
       */

    }, {
      key: "haxHooks",
      value:
      /**
       * haxHooks
       */
      function haxHooks() {
        return {
          editModeChanged: "haxeditModeChanged",
          inlineContextMenu: "haxinlineContextMenu",
          activeElementChanged: "haxactiveElementChanged",
          setupActiveElementForm: "haxsetupActiveElementForm",
          preProcessInsertContent: "haxpreProcessInsertContent",
          trayDragNDropToNode: "haxtrayDragNDropToNode"
        };
      }
      /**
       * on insert, test for other page-break tags via manager to see
       * if we're able to steal sane defaults from there
       */

    }, {
      key: "haxpreProcessInsertContent",
      value: function () {
        var _haxpreProcessInsertContent = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(details, activeNode) {
          var testNode, closestPB;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  // look up the current page breaks from manager
                  // if a haxcms one exists then use that for defaults
                  // if activeNode would have us be at a different page-break, use this
                  // as the target for drawing the following settings:
                  // for parent (same parent), order (+1 from it), published (mirror), locked (mirror)
                  // this ensures we look at the level just below the body container level
                  testNode = activeNode;

                  if (!(testNode && testNode.parentNode)) {
                    _context.next = 7;
                    break;
                  }

                  while (testNode.parentNode.tagName !== "HAX-BODY") {
                    testNode = testNode.parentNode;
                  }

                  _context.next = 5;
                  return _pageBreakManager.pageBreakManager.associatedPageBreak(testNode);

                case 5:
                  closestPB = _context.sent;

                  if (closestPB) {
                    details.properties.parent = closestPB.parent;
                    details.properties.order = closestPB.order + 1;
                    details.properties.published = closestPB.published;
                    details.properties.locked = closestPB.locked;
                  }

                case 7:
                  return _context.abrupt("return", details);

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function haxpreProcessInsertContent(_x, _x2) {
          return _haxpreProcessInsertContent.apply(this, arguments);
        }

        return haxpreProcessInsertContent;
      }()
      /**
       * Same as the above hook in capability however because of the interim state
       * of a drag event, we need a specialized hook that is for when the new
       * element has been dropped into the page
       */

    }, {
      key: "haxtrayDragNDropToNode",
      value: function () {
        var _haxtrayDragNDropToNode = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(activeNode) {
          var testNode, closestPB;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  // look up the current page breaks from manager
                  // if a haxcms one exists then use that for defaults
                  // if activeNode would have us be at a different page-break, use this
                  // as the target for drawing the following settings:
                  // for parent (same parent), order (+1 from it), published (mirror), locked (mirror)
                  // this ensures we look at the level just below the body container level
                  testNode = activeNode;

                  while (testNode.parentNode.tagName !== "HAX-BODY") {
                    testNode = testNode.parentNode;
                  }

                  _context2.next = 4;
                  return _pageBreakManager.pageBreakManager.associatedPageBreak(testNode);

                case 4:
                  closestPB = _context2.sent;

                  if (closestPB) {
                    activeNode.parent = closestPB.parent;
                    activeNode.order = closestPB.order + 1;
                    activeNode.published = closestPB.published;
                    activeNode.locked = closestPB.locked;
                  }

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        function haxtrayDragNDropToNode(_x3) {
          return _haxtrayDragNDropToNode.apply(this, arguments);
        }

        return haxtrayDragNDropToNode;
      }()
      /**
       * Allow for dynamic setting of the parent field if we have the store around
       * with values to do so
       */

    }, {
      key: "haxsetupActiveElementForm",
      value: function haxsetupActiveElementForm(props) {
        var _this4 = this;

        if (window.HAXCMS) {
          var itemManifest = window.HAXCMS.requestAvailability().store.getManifestItems(true); // default to null parent as the whole site

          var items = [{
            text: "-- ".concat(this.t.noParent, " --"),
            value: null
          }];
          itemManifest.forEach(function (el) {
            if (el.id != _this4.itemId) {
              (function () {
                // calculate -- depth so it looks like a tree
                var itemBuilder = el; // walk back through parent tree

                var distance = "- ";

                while (itemBuilder && itemBuilder.parent != null) {
                  itemBuilder = itemManifest.find(function (i) {
                    return i.id == itemBuilder.parent;
                  }); // double check structure is sound

                  if (itemBuilder) {
                    distance = "--" + distance;
                  }
                }

                items.push({
                  text: distance + el.title,
                  value: el.id
                });
              })();
            }
          });
          props.settings.configure.forEach(function (attr, index) {
            if (attr.property === "parent") {
              props.settings.configure[index].inputMethod = "select";
              props.settings.configure[index].itemsList = items;
            }
          });
        }
      }
      /**
       * Ensure that if we WERE active and now are not
       * and have a reference to the custom element menu in hax
       * and are the right break type, that we reset these items
       */

    }, {
      key: "haxactiveElementChanged",
      value: function haxactiveElementChanged(element, value) {
        if (!value && this._ceMenu) {
          if (this.breakType === "site") {
            this._ceMenu.disableOps = false;
            this._ceMenu.canMoveElement = true;
            this._ceMenu.insertAbove = true;
          } else {
            this._ceMenu.disableDuplicate = false;
          }
        }
      }
      /**
       * ensure that when we flip states here that we are actively switching the original level var
       */

    }, {
      key: "haxeditModeChanged",
      value: function haxeditModeChanged(value) {
        this._haxState = value;
      }
      /**
       * add buttons when it is in context
       */

    }, {
      key: "haxinlineContextMenu",
      value: function haxinlineContextMenu(ceMenu) {
        this._ceMenu = ceMenu;

        this._updateHAXCEMenu(); // forcibly prevent duplication and deleting of the node controlling the page itself


        if (this.breakType === "site") {
          this._ceMenu.disableOps = true;
          this._ceMenu.canMoveElement = false;
          this._ceMenu.insertAbove = false;
        } else {
          this._ceMenu.disableDuplicate = true;
        }
      } // update custom element buttons so we can do live status changes

    }, {
      key: "_updateHAXCEMenu",
      value: function _updateHAXCEMenu() {
        this._ceMenu.ceButtons = [{
          icon: this.locked ? "icons:lock" : "icons:lock-open",
          callback: "haxClickInlineLock",
          label: this.t.toggleLock
        }, {
          icon: this.published ? "lrn:view" : "lrn:view-off",
          callback: "haxClickInlinePublished",
          label: this.t.togglePublished
        }];
      }
    }, {
      key: "haxClickLockInPage",
      value: function haxClickLockInPage(e) {
        this.locked = !this.locked;
        window.dispatchEvent(new CustomEvent("hax-refresh-tray-form", {}));
      }
    }, {
      key: "haxClickInlineLock",
      value: function haxClickInlineLock(e) {
        this.locked = !this.locked;
        return true;
      }
    }, {
      key: "haxClickInlinePublished",
      value: function haxClickInlinePublished(e) {
        this.published = !this.published;
        return true;
      }
    }], [{
      key: "tag",
      get: function get() {
        return "page-break";
      }
    }, {
      key: "properties",
      get: function get() {
        var props = babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak), "properties", this) || {};
        return _objectSpread(_objectSpread({}, props), {}, {
          order: {
            type: Number
          },
          title: {
            type: String,
            reflect: true
          },
          slug: {
            type: String
          },
          parent: {
            type: String,
            reflect: true
          },
          published: {
            type: Boolean,
            reflect: true
          },
          locked: {
            type: Boolean,
            reflect: true
          },
          depth: {
            type: Number,
            reflect: true
          },
          itemId: {
            type: String,
            attribute: "item-id",
            reflect: true
          },
          breakType: {
            type: String,
            attribute: "break-type"
          },
          status: {
            type: String
          },
          _haxState: {
            type: Boolean
          }
        });
      }
    }, {
      key: "styles",
      get: function get() {
        return [(0, _index.css)(_templateObject3_6f4a1520809211edaa2833647dc78c6c || (_templateObject3_6f4a1520809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          opacity: 0;\n          height: 1px;\n        }\n        :host([data-hax-ray]) {\n          display: block;\n          margin: 20px 0;\n          padding: 20px;\n          opacity: 0.2;\n          background-position: center;\n          background-repeat: no-repeat;\n          transition: all 0.2s linear;\n        }\n        .mid {\n          border: none;\n          border-top: 2px solid #cccccc;\n          overflow: visible;\n          margin: 4px 0 0 0;\n          padding: 0;\n          height: 0;\n        }\n        :host([data-hax-ray]:hover) {\n          opacity: 1;\n        }\n        :host([data-hax-ray]:hover) .mid::before {\n          font-weight: bold;\n          color: #000000;\n          background-color: #ffffff;\n          font-size: 16px;\n          left: calc(50% - 2.5em);\n          top: -16px;\n          position: relative;\n          height: 0;\n          line-height: 36px;\n        }\n        simple-icon-button-lite {\n          float: right;\n          color: #000000;\n          --simple-icon-width: 36px;\n          --simple-icon-height: 36px;\n          margin-top: -28px;\n          margin-right: -46px;\n        }\n        .sr-only {\n          position: absolute;\n          left: -10000px;\n          top: auto;\n          width: 1px;\n          height: 1px;\n          overflow: hidden;\n        }\n      "])))];
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return new URL("./lib/page-break.haxProperties.json", meta.url).href;
      }
    }]);
    return PageBreak;
  }((0, _IntersectionObserverMixin.IntersectionObserverMixin)((0, _I18NMixin.I18NMixin)((0, _schemaBehaviors.SchemaBehaviors)(_index.LitElement))));

  _exports.PageBreak = PageBreak;
  customElements.define(PageBreak.tag, PageBreak);
});