define(["exports", "meta", "../../../@polymer/polymer/polymer-element.js", "../../circle-progress/circle-progress.js", "../../simple-tooltip/simple-tooltip.js", "../../../@polymer/paper-styles/paper-styles.js", "../../../@polymer/paper-spinner/paper-spinner.js", "../../simple-icon/simple-icon.js", "../../simple-icon/lib/simple-icons.js"], function (_exports, meta, _polymerElement, _circleProgress, _simpleTooltip, _paperStyles, _paperSpinner, _simpleIcon, _simpleIcons) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LrnsysProgressCircle = void 0;
  meta = _interopRequireWildcard(meta);

  var _templateObject_d90152008e0011ed99ce491205e67b1d;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `lrnsys-progress-circle`
   * @element lrnsys-progress-circle
   * `circle that the outline grows as the percentage ticks up`
   *
   */
  var LrnsysProgressCircle = /*#__PURE__*/function (_PolymerElement) {
    babelHelpers.inherits(LrnsysProgressCircle, _PolymerElement);

    var _super = _createSuper(LrnsysProgressCircle);

    function LrnsysProgressCircle() {
      var _this;

      babelHelpers.classCallCheck(this, LrnsysProgressCircle);
      _this = _super.call(this);
      _this.completeSound = new URL("./lib/assets/complete.mp3", meta.url).href;
      _this.finishedSound = new URL("./lib/assets/finished.mp3", meta.url).href;
      setTimeout(function () {
        _this.addEventListener("click", _this.tapEventOn.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("mouseover", _this.focusOn.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("mouseout", _this.focusOff.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("focused-changed", _this.focusEvent.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      return _this;
    }
    /**
     * Focus event for UX consistency.
     */


    babelHelpers.createClass(LrnsysProgressCircle, [{
      key: "ready",
      value:
      /**
       * Ready state
       */
      function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(LrnsysProgressCircle.prototype), "ready", this).call(this); // seems odd but if we don't do this we can get issues with
        // this field being unified across all circles when really
        // we have to track this state per circle.

        this._bubbleProgress = {
          25: false,
          50: false,
          75: false
        };
      }
      /**
       * Test if the value = max meaning that we hit complete from available
       */

    }, {
      key: "_testValueComplete",
      value: function _testValueComplete(newValue, oldValue) {
        // ensure we were previously available before marking complete
        // this way we don't conflict with the finished state which can
        // only be set from outside the circle as the circle doesn't
        // know how many items are in the set
        if (newValue >= this.max && this.status == "available") {
          this.status = "complete";
        } // add events for certain mile stones; this has to be in reverse order
        // otherwise we could actuall be passing 75 but it was at 0. This allows
        // for jumping ahead and not triggering 25/50/75 all at once and preventing
        // over reported percentages upstream
        else if (newValue / this.max >= 0.75 && !this._bubbleProgress["75"]) {
            this.dispatchEvent(new CustomEvent("node-percent-milestone", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: {
                percentage: 75
              }
            }));
            this._bubbleProgress["75"] = true;
          } else if (newValue / this.max >= 0.5 && !this._bubbleProgress["50"]) {
            this.dispatchEvent(new CustomEvent("node-percent-milestone", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: {
                percentage: 50
              }
            }));
            this._bubbleProgress["50"] = true;
          } else if (newValue / this.max >= 0.25 && !this._bubbleProgress["25"]) {
            this.dispatchEvent(new CustomEvent("node-percent-milestone", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: {
                percentage: 25
              }
            }));
            this._bubbleProgress["25"] = true;
          }
      }
    }, {
      key: "focusEvent",
      value: function focusEvent(e) {
        // see if it has hover classes
        if (!this.disabled && this.status != "loading") {
          // focus shows focus
          if (this.focusState) {
            // force icon to be set to real one and class added
            this.shadowRoot.querySelector("#icon").icon = this.icon;
            this.shadowRoot.querySelector("#icon").classList.add("activeIcon");
          } else {
            // if complete set it back to what it was
            if (this.status == "complete" || this.status == "finished") {
              this.shadowRoot.querySelector("#icon").icon = this.activeIcon;
            } // drop the class for active step


            this.shadowRoot.querySelector("#icon").classList.remove("activeIcon");
          }

          this.focusState = !this.focusState;
        }
      }
      /**
       * Focus event for UX consistency.
       */

    }, {
      key: "focusOn",
      value: function focusOn(e) {
        // see if it has hover classes
        if (!this.disabled && this.status != "loading") {
          // force icon to be set to real one and class added
          this.shadowRoot.querySelector("#icon").icon = this.icon;
          this.shadowRoot.querySelector("#icon").classList.add("activeIcon");
        }
      }
      /**
       * Focus event for UX consistency.
       */

    }, {
      key: "focusOff",
      value: function focusOff(e) {
        // see if it has hover classes
        if (!this.disabled && this.status != "loading") {
          // if complete set it back to what it was
          if (this.status == "complete" || this.status == "finished") {
            this.shadowRoot.querySelector("#icon").icon = this.activeIcon;
          } // drop the class for active step


          this.shadowRoot.querySelector("#icon").classList.remove("activeIcon");
        }
      }
      /**
       * Tapped on the item.
       */

    }, {
      key: "tapEventOn",
      value: function tapEventOn(e) {
        var target = e.target;
        this.dispatchEvent(new CustomEvent("node-is-active", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            target: target
          }
        }));
      }
      /**
       * Calculate which icon to present.
       */

    }, {
      key: "_getActiveIcon",
      value: function _getActiveIcon(icon, iconComplete, status) {
        if (babelHelpers.typeof(icon) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && this.shadowRoot) {
          var tmp = icon; // support for a loading icon while loading

          if (status == "loading") {
            tmp = this.loadingIcon;
            this.shadowRoot.querySelector("#icon").classList.add("transition");
          } else if (status == "finished") {
            tmp = this.finishedIcon;
          } else if (status == "complete" && babelHelpers.typeof(iconComplete) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            if (this.playSound && !this.__chimed) {
              this._playSound();
            }

            tmp = iconComplete;
          } else {
            this.shadowRoot.querySelector("#icon").classList.remove("transition");
          }

          return tmp;
        }

        return false;
      }
      /**
       * Play the sound effect.
       */

    }, {
      key: "_playSound",
      value: function _playSound() {
        // calculate sound to use and ensure it only ever happens once
        // via the __chimed flag
        if (this.status == "complete") {
          window.audio = new Audio(this.completeSound);
          this.__chimed = true;
        } else if (this.status == "finished") {
          window.audio = new Audio(this.finishedSound);
          this.__finishchimed = true;
        } else {
          // shouldn't be possible
          window.audio = new Audio();
        }

        window.audio.play();
      }
      /**
       * Calculate loading based on the status of the item.
       */

    }, {
      key: "_loadingStatus",
      value: function _loadingStatus(status) {
        if (status == "loading") {
          return true;
        }

        return false;
      }
      /**
       * Calculate loading based on the status of the item.
       */

    }, {
      key: "_finishedStatus",
      value: function _finishedStatus(status) {
        if (status == "finished") {
          if (this.playFinishSound && !this.__finishchimed) {
            this._playSound();
          }

          return true;
        }

        return false;
      }
      /**
       * Notice when state changes to fire up an event for others to respond to.
       */

    }, {
      key: "_statusChange",
      value: function _statusChange(newValue, oldValue) {
        // verify this isn't loading up
        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue !== oldValue) {
          this.dispatchEvent(new CustomEvent("node-status-change", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              status: newValue
            }
          }));
        }
      }
      /**
       * Calculate disable based on the status of the item.
       */

    }, {
      key: "_disableStatus",
      value: function _disableStatus(status) {
        if (status == "disabled") {
          return true;
        }

        return false;
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_d90152008e0011ed99ce491205e67b1d || (_templateObject_d90152008e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <custom-style>\n        <style is=\"custom-style\" include=\"paper-material-styles\">\n          :host {\n            display: block;\n            transition: box-shadow\n                var(--lrnsys-progress-circle-transition, 0.5s) linear,\n              color var(--lrnsys-progress-circle-transition, 0.5s) ease-in-out,\n              background-color var(--lrnsys-progress-circle-transition, 0.5s)\n                ease-in-out;\n          }\n          :host([status=\"complete\"]) .circle-wrapper {\n            box-shadow: 0px 0px 0px 0.16px\n              var(--lrnsys-progress-complete-color, var(--paper-green-900));\n          }\n          :host([status=\"disabled\"]) .circle-wrapper {\n            box-shadow: none;\n          }\n          :host([status=\"available\"]) .circle-wrapper {\n            box-shadow: none;\n          }\n          :host([active]) .circle-wrapper {\n            box-shadow: 0px 0px 0px 0.16px var(--google-grey-500, #555555);\n          }\n          .circle-wrapper {\n            border-radius: 100%;\n          }\n          .button {\n            margin: 0;\n            padding: 0;\n            display: flex;\n            min-width: 40px;\n            border-radius: 100%;\n          }\n          button {\n            width: var(--lrnsys-progress-circle-size, 40px);\n            height: var(--lrnsys-progress-circle-size, 40px);\n          }\n          circle-progress {\n            margin: 0;\n            --circle-progress-width: var(--lrnsys-progress-circle-size, 40px);\n            --circle-progress-height: var(--lrnsys-progress-circle-size, 40px);\n            --circle-progress-stroke-color: var(\n              --lrnsys-progress-color,\n              var(--paper-green-500)\n            );\n            --circle-progress-bg-stroke-color: var(\n              --lrnsys-progress-container-color,\n              var(--google-grey-300)\n            );\n            --circle-progress-transition: 0.5s;\n            --circle-progress-stroke-linecap: square;\n            transition: color 0.5s ease-in-out,\n              background-color 0.5s ease-in-out;\n          }\n          paper-spinner {\n            display: block;\n            font-size: 16px;\n            width: var(--lrnsys-progress-spinner-size, 32px);\n            height: var(--lrnsys-progress-spinner-size, 32px);\n            position: absolute;\n            z-index: 1;\n            margin: 4px;\n            padding: 0;\n            visibility: visible;\n            opacity: 1;\n            transition: visibility 0.4s, opacity 0.4s ease;\n          }\n          paper-spinner.multi {\n            --paper-spinner-layer-1-color: var(--paper-purple-500);\n            --paper-spinner-layer-2-color: var(--paper-cyan-500);\n            --paper-spinner-layer-3-color: var(--paper-blue-grey-500);\n            --paper-spinner-layer-4-color: var(--paper-amber-500);\n          }\n          .transition {\n            opacity: 0.4;\n            width: calc(var(--lrnsys-progress-icon-size, 24px) - 8px);\n            height: calc(var(--lrnsys-progress-icon-size, 24px) - 8px);\n          }\n          simple-icon {\n            visibility: visible;\n            opacity: 1;\n            transition: width 0.1s linear, height 0.1s linear,\n              visibility 0.4s ease, opacity 0.4s ease;\n            --simple-icon-width: var(--lrnsys-progress-icon-size, 24px);\n            --simple-icon-height: var(--lrnsys-progress-icon-size, 24px);\n          }\n          .disabled {\n            background-color: var(\n              --lrnsys-progress-disabled-color,\n              var(--google-grey-500)\n            );\n            color: white;\n          }\n          .loading {\n            background-color: white;\n            color: black;\n          }\n          .finished simple-icon:not(.activeIcon) {\n            --simple-icon-width: calc(\n              var(--lrnsys-progress-icon-size, 24px) - 8px\n            );\n            --simple-icon-height: calc(\n              var(--lrnsys-progress-icon-size, 24px) - 8px\n            );\n          }\n          .available {\n            background-color: var(\n              --lrnsys-progress-active-color,\n              var(--google-grey-300)\n            );\n            color: var(\n              --lrnsys-progress-active-text-color,\n              var(--google-grey-500)\n            );\n          }\n          .activeIcon {\n            color: black;\n          }\n          .complete .activeIcon {\n            color: white;\n          }\n          :host([active]) .complete .activeIcon,\n          :host([active]) .finished .activeIcon {\n            color: black;\n          }\n          .complete,\n          .finished {\n            background-color: var(\n              --lrnsys-progress-container-color,\n              var(--paper-green-500)\n            );\n            color: white;\n          }\n          :host([active]) circle-progress {\n            background-color: white;\n            color: black;\n          }\n          .listview-title {\n            font-size: 16px;\n            padding: 0;\n            margin: 0;\n          }\n          .description-content {\n            font-size: 8px;\n            font-style: italic;\n          }\n          .circle-wrapper {\n            display: inline-block;\n          }\n          .listview {\n            height: 32px;\n            padding: 4px 0;\n            margin: 0;\n            vertical-align: top;\n          }\n          .link {\n            height: 40px;\n            width: 100%;\n          }\n          :host([list-view]) .button {\n            margin: 0;\n            padding: 0;\n            display: block;\n            min-width: 40px;\n            border-radius: 0;\n          }\n        </style>\n      </custom-style>\n      <simple-tooltip\n        hidden$=\"[[!toolTip]]\"\n        for=\"button\"\n        position=\"bottom\"\n        offset=\"8\"\n        animation-delay=\"0\"\n      >\n        [[label]]\n      </simple-tooltip>\n      <button\n        id=\"button\"\n        class=\"button\"\n        disabled$=\"[[disabled]]\"\n        title=\"[[label]]\"\n      >\n        <span class=\"circle-wrapper\">\n          <paper-spinner\n            active$=\"[[loading]]\"\n            hidden$=\"[[!loading]]\"\n            class=\"multi\"\n            alt$=\"Loading content for [[label]]\"\n          ></paper-spinner>\n          <circle-progress\n            class$=\"[[status]]\"\n            value=\"[[value]]\"\n            max=\"[[max]]\"\n            stroke-width=\"[[strokeWidth]]\"\n            angle=\"180\"\n          >\n            <simple-icon\n              id=\"icon\"\n              icon=\"[[activeIcon]]\"\n              hidden$=\"[[!activeIcon]]\"\n            ></simple-icon>\n            <slot name=\"image\"></slot>\n          </circle-progress>\n        </span>\n        <span hidden$=\"[[!listView]]\" id=\"listview\" class=\"listview\">\n          <h3 class=\"listview-title\">[[label]]</h3>\n          <div class=\"description-content\">\n            <slot name=\"description\"></slot> <slot></slot>\n          </div>\n        </span>\n      </button>\n    "])));
      }
    }, {
      key: "tag",
      get: function get() {
        return "lrnsys-progress-circle";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Current value.
           */
          value: {
            type: Number,
            value: 0,
            notify: true,
            reflectToAttribute: true,
            observer: "_testValueComplete"
          },

          /**
           * Whether to add a tooltip on hover.
           */
          toolTip: {
            type: Boolean,
            value: true,
            reflectToAttribute: true
          },

          /**
           * If this is in a list view, expand the output.
           */
          listView: {
            type: Boolean,
            value: true,
            reflectToAttribute: true
          },

          /**
           * Icon.
           */
          icon: {
            type: String,
            value: "icons:description",
            reflectToAttribute: true
          },

          /**
           * Special icon to use when the item has been completed.
           */
          iconComplete: {
            type: String,
            value: "icons:description",
            reflectToAttribute: true
          },

          /**
           * Loading icon
           */
          loadingIcon: {
            type: String,
            value: "hourglass-full",
            reflectToAttribute: true
          },

          /**
           * Finished icon
           */
          finishedIcon: {
            type: String,
            value: "thumb-up",
            reflectToAttribute: true
          },

          /**
           * Current value.
           */
          activeIcon: {
            type: String,
            notify: true,
            computed: "_getActiveIcon(icon, iconComplete, status)"
          },

          /**
           * Array position within a larger body of items.
           */
          step: {
            type: Number,
            value: 0,
            reflectToAttribute: true
          },

          /**
           * If this item is active or not in the larger list
           */
          active: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            notify: true
          },

          /**
           * Status of the progression.
           * Possible values are disabled, loading, available, complete
           */
          status: {
            type: String,
            value: "available",
            reflectToAttribute: true,
            notify: true,
            observer: "_statusChange"
          },

          /**
           * Correctly disable the button if it's status is such.
           */
          disabled: {
            type: Boolean,
            computed: "_disableStatus(status)"
          },

          /**
           * Calculate if something is in a loading status which invokes a swirl.
           */
          loading: {
            type: Boolean,
            computed: "_loadingStatus(status)"
          },

          /**
           * Boolean to invoke "finished" state. Useful for the last circle
           * in a series.
           */
          finished: {
            type: Boolean,
            computed: "_finishedStatus(status)"
          },

          /**
           * Max progression for doing math against.
           */
          max: {
            type: String,
            reflectToAttribute: true
          },

          /**
           * Internal property to ensure we only ding 1x
           */
          __chimed: {
            type: Boolean,
            value: false
          },

          /**
           * Internal property to ensure we only finish 1x
           */
          __finishchimed: {
            type: Boolean,
            value: false
          },

          /**
           * URL to link to on click.
           */
          url: {
            type: String,
            value: "#",
            reflectToAttribute: true
          },

          /**
           * Data url to bubble up for more advanced implementations.
           */
          dataUrl: {
            type: String,
            value: false,
            reflectToAttribute: true
          },

          /**
           * Stroke width.
           */
          strokeWidth: {
            type: Number,
            value: 4
          },

          /**
           * Tracks if focus state is applied for element consistency
           * when dealing with focus vs hover states.
           */
          focusState: {
            type: Boolean,
            value: false
          },

          /**
           * Play sound status; if this should play sound
           * when it hits certain milestones or not.
           */
          playSound: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },

          /**
           * Play sound at end; if this should play sound
           * when it hits certain milestones or not.
           */
          playFinishSound: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },

          /**
           * Play sound on complete.
           */
          completeSound: {
            type: String,
            reflectToAttribute: true
          },

          /**
           * Play sound on complete.
           */
          finishedSound: {
            type: String,
            reflectToAttribute: true
          },

          /**
           * Fire and track milestones towards completion state.
           */
          _bubbleProgress: {
            type: Object,
            value: {
              25: false,
              50: false,
              75: false
            }
          }
        };
      }
    }]);
    return LrnsysProgressCircle;
  }(_polymerElement.PolymerElement);

  _exports.LrnsysProgressCircle = LrnsysProgressCircle;
  customElements.define(LrnsysProgressCircle.tag, LrnsysProgressCircle);
});