define(["exports", "../../../../lit/index.js", "./HAXCMSThemeWiring.js", "../../../responsive-utility/lib/responsive-utility-behaviors.js", "./haxcms-site-store.js", "../../../../mobx/dist/mobx.esm.js", "../../../simple-icon/lib/simple-icons.js", "../../../simple-icon/lib/simple-iconset.js", "../../../editable-table/lib/editable-table-behaviors.js"], function (_exports, _index, _HAXCMSThemeWiring, _responsiveUtilityBehaviors, _haxcmsSiteStore, _mobxEsm, _simpleIcons, _simpleIconset, _editableTableBehaviors) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSLitElementTheme = void 0;

  var _templateObject_e70c71908e0011ed99ce491205e67b1d, _templateObject2_e70c71908e0011ed99ce491205e67b1d;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * LitElement Version of HAXCMSTheme
   */
  var HAXCMSLitElementTheme = /*#__PURE__*/function (_HAXCMSTheme) {
    babelHelpers.inherits(HAXCMSLitElementTheme, _HAXCMSTheme);

    var _super = _createSuper(HAXCMSLitElementTheme);

    function HAXCMSLitElementTheme() {
      var _this;

      babelHelpers.classCallCheck(this, HAXCMSLitElementTheme);
      _this = _super.call(this);
      _this.editMode = false;
      _this.isLoggedIn = false;
      _this.__disposer = _this.__disposer ? _this.__disposer : [];
      (0, _mobxEsm.autorun)(function (reaction) {
        _this.editMode = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.editMode);

        _this.__disposer.push(reaction);
      }); // when this changes, query our light dom children and apply a click hanlder to copy a link to the item

      (0, _mobxEsm.autorun)(function (reaction) {
        var tmp = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.activeItemContent);

        if (_this.HAXCMSThemeSettings.autoScroll && _this.shadowRoot && _this.HAXCMSThemeSettings.scrollTarget) {
          _this.HAXCMSThemeSettings.scrollTarget.scrollTo({
            top: 0,
            left: 0
          });
        } // delay bc this shouldn't block page load in any way


        setTimeout(function () {
          // headings only
          var kidHeadings = _this.querySelectorAll("h1,h2,h3,h4,h5,h6");

          if (kidHeadings.length > 0) {
            kidHeadings.forEach(function (node) {
              node.addEventListener("click", _this.copyLink.bind(babelHelpers.assertThisInitialized(_this)));
              node.addEventListener("pointerenter", _this.hoverIntentEnter.bind(babelHelpers.assertThisInitialized(_this)));
              node.addEventListener("pointerout", _this.hoverIntentLeave.bind(babelHelpers.assertThisInitialized(_this)));
            });
          }
        }, 500);

        _this.__disposer.push(reaction);
      });
      return _this;
    }

    babelHelpers.createClass(HAXCMSLitElementTheme, [{
      key: "hoverIntentEnter",
      value: function hoverIntentEnter(e) {
        this.__styleTag = document.createElement("style");

        var iconPath = _simpleIconset.SimpleIconsetStore.getIcon("icons:link");

        this.__styleTag.innerHTML = "\n    #".concat(e.target.getAttribute("id"), " { cursor: copy; text-decoration: dotted underline}\n    #").concat(e.target.getAttribute("id"), " {\n      background-image: url(\"").concat(iconPath, "\");\n      background-position: right;\n      background-repeat: no-repeat;\n      background-size: 36px;\n    }");
        e.target.appendChild(this.__styleTag);
      }
    }, {
      key: "hoverIntentLeave",
      value: function hoverIntentLeave(e) {
        if (this.__styleTag) {
          this.__styleTag.remove();
        }
      }
    }, {
      key: "HAXCMSGlobalStyleSheetContent",
      value: function HAXCMSGlobalStyleSheetContent() {
        var styles = ["red", "blue", "green", "orange", "purple"].map(function (item) {
          return (0, _index.css)(_templateObject_e70c71908e0011ed99ce491205e67b1d || (_templateObject_e70c71908e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n          .haxcms-theme-element [data-style-decoration~=\"highlight\"] {\n            color: var(--haxcms-style-element-color, white);\n            background-color: var(\n              --haxcms-style-element-background-color,\n              black\n            );\n            font-weight: 400;\n            word-wrap: break-word;\n            padding: 4px 8px;\n            text-transform: uppercase;\n            text-decoration: none;\n          }\n          .haxcms-theme-element [data-style-decoration~=\"", "\"] {\n            --haxcms-style-element-background-color: var(\n              --simple-colors-default-theme-", "-7,\n              ", "\n            );\n          }\n        "])), (0, _index.unsafeCSS)(item), (0, _index.unsafeCSS)(item), (0, _index.unsafeCSS)(item));
        });
        return [].concat(babelHelpers.toConsumableArray(styles), [_editableTableBehaviors.editableTableDisplayStyles]);
      }
    }, {
      key: "copyLink",
      value: function copyLink(e) {
        var target = e.target;

        if (!target) {
          target = e.path[0];
        }

        var el = document.createElement("textarea");
        el.value = window.location.origin + window.location.pathname + "#" + target.getAttribute("id"); // alter URL state

        window.history.pushState({}, null, el.value);
        document.body.appendChild(el);
        el.select();
        document.execCommand("copy");
        document.body.removeChild(el);
        window.dispatchEvent(new CustomEvent("haxcms-toast-show", {
          cancelable: true,
          detail: {
            text: "Link copied to clipboard",
            duration: 3000
          }
        }));
      }
    }, {
      key: "firstUpdated",
      value: // LitElement life cycle
      function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLitElementTheme.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLitElementTheme.prototype), "firstUpdated", this).call(this, changedProperties);
        }

        if (this.contentContainer == null) {
          this.contentContainer = this.shadowRoot.querySelector("#contentcontainer");
        } // update the global managed CSS styles so we can "theme" the content
        // witout leaning on ::slotted which doesn't work always


        (0, _index.render)(this.HAXCMSGlobalStyleSheetContent(), _haxcmsSiteStore.store.themeStyleElement);
      } // LitElement life cycle

    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLitElementTheme.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLitElementTheme.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "_location") {
            _this2._locationChanged(_this2[propName], oldValue);
          }

          if (propName == "color") {
            _this2._colorChanged(_this2[propName], oldValue);
          }

          if (propName == "contentContainer") {
            // fire an to match notify
            _this2.dispatchEvent(new CustomEvent("content-container-changed", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: _this2[propName]
            }));

            _this2._contentContainerChanged(_this2[propName], oldValue);
          }

          if (propName == "isLoggedIn") {
            // fire an to match notify
            _this2.dispatchEvent(new CustomEvent("is-logged-in-changed", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: _this2[propName]
            }));
          }

          if (propName == "editMode") {
            // fire an to match notify
            _this2.dispatchEvent(new CustomEvent("edit-mode-changed", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: _this2[propName]
            }));

            _this2._editModeChanged(_this2[propName], oldValue);
          }
        });
      }
    }], [{
      key: "properties",
      get: function get() {
        var props = {};

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLitElementTheme), "properties", this)) {
          props = babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLitElementTheme), "properties", this);
        }

        return _objectSpread(_objectSpread({}, props), {}, {
          /**
           * Class for the color
           */
          hexColor: {
            type: String,
            attribute: "hex-color"
          },

          /**
           * Color class work to apply
           */
          color: {
            type: String,
            reflect: true
          },

          /**
           * editting state for the page
           */
          editMode: {
            type: Boolean,
            reflect: true,
            attribute: "edit-mode"
          },

          /**
           * editting state for the page
           */
          isLoggedIn: {
            type: Boolean,
            reflect: true,
            attribute: "is-logged-in"
          },

          /**
           * DOM node that wraps the slot
           */
          contentContainer: {
            type: Object
          },

          /**
           * location as object
           */
          _location: {
            type: Object
          }
        });
      }
    }, {
      key: "styles",
      get: function get() {
        var styles = [];

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLitElementTheme), "styles", this)) {
          styles = babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLitElementTheme), "styles", this);
        }

        return [].concat(babelHelpers.toConsumableArray(styles), [(0, _index.css)(_templateObject2_e70c71908e0011ed99ce491205e67b1d || (_templateObject2_e70c71908e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n        :host([edit-mode]) {\n          opacity: 1;\n          --hax-base-styles-p-min-height: 38px;\n        }\n        :host([hidden]) {\n          display: none;\n        }\n        [hidden] {\n          display: none !important;\n        }\n\n        @media (prefers-reduced-motion: reduce) {\n          * {\n            transition: none !important;\n          }\n        }\n        /**\n        * Hide the slotted content during edit mode. This must be here to work.\n        */\n        :host([edit-mode]) #slot {\n          display: none;\n        }\n        #slot {\n          min-height: 50vh;\n        }\n      "])))]);
      }
    }]);
    return HAXCMSLitElementTheme;
  }((0, _HAXCMSThemeWiring.HAXCMSTheme)((0, _responsiveUtilityBehaviors.ResponsiveUtilityBehaviors)(_index.LitElement)));

  _exports.HAXCMSLitElementTheme = HAXCMSLitElementTheme;
});