define(["exports", "../../../../lit/index.js", "./rich-text-editor-button.js", "../singletons/rich-text-editor-prompt.js"], function (_exports, _index, _richTextEditorButton, _richTextEditorPrompt) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RichTextEditorPromptButtonBehaviors = _exports.RichTextEditorPromptButton = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * RichTextEditorPromptButtonBehaviors
   *
   * @customElement
   * @class
   * @lit-html
   * @lit-element
   * @extends RichTextEditorButtonBehaviors
   */
  var RichTextEditorPromptButtonBehaviors = function RichTextEditorPromptButtonBehaviors(SuperClass) {
    return /*#__PURE__*/function (_RichTextEditorButton) {
      babelHelpers.inherits(_class, _RichTextEditorButton);

      var _super = _createSuper(_class);

      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this);
        _this.editableSelection = false;
        _this.fields = [{
          property: "innerHTML",
          title: "Text",
          inputMethod: "textfield"
        }];
        _this.tagsList = "span";
        _this.value = {
          innerHTML: undefined
        };
        return _this;
      }

      babelHelpers.createClass(_class, [{
        key: "render",
        value: // render function for template
        function render() {
          return babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "render", this).call(this);
        } // properties available to custom element for data binding

      }, {
        key: "firstUpdated",
        value: function firstUpdated(changedProperties) {
          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "firstUpdated", this).call(this, changedProperties);
        }
        /**
         * determines which command based on values passed from prompt
         * (can be overriden for custom prompt  commands)
         *
         * @readonly
         */

      }, {
        key: "promptCommand",
        get: function get() {
          return this.toggledCommand && !this.toggled ? this.toggledCommand : this.command;
        }
        /**
         * determines commandVal based on values passed from prompt
         * (can be overriden for custom prompt command values)
         */

      }, {
        key: "promptCommandVal",
        get: function get() {
          return this.commandVal;
        }
        /**
         * determines if prompt also sets innerHTML of range
         * (can be overriden for custom prompts)
         */

      }, {
        key: "setsInnerHTML",
        get: function get() {
          var innerHTML = (this.fields || []).filter(function (field) {
            return field.property === "innerHTML";
          });
          return innerHTML && innerHTML.length > 0;
        }
      }, {
        key: "targetedNode",
        get: function get() {
          var firstMatch = this.__highlight.querySelectorAll(this.tagsList);

          return firstMatch.length === 1 ? firstMatch[0] : this.__highlight;
        }
        /**
         * override this custom function to perform a
         * custom operation when an element that matches the tags list is clicked
         *
         * @param {event} e click event
         */

      }, {
        key: "tagClickCallback",
        value: function tagClickCallback() {
          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          if (e.detail) this.open(e.detail);
        }
        /**
         * closes without updates
         */

      }, {
        key: "cancel",
        value: function cancel() {
          this.close();
        }
        /**
         * closes prompt
         * @event rich-text-editor-prompt-closed
         *
         */

      }, {
        key: "close",
        value: function close() {
          this.__highlight.unwrap(this.range);

          if (this.range) this.range.collapse();
        }
        /**
         * updates insertion based on fields
         */

      }, {
        key: "confirm",
        value: function confirm(val) {
          this.value = val; //this.update();

          this.setToggled();
          this.updateSelection();
          this.close();
        }
        /**
         * gets a field value (and trims it if it's a string)
         *
         * @param {string} prop field name
         * @returns {*}
         * @memberof RichTextEditorPrompt
         */

      }, {
        key: "getPropValue",
        value: function getPropValue(prop) {
          var val = !!this.value ? _objectSpread({}, this.value) : false,
              rawVal = !val || !val[prop] ? false : val[prop].trim ? val[prop].trim() : val[prop];
          return rawVal && rawVal !== "" ? rawVal : false;
        }
        /**
         * gets value for prompt based on current selection
         * (can be overriden for custom prompt field values)
         */

      }, {
        key: "getValue",
        value: function getValue() {
          return {
            innerHTML: this.targetedNode.innerHTML || ""
          };
        }
        /**
         * Handles selecting text and opening prompt
         * @param {object} node optional node to select instead of range
         * @event rich-text-editor-prompt-open
         */

      }, {
        key: "open",
        value: function open(node) {
          this.highlightNode(node);
          this.value = this.getValue();
          this.dispatchEvent(new CustomEvent("rich-text-editor-prompt-open", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: this
          }));
        }
        /**
         * sets inner HTML of selection
         *
         * @param {string} html
         */

      }, {
        key: "setInnerHTML",
        value: function setInnerHTML(html) {
          if (this.setsInnerHTML) this.targetedNode.innerHTML = html;
        }
        /**
         * updates toggled based on values passed from prompt
         * (can be overriden for custom toggled state)
         */

      }, {
        key: "setToggled",
        value: function setToggled() {
          this.toggled = !this.value;
        }
        /**
         * updates selection based on values passed from prompt
         */

      }, {
        key: "updateSelection",
        value: function updateSelection() {
          var command = this.promptCommand,
              commandVal = this.promptCommandVal;
          this.setInnerHTML(this.getPropValue("innerHTML"));

          if (this.targetedNode === this.__highlight) {
            this.selectNodeContents(this.targetedNode);
          } else {
            this.selectNode(this.targetedNode);
          }

          this._handleCommand(command, commandVal, this.range);
        }
        /**
         * Handles button tap
         * @param {event} e button tap event
         */

      }, {
        key: "_handleClick",
        value: function _handleClick(e) {
          e.preventDefault();
          this.open();
        }
        /**
         * Handles range change
         * @param {event} e button tap event
         */

      }, {
        key: "_rangeChanged",
        value: function _rangeChanged(newVal, oldVal) {
          this.value = this.getValue();
          this.setToggled();
        }
      }], [{
        key: "tag",
        get:
        /**
         * Store tag name to make it easier to obtain directly.
         */
        function get() {
          return "rich-text-editor-prompt-button";
        }
      }, {
        key: "properties",
        get: function get() {
          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)), {}, {
            /**
             * fields for prompt popover.
             */
            fields: {
              type: Array
            },

            /**
             * is element a custom inline widget element?
             */
            id: {
              name: "id",
              type: String,
              reflect: true,
              attribute: "id"
            },

            /**
             * prefilled value of prompt
             */
            value: {
              type: Object
            },

            /**
             * contents node inside selected range
             */
            __wrap: {
              name: "__wrap",
              type: Object
            },

            /**
             * contents node inside selected range
             */
            __oldValue: {
              name: "__oldValue",
              type: Object
            }
          });
        }
      }]);
      return _class;
    }((0, _richTextEditorButton.RichTextEditorButtonBehaviors)(SuperClass));
  };
  /**
   * `rich-text-editor-prompt-button`
   * prompts for more information for rich text editor
   * (custom buttons can extend RichTextEditorPromptButtonBehaviors)
   *
   * @extends RichTextEditorPromptButtonBehaviors
   * @extends LitElement
   * @customElement
   * @lit-html
   * @lit-element
   * @element rich-text-editor-prompt-button
   * @demo ./demo/buttons.html
   */


  _exports.RichTextEditorPromptButtonBehaviors = RichTextEditorPromptButtonBehaviors;

  var RichTextEditorPromptButton = /*#__PURE__*/function (_RichTextEditorPrompt) {
    babelHelpers.inherits(RichTextEditorPromptButton, _RichTextEditorPrompt);

    var _super2 = _createSuper(RichTextEditorPromptButton);

    function RichTextEditorPromptButton() {
      babelHelpers.classCallCheck(this, RichTextEditorPromptButton);
      return _super2.apply(this, arguments);
    }

    return babelHelpers.createClass(RichTextEditorPromptButton);
  }(RichTextEditorPromptButtonBehaviors(_index.LitElement));

  _exports.RichTextEditorPromptButton = RichTextEditorPromptButton;
  customElements.define(RichTextEditorPromptButton.tag, RichTextEditorPromptButton);
});