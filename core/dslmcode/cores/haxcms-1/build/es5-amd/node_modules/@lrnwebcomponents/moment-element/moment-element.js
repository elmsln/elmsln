define(["exports", "meta", "../../lit/index.js", "../es-global-bridge/es-global-bridge.js"], function (_exports, meta, _index, _esGlobalBridge) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.MomentElement = void 0;
  meta = _interopRequireWildcard(meta);

  var _templateObject_715c5350809211edaa2833647dc78c6c;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @license
   * Copyright (c) 2016 Abdón Rodríguez Davila (@abdonrd). All rights reserved.
   * This code may only be used under the MIT style license found at https://abdonrd.github.io/LICENSE.txt
   */

  /**
  Polymer element wrapper for the [moment](https://github.com/moment/moment) library.
  
  Examples:
  
      <moment-element></moment-element>
      <moment-element datetime="1991-12-31" output-format="MMM DD[,] YYYY"></moment-element>
  
  * @demo demo/index.html
  */
  var MomentElement = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(MomentElement, _LitElement);

    var _super = _createSuper(MomentElement);

    function MomentElement() {
      var _this;

      babelHelpers.classCallCheck(this, MomentElement);
      _this = _super.call(this);
      _this.datetime = new Date();
      _this.inputFormat = "";
      _this.outputFormat = "";
      _this.from = "";
      _this.to = "";
      var location = new URL("./lib/moment/moment.js", meta.url).href;
      window.addEventListener("es-bridge-moment-loaded", _this._momentLoaded.bind(babelHelpers.assertThisInitialized(_this)));
      window.ESGlobalBridge.requestAvailability().load("moment", location);
      return _this;
    }

    babelHelpers.createClass(MomentElement, [{
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_715c5350809211edaa2833647dc78c6c || (_templateObject_715c5350809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral([" ", " "])), this.output);
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        changedProperties.forEach(function (oldValue, propName) {
          var notifiedProps = ["output"];

          if (notifiedProps.includes(propName)) {
            // notify
            var eventName = "".concat(propName.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase(), "-changed");

            _this2.dispatchEvent(new CustomEvent(eventName, {
              detail: {
                value: _this2[propName]
              }
            }));
          }

          if (["datetime", "inputFormat", "outputFormat", "from", "to", "libraryLoaded"].includes(propName)) {
            _this2.output = _this2._computeOutput(_this2.datetime, _this2.inputFormat, _this2.outputFormat, _this2.from, _this2.to, _this2.libraryLoaded);
          }
        });
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("es-bridge-moment-loaded", this._momentLoaded.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(MomentElement.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "_momentLoaded",
      value: function _momentLoaded() {
        this.libraryLoaded = true;
      }
    }, {
      key: "_computeOutput",
      value: function _computeOutput(datetime, inputFormat, outputFormat, from, to, libraryLoaded) {
        if (libraryLoaded) {
          var output = inputFormat ? moment(datetime, inputFormat) : moment(datetime);

          if (outputFormat) {
            output = output.format(outputFormat);
          } else if (from) {
            output = from === "now" ? output.fromNow() : output.from(moment(from));
          } else if (to) {
            output = to === "now" ? output.toNow() : output.to(moment(to));
          }

          return output;
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "moment-element";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          datetime: {
            type: String
          },
          inputFormat: {
            type: String,
            attribute: "input-format"
          },
          outputFormat: {
            type: String,
            attribute: "output-format"
          },
          from: {
            type: String
          },
          to: {
            type: String
          },
          output: {
            type: String
          },
          libraryLoaded: {
            type: Boolean
          }
        };
      }
    }]);
    return MomentElement;
  }(_index.LitElement);

  _exports.MomentElement = MomentElement;
  customElements.define(MomentElement.tag, MomentElement);
});