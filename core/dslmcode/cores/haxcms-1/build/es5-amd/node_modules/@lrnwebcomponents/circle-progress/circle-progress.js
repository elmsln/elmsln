define(["exports", "../../@polymer/polymer/polymer-element.js", "../../@polymer/paper-styles/paper-styles.js", "../../@polymer/iron-flex-layout/iron-flex-layout.js", "../../@polymer/iron-resizable-behavior/iron-resizable-behavior.js", "../../@polymer/polymer/lib/legacy/class.js"], function (_exports, _polymerElement, _paperStyles, _ironFlexLayout, _ironResizableBehavior, _class) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.CircleProgress = void 0;

  var _templateObject_63f40370809211edaa2833647dc78c6c;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `circle-progress`
   * `Polymer-based web component displaying a circular progress bar.`
   *
   * @demo demo/index.html
   * @element circle-progress
   */
  var CircleProgress = /*#__PURE__*/function (_mixinBehaviors) {
    babelHelpers.inherits(CircleProgress, _mixinBehaviors);

    var _super = _createSuper(CircleProgress);

    function CircleProgress() {
      var _this;

      babelHelpers.classCallCheck(this, CircleProgress);
      _this = _super.call(this);
      setTimeout(function () {
        _this.addEventListener("iron-resize", _this._onIronResize.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      return _this;
    }

    babelHelpers.createClass(CircleProgress, [{
      key: "_computeDashArray",
      value: function _computeDashArray(radius) {
        return 2 * Math.PI * radius;
      }
    }, {
      key: "_computeDashOffset",
      value: function _computeDashOffset(value, max, dasharray) {
        return (1 - value / max) * dasharray;
      }
    }, {
      key: "_computeRadius",
      value: function _computeRadius(cx, cy, strokeWidth) {
        return cx && cy ? Math.max(0, Math.min(cx, cy) - strokeWidth / 2) : 0;
      }
    }, {
      key: "_computeTransform",
      value: function _computeTransform(angle, cx, cy) {
        return cx && cy ? "rotate(" + angle + ", " + cx + ", " + cy + ")" : "";
      }
    }, {
      key: "_onIronResize",
      value: function _onIronResize() {
        if (this.offsetWidth && this.offsetHeight) {
          this._cx = this.offsetWidth / 2;
          this._cy = this.offsetHeight / 2;
          this.shadowRoot.querySelector("#circle").style.display = "block";
        }
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_63f40370809211edaa2833647dc78c6c || (_templateObject_63f40370809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"paper-material-styles\">\n        :host {\n          @apply --layout-vertical;\n          @apply --layout-center-center;\n          position: relative;\n          width: var(--circle-progress-width, 64px);\n          height: var(--circle-progress-height, 64px);\n          margin: 24px;\n          border-radius: 50%;\n        }\n        svg {\n          position: absolute;\n          top: 0;\n          left: 0;\n          display: none;\n        }\n        .circle-background {\n          stroke: var(--circle-progress-bg-stroke-color, --paper-grey-100);\n        }\n        .circle-foreground {\n          transition: stroke-dashoffset var(--circle-progress-transition, 150ms);\n          stroke: var(--circle-progress-stroke-color, blue);\n          stroke-linecap: var(--circle-progress-stroke-linecap, round);\n        }\n      </style>\n\n      <svg id=\"circle\" width=\"100%\" height=\"100%\">\n        <circle\n          class=\"circle-background\"\n          r$=\"[[_radius]]\"\n          cx$=\"[[_cx]]\"\n          cy$=\"[[_cy]]\"\n          fill=\"transparent\"\n          stroke-width$=\"[[strokeWidth]]\"\n        ></circle>\n        <circle\n          class=\"circle-foreground\"\n          r$=\"[[_radius]]\"\n          cx$=\"[[_cx]]\"\n          cy$=\"[[_cy]]\"\n          fill=\"transparent\"\n          stroke-width$=\"[[strokeWidth]]\"\n          stroke-dasharray$=\"[[_dasharray]]\"\n          stroke-dashoffset$=\"[[_dashoffset]]\"\n          transform$=\"[[_transform]]\"\n        ></circle>\n      </svg>\n      <slot></slot>\n    "])));
      }
    }, {
      key: "tag",
      get: function get() {
        return "circle-progress";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(CircleProgress), "properties", this)), {}, {
          /**
           * Value of circular progress bar.
           */
          value: {
            name: "value",
            type: Number,
            value: 0
          },

          /**
           * Maximum of value.
           */
          max: {
            name: "max",
            type: Number,
            value: 100
          },

          /**
           * Stroke width of circle.
           */
          strokeWidth: {
            name: "strokeWidth",
            type: Number,
            value: 4
          },

          /**
           * Starting angle of the progress.
           */
          angle: {
            name: "angle",
            type: Number,
            value: -90
          },
          _cx: {
            name: "_cx",
            type: Number,
            value: null
          },
          _cy: {
            name: "_cy",
            type: Number,
            value: null
          },
          _radius: {
            name: "_radius",
            type: Number,
            computed: "_computeRadius(_cx, _cy, strokeWidth)"
          },
          _transform: {
            name: "_transform",
            type: String,
            computed: "_computeTransform(angle, _cx, _cy)"
          },
          _dasharray: {
            name: "_dasharray",
            type: Number,
            computed: "_computeDashArray(_radius)"
          },
          _dashoffset: {
            name: "_dashoffset",
            type: Number,
            computed: "_computeDashOffset(value, max, _dasharray)"
          }
        });
      }
    }]);
    return CircleProgress;
  }((0, _class.mixinBehaviors)([_ironResizableBehavior.IronResizableBehavior], _polymerElement.PolymerElement));

  _exports.CircleProgress = CircleProgress;
  customElements.define(CircleProgress.tag, CircleProgress);
});