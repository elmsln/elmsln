define(["exports", "./haxcms-site-store.js", "../../../../mobx/dist/mobx.esm.js", "../../../utils/utils.js", "../../../simple-colors-shared-styles/simple-colors-shared-styles.js", "../../../anchor-behaviors/anchor-behaviors.js"], function (_exports, _haxcmsSiteStore, _mobxEsm, _utils, _simpleColorsSharedStyles, _anchorBehaviors) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSThemeWiring = _exports.HAXCMSTheme = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function localStorageGet(name) {
    try {
      return localStorage.getItem(name);
    } catch (e) {
      return false;
    }
  }

  function localStorageSet(name, newItem) {
    try {
      return localStorage.setItem(name, newItem);
    } catch (e) {
      return false;
    }
  }
  /**
   * `HAXCMSTheme` mixin class to automatically apply HAXcms theme state
   * Typically an element will be extended from this and while not all,
   * many will want to customize the `contentContainer` property in order
   * to ensure the editable layer is correctly applied visually.
   *
   * This will then need a rendering helper library to make work
   */


  var HAXCMSTheme = function HAXCMSTheme(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);

      var _super = _createSuper(_class);

      // leverage the wiring class element; this helps us clean things up smoothly later
      // while still keeping it abstract enough for direct usage in PolymerLegacy elements
      // as well as those wanting a custom integration methodology
      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this); // a bucket for settings that can be for reusable
        // functionality across themes yet they might want
        // to opt in / out

        _this.HAXCMSThemeSettings = {
          // should we scroll to the top when a new page
          // is selected
          autoScroll: false,
          scrollTarget: window
        };
        _this.__disposer = _this.__disposer ? _this.__disposer : [];
        _this.HAXCMSThemeWiring = new HAXCMSThemeWiring(babelHelpers.assertThisInitialized(_this));
        return _this;
      }
      /**
       * This is a render function example. All new HAXcms capable themes need
       * to define a contentcontainer and a slot id wrapper. this allows HAXcms
       * to correctly target the area that will display the HAXeditor when in
       * edit-mode and correctly hide the editor when in normal content presentation.
       * static get template() {
       *  return html`
       *  <style include="simple-colors-shared-styles-polymer">
       *   :host {
       *     display: block;
       *     background-color: var(--haxcms-color, white);
       *   }
       *   :host([edit-mode]) #slot {
       *     display: none;
       *   }
       *  </style>
       *  <div id="contentcontainer">
       *    <div id="slot"><slot></slot></div>
       *  </div>`;
       *  }
       */


      babelHelpers.createClass(_class, [{
        key: "_colorChanged",
        value: function _colorChanged(newValue) {
          if (newValue) {
            this.hexColor = this._getHexColor(newValue);
          }
        }
        /**
         * Convert color name to HEX
         */

      }, {
        key: "_getHexColor",
        value: function _getHexColor(color) {
          // legacy support for materializeCSS names
          var name = color.replace("-text", "");
          var colors = window.SimpleColorsStyles.colors;

          if (colors[name]) {
            return colors[name][6];
          }

          return "#000000";
        }
        /**
         * notice edit changed, make sure we fake a resize because of that container flyout
         */

      }, {
        key: "_editModeChanged",
        value: function _editModeChanged(newValue, oldValue) {
          if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            // ensure global is kept in sync
            _haxcmsSiteStore.store.editMode = newValue;

            this.__styleReapply();
          }
        }
        /**
         * private: Notice content container has changed
         */

      }, {
        key: "_contentContainerChanged",
        value: function _contentContainerChanged(newValue, oldValue) {
          // test that this hasn't been connected previously
          if (newValue && (babelHelpers.typeof(oldValue) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) || oldValue == null)) {
            this.HAXCMSThemeWiring.connect(this, newValue);
          } // previously connected, needs to change to new connection
          // this is an edge case at best...
          else if (newValue && oldValue) {
              this.HAXCMSThemeWiring.disconnect(this);
              this.HAXCMSThemeWiring.connect(this, newValue);
            } // no longer connected
            else if (oldValue && newValue == null) {
                this.HAXCMSThemeWiring.disconnect(this);
              }
        }
      }, {
        key: "_locationChanged",
        value: function _locationChanged(newValue, oldValue) {
          if (!newValue || typeof newValue.route === "undefined") return;
          var location = newValue;
          var name = location.route.name;

          if (name == "home" || name == "404") {
            // if we are on the homepage then load the first item in the manifest
            // and set it active
            var firstItem = _haxcmsSiteStore.store.routerManifest.items.find(function (i) {
              return typeof i.id !== "undefined";
            });

            if (firstItem) {
              _haxcmsSiteStore.store.activeId = firstItem.id;
            }
          }

          if (this.HAXCMSThemeSettings.autoScroll && oldValue) {
            if (newValue.hash != oldValue.hash && newValue.hash) {
              var target = document.querySelector(newValue.hash); // we have to delay here because the URL event of hash change hasn't executed
              // this is our store telling us we are about to modify the href

              if (target) {
                setTimeout(function () {
                  target.scrollIntoView({
                    behavior: "smooth",
                    block: "start",
                    inline: "nearest"
                  });
                }, 0);
              }
            } else {
              this.HAXCMSThemeSettings.scrollTarget.scrollTo({
                top: 0,
                left: 0
              }); // @todo hacky timing thing

              setTimeout(function () {
                // try scrolling to the target ID after content gets imported
                window.AnchorBehaviors.getTarget(_haxcmsSiteStore.store.themeElement);
              }, 1000);
            }
          }
        }
        /**
         * Connect state and theme wiring
         */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          var _this2 = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "connectedCallback", this).call(this); // edge case, we just swapped theme faster then content loaded... lol

          setTimeout(function () {
            if (_this2.childNodes.length === 0) {
              var frag = document.createRange().createContextualFragment(_haxcmsSiteStore.store.activeItemContent);

              _this2.appendChild(frag);
            }

            _this2.__styleReapply();
          }, 50); // keep activeItemContent in sync globally

          (0, _mobxEsm.autorun)(function (reaction) {
            _this2.activeItemContent = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.activeItemContent);
            setTimeout(function () {
              if (_this2.HAXCMSThemeSettings.autoScroll) {
                _this2.HAXCMSThemeSettings.scrollTarget.scrollTo({
                  top: 0,
                  left: 0
                });

                setTimeout(function () {
                  // try scrolling to the target ID after content gets imported
                  window.AnchorBehaviors.getTarget(_haxcmsSiteStore.store.themeElement);
                }, 500);
              }
            }, 10);

            _this2.__disposer.push(reaction);
          }); // keep editMode in sync globally

          (0, _mobxEsm.autorun)(function (reaction) {
            _this2.editMode = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.editMode);

            _this2.__disposer.push(reaction);
          }); // logged in so we can visualize things differently as needed

          (0, _mobxEsm.autorun)(function (reaction) {
            _this2.isLoggedIn = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.isLoggedIn);

            _this2.__disposer.push(reaction);
          }); // store disposer so we can clean up later

          (0, _mobxEsm.autorun)(function (reaction) {
            var __manifest = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.manifest);

            if (__manifest && (0, _utils.varExists)(__manifest, "title")) {
              document.title = __manifest.title;
            }

            if (__manifest && (0, _utils.varExists)(__manifest, "metadata.theme.variables.cssVariable")) {
              // json outline schema changed, allow other things to react
              // fake way of forcing an update of these items
              var ary = __manifest.metadata.theme.variables.cssVariable.replace("--simple-colors-default-theme-", "").split("-");

              ary.pop(); // simple colors "accent color" property

              _this2.accentColor = ary.join("-");
              var color = (0, _utils.varGet)(__manifest, "metadata.theme.variables.cssVariable", null); // fallback if color wasn't set via css var

              if (color == null) {
                color = (0, _utils.varGet)(__manifest, "metadata.theme.variables.hexCode", "#ff0074");
              } else {
                color = "var(".concat(color, ")");
              } // set this directly instead of messing w/ accentColor


              document.body.style.setProperty("--haxcms-color", color);
            }

            _this2.__disposer.push(reaction);
          });
          (0, _mobxEsm.autorun)(function (reaction) {
            _this2._location = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.location);

            _this2.__disposer.push(reaction);
          });
        }
      }, {
        key: "__styleReapply",
        value: function __styleReapply() {
          // trick browser into thinking we just reized
          window.dispatchEvent(new Event("resize"));
        }
        /**
         * Disconnect the wiring for the theme and clean up state
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          // remove our content container var which will disconnect the wiring
          delete this.contentContainer; // clean up state

          for (var i in this.__disposer) {
            this.__disposer[i].dispose();
          }

          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);
        }
        /**
         * Correctly reset state and dispatch event to notify of active item change
         */

      }, {
        key: "resetActive",
        value: function resetActive() {
          window.history.pushState(null, null, _haxcmsSiteStore.store.location.baseUrl);
          window.dispatchEvent(new PopStateEvent("popstate"));
          this.dispatchEvent(new CustomEvent("haxcms-active-item-changed", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: {}
          }));
        }
      }]);
      return _class;
    }(SuperClass);
  };
  /**
   * `HAXCMSThemeWiring` streamline hooking themes up to HAXCMS
   * Directly invoking this class is not advised unless
   * the mixin class `HAXCMSTheme` integration needs modified beyond the norm
   */


  _exports.HAXCMSTheme = HAXCMSTheme;

  var HAXCMSThemeWiring = /*#__PURE__*/function () {
    function HAXCMSThemeWiring(element) {
      var load = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      babelHelpers.classCallCheck(this, HAXCMSThemeWiring);
      window.SimpleColorsSharedStyles.requestAvailability();

      if (load) {
        // @todo may want to set this to sessionStorage instead...
        if (localStorageGet("HAXCMSSystemData") == null) {
          localStorageSet("HAXCMSSystemData", JSON.stringify({}));
        }
      }
    }
    /**
     * connect the theme and see if we have an authoring experience to inject correctly
     */


    babelHelpers.createClass(HAXCMSThemeWiring, [{
      key: "connect",
      value: function connect(element, injector) {
        window.addEventListener("haxcms-active-item-changed", this._activeItemUpdate.bind(element));
        window.addEventListener("haxcms-edit-mode-changed", this._globalEditChanged.bind(element));
        window.addEventListener("haxcms-trigger-update", this._triggerUpdate.bind(element)); // inject the tools to allow for an authoring experience
        // ensuring they are loaded into the correct theme

        _haxcmsSiteStore.store.cmsSiteEditorAvailability();

        _haxcmsSiteStore.store.cmsSiteEditor.instance.appElement = element;
        _haxcmsSiteStore.store.cmsSiteEditor.instance.appendTarget = injector;

        _haxcmsSiteStore.store.cmsSiteEditor.instance.appendTarget.appendChild(_haxcmsSiteStore.store.cmsSiteEditor.instance);
      }
      /**
       * detatch element events from whats passed in
       */

    }, {
      key: "disconnect",
      value: function disconnect(element) {
        window.removeEventListener("haxcms-active-item-changed", this._activeItemUpdate.bind(element));
        window.removeEventListener("haxcms-edit-mode-changed", this._globalEditChanged.bind(element));
        window.removeEventListener("haxcms-trigger-update", this._triggerUpdate.bind(element)); // need to unplug this so that the new theme can pick it up.

        document.body.appendChild(_haxcmsSiteStore.store.cmsSiteEditorAvailability());
      }
      /**
       * Global edit state changed
       */

    }, {
      key: "_globalEditChanged",
      value: function _globalEditChanged(e) {
        this.editMode = e.detail;
      }
      /**
       * HAXcms: Active item has been updated
       */

    }, {
      key: "_activeItemUpdate",
      value: function _activeItemUpdate(e) {
        var newValue = e.detail;

        if (newValue && babelHelpers.typeof(newValue.id) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // dispatch to the store
          _haxcmsSiteStore.store.activeId = newValue.id; // dispatch to everything else caring

          var evt = new CustomEvent("json-outline-schema-active-item-changed", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: newValue
          });
          this.dispatchEvent(evt); // update title as a simple nicity

          if (babelHelpers.typeof(newValue.title) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            document.title = _haxcmsSiteStore.store.routerManifest.title + " - " + newValue.title;
          } else {
            document.title = _haxcmsSiteStore.store.routerManifest.title;
          }
        } else {
          document.title = _haxcmsSiteStore.store.routerManifest.title;
        }
      }
      /**
       * Generic event to ensure that the active item change is noticed
       */

    }, {
      key: "_triggerUpdate",
      value: function _triggerUpdate(e) {
        this.dispatchEvent(new CustomEvent("haxcms-active-item-changed", {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {}
        }));
      }
    }]);
    return HAXCMSThemeWiring;
  }();

  _exports.HAXCMSThemeWiring = HAXCMSThemeWiring;
});