define(["../../../@polymer/polymer/lib/utils/wrap.js","../../../@polymer/polymer/lib/utils/async.js"],function(_wrap,async){"use strict";async=babelHelpers.interopRequireWildcard(async);var _obj;/**
 * `window.MaterialProgressBehavior` is the base behavior for all `material-progress`
 * elements.
 * @polymerBehavior window.MaterialProgressBehavior
 */window.MaterialProgressBehaviorImpl=_obj={properties:{/**
     * Height of the bar and bars, in pixels.
     */barHeight:{type:Number,value:22,observer:"_refresh"},/**
     * Animate when the size of a bar changes.
     */animated:{type:Boolean,value:!1,reflectToAttribute:!0},/**
     * Label to display before the legend.
     */legendLabel:{type:String,value:"",observer:"_refresh"},/**
     * The displayed bar nodes (ie direct children with
     * the `bar` class and a `data-value` attribute).
     */bars:{type:Array,value:function value(){return[]},notify:!0,readOnly:!0},/**
     * Sum of all the bars' values.
     */sum:{type:Number,value:0,notify:!0,readOnly:!0,reflectToAttribute:!0},/**
     * The legend items to be displayed: Each is composed of the following
     * attributes :
     * - `label`: match the `data-legend` attribute of the corresponding bar.
     * - `color`: match the css `background-color` of the corresponding bar.
     */_legendItems:{type:Array,value:function value(){return[]},readOnly:!0},/**
     * Indicates if the legend needs to be displayed.
     */_legendNeeded:{type:Boolean,value:!1,compute:"_computeLegendNeeded(_legendItems)",readOnly:!0}},listeners:{"dom-mutation":"refresh"},/**
   * Refresh the element.
   */refresh:function refresh(){if(this._attached){// Reading and computing fundamental data
this._computeSumAndBars();var i,index,bar,barMeta,foundOneValue=!1,animationDelay=600/(this.bars.length-1);// Legend initialization
this.splice("_legendItems",0,this._legendItems.length);if(this.legendLabel){this.push("_legendItems",{label:this.legendLabel})}// Computing each bar
if(this.bars){for(i=this.bars.length-1,index=this._barWithValueCount-1;0<=i;i--){bar=this.bars[i];barMeta=this._getBarMeta(bar);// Sizing/Styling
this.toggleClass("visible",0<barMeta.value,bar);this.toggleClass("last",0<barMeta.value&&!foundOneValue,bar);bar.style.width=0<this.bars.length?this._getWidthForBar(barMeta.value,this.sum,this._maxBarValue,this.barHeight):"0px";bar.style.zIndex=this.bars.length-i;if(0<barMeta.value){foundOneValue=!0;// Entry animation
if(!this._initialized){this._playFirstAnimation(bar,index,animationDelay)}index--}// Legend shown if value > 0 or if forced
if(barMeta.legend&&(0<barMeta.value||barMeta.legendAlwaysVisible)){this.splice("_legendItems",1,0,{label:barMeta.legend,color:window.getComputedStyle(bar).backgroundColor})}}}// Update Polymer's custom styles
if(!this._oldBarHeight||this._oldBarHeight!==this.barHeight){this.customStyle["--material-progress-bar-height"]=this.barHeight+"px";this.updateStyles();this._oldBarHeight=this.barHeight}this._initialized=foundOneValue}},ready:function ready(){babelHelpers.get(babelHelpers.getPrototypeOf(_obj),"ready",this).call(this);// Setting up the mutation observer
this._mutationOptions={childList:!0,subtree:!0,attributes:!0,characterData:!1,attributeFilter:["data-value","data-legend","data-legend-always-visible"]};this._mutationFilter=function(mutation){// We only want to listen to mutations (addition, removal, attribute change)
// of the direct children of the bar's container
return this._mutationIsChildList(mutation,this.shadowRoot.querySelector("#barsContainer"))||this._mutationIsChildAttributes(mutation,this.shadowRoot.querySelector("#barsContainer"))}},connectedCallback:function connectedCallback(){babelHelpers.get(babelHelpers.getPrototypeOf(_obj),"connectedCallback",this).call(this);this._attached=!0;this._refresh()},_refresh:function _refresh(){this.debounce("refresh",this.refresh,10)},getDistributedNodes:function getDistributedNodes(node){return"slot"===node.localName?(0,_wrap.wrap)(node).assignedNodes({flatten:!0}):[]},_computeSumAndBars:function _computeSumAndBars(){var sum=0,value=0,withValueCount=0,max=0,validBars=[],allChildren=this.getDistributedNodes(this.shadowRoot.querySelector("#content"));if(allChildren){allChildren.forEach(function(child){if(child.classList&&child.classList.contains("bar")&&child.hasAttribute("data-value")){validBars.push(child);value=this._getBarMeta(child).value;sum+=value;withValueCount+=0<value?1:0;max=Math.max(max,value)}},this)}this._setBars(validBars);this._setSum(sum);this._maxBarValue=max;this._barWithValueCount=withValueCount;return sum},_getBarMeta:function _getBarMeta(bar){var meta={value:0,legend:void 0},val;if(bar&&bar.getAttribute){val=+bar.getAttribute("data-value");meta.value=isNaN(val)?0:Math.max(0,val);meta.legend=bar.getAttribute("data-legend");meta.legendAlwaysVisible=bar.hasAttribute("data-legend-always-visible")}return meta},_getWidthForBar:function _getWidthForBar(barValue,barValuesSum,maxBarValue,barHeight){// To implement
return"0px"},_playFirstAnimation:function _playFirstAnimation(node,index,animationDelay){var _this=this;this.toggleClass("entry",!0,node);(function(node,index,animationDelay){async.microTask.run(function(){_this.toggleClass("entry",!1,node)},500+animationDelay*index)})},_computeLegendNeeded:function _computeLegendNeeded(legendItems){return legendItems&&0<legendItems.length}};/** @polymerBehavior */window.MaterialProgressBehavior=[window.MaterialProgressBehaviorImpl]});