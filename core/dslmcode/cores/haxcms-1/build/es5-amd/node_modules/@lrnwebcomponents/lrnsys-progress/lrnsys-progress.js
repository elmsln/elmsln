define(["exports", "meta", "../../@polymer/polymer/polymer-element.js", "../simple-progress/simple-progress.js", "./lib/lrnsys-progress-circle.js"], function (_exports, meta, _polymerElement, _simpleProgress, _lrnsysProgressCircle) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LrnsysProgress = void 0;
  meta = _interopRequireWildcard(meta);

  var _templateObject_1ecac290942811ecb1937969798b231a;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `lrnsys-progress`
   * @element lrnsys-progress
   * `track progression as a circle and series of circles`
   *
   * @demo demo/index.html
   * @microcopy
   *  - node / circle - A progress circle on the line
   *  - nodes / items - the list of items in the progress bar
   *  - bubble - reserved for when events fire out of an element or value is tracking events
   *  - percentage - amount complete either in the bar or the nodes themselves
   *  - bar - the underlayed bar that's tracking overall progression
   */
  var LrnsysProgress = /*#__PURE__*/function (_PolymerElement) {
    babelHelpers.inherits(LrnsysProgress, _PolymerElement);

    var _super = _createSuper(LrnsysProgress);

    function LrnsysProgress() {
      var _this;

      babelHelpers.classCallCheck(this, LrnsysProgress);
      _this = _super.call(this);
      _this.completeSound = new URL("./", meta.url).href + "lib/assets/complete.mp3";
      _this.finishedSound = new URL("./", meta.url).href + "lib/assets/finished.mp3";
      return _this;
    }

    babelHelpers.createClass(LrnsysProgress, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(LrnsysProgress.prototype), "connectedCallback", this).call(this);
        this.addEventListener("node-is-active", this._bubbleUpChangeActive.bind(this));
        this.addEventListener("node-status-change", this._statusChanged.bind(this));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.removeEventListener("node-is-active", this._bubbleUpChangeActive.bind(this));
        this.removeEventListener("node-status-change", this._statusChanged.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(LrnsysProgress.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "_getStrokeWidth",
      value:
      /**
       * Set an appropriate stroke width based on size of the element.
       * This is because it's a hard pixel value when the rest of our
       * sizing is based on em's
       */
      function _getStrokeWidth(size) {
        var width = 4;

        if (size == "tiny") {
          width = 3;
        } else if (size == "small") {
          width = 4;
        } else if (size == "medium") {
          width = 5;
        } else if (size == "large") {
          width = 6;
        } else if (size == "x-large") {
          width = 7;
        } else if (size == "epic") {
          width = 8;
        }

        return width;
      }
      /**
       * Fire event that state has changed with what the statement is.
       * This gives a readable name to what the state is of the progress bar
       * as well as access to the full item that triggered the state change.
       */

    }, {
      key: "_reportState",
      value: function _reportState(newValue, oldValue) {
        // help avoid initial ready state being null
        if (newValue != null && this.items.length > 0) {
          this.dispatchEvent(new CustomEvent("progress-state-change", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              state: this.state,
              active: this.items[this.active]
            }
          }));
        }
      }
      /**
       * Notice items have changed; only worry about if the count changes
       * though since other oberservers handle downstream mutation
       */

    }, {
      key: "_itemsChanged",
      value: function _itemsChanged(newValue, oldValue) {
        var _this2 = this;

        // strange but this is effectively the same as "ready" except the ready
        // state invokes potentially without items while this one will only
        // match a case where there was no values and now we have one
        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue.length != oldValue.length && babelHelpers.typeof(this._responseList[this.active]) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          newValue[this.active].metadata.status = "loading";
          this.set("items." + this.active + ".metadata.status", "loading");
          this.notifyPath("items." + this.active + ".metadata.status"); // becasue this is so early in bootstrap of the element we
          // won't be able to detect the initial loading event

          if (babelHelpers.typeof(newValue[this.active].dataUrl) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && !this.disableAjaxCalls) {
            this.shadowRoot.querySelector("#ajax").url = newValue[this.active].dataUrl;
            this.shadowRoot.querySelector("#ajax").generateRequest();
          } else {
            setTimeout(function () {
              newValue[_this2.active].metadata.status = "available";

              _this2.set("items." + _this2.active + ".metadata.status", "available");

              _this2.notifyPath("items." + _this2.active + ".metadata.status");

              _this2._responseList[_this2.active] = {};
              _this2.activeNodeResponse = _this2._responseList[_this2.active];
            }, 1200);
          }
        }
      }
      /**
       * Simple boolean for whatever is active currently.
       */

    }, {
      key: "_isActive",
      value: function _isActive(index, active) {
        return index === active;
      }
      /**
       * Active Response changed; bubble it up.
       */

    }, {
      key: "_activeResponseChanged",
      value: function _activeResponseChanged(value) {
        this.dispatchEvent(new CustomEvent("progress-response-loaded", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            response: value
          }
        }));
      }
      /**
       * Notice event from the nodes themselves
       * and set active based on a node bubbling up an event
       * that says "Hey I am active now!"
       */

    }, {
      key: "_bubbleUpChangeActive",
      value: function _bubbleUpChangeActive(e) {
        // changing active will kick off events internally
        this.active = e.detail.target.step;
        this.dispatchEvent(new CustomEvent("json-outline-schema-active-item-changed", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: this.items[this.active]
        }));
      }
      /**
       * Allow for JSON Outline Schema manifest structure changes
       */

    }, {
      key: "_manifestChanged",
      value: function _manifestChanged(newValue, oldValue) {
        if (newValue) {
          this.set("items", newValue.items);
          this.notifyPath("items.*");
        }
      }
      /**
       * Active item has changed, set the rest of the data to match.
       */

    }, {
      key: "_activeChanged",
      value: function _activeChanged(newValue, oldValue) {
        var _this3 = this;

        // bubble up event from state being set
        this.state = "active item is " + this.active;
        this.items.forEach(function (element, index, array) {
          // if the current item is disabled, check the 1 prior to it if we can
          if (_this3.items[index].metadata.status == "disabled") {
            // do nothing, it's disabled unless....
            if (index != 0 && _this3.progressiveUnlock && _this3.items[index - 1].metadata.status == "complete") {
              _this3.items[index].metadata.status = "loading";

              _this3.set("items." + index + ".metadata.status", "loading");

              _this3.notifyPath("items." + index + ".metadata.status");
            }
          } // or if our value is at max AND it's the last item in the list
          else if (_this3.items[index].metadata.value >= _this3.items[index].metadata.max && index == _this3.items.length - 1) {
              _this3.items[index].metadata.status = "finished";

              _this3.set("items." + index + ".metadata.status", "finished");

              _this3.notifyPath("items." + index + ".metadata.status");
            } // or if we're just at max then mark us complete
            else if (_this3.items[index].metadata.value >= _this3.items[index].metadata.max) {
                _this3.items[index].metadata.status = "complete";

                _this3.set("items." + index + ".metadata.status", "complete");

                _this3.notifyPath("items." + index + ".metadata.status");
              } // or if the index is the currently active item
              else if (index == _this3.active) {
                  // see if we have the data for it already otherwise trigger loading
                  if (babelHelpers.typeof(_this3._responseList[index]) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    _this3.items[index].metadata.status = "loading";

                    _this3.set("items." + index + ".metadata.status", "loading");

                    _this3.notifyPath("items." + index + ".metadata.status");
                  } // if we already had a response, then mark available
                  else {
                      _this3.activeNodeResponse = _this3._responseList[index];
                      _this3.items[index].metadata.status = "available";

                      _this3.set("items." + index + ".metadata.status", "available");

                      _this3.notifyPath("items." + index + ".metadata.status");
                    }
                } else {
                  // we didn't match any cases, just leave it active
                  _this3.items[index].metadata.status = "available";

                  _this3.set("items." + index + ".metadata.status", "available");

                  _this3.notifyPath("items." + index + ".metadata.status");
                }
        });
      }
      /**
       * Listen for the state of anything below to change.
       */

    }, {
      key: "_statusChanged",
      value: function _statusChanged(e) {
        var _this4 = this;

        // we are in loading state so go load data and let the response
        // dictate what state we reach after that
        if (e.target.status == "loading") {
          if (babelHelpers.typeof(this.items[this.active].metadata.dataUrl) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && !this.disableAjaxCalls) {
            this.shadowRoot.querySelector("#ajax").url = this.items[this.active].metadata.dataUrl;
            this.shadowRoot.querySelector("#ajax").generateRequest();
          } else {
            setTimeout(function () {
              _this4.items[_this4.active].metadata.status = "available";

              _this4.set("items." + _this4.active + ".metadata.status", "available");

              _this4.notifyPath("items." + _this4.active + ".metadata.status");

              _this4._responseList[_this4.active] = {};
              _this4.activeNodeResponse = _this4._responseList[_this4.active];
            }, 1500);
          }
        } else if (e.target.status == "complete" && this.items.length === this.active + 1) {
          setTimeout(function () {
            _this4.items[_this4.active].metadata.status = "finished";

            _this4.set("items." + _this4.active + ".metadata.status", "finished");

            _this4.notifyPath("items." + _this4.active + ".metadata.status");
          }, 100);
        }
      }
      /**
       * Response returned from triggering the Node's URL to fire to get a response.
       */

    }, {
      key: "handleNodeResponse",
      value: function handleNodeResponse(e) {
        var _this5 = this;

        var detail = e.detail; // this means that it was an internal path, fake "loading"

        if (babelHelpers.typeof(detail.response) === babelHelpers.typeof(null)) {
          setTimeout(function () {
            _this5.items[_this5.active].metadata.status = "available";

            _this5.set("items." + _this5.active + ".metadata.status", "available");

            _this5.notifyPath("items." + _this5.active + ".metadata.status");

            _this5._responseList[_this5.active] = detail.response;
            _this5.activeNodeResponse = _this5._responseList[_this5.active];
          }, 1500);
        } // valid response, pass it along for other things to use
        else {
            this.items[this.active].metadata.status = "available";
            this.set("items." + this.active + ".metadata.status", "available");
            this.notifyPath("items." + this.active + ".metadata.status");
            this._responseList[this.active] = detail.response;
            this.activeNodeResponse = this._responseList[this.active];
          }
      }
      /**
       * Weak support for error code being found
       */

    }, {
      key: "_handleNodeError",
      value: function _handleNodeError(newValue, oldValue) {
        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue != null && newValue.length != 0) {
          // @todo, need support for a failed to load state; could be useful
          // if we go into an offline capability in the future
          this._responseList[this.active] = newValue;
          this.activeNodeResponse = this._responseList[this.active]; // set available because we don't have a failed state

          this.items[this.active].metadata.status = "available";
          this.set("items." + this.active + ".metadata.status", "available");
          this.notifyPath("items." + this.active + ".metadata.status"); // fire an event that this isn't really available so we know an issue occured

          this.dispatchEvent(new CustomEvent("node-load-failed", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: this.items[this.active]
          }));
        }
      }
      /**
       * Calculate the overall percentage competed.
       * This forms the line that's connecting the steps.
       */

    }, {
      key: "_overallPercentageCompute",
      value: function _overallPercentageCompute(items, active) {
        if (babelHelpers.typeof(items) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.shadowRoot.querySelector("#progress").classList.add("transiting");
          return active / (items.length - 1) * 100;
        }

        return 0;
      }
      /**
       * Change the percentage for the active item.
       */

    }, {
      key: "changePercentage",
      value: function changePercentage(percentage, mode) {
        var newp = 0; // support for adding and removing percentage as well as setting

        if (mode == "add") {
          newp = this.items[this.active].metadata.value + percentage;
        } else if (mode == "subtract") {
          newp = this.items[this.active].metadata.value - percentage;
        } else {
          newp = percentage;
        } // after establishing the new percentage, make sure it's less then max
        // if it's at or over max then we need to trigger events and state to change


        if (newp >= this.items[this.active].metadata.max) {
          if (this.items.length == this.active + 1) {
            // fire an event change to indicate that this happened
            this.state = "finished";
            this.items[this.active].metadata.status = "finished";
            this.set("items." + this.active + ".metadata.status", "finished");
            this.notifyPath("items." + this.active + ".metadata.status"); // need to make sure finished happens prior to value set to 100
            // otherwise this will kick off the circle to complete itself

            this.items[this.active].metadata.value = this.items[this.active].metadata.max;
            this.set("items." + this.active + ".metadata.value", this.items[this.active].metadata.max);
            this.notifyPath("items." + this.active + ".metadata.value");
          } else {
            // set value = max which will automatically trigger complete in the circle
            this.items[this.active].metadata.value = this.items[this.active].metadata.max;
            this.set("items." + this.active + ".metadata.value", this.items[this.active].metadata.max);
            this.notifyPath("items." + this.active + ".metadata.value");
          } // ensure we still have more items to go in the list


          if (this.items.length > this.active + 1) {
            // if we have progressive unlocking then set the next thing available
            // assuming that the next thing is currently disabled and that we're not
            // on the first item. OR, if we don't have a response for the current
            // item in local storage then let's mark loading to kick off the calls
            if (this.progressiveUnlock && this.items[this.active].metadata.status == "complete" && this.items[this.active + 1].metadata.status == "disabled" || babelHelpers.typeof(this._responseList[this.active + 1]) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              this.items[this.active + 1].metadata.status = "loading";
              this.set("items." + (this.active + 1) + ".metadata.status", "loading");
              this.notifyPath("items." + (this.active + 1) + ".metadata.status");
            } // set state so it gets reported upstream in events


            this.state = "active item is " + (this.active + 1); // bump active ahead 1 because we still have more items in the list

            this.active = this.active + 1;
          }
        } else {
          this.items[this.active].metadata.value = newp;
          this.set("items." + this.active + ".metadata.value", newp);
          this.notifyPath("items." + this.active + ".metadata.value");
        }
      }
      /**
       * Modify items and update template binding correctly.
       */

    }, {
      key: "updateItems",
      value: function updateItems(op, item) {
        var response = false;

        if (op == "push") {
          this.push("items", item);
          response = true;
        } else if (op == "pop") {
          response = this.pop("items");
        } else if (op == "splice") {
          this.splice("items", this.items.length, 0, item);
          response = true;
        } // force active to reprocess


        var active = this.active;
        this.set("active", 0);
        this.set("active", active);
        this.notifyPath("active");
        return response;
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_1ecac290942811ecb1937969798b231a || (_templateObject_1ecac290942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"paper-material-styles\">\n        :host {\n          display: block;\n          margin-top: 24px;\n        }\n        :host([size=\"tiny\"]) {\n          font-size: 12.8px;\n        }\n        :host([size=\"small\"]) {\n          font-size: 19.2px;\n        }\n        :host([size=\"medium\"]) {\n          font-size: 25.6px;\n        }\n        :host([size=\"large\"]) {\n          font-size: 44.8px;\n        }\n        :host([size=\"x-large\"]) {\n          font-size: 64px;\n        }\n        :host([size=\"epic\"]) {\n          font-size: 96px;\n        }\n        #circle-container {\n          display: flex;\n          justify-content: space-between;\n          margin: -24px 0 0 0;\n          padding: 0;\n          list-style: none;\n        }\n        .progress-title {\n          position: absolute !important;\n          clip: rect(1px 1px 1px 1px); /* IE6, IE7 */\n          clip: rect(1px, 1px, 1px, 1px);\n          overflow: hidden;\n          height: 1px;\n        }\n        simple-progress {\n          height: 8px;\n          --simple-progress-transition-duration: 0.5s;\n          --simple-progress-transition-timing-function: ease;\n          --simple-progress-transition-delay: 0.4s;\n          width: 100%;\n        }\n        /* required to get the box shadow above the progress bar */\n        .circle-node {\n          z-index: 1;\n        }\n        ul#circle-container li.circle-node {\n          list-style-type: none;\n        }\n\n        :host([vertical]) {\n          width: max-content;\n        }\n        :host([vertical]) #circle-container {\n          display: block;\n        }\n        :host([vertical]) simple-progress {\n          display: none !important;\n        }\n        :host([vertical]) lrnsys-progress-circle {\n          margin: 16px 0;\n          padding: 0;\n          width: 100%;\n        }\n\n        lrnsys-progress-circle {\n          width: 40px;\n          height: 40px;\n          --lrnsys-progress-circle-size: 40px;\n          --lrnsys-progress-spinner-size: 32px;\n          --lrnsys-progress-icon-size: 24px;\n          --paper-spinner-stroke-width: 1.2px;\n        }\n      </style>\n\n      <iron-ajax\n        id=\"ajax\"\n        url=\"[[activeNodeURL]]\"\n        handle-as=\"json\"\n        last-error=\"{{nodeDataError}}\"\n        on-response=\"handleNodeResponse\"\n      ></iron-ajax>\n      <h3 class=\"progress-title\">[[title]]</h3>\n      <simple-progress\n        id=\"progress\"\n        value=\"[[overallPercentage]]\"\n      ></simple-progress>\n      <ul id=\"circle-container\">\n        <template is=\"dom-repeat\" items=\"[[items]]\" as=\"item\">\n          <li class=\"circle-node\">\n            <lrnsys-progress-circle\n              play-finish-sound=\"[[soundFinish]]\"\n              play-sound=\"[[sound]]\"\n              complete-sound=\"[[completeSound]]\"\n              finished-sound=\"[[finishedSound]]\"\n              active=\"[[_isActive(index, active)]]\"\n              step=\"[[index]]\"\n              label=\"[[item.title]]\"\n              icon=\"[[item.metadata.icon]]\"\n              icon-complete=\"[[item.metadata.iconComplete]]\"\n              data-url=\"[[item.metadata.dataUrl]]\"\n              url=\"[[item.slug]]\"\n              status=\"[[item.metadata.status]]\"\n              value=\"[[item.metadata.value]]\"\n              max=\"[[item.metadata.max]]\"\n              stroke-width=\"[[strokeWidth]]\"\n              tool-tip=\"[[!vertical]]\"\n              list-view=\"[[vertical]]\"\n              class$=\"[[size]]\"\n            >\n              <span slot=\"description\">[[item.description]]</span>\n            </lrnsys-progress-circle>\n          </li>\n        </template>\n      </ul>\n    "])));
      }
    }, {
      key: "tag",
      get: function get() {
        return "lrnsys-progress";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Disable internal ajax calls as something is handling them above.
           */
          disableAjaxCalls: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },

          /**
           * Items to display to visualize the progression.
           */
          items: {
            type: Array,
            value: [],
            notify: true,
            observer: "_itemsChanged"
          },

          /**
           * Play sounds whenever an item is complete.
           * This can get pretty annoying though unless the items
           * won't be completed for awhile.
           */
          sound: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },

          /**
           * Play sound when the user finishes the progression. This
           * could also be annoying but far less so :)
           */
          soundFinish: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },

          /**
           * Play sound on complete.
           */
          completeSound: {
            type: String,
            reflectToAttribute: true
          },

          /**
           * Play sound on complete.
           */
          finishedSound: {
            type: String,
            reflectToAttribute: true
          },

          /**
           * Title of this progression, primarily for accessibility.
           */
          title: {
            type: String,
            value: "Steps to completion",
            reflectToAttribute: true
          },

          /**
           * Items displayed at specific points on the progression.
           * These aren't filled up but place points along the progression
           * which can help people see where they are relative to other
           * factors such as % complete as a tick mark or icon.
           */
          keyItems: {
            type: Array,
            value: [],
            notify: true
          },

          /**
           * ID of the active item.
           */
          active: {
            type: Number,
            value: 0,
            notify: true,
            reflectToAttribute: true,
            observer: "_activeChanged"
          },

          /**
           * Whether to automatically make disabled items available
           * or not when the previous one was just complete.
           */
          progressiveUnlock: {
            type: Boolean,
            value: true,
            reflectToAttribute: true,
            notify: true
          },

          /**
           * State of progress in the current progression
           */
          state: {
            type: String,
            value: null,
            reflectToAttribute: true,
            observer: "_reportState"
          },

          /**
           * How far is the user through this series of items.
           */
          overallPercentage: {
            type: Number,
            computed: "_overallPercentageCompute(items, active)",
            reflectToAttribute: true
          },

          /**
           * Responses for each item.
           */
          _responseList: {
            type: Array,
            value: []
          },

          /**
           * Active response from the node selected.
           */
          activeNodeResponse: {
            type: String,
            value: "",
            observer: "_activeResponseChanged"
          },

          /**
           * Active response from the node selected.
           */
          manifest: {
            type: Object,
            value: {},
            notify: true,
            observer: "_manifestChanged"
          },

          /**
           * Error.
           */
          nodeDataError: {
            type: Object,
            value: [],
            observer: "_handleNodeError"
          },

          /**
           * Flag to be vertical instead of horizontal.
           */
          vertical: {
            type: Boolean,
            value: false
          },

          /**
           * Size to make everything, small, medium, large, and epic
           * are available class names; default medium.
           */
          size: {
            type: String,
            value: "medium",
            notify: true,
            reflectToAttribute: true
          },

          /**
           * Calculate width based on the size since we have to convert em to px.
           */
          strokeWidth: {
            type: Number,
            computed: "_getStrokeWidth(size)"
          }
        };
      }
    }]);
    return LrnsysProgress;
  }(_polymerElement.PolymerElement);

  _exports.LrnsysProgress = LrnsysProgress;
  window.customElements.define(LrnsysProgress.tag, LrnsysProgress);
});