define(["exports", "../../lit/index.js"], function (_exports, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.JwtLogin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `jwt-login`
   * `a simple element to check for and fetch JWTs`
   * @demo demo/index.html
   * @microcopy - the mental model for this element
   * - jwt - a json web token which is an encrypted security token to talk
   * @element jwt-login
   */
  var JwtLogin = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(JwtLogin, _LitElement);

    var _super = _createSuper(JwtLogin);

    function JwtLogin() {
      var _this;

      babelHelpers.classCallCheck(this, JwtLogin);
      _this = _super.call(this);
      _this.auto = false;
      _this.method = "GET";
      _this.body = {};
      _this.key = "jwt";
      _this.jwt = null;
      _this.ready = false;
      return _this;
    }
    /**
     * Handle the last error rolling in
     */


    babelHelpers.createClass(JwtLogin, [{
      key: "lastErrorChanged",
      value: function lastErrorChanged(e) {
        if (e && this.__context != "logout") {
          // check for JWT needing refreshed vs busted but must be 403
          console.error(e);
          this.dispatchEvent(new CustomEvent("jwt-login-refresh-error", {
            composed: true,
            bubbles: true,
            cancelable: false,
            detail: {
              value: e
            }
          }));
        }
      }
    }, {
      key: "updated",
      value:
      /**
       * LitElement life cycle - properties changed callback
       */
      function updated(changedProperties) {
        var _this2 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(JwtLogin.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(JwtLogin.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (["auto", "method", "url"].includes(propName) && _this2.url && !_this2.jwt && _this2.ready) {
            clearTimeout(_this2.__debounce);
            _this2.__debounce = setTimeout(function () {
              _this2.generateRequest(_this2.url, _this2.body);
            }, 0);
          }

          if (propName == "jwt") {
            _this2._jwtChanged(_this2[propName], oldValue); // notify


            _this2.dispatchEvent(new CustomEvent("jwt-changed", {
              detail: {
                value: _this2[propName]
              }
            }));
          }
        });
      }
    }, {
      key: "_jwtChanged",
      value: function _jwtChanged(newValue, oldValue) {
        if ((newValue == null || newValue == "" || newValue == "null") && babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // remove this key from local storage bin
          localStorage.removeItem(this.key); // jwt was invalid some how

          this.dispatchEvent(new CustomEvent("jwt-logged-in", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: false
          }));
        } else if (newValue) {
          // set the jwt into local storage so we can reference later
          localStorage.setItem(this.key, newValue);
          this.dispatchEvent(new CustomEvent("jwt-token", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: newValue
          }));
          this.dispatchEvent(new CustomEvent("jwt-logged-in", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: true
          }));
        }
      }
      /**
       * HTMLElement
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(JwtLogin.prototype), "connectedCallback", this).call(this);
        window.addEventListener("jwt-login-refresh-token", this.requestRefreshToken.bind(this));
        window.addEventListener("jwt-login-toggle", this.toggleLogin.bind(this));
        window.addEventListener("jwt-login-login", this.loginRequest.bind(this));
        window.addEventListener("jwt-login-logout", this.logoutRequest.bind(this));
      }
      /**
       * HTMLElement
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("jwt-login-refresh-token", this.requestRefreshToken.bind(this));
        window.removeEventListener("jwt-login-login", this.loginRequest.bind(this));
        window.removeEventListener("jwt-login-toggle", this.toggleLogin.bind(this));
        window.removeEventListener("jwt-login-logout", this.logoutRequest.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(JwtLogin.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * LitElement life cycle - ready
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(JwtLogin.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(JwtLogin.prototype), "firstUpdated", this).call(this, changedProperties);
        }

        this.ready = true; // set jwt from local storage bin

        this.jwt = localStorage.getItem(this.key);
      }
      /**
       * Request a refresh token
       */

    }, {
      key: "requestRefreshToken",
      value: function requestRefreshToken(e) {
        this.__context = "refresh";

        if (e.detail.element) {
          this.__element = e.detail.element;
        }

        this.generateRequest(this.refreshUrl);
      } // generate request for token data

    }, {
      key: "generateRequest",
      value: function generateRequest(url) {
        var _this3 = this;

        var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var data = {
          method: this.method,
          headers: {
            "Content-Type": "application/json"
          }
        };

        if (this.method != "GET") {
          data.body = JSON.stringify(body);
        }

        fetch(url, data).then(function (response) {
          if (response.ok) {
            return response.json();
          } else {
            // prevent infinite loop if we fail on the logout endpoint
            if (_this3.__context == "logout" && _this3.__redirect && _this3.redirectUrl) {
              setTimeout(function () {
                window.location.href = _this3.redirectUrl;
              }, 100);
            }

            _this3.lastErrorChanged(response);
          }
        }).then(function (token) {
          try {
            _this3.loginResponse(token);
          } catch (e) {
            console.warn(e);
          }
        });
      }
      /**
       * Request a user login if we need one or log out
       */

    }, {
      key: "toggleLogin",
      value: function toggleLogin(e) {
        // null is default, if we don't have anything go get one
        if (this.jwt == null) {
          this.loginRequest(e);
        } else {
          this.logoutRequest(e);
        }
      }
    }, {
      key: "loginRequest",
      value: function loginRequest(e) {
        this.__context = "login"; // detail of a login request event is the body which should have
        // the authorization data in it

        this.body = e.detail;
        this.generateRequest(this.url, this.body);
      }
    }, {
      key: "logoutRequest",
      value: function logoutRequest(e) {
        this.__context = "logout";
        this.__redirect = e.detail.redirect; // we were told to logout, reset body

        this.body = {}; // reset jwt which will do all the events / local storage work

        this.jwt = null;
        this.generateRequest(this.logoutUrl);
      }
      /**
       * Login bridge to get a JWT and hang onto it
       */

    }, {
      key: "loginResponse",
      value: function loginResponse(response) {
        var _this4 = this;

        // trap in case front end thinks this is a valid response..
        switch (this.__context) {
          case "login":
            this.jwt = response;
            break;

          case "refresh":
            // jwt change events will propagate and do their thing
            this.jwt = response; // if we had a requesting element, let's let it do its thing

            if (this.__element) {
              var _this$__element$obj;

              (_this$__element$obj = this.__element.obj)[this.__element.callback].apply(_this$__element$obj, [this.jwt].concat(babelHelpers.toConsumableArray(this.__element.params)));

              this.__element = false;
            }

            break;

          case "logout":
            if (this.__redirect && this.redirectUrl) {
              setTimeout(function () {
                window.location.href = _this4.redirectUrl;
              }, 100);
            }

            break;
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "jwt-login";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * auto, useful for demos
           */
          auto: {
            type: Boolean
          },

          /**
           * refreshUrl to get a new JSON web token
           */
          refreshUrl: {
            type: String,
            attribute: "refresh-url"
          },

          /**
           * where to redirect for a login token if we REALLY are logged out
           */
          redirectUrl: {
            type: String,
            attribute: "redirect-url"
          },

          /**
           * logout url
           */
          logoutUrl: {
            type: String,
            attribute: "logout-url"
          },

          /**
           * url to get the JWT
           */
          url: {
            type: String
          },

          /**
           * Request method
           */
          method: {
            type: String
          },

          /**
           * Optional body, useful when doing posts
           */
          body: {
            type: Object
          },

          /**
           * Key that contains the token in local storage
           */
          key: {
            type: String
          },

          /**
           * JSON Web token to securely pass around
           */
          jwt: {
            type: String
          }
        };
      }
    }]);
    return JwtLogin;
  }(_index.LitElement);

  _exports.JwtLogin = JwtLogin;
  window.customElements.define(JwtLogin.tag, JwtLogin);
});