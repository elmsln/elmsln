define(["exports", "../../../lit/index.js", "../lrndesign-chart.js", "../../simple-colors/simple-colors.js"], function (_exports, _index, _lrndesignChart, _simpleColors) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LrndesignBar = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `lrndesign-bar`
   * a bar chart
   *
   * @element lrndesign-bar
   * @extends LrndesignChart
   * @extends SimpleColors
   * @see ../lrndesign-chart.js
   * @demo ./demo/bar.html
   *
   */
  var LrndesignBar = /*#__PURE__*/function (_LrndesignChart) {
    babelHelpers.inherits(LrndesignBar, _LrndesignChart);

    var _super = _createSuper(LrndesignBar);

    function LrndesignBar() {
      var _this;

      babelHelpers.classCallCheck(this, LrndesignBar);
      _this = _super.call(this);

      _this.setProperties();

      return _this;
    } // properties available to the custom element for data binding


    babelHelpers.createClass(LrndesignBar, [{
      key: "options",
      get:
      /**
       * gets options as an array
       * @returns {array} options
       * @readonly
       * @memberof LrndesignChart
       */
      function get() {
        return _objectSpread(_objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(LrndesignBar.prototype), "options", this)), this.lineBarOptions), {}, {
          axisX: {
            onlyInteger: this.axisXOnlyInteger,
            scaleMinSpace: this.axisXScaleMinSpace
          },
          distributeSeries: this.distributeSeries,
          horizontalBars: this.horizontalBars,
          referenceValue: this.referenceValue,
          seriesBarDistance: this.seriesBarDistance,
          stackBars: this.stackBars,
          stackMode: this.stackMode
        });
      }
      /**
       * Overrides default properties with bar-specific properties.
       */

    }, {
      key: "setProperties",
      value: function setProperties() {
        babelHelpers.get(babelHelpers.getPrototypeOf(LrndesignBar.prototype), "setProperties", this).call(this);
        this.setBarLineProperties();
        this.axisXOnlyInteger = false;
        this.axisXScaleMinSpace = 30;
        this.distributeSeries = false;
        this.horizontalBars = false;
        this.referenceValue = 0;
        this.seriesBarDistance = 15;
        this.stackBars = false;
        this.stackMode = true;
        this.type = "bar";
      }
    }], [{
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(LrndesignBar), "properties", this)), babelHelpers.get(babelHelpers.getPrototypeOf(LrndesignBar), "lineBarProperties", this)), {}, {
          /**
           * Use only integer values (whole numbers) for the scale steps
           */
          axisXOnlyInteger: {
            attribute: "axis-x-only-integer",
            type: Boolean
          },

          /**
           * TODO
           */
          axisXScaleMinSpace: {
            attribute: "axis-x-min-space",
            type: Number
          },

          /**
           * If set to true then each bar will represent a series and
           * the data array is expected to be a one dimensional array
           * of data values rather than a series array of series.
           * This is useful if the bar chart should represent
           * a profile rather than some data over time.
           */
          distributeSeries: {
            attribute: "distribute-series",
            type: Boolean
          },

          /**
           * Inverts the axes of the bar chart in order to draw
           * a horizontal bar chart. Be aware that you also need
           * to invert your axis settings as the Y Axis will now display
           * the labels and the X Axis the values.
           */
          horizontalBars: {
            attribute: "horizontal-bars",
            type: Boolean
          },

          /**
           * Unless low/high are explicitly set, bar chart will be
           * centered at zero by default. Set referenceValue to null to auto scale.
           */
          referenceValue: {
            attribute: "reference-value",
            type: Number
          },

          /**
           * Specify the distance in pixel of bars in a group.
           */
          seriesBarDistance: {
            attribute: "series-bar-distance",
            type: Number
          },

          /**
           * If set to true this property will cause the series bars
           * to be stacked. Check the "stackMode" option
           * for further stacking options.
           */
          stackBars: {
            attribute: "stack-bars",
            type: Boolean
          },

          /**
           * If set to "true" this property will form a total
           * for each series point. This will also influence
           * the y-axis and the overall bounds of the chart.
           * If set to "false" this property will force
           * the stacked bars to draw from the zero line.
           * In stacked mode the "seriesBarDistance" property will have no effect.
           */
          stackMode: {
            attribute: "stack-mode",
            type: Boolean
          }
        });
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       */

    }, {
      key: "tag",
      get: function get() {
        return "lrndesign-bar";
      } // haxProperty definition

    }, {
      key: "haxProperties",
      get: function get() {
        var haxProps = babelHelpers.get(babelHelpers.getPrototypeOf(LrndesignBar), "haxProperties", this),
            lineBar = babelHelpers.get(babelHelpers.getPrototypeOf(LrndesignBar), "lineBarHaxProperties", this),
            barConfig = [{
          property: "horizontalBars",
          title: "Horizontal Bars",
          description: "\n            Inverts the axes of the bar chart in order to draw\n            a horizontal bar chart. Be aware that you also need\n            to invert your axis settings as the Y Axis will now display\n            the labels and the X Axis the values.",
          inputMethod: "boolean"
        }, {
          property: "stackBars",
          title: "Stack Bars",
          description: "\n            If set to true this property will cause the series bars\n            to be stacked.",
          inputMethod: "boolean"
        }, {
          property: "distributeSeries",
          title: "Distribute Series",
          description: "\n            If set to true then each bar will represent a series and\n            the data array is expected to be a one dimensional array\n            of data values rather than a series array of series.",
          inputMethod: "boolean"
        }],
            barX = [{
          property: "axisXScaleMinSpace",
          title: "X-Axis Scale Minimum Space",
          description: "Specifies minimum height in pixel of scale steps.",
          inputMethod: "number"
        }, {
          property: "axisXOnlyInteger",
          title: "X-Axis Scale (only integers)",
          description: "Use only integer values (whole numbers) for the scale steps.",
          inputMethod: "boolean"
        }],
            barY = [{
          property: "referenceValue",
          title: "Reference Value",
          description: "\n            Unless low/high are explicitly set, bar chart will be\n            centered at zero by default.",
          inputMethod: "number"
        }, {
          property: "seriesBarDistance",
          title: "Series Bar Distance",
          description: "Specify the distance in pixel of bars in a group.",
          inputMethod: "number"
        }, {
          property: "stackMode",
          title: "Stack Mode",
          description: "\n            If set to \"true\" this property will form a total\n            for each series point. This will also influence\n            the y-axis and the overall bounds of the chart.\n            If set to \"false\" this property will force\n            the stacked bars to draw from the zero line.\n            In stacked mode the \"seriesBarDistance\" property will have no effect.",
          inputMethod: "boolean"
        }];
        haxProps.gizmo.title = "Bar Chart";
        haxProps.gizmo.icon = "editor:insert-chart";
        haxProps.settings.configure = haxProps.settings.configure.concat(lineBar.gridBackground, barConfig, lineBar.padding);
        haxProps.settings.advanced = haxProps.settings.advanced.concat(lineBar.minMax, lineBar.xAxis, barX, lineBar.yAxis, barY);
        return haxProps;
      }
    }]);
    return LrndesignBar;
  }((0, _lrndesignChart.LrndesignChart)(_simpleColors.SimpleColors));
  /**
   * life cycle, element is removed from the DOM
   */
  //disconnectedCallback() {}


  _exports.LrndesignBar = LrndesignBar;
  window.customElements.define(LrndesignBar.tag, LrndesignBar);
});