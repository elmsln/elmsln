define(["exports", "../../lit/index.js"], function (_exports, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.UndoManagerCommand = _exports.UndoManagerBehaviors = _exports.UndoManager = _exports.Undo = void 0;

  var _templateObject_72686c20809211edaa2833647dc78c6c;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `undo-manager`
   * `an undo history manager element`
   *  This brings ideas from https://addyosmani.com/blog/mutation-observers/
   *  back to life and this time as LitElement + with the web drastically
   *  moved forward vs when this was originally published (2014).
   *
   * @element undo-manager
   * @demo demo/index.html
   */
  var UndoManagerBehaviors = function UndoManagerBehaviors(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);

      var _super = _createSuper(_class);

      /**
       * HTMLElement
       */
      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this);
        _this.__StackDebounce;
        _this.undoStackLimit = 20;
        _this.undoStackTimer = 300;
        _this.undoStackIgnore = false;
        _this.undoStackObserver = null; // this is aggressive but it should capture everything

        _this.undoStackObserverProps = {
          attributes: true,
          attributeOldValue: true,
          childList: true,
          characterData: true,
          characterDataOldValue: true,
          subtree: true
        }; // set beginning value

        _this.undoStackInitialValue = _this.innerHTML; // set previous value, to start

        _this.undoStackPrevValue = _this.undoStackInitialValue;
        return _this;
      }
      /**
       * HTMLElement
       */


      babelHelpers.createClass(_class, [{
        key: "connectedCallback",
        value: function connectedCallback() {
          var _this2 = this;

          // watch for changes to the element itself
          this.undoStackObserver = new MutationObserver(function (mutations) {
            clearTimeout(_this2.__StackDebounce);
            _this2.__StackDebounce = setTimeout(function () {
              // ensure this was not a change record to perform undo/redo itself!
              if (_this2.undoStackIgnore) {
                _this2.undoStackIgnore = false;
                return;
              } // run the stack logic


              _this2.undoManagerStackLogic(mutations);
            }, _this2.undoStackTimer);
          }); // watch attributes, children and the subtree for changes

          this.undoStackObserver.observe(this, this.undoStackObserverProps);
          this.undoManagerStackLogic({});
          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);
        }
        /**
         * While a mutation observer, we only respond to there being ANY change
         * not the specfic record. This lets the developer select granularity
         * in what to notice (lots of stuff) yet only push state change
         * if it matches what they care to monitor as far as detail.
         * Default is to monitor every possible useful detail
         */

      }, {
        key: "undoManagerStackLogic",
        value: function undoManagerStackLogic(mutations) {
          // compare light dom children to previous value
          var newValue = this.innerHTML;

          if (this.undoStack && newValue != "" && newValue != this.undoStackPrevValue && this.undoStackInitialValue != newValue) {
            this.undoStack.execute(new UndoManagerCommand(this, this.undoStackPrevValue, newValue));
            this.undoStackPrevValue = newValue; // we only notify there WAS a change

            this.dispatchEvent(new CustomEvent("stack-changed", {
              detail: {
                value: this.undoStack
              },
              bubbles: true,
              composed: true
            }));
          }
        }
        /**
         * HTMLElement
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (this.undoStackObserver) {
            this.undoStackObserver.disconnect();
          }

          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);
        }
        /**
         * LitElement ready
         */

      }, {
        key: "firstUpdated",
        value: function firstUpdated(changedProperties) {
          var _this3 = this;

          if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "firstUpdated", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "firstUpdated", this).call(this, changedProperties);
          }

          this.undoStack = new Undo();
          this.undoStack.undoStackLimit = this.undoStackLimit;
          this.undoStack.undoStackPosition = -1;
          this.undoStack.commands = []; // simple hook into being notified of changes to the object

          this.undoStack.changed = function (e) {
            _this3.canRedo = _this3.undoStack.canRedo();
            _this3.canUndo = _this3.undoStack.canUndo();
          }; // execute once just to get these values


          this.undoStack.changed();
        }
        /**
         * updated / notice property changes
         */

      }, {
        key: "updated",
        value: function updated(changedProperties) {
          var _this4 = this;

          if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "updated", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "updated", this).call(this, changedProperties);
          }

          changedProperties.forEach(function (oldValue, propName) {
            if (propName == "canUndo") {
              // notify
              _this4.dispatchEvent(new CustomEvent("can-undo-changed", {
                detail: {
                  value: _this4[propName]
                },
                bubbles: true,
                composed: true
              }));
            }

            if (propName == "canRedo") {
              // notify
              _this4.dispatchEvent(new CustomEvent("can-redo-changed", {
                detail: {
                  value: _this4[propName]
                },
                bubbles: true,
                composed: true
              }));
            }
          });
        } // execute an undo

      }, {
        key: "undo",
        value: function undo() {
          return this.undoStack.undo();
        } // execute a redo

      }, {
        key: "redo",
        value: function redo() {
          return this.undoStack.redo();
        } // return a list of the command stack

      }, {
        key: "commands",
        value: function commands() {
          return this.undoStack.commands;
        }
      }], [{
        key: "properties",
        get:
        /**
         * LitElement / popular convention
         */
        function get() {
          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)), {}, {
            /**
             * If we can currently undo based on stack position
             */
            canUndo: {
              type: Boolean,
              attribute: "can-undo"
            },

            /**
             * If we can currently redo based on stack position
             */
            canRedo: {
              type: Boolean,
              attribute: "can-redo"
            },

            /**
             * Properties for the mutation observer
             */
            undoStackObserverProps: {
              type: Object
            },

            /**
             * Allow for targetting OTHER elements w/ this behavior
             */
            target: {
              type: Object
            },

            /**
             * The undo stack order
             */
            stack: {
              type: Object
            }
          });
        }
      }]);
      return _class;
    }(SuperClass);
  };

  _exports.UndoManagerBehaviors = UndoManagerBehaviors;

  var UndoManager = /*#__PURE__*/function (_UndoManagerBehaviors) {
    babelHelpers.inherits(UndoManager, _UndoManagerBehaviors);

    var _super2 = _createSuper(UndoManager);

    function UndoManager() {
      babelHelpers.classCallCheck(this, UndoManager);
      return _super2.apply(this, arguments);
    }

    babelHelpers.createClass(UndoManager, [{
      key: "render",
      value:
      /**
       * LitElement render
       */
      function render() {
        return (0, _index.html)(_templateObject_72686c20809211edaa2833647dc78c6c || (_templateObject_72686c20809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["<slot></slot>"])));
      }
    }], [{
      key: "tag",
      get:
      /**
       * Convention
       */
      function get() {
        return "undo-manager";
      }
    }]);
    return UndoManager;
  }(UndoManagerBehaviors(_index.LitElement));

  _exports.UndoManager = UndoManager;
  customElements.define("undo-manager", UndoManager);
  /*
   * Fork of Undo.js - A undo/redo framework for JavaScript
   *
   * http://jzaefferer.github.com/undo
   *
   * Copyright (c) 2011 Jörn Zaefferer
   *
   * MIT licensed.
   */

  var Undo = /*#__PURE__*/function () {
    function Undo() {
      babelHelpers.classCallCheck(this, Undo);
      this.commands = [];
      this.undoStackPosition = -1;
      this.undoStackLimit = 20;
    }

    babelHelpers.createClass(Undo, [{
      key: "execute",
      value: function execute(command) {
        // clear out the redo queue
        this._clearRedo(); // run the command (inner for inner)


        command.execute(); // if we're at our limit, start forgetting about past history but not all of it

        if (this.undoStackLimit == this.commands.length) {
          this.commands.splice(Math.round(this.commands.length / 3), 1);
        } else {
          // move the position forward
          this.undoStackPosition++;
        } // push the command into the stack


        this.commands.push(command);
        this.changed();
      }
    }, {
      key: "undo",
      value: function undo() {
        // sanity check
        if (this.commands[this.undoStackPosition]) {
          this.commands[this.undoStackPosition].undo();
          this.undoStackPosition--;
          this.changed();
        }
      }
    }, {
      key: "canUndo",
      value: function canUndo() {
        return this.undoStackPosition >= 0;
      }
    }, {
      key: "redo",
      value: function redo() {
        if (this.commands[this.undoStackPosition + 1]) {
          this.undoStackPosition++;
          this.commands[this.undoStackPosition].redo();
          this.changed();
        }
      }
    }, {
      key: "canRedo",
      value: function canRedo() {
        return this.undoStackPosition < this.commands.length - 1;
      } // remove right above where we are

    }, {
      key: "_clearRedo",
      value: function _clearRedo() {
        this.commands = this.commands.slice(0, this.undoStackPosition + 1);
      }
    }, {
      key: "changed",
      value: function changed() {// do nothing, override
      }
    }]);
    return Undo;
  }();
  /**
   * UndoManagerCommand, simple command scaffold to bridge undo.js with element
   */


  _exports.Undo = Undo;

  var UndoManagerCommand = /*#__PURE__*/function () {
    function UndoManagerCommand(el, oldValue, newValue) {
      babelHelpers.classCallCheck(this, UndoManagerCommand);
      // refernece to us
      this.el = el;
      this.oldValue = oldValue;
      this.newValue = newValue;
    } // required for undo.js though we don't use


    babelHelpers.createClass(UndoManagerCommand, [{
      key: "execute",
      value: function execute() {} // perform a "undo"

    }, {
      key: "undo",
      value: function undo() {
        this.el.undoStackIgnore = true; // execute the change in value from what it was to what it is now

        if (this.el.undoStack.commands && this.el.undoStack.commands[this.el.undoStack.undoStackPosition - 1]) {
          this.el.innerHTML = this.el.undoStack.commands[this.el.undoStack.undoStackPosition - 1].newValue;
        } else if (this.el.undoStack.commands && this.el.undoStack.undoStackPosition === 0) {
          this.el.innerHTML = this.el.undoStackInitialValue;
        } else {
          this.el.innerHTML = this.oldValue;
        }
      } // perform a "redo"

    }, {
      key: "redo",
      value: function redo() {
        this.el.undoStackIgnore = true;
        this.el.innerHTML = this.newValue;
      }
    }]);
    return UndoManagerCommand;
  }();

  _exports.UndoManagerCommand = UndoManagerCommand;
});