define(["exports", "meta"], function (_exports, meta) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.OptImg = void 0;
  meta = _interopRequireWildcard(meta);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Copyright 2022 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `opt-img`
   * `an optimized image delivery that is vanilla`
   *
   * @demo demo/index.html
   * @element opt-img
   */
  var OptImg = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(OptImg, _HTMLElement);

    var _super = _createSuper(OptImg);

    function OptImg() {
      var _this;

      babelHelpers.classCallCheck(this, OptImg);
      _this = _super.call(this); // for translation support if globally managed

      _this.t = _this.t || {};
      _this.t.imageLoading = "Image loading.."; // alt as nothing for decorative purposes if not set

      _this.alt = "";
      _this.src = "";
      _this.width = "300px";
      _this.height = "200px"; // see if we have anything to pull data from light dom

      if (_this.querySelector("img")) {
        var img = _this.querySelector("img");

        _this.alt = img.alt || "";
        _this.src = img.src || "";
        _this.width = img.width || "300px";
        _this.height = img.height || "200px";
      } // wipe anything that may be here from before


      _this.innerHTML = null; // create a 'loading' container

      _this._loading = document.createElement("div");
      _this._loading.style.height = _this.height;
      _this._loading.style.width = _this.width;
      _this._loading.innerHTML = _this.loading;

      _this.appendChild(_this._loading); // used for flipping visibility status to change what loads


      _this.loadingvisible = false;
      _this.template = document.createElement("template"); // preconnect the domain early on

      _this._preconnect = document.createElement("link");
      _this._preconnect.rel = "preconnect";
      return _this;
    }

    babelHelpers.createClass(OptImg, [{
      key: "handleIntersectionCallback",
      value:
      /**
       * Very basic IntersectionObserver callback which will set loadingvisible to true
       */
      function handleIntersectionCallback(entries) {
        var _iterator = _createForOfIteratorHelper(entries),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var entry = _step.value;
            var ratio = Number(entry.intersectionRatio).toFixed(2); // ensure ratio is higher than our limit before trigger visibility
            // call when 1/2 of our loader is visible

            if (ratio >= 0.25) {
              this.loadingvisible = true; // remove the observer if we've reached our target of being visible

              this.intersectionObserver.disconnect();
            } else {
              this.loadingvisible = false;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "html",
      get: // return a basic img tag w/ values printed in
      function get() {
        return "<img \n    src=\"".concat(this.src, "\" \n    height=\"").concat(this.height, "\" \n    width=\"").concat(this.width, "\" \n    alt=\"").concat(this.alt, "\" \n    decoding=\"async\" \n    loading=\"lazy\"\n    fetchpriority=\"high\" />");
      } // get a basic loading svg that's styled

    }, {
      key: "loading",
      get: function get() {
        return "\n    <style>\n    opt-img {\n      display: inline;\n    }\n    opt-img #dots circle{\n      animation: load 1s infinite;\n    }\n    \n    opt-img #dots #dot2{\n      animation-delay: 0.2s;\n    }\n    \n    opt-img #dots #dot3{\n      animation-delay: 0.4s;\n    }\n    \n    @keyframes load{\n      0%{\n        opacity: 0;\n      }\n      50%{\n        opacity: 1;\n      }\n      100%{\n        opacity: 0;\n      }\n    }\n    </style>\n    <svg id=\"dots-svg\" width=\"132px\" height=\"58px\" viewBox=\"0 0 132 58\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n          <g id=\"dots\" sketch:type=\"MSArtboardGroup\" fill=\"#A3A3A3\">\n              <circle id=\"dot1\" sketch:type=\"MSShapeGroup\" cx=\"25\" cy=\"30\" r=\"13\"></circle>\n              <circle id=\"dot2\" sketch:type=\"MSShapeGroup\" cx=\"65\" cy=\"30\" r=\"13\"></circle>\n              <circle id=\"dot3\" sketch:type=\"MSShapeGroup\" cx=\"105\" cy=\"30\" r=\"13\"></circle>\n          </g>\n      </g>\n    </svg>\n    <div aria-busy=\"true\" aria-live=\"polite\">".concat(this.t.imageLoading, "</div>\n    ");
      }
      /**
       * only update on the 3 values we care about changing
       */

    }, {
      key: "attributeChangedCallback",
      value:
      /**
       * callback when any observed attribute changes
       */
      function attributeChangedCallback(attr, oldValue, newValue) {
        if (["src", "alt"].includes(attr)) {
          this[attr] = newValue; // force a repaint

          this.render();
        } else if (["loadingvisible"].includes(attr)) {
          this.render();
        } // source being set, let's preconnect the domain prior to usage


        if (attr === "src") {
          // preconnect domain
          this._preconnect.href = new URL(this.src).origin;
          document.head.appendChild(this._preconnect);
        }
      } // peg attribute to property change internally

    }, {
      key: "loadingvisible",
      get: function get() {
        return this.getAttribute("loadingvisible");
      }
      /**
       * This is a convention, not the standard
       */
      ,
      set: function set(val) {
        if (val === false) {
          this.removeAttribute("loadingvisible");
        } else {
          this.setAttribute("loadingvisible", "loadingvisible");
        }
      }
    }, {
      key: "render",
      value:
      /**
       * Render for guts of the tag
       */
      function render() {
        var _this2 = this;

        // only render if we're visible
        if (this.loadingvisible) {
          // make a fake image
          var i = new Image();
          i.fetchpriority = "high"; // when we load, we'll have the props about it

          i.onload = function () {
            // subtle, but these 4 lines help reduce the jarring of painting the image
            // by setting the height/width quickly on the container + img tag
            _this2.style.height = i.height + "px";
            _this2.style.width = i.width + "px";
            _this2.height = i.height + "px";
            _this2.width = i.width + "px"; // render the actual image happens in this block

            _this2.template.innerHTML = _this2.html;

            _this2.appendChild(_this2.template.content); // delay a cycle, undo the style height/width on container
            // and remove the loading element. this delay helps reduce layout jar


            setTimeout(function () {
              _this2.style.height = "";
              _this2.style.width = "";

              _this2._loading.remove();
            }, 0);
          }; // setting the src triggers the image to be requested


          i.src = this.src; // delete the preconnect tag in the head for clean up

          this._preconnect.remove();
        }
      }
      /**
       * HTMLElement specification
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(OptImg.prototype), "connectedCallback", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(OptImg.prototype), "connectedCallback", this).call(this);
        }

        window.dispatchEvent(new CustomEvent("i18n-manager-register-element", {
          detail: {
            context: this,
            namespace: "opt-img",
            localesPath: new URL("./locales", meta.url).href,
            updateCallback: "render",
            locales: ["es"]
          }
        })); // setup the intersection observer, only if we are not visible

        if (!this.loadingvisible) {
          this.intersectionObserver = new IntersectionObserver(this.handleIntersectionCallback.bind(this), {
            root: null,
            rootMargin: "0px",
            threshold: [0.0, 0.25, 0.5, 0.75, 1.0],
            // when to return records
            delay: 500 // how often to query this

          });
          this.intersectionObserver.observe(this);
        }
      }
      /**
       * HTMLElement specification
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        // if we have an intersection observer, disconnect it
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect(); // edge case where element is moved in the DOM so that
          // connnected will set the event back up accurately

          this.loadingvisible = false;
        }

        if (babelHelpers.get(babelHelpers.getPrototypeOf(OptImg.prototype), "disconnectedCallback", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(OptImg.prototype), "disconnectedCallback", this).call(this);
        }
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["src", "alt", "loadingvisible"];
      }
    }, {
      key: "tag",
      get: function get() {
        return "opt-img";
      }
    }]);
    return OptImg;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.OptImg = OptImg;
  customElements.define(OptImg.tag, OptImg);
});