define(["exports", "meta", "../../lit/index.js", "../i18n-manager/lib/I18NMixin.js", "../../lit/directives/unsafe-html.js", "../hax-body/lib/hax-store.js", "../haxcms-elements/lib/core/haxcms-site-store.js", "../../mobx/dist/mobx.esm.js", "../json-outline-schema/lib/json-outline-schema-item.js", "../json-outline-schema/json-outline-schema.js", "../simple-popover/simple-popover.js", "../simple-icon/lib/simple-icon-lite.js", "../hax-iconset/lib/simple-hax-iconset.js", "../simple-icon/lib/simple-icon-button.js", "../simple-fields/lib/simple-fields-field.js", "../utils/utils.js"], function (_exports, meta, _index, _I18NMixin2, _unsafeHtml, _haxStore, _haxcmsSiteStore, _mobxEsm, _jsonOutlineSchemaItem, _jsonOutlineSchema, _simplePopover, _simpleIconLite, _simpleHaxIconset, _simpleIconButton, _simpleFieldsField, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.OutlineDesigner = void 0;
  meta = _interopRequireWildcard(meta);

  var _templateObject_abc0b1f08e0011ed99ce491205e67b1d, _templateObject2_abc0b1f08e0011ed99ce491205e67b1d, _templateObject3_abc0b1f08e0011ed99ce491205e67b1d, _templateObject4_abc0b1f08e0011ed99ce491205e67b1d, _templateObject5_abc0b1f08e0011ed99ce491205e67b1d, _templateObject6_abc0b1f08e0011ed99ce491205e67b1d, _templateObject7_abc0b1f08e0011ed99ce491205e67b1d, _templateObject8_abc0b1f08e0011ed99ce491205e67b1d, _templateObject9_abc0b1f08e0011ed99ce491205e67b1d, _templateObject10_abc0b1f08e0011ed99ce491205e67b1d, _templateObject11_abc0b1f08e0011ed99ce491205e67b1d, _templateObject12_abc0b1f08e0011ed99ce491205e67b1d, _templateObject13_abc0b1f08e0011ed99ce491205e67b1d;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && babelHelpers.instanceof(outerFn.prototype, Generator) ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == babelHelpers.typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
    * `outline-designer`
    * @element outline-designer
    * `tools to modify and visualize JSON Outline Schema for editing`
    * @demo demo/index.html
    */
  var OutlineDesigner = /*#__PURE__*/function (_I18NMixin) {
    babelHelpers.inherits(OutlineDesigner, _I18NMixin);

    var _super = _createSuper(OutlineDesigner);

    function OutlineDesigner() {
      var _this;

      babelHelpers.classCallCheck(this, OutlineDesigner);
      _this = _super.call(this);
      _this.fidelity = 'medium';
      _this.haxGizmos = [];
      _this.hideDelete = false;
      _this.activeItemForActions = null;
      _this.storeTools = false;
      _this.hideContentOps = false;
      _this.items = [];
      _this.appReady = false;
      _this.eventData = {};
      _this.activeId = null;
      _this.activePreview = null;
      _this.activePreviewIndex = -1;
      _this.t = {
        selectParent: "Select target",
        importContentUnderThisPage: "Import content under this page",
        importThisContent: "Import this content",
        thisPage: "this page",
        newPage: "New page",
        copyOf: "Copy of"
      };

      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        basePath: meta.url,
        locales: ["es"]
      }); // so we can prepopulate the parent options menu


      (0, _mobxEsm.autorun)(function () {
        _this.activeId = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.activeId);
      });
      (0, _mobxEsm.autorun)(function () {
        _this.appReady = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.appReady);
      }); // valid list of hax Gizmos

      (0, _mobxEsm.autorun)(function () {
        _this.haxGizmos = (0, _mobxEsm.toJS)(_haxStore.HAXStore.gizmoList).filter(function (schema) {
          if (schema && schema.meta && schema.meta.outlineDesigner) {
            return true;
          }

          return false;
        });
      });

      _this.addEventListener('click', _this.resetPopOver.bind(babelHelpers.assertThisInitialized(_this)));

      return _this;
    }

    babelHelpers.createClass(OutlineDesigner, [{
      key: "resetPopOver",
      value: function resetPopOver() {
        // clean up if something is active
        if (this.activePreview) {
          this.shadowRoot.querySelector('simple-popover').setAttribute('hidden', 'hidden');
          this.activePreview = null;
          this.activePreviewIndex = -1;
        }
      } // selectable list of items in the current site

    }, {
      key: "getSiteItems",
      value: function getSiteItems() {
        // default to null parent as the whole site
        var items = [{
          text: this.t.selectParent,
          value: null
        }];

        if (this.appReady && this.items.length > 0) {
          var rawItemList = _haxcmsSiteStore.store.getManifestItems(true);

          rawItemList.forEach(function (el) {
            // calculate -- depth so it looks like a tree
            var itemBuilder = el; // walk back through parent tree

            var distance = "- ";

            while (itemBuilder && itemBuilder.parent != null) {
              itemBuilder = rawItemList.find(function (i) {
                return i.id == itemBuilder.parent;
              }); // double check structure is sound

              if (itemBuilder) {
                distance = "--" + distance;
              }
            }

            items.push({
              text: distance + el.title,
              value: el.id
            });
          });
        }

        return items;
      } // render function

    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        return (0, _index.html)(_templateObject_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n    <div class=\"controls\">\n      ", "\n      <simple-icon-button-lite\n          class=\"control\"\n          icon=\"add\"\n          @click=\"", "\"\n        >Add page</simple-icon-button-lite>\n      <simple-icon-button-lite icon=\"hardware:keyboard-arrow-right\" @click=\"", "\" class=\"control\">Collapse all</simple-icon-button-lite>\n      <simple-icon-button-lite icon=\"hardware:keyboard-arrow-down\" @click=\"", "\" class=\"control\">Expand all</simple-icon-button-lite>\n      ", "\n    </div>\n    <ul id=\"list\">\n      ", "\n    </ul>\n    <simple-popover auto for=\"list\" hidden>\n      <simple-icon-button @click=\"", "\" title=\"Close\" icon=\"cancel\" class=\"close-btn\"></simple-icon-button>\n      ", "\n    </simple-popover>"])), this.storeTools ? (0, _index.html)(_templateObject2_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject2_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <label for=\"targetselector\">", "</label>\n      <simple-fields-field id=\"targetselector\" type=\"select\" value=\"children\" .itemsList=\"", "\"></simple-fields-field>\n      ", ":\n      <simple-fields-field id=\"itemselector\" type=\"select\" value=\"", "\" .itemsList=\"", "\"></simple-fields-field>\n      <label for=\"itemselector\">", "</label>\n      "])), this.t.importThisContent, [{
          text: "as children of",
          value: "children"
        }, {
          text: "Above",
          value: "above"
        }, {
          text: "Below",
          value: "below"
        }], this.t.thisPage, this.activeId, this.getSiteItems(), this.t.importContentUnderThisPage) : "", this.addItemToTop, this.collapseAll, this.expandAll, this.hasDeletedItems() ? (0, _index.html)(_templateObject3_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject3_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["<simple-icon-button-lite icon=\"delete\" @click=\"", "\" class=\"control\">", "</simple-icon-button-lite>"])), this.toggleDelete, !this.hideDelete ? "Hide Deleted" : "Show Deleted") : "", this.items.map(function (item, index) {
          return _this2.getItemParentsCollapsed(item) === '' ? _this2.renderItem(item, index) : "";
        }), this.resetPopOver, this.renderActiveContentItem(this.activePreview, this.activePreviewIndex));
      }
    }, {
      key: "hasDeletedItems",
      value: function hasDeletedItems() {
        if (this.items.find(function (item) {
          return item.delete == true;
        })) {
          return true;
        }

        return false;
      }
    }, {
      key: "toggleDelete",
      value: function toggleDelete(e) {
        this.hideDelete = !this.hideDelete;
      }
    }, {
      key: "renderActiveContentItem",
      value: function renderActiveContentItem(activeItemContentNode, targetNodeIndex) {
        if (activeItemContentNode && targetNodeIndex != -1) {
          var item = this.items.find(function (item) {
            return item.id === activeItemContentNode.getAttribute('data-content-parent-id');
          }); // should have contents but verify

          if (item.contents) {
            var div = document.createElement('div');
            div.innerHTML = item.contents; // walk up to the index in question

            for (var i = 0; i < div.childNodes.length; i++) {
              var node = div.childNodes[i];

              if (i === targetNodeIndex) {
                // unsafe, but we encap script so should be.
                return (0, _index.html)(_templateObject4_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject4_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["", ""])), (0, _unsafeHtml.unsafeHTML)((0, _utils.encapScript)(node.outerHTML)));
              }
            }
          }
        }
      }
    }, {
      key: "setActiveItemForActions",
      value: function setActiveItemForActions(e) {
        this.activeItemForActions = e.target.closest("[data-item-id]").getAttribute('data-item-id');
      }
    }, {
      key: "renderItem",
      value: function renderItem(item, index) {
        var _this3 = this;

        return (0, _index.html)(_templateObject5_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject5_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n    <li\n      @dragenter=\"", "\"\n      @dragleave=\"", "\"\n      @mouseenter=\"", "\"\n      class=\"item indent-", " ", " ", "\"\n      data-item-id=\"", "\"\n      @focusin=\"", "\"\n      data-parents=\"", "\"\n      ?data-has-children=\"", "\"\n      ?data-about-to-delete=\"", "\"\n      ?hidden=\"", "\"\n    >\n      <simple-icon-button\n        ?disabled=\"", "\"\n        class=\"collapse-btn\"\n        icon=\"", "\"\n        @click=\"", "\"></simple-icon-button>\n      <simple-icon-button\n        ?disabled=\"", "\"\n        @dragstart=\"", "\"\n        @dragend=\"", "\"\n        draggable=\"", "\"\n        icon=\"hax:arrow-all\"></simple-icon-button>\n      <simple-icon-button-lite\n        ?disabled=\"", "\"\n        ?hidden=\"", "\"\n        icon=\"editor:insert-drive-file\"\n        @click=\"", "\"\n        title=\"Content structure\"\n        >\n        ", "\n      </simple-icon-button-lite>\n      <span class=\"label shown\" ?disabled=\"", "\" @dblclick=\"", "\">", "</span>\n      <span class=\"label-edit\" @keypress=\"", "\" @keydown=\"", "\"></span>\n      <div class=\"operations\">\n        ", "\n      </div>\n    </li>\n    ", "\n    "])), this._dragEnter, this._dragLeave, this.setActiveItemForActions, item.indent < 20 ? item.indent : 20, item.modified ? 'modified' : '', this.getItemParentsCollapsed(item), item.id, this.setActiveItemForActions, this.getItemParents(item), this.hasChildren(item.id), item.delete, this.hideDelete && item.delete, this.isLocked(index), this.isCollapsed(item.id) ? "hardware:keyboard-arrow-right" : "hardware:keyboard-arrow-down", this.collapseExpand, this.isLocked(index), this._dragStart, this._dragEnd, !this.isLocked(index), this.isLocked(index), this.hideContentOps || item.contents === '' || !item.contents, this.toggleContent, item.new ? (0, _index.html)(_templateObject6_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject6_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["<simple-icon ?disabled=\"", "\"\n icon=\"av:fiber-new\" title=\"", "\" class=\"new\" accent-color=\"green\" dark contrast=\"1\"></simple-icon>"])), this.isLocked(index), this.t.newPage) : "", this.isLocked(index), this.editTitle, item.title, this.monitorTitle, this.monitorEsc, this.activeItemForActions === item.id ? (0, _index.html)(_templateObject7_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject7_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n        <simple-icon-button\n          part=\"lockbtn\"\n          class=\"operation lock\"\n          icon=\"", "\"\n          @click=\"", "\"\n          title=\"Lock / Unlock\"\n        ></simple-icon-button>\n        <simple-icon-button\n          class=\"operation\"\n          icon=\"hax:outline-designer-outdent\"\n          @click=\"", "\"\n          title=\"Move next to parent\"\n          ?disabled=\"", "\"\n        ></simple-icon-button>\n        <simple-icon-button\n          class=\"operation\"\n          icon=\"hax:keyboard-arrow-up\"\n          @click=\"", "\"\n          title=\"Move up\"\n          ?disabled=\"", "\"\n        ></simple-icon-button>\n        <simple-icon-button\n          class=\"operation\"\n          icon=\"hax:keyboard-arrow-down\"\n          @click=\"", "\"\n          title=\"Move down\"\n          ?disabled=\"", "\"\n        ></simple-icon-button>\n        <simple-icon-button\n          class=\"operation\"\n          icon=\"hax:outline-designer-indent\"\n          @click=\"", "\"\n          title=\"Make child\"\n          ?disabled=\"", "\"\n        ></simple-icon-button>\n        <simple-icon-button\n          class=\"operation add\"\n          icon=\"add\"\n          accent-color=\"green\"\n          @click=\"", "\"\n          title=\"Add\"\n          ?disabled=\"", "\"\n        ></simple-icon-button>\n        <simple-icon-button\n          class=\"operation\"\n          icon=\"content-copy\"\n          accent-color=\"green\"\n          @click=\"", "\"\n          title=\"Duplicate\"\n          ?disabled=\"", "\"\n        ></simple-icon-button>\n        <simple-icon-button\n          class=\"operation del\"\n          icon=\"", "\"\n          accent-color=\"red\"\n          @click=\"", "\"\n          title=\"", "\"\n          ?disabled=\"", "\"\n        ></simple-icon-button>\n        "])), this.isLocked(index) ? "icons:lock" : "icons:lock-open", function (e) {
          return _this3.itemOp(index, "lock");
        }, function (e) {
          return _this3.itemOp(index, "out");
        }, this.isLocked(index), function (e) {
          return _this3.itemOp(index, "up");
        }, this.isLocked(index), function (e) {
          return _this3.itemOp(index, "down");
        }, this.isLocked(index), function (e) {
          return _this3.itemOp(index, "in");
        }, this.isLocked(index), function (e) {
          return _this3.itemOp(index, "add");
        }, this.isLocked(index), function (e) {
          return _this3.itemOp(index, "duplicate");
        }, this.isLocked(index), !item.delete ? "delete" : "hax:delete-restore", function (e) {
          return _this3.itemOp(index, "delete");
        }, !item.delete ? "Delete" : "Restore", this.isLocked(index)) : "", !this.hideContentOps && item.showContent ? this.renderItemContents(item) : "");
      }
    }, {
      key: "hasContents",
      value: function hasContents(item) {
        if (item.contents && item.contents != '') {
          return true;
        }

        return false;
      }
    }, {
      key: "renderItemContents",
      value: function renderItemContents(item) {
        var _this4 = this;

        var render = [this.itemContentsOperations(item)];

        if (item.contents) {
          var div = document.createElement('div');
          div.innerHTML = item.contents;
          var activeHeadingDepth = 1;
          var modifier = 0;
          div.childNodes.forEach(function (node, index) {
            // increase the indent addition to match the activeheading depth
            // this way h1 gets all things below it indented 1 more level
            // while things 4 in get indented 4.
            modifier = 0;

            if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(node.tagName.toLowerCase())) {
              activeHeadingDepth = parseInt(node.tagName.toLowerCase().replace('h', '')); // this ensures when we drop a level that the item itself is NOT
              // rendered a level below where it should be

              modifier = -1;
            }

            render.push(_this4.renderNodeAsItem(node, index, item, parseInt(item.indent) + activeHeadingDepth + modifier));
          });
        }

        return render;
      } // support very, very, very basic content adding

    }, {
      key: "itemContentsOperations",
      value: function itemContentsOperations(item) {
        var _this5 = this;

        return (0, _index.html)(_templateObject8_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject8_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n    <li \n      class=\"item content-adding-operations indent-", "\" \n      data-item-for-content-id=\"", "\" \n      ?data-contents-collapsed=\"", "\"\n      ?data-about-to-delete=\"", "\"\n      ?hidden=\"", "\">\n      ", "\n    </li>"])), item.indent < 20 ? item.indent : 20, item.id, !item.showContent, item.delete, this.hideDelete && item.delete, this.haxGizmos.map(function (gizmo) {
          return (0, _index.html)(_templateObject9_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject9_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <simple-icon-button-lite class=\"operation\" icon=\"", "\" value=\"", "\" @click=\"", "\"\n      >Add ", "</simple-icon-button-lite>\n      "])), gizmo.icon, gizmo.tag, _this5.prependNodeToContent, gizmo.title);
        }));
      } // add content to the top of the item in question

    }, {
      key: "prependNodeToContent",
      value: function prependNodeToContent(e) {
        var _this6 = this;

        var itemId = e.target.closest('[data-item-for-content-id]').getAttribute('data-item-for-content-id');
        this.items.map(function (item, index) {
          if (item.id === itemId && e.target.value) {
            // @todo add support for surfacing these options from the HAX schema
            // could be something like a gizmo.metadata.outlineDesigner = true flag
            var schema = _haxStore.HAXStore.haxSchemaFromTag(e.target.value);

            var node;

            if (schema.gizmo && schema.gizmo.tag && schema.demoSchema && schema.demoSchema[0]) {
              node = (0, _utils.haxElementToNode)(schema.demoSchema[0]);
            } else {
              node = document.createElement(tag);
            }

            _this6.items[index].contents = node.outerHTML + item.contents;

            _this6.resetPopOver();

            _this6.__syncUIAndDataModel();
          }
        });
      } // render a content node within an item

    }, {
      key: "renderNodeAsItem",
      value: function renderNodeAsItem(node, index, item, indent) {
        var _this7 = this;

        var tagName = node.tagName.toLowerCase();
        var icon = 'hax:bricks';
        var label = tagName;
        var part = 'non-heading';

        var schema = _haxStore.HAXStore.haxSchemaFromTag(tagName);

        if (schema && schema.gizmo) {
          icon = schema.gizmo.icon;
          label = schema.gizmo.title; // headings we want to render the title as it can become a full page

          switch (tagName) {
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
              label = node.innerText;
              part = 'heading';
              break;
          }
        }

        return (0, _index.html)(_templateObject10_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject10_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n    <li \n      class=\"item content-child content-", " indent-", "\" \n      data-node-index=\"", "\"\n      data-content-parent-id=\"", "\" \n      ?data-contents-collapsed=\"", "\"\n      ?data-about-to-delete=\"", "\"\n      ?hidden=\"", "\">\n      <simple-icon-button-lite icon=\"", "\" title=\"Click to preview\" @click=\"", "\"\n></simple-icon-button-lite>\n      ", "\n      <div class=\"content-operations\">\n      <simple-icon-button\n          class=\"content-operation\"\n          icon=\"hax:outline-designer-outdent\"\n          @click=\"", "\"\n          title=\"Increase heading\"\n          ?disabled=\"", "\"\n          ?hidden=\"", "\"\n        ></simple-icon-button>\n      <simple-icon-button\n          icon=\"hax:keyboard-arrow-up\"\n          @click=\"", "\"\n          title=\"Move up\"\n          ?disabled=\"", "\"\n          class=\"content-operation\"\n        ></simple-icon-button>  \n        <simple-icon-button\n          icon=\"hax:keyboard-arrow-down\"\n          @click=\"", "\"\n          title=\"Move down\"\n          ?disabled=\"", "\"\n          class=\"content-operation\"\n        ></simple-icon-button>\n        <simple-icon-button\n          class=\"content-operation\"\n          icon=\"hax:outline-designer-indent\"\n          @click=\"", "\"\n          title=\"Decrease Heading\"\n          ?disabled=\"", "\"\n          ?hidden=\"", "\"\n        ></simple-icon-button>\n        <simple-icon-button \n          class=\"content-operation\" \n          icon=\"editor:format-page-break\"\n          @click=\"", "\"\n          title=\"Promote to page\"\n          ?disabled=\"", "\"\n          ?hidden=\"", "\"\n          ></simple-icon-button>\n        <simple-icon-button\n          icon=\"delete\"\n          @click=\"", "\"\n          class=\"content-operation del\"\n          title=\"Delete\"\n          ?disabled=\"", "\"\n          accent-color=\"red\"\n        ></simple-icon-button>\n      </div>\n    </li>"])), part, indent < 20 ? indent : 20, index, item.id, !item.showContent, item.delete, this.hideDelete && item.delete, icon, this.setActivePreview, part === 'heading' ? (0, _index.html)(_templateObject11_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject11_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <span class=\"label shown\" ?disabled=\"", "\" @dblclick=\"", "\">", "</span>\n      <span class=\"label-edit\" @keypress=\"", "\" @keydown=\"", "\"></span>\n      "])), item.metadata.locked, this.editTitle, label, this.monitorHeading, this.monitorEsc) : (0, _index.html)(_templateObject12_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject12_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["<span class=\"label shown\">", "</span>"])), label), function (e) {
          return _this7.modifyContentAction(e, item, "in");
        }, tagName === 'h1' || item.metadata.locked, part !== 'heading', function (e) {
          return _this7.modifyContentAction(e, item, "up");
        }, item.metadata.locked, function (e) {
          return _this7.modifyContentAction(e, item, "down");
        }, item.metadata.locked, function (e) {
          return _this7.modifyContentAction(e, item, "out");
        }, tagName === 'h6' || item.metadata.locked, part !== 'heading', function (e) {
          return _this7.pageBreakHere(e, item);
        }, item.metadata.locked, part !== 'heading', function (e) {
          return _this7.modifyContentAction(e, item, 'delete');
        }, item.metadata.locked);
      } // preview of the item in question

    }, {
      key: "setActivePreview",
      value: function setActivePreview(e) {
        var target = e.target.closest('[data-content-parent-id]');
        var targetNodeIndex = parseInt(target.getAttribute('data-node-index'));
        this.activePreview = target;
        this.shadowRoot.querySelector('simple-popover').removeAttribute('hidden'); // set target so it points to our current item

        this.shadowRoot.querySelector('simple-popover').target = target;
        this.activePreviewIndex = targetNodeIndex;
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
      } // ability to mod the content to move heading up or down between h1 and h6

    }, {
      key: "modifyContentAction",
      value: function modifyContentAction(e, item, action) {
        if (!item.metadata.locked) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation(); // Take UI index and split at that dom node by recreating
          // the structure. Bonkers.

          var target = e.target.closest('[data-content-parent-id]');
          var itemId = target.getAttribute('data-content-parent-id');
          var targetNodeIndex = parseInt(target.getAttribute('data-node-index'));

          var _item = this.items.find(function (item) {
            return item.id === itemId;
          }); // should have contents but verify


          if (_item.contents) {
            var div = document.createElement('div');
            div.innerHTML = _item.contents;
            var content = ''; // up / down require reorganization prior to html calculation

            switch (action) {
              case "up":
                if (targetNodeIndex !== 0) {
                  div.childNodes[targetNodeIndex].previousElementSibling.insertAdjacentElement("beforebegin", div.childNodes[targetNodeIndex]);
                }

                break;

              case "down":
                if (targetNodeIndex !== div.childNodes.length - 1) {
                  div.childNodes[targetNodeIndex].nextElementSibling.insertAdjacentElement("afterend", div.childNodes[targetNodeIndex]);
                }

                break;
            } // walk up to the index in question


            for (var i = 0; i < div.childNodes.length; i++) {
              var node = div.childNodes[i]; // so long as index is LOWER than the target, this is original item content

              if (i < targetNodeIndex) {
                content += node.outerHTML;
              } else if (i === targetNodeIndex) {
                switch (action) {
                  case 'delete':
                    // do nothing as we skip this, effectively deleting it
                    this.setAttribute('stop-animation', 'true');
                    break;

                  case "up":
                  case "down":
                    // up and down happen prior to here
                    content += node.outerHTML;
                    break;

                  case "in":
                  case "out":
                    // heading to modify
                    var hlevel = parseInt(node.tagName.toLowerCase().replace('h', ''));
                    var h = void 0;

                    if (action === 'in' && hlevel > 1) {
                      h = document.createElement("h".concat(hlevel - 1));
                      h.innerText = node.innerText;
                    } else if (action === 'out' && hlevel < 6) {
                      h = document.createElement("h".concat(hlevel + 1));
                      h.innerText = node.innerText;
                    } else {
                      // blocked operation
                      h = node;
                    }

                    content += h.outerHTML;
                    break;
                }
              } else {
                content += node.outerHTML;
              }
            }

            _item.contents = content;
            this.resetPopOver();

            this.__syncUIAndDataModel();
          }
        }
      } // split page to make another one at the heading level

    }, {
      key: "pageBreakHere",
      value: function pageBreakHere(e, item) {
        if (!item.metadata.locked) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation(); // Take UI index and split at that dom node by recreating
          // the structure. Bonkers.

          var target = e.target.closest('[data-content-parent-id]');
          var itemId = target.getAttribute('data-content-parent-id');
          var targetNodeIndex = parseInt(target.getAttribute('data-node-index'));

          var _item2 = this.items.find(function (item) {
            return item.id === itemId;
          });

          var targetItemIndex;
          this.items.map(function (item, index) {
            return item.id === itemId ? targetItemIndex = index : null;
          }); // should have contents but verify

          if (_item2.contents) {
            var div = document.createElement('div');
            div.innerHTML = _item2.contents;
            var oldContent = '';
            var newContent = '';
            var title = this.t.newPage; // walk up to the index in question

            for (var i = 0; i < div.childNodes.length; i++) {
              var node = div.childNodes[i]; // so long as index is LOWER than the target, this is original item content

              if (i < targetNodeIndex) {
                oldContent += node.outerHTML;
              } else if (i === targetNodeIndex) {
                if (node.innerText != '') {
                  title = node.innerText;
                }
              } else {
                newContent += node.outerHTML;
              }
            }

            _item2.contents = oldContent; // create a new item

            var newItem = new _jsonOutlineSchemaItem.JSONOutlineSchemaItem();
            newItem.title = title; // slug and location NOT set because backend will fill these in

            newItem.order = _item2.order + 1;
            newItem.parent = _item2.parent;
            newItem.indent = _item2.indent;
            newItem.metadata.locked = false;
            newItem.new = true;
            newItem.contents = newContent; // set modified on targetItemIndex

            this.items[targetItemIndex].modified = true; // splice back into the items array just below where we issued the split

            this.items.splice(targetItemIndex + 1, 0, newItem);
            this.resetPopOver();

            this.__syncUIAndDataModel();
          }
        }
      } // common update

    }, {
      key: "__syncUIAndDataModel",
      value: function __syncUIAndDataModel() {
        var _this8 = this;

        this._recurseUpdateIndent();

        this._schemaOrderUpdate(); // delay ensures array data is updated in prior execution loop


        setTimeout(function () {
          _this8.requestUpdate(); // if animation was stopped, unset it


          setTimeout(function () {
            _this8.removeAttribute('stop-animation');
          }, 300);
        }, 0);
      }
    }, {
      key: "collapseAll",
      value: function collapseAll() {
        var _this9 = this;

        this.items.map(function (item, index) {
          if (_this9.hasChildren(item.id) && !item.collapsed) {
            _this9.items[index].collapsed = true;
          }
        });
        setTimeout(function () {
          _this9.requestUpdate();
        }, 0);
      }
    }, {
      key: "expandAll",
      value: function expandAll() {
        var _this10 = this;

        this.items.map(function (item, index) {
          if (_this10.hasChildren(item.id) && item.collapsed) {
            _this10.items[index].collapsed = false;
          }
        });
        setTimeout(function () {
          _this10.requestUpdate();
        }, 0);
      }
    }, {
      key: "getItemParents",
      value: function getItemParents(activeItem) {
        var parent = this.items.find(function (item) {
          return item.id == activeItem.parent;
        });
        var list = '';

        while (parent) {
          list += parent.id + " ";
          parent = this.items.find(function (item) {
            return item.id == parent.parent;
          });
        }

        return list;
      } // generate a class that includes all collapsed parents
      // based on the statefulness of that data

    }, {
      key: "getItemParentsCollapsed",
      value: function getItemParentsCollapsed(activeItem) {
        var parent = this.items.find(function (item) {
          return item.id == activeItem.parent;
        });
        var list = '';

        while (parent) {
          if (parent.collapsed && parent.id) {
            list += "collapsed-by-".concat(parent.id) + " ";
          }

          parent = this.items.find(function (item) {
            return item.id == parent.parent;
          });
        }

        return list;
      }
    }, {
      key: "isCollapsed",
      value: function isCollapsed(itemId) {
        var item = this.items.find(function (item) {
          return item.id == itemId;
        });

        if (item.collapsed) {
          return true;
        }

        return false;
      }
    }, {
      key: "hasChildren",
      value: function hasChildren(itemId) {
        var children = this.items.find(function (item) {
          return item.parent == itemId;
        });

        if (children) {
          return true;
        }

        return false;
      }
    }, {
      key: "collapseExpand",
      value: function collapseExpand(e) {
        var _this11 = this;

        var itemId = e.target.closest("[data-item-id]").getAttribute('data-item-id'); // find the item and act on it's index to toggle content collapse status

        this.items.map(function (item, index) {
          if (item.id === itemId && !_this11.isLocked(index)) {
            if (_this11.items[index].collapsed) {
              _this11.items[index].collapsed = false;
            } else {
              _this11.items[index].collapsed = true;
            }

            _this11.requestUpdate();
          }
        });
      }
    }, {
      key: "toggleContent",
      value: function toggleContent(e) {
        var _this12 = this;

        var target = e.target.closest("[data-item-id]"); // prevent if we are in a disabled state

        if (target && !e.target.disabled) {
          var itemId = target.getAttribute('data-item-id'); // find the item and act on it's index to toggle content collapse status

          this.items.map(function (item, index) {
            if (item.id === itemId) {
              if (_this12.items[index].showContent) {
                _this12.items[index].showContent = false;
              } else {
                _this12.items[index].showContent = true;
              }
            }
          });
          this.requestUpdate();
        }
      }
    }, {
      key: "editTitle",
      value: function editTitle(e) {
        e.target.classList.remove('shown');
        var target = e.target.nextElementSibling;
        target.setAttribute('contenteditable', 'true');
        target.classList.add('shown');
        target.innerText = e.target.innerText;
        target.focus(); // get the selection and select all

        if (this.shadowRoot.getSelection) {
          var range = document.createRange();
          range.selectNodeContents(target);
          this.shadowRoot.getSelection().removeAllRanges();
          this.shadowRoot.getSelection().addRange(range);
        } // deprecated but best we got
        else {
            try {
              document.execCommand('selectAll', false, null);
            } catch (e) {
              console.warn(e);
            }
          }
      }
    }, {
      key: "monitorTitle",
      value: function monitorTitle(e) {
        if (e.key === 'Enter') {
          e.target.classList.remove('shown');
          e.target.previousElementSibling.classList.add('shown');
          e.target.removeAttribute('contenteditable');
          var itemId = e.target.closest("[data-item-id]").getAttribute('data-item-id');

          for (var index = 0; index < this.items.length; index++) {
            if (this.items[index].id === itemId && e.target.innerText != '') {
              if (!this.items[index].new) {
                this.items[index].modified = true;
              }

              this.items[index].title = e.target.innerText;
            }
          }

          this.requestUpdate();
        }
      }
    }, {
      key: "monitorHeading",
      value: function monitorHeading(e) {
        if (e.key === 'Enter') {
          e.target.classList.remove('shown');
          e.target.previousElementSibling.classList.add('shown');
          e.target.removeAttribute('contenteditable');
          var target = e.target.closest('[data-content-parent-id]');
          var itemId = target.getAttribute('data-content-parent-id');
          var targetNodeIndex = parseInt(target.getAttribute('data-node-index'));
          var item = this.items.find(function (item) {
            return item.id === itemId;
          }); // should have contents but verify

          if (item.contents) {
            var div = document.createElement('div');
            div.innerHTML = item.contents;
            var content = ''; // walk up to the index in question

            for (var i = 0; i < div.childNodes.length; i++) {
              var node = div.childNodes[i]; // so long as index is LOWER than the target, this is original item content

              if (i < targetNodeIndex) {
                content += node.outerHTML;
              } else if (i === targetNodeIndex) {
                node.innerText = e.target.innerText;
                content += node.outerHTML;
              } else {
                content += node.outerHTML;
              }
            }

            item.contents = content;
            this.resetPopOver();
            this.requestUpdate();
          }
        }
      }
    }, {
      key: "monitorEsc",
      value: function monitorEsc(e) {
        if (e.key === 'Escape') {
          e.target.classList.remove('shown');
          e.target.removeAttribute('contenteditable');
          e.target.previousElementSibling.classList.add('shown');
          e.target.innerText = e.target.previousElementSibling.innerText;
        }
      }
    }, {
      key: "_mouseDownDrag",
      value: function _mouseDownDrag(e) {
        var _this13 = this;

        // force collapse kids on move
        var itemId = e.target.closest("[data-item-id]").getAttribute('data-item-id');
        this.items.map(function (item, index) {
          if (item.id === itemId && _this13.hasChildren(item.id)) {
            _this13.items[index].collapsed = true;
          }
        });
        setTimeout(function () {
          _this13.requestUpdate();
        }, 0);
      }
      /**
       * Enter an element, meaning we've over it while dragging
       */

    }, {
      key: "_dragEnter",
      value: function _dragEnter(e) {
        if (this._targetDrop !== e.target.closest("[data-item-id]")) {
          e.preventDefault();
          e.target.closest("[data-item-id]").classList.add("outline-designer-hovered");
          this._targetDrop = e.target.closest("[data-item-id]");
        }
      }
      /**
       * Leaving an element while dragging.
       */

    }, {
      key: "_dragLeave",
      value: function _dragLeave(e) {
        if (this._targetDrop !== e.target.closest("[data-item-id]")) {
          e.target.closest("[data-item-id]").classList.remove("outline-designer-hovered");
        }
      }
      /**
       * When we end dragging this is the same as a drop event; ensure we remove the mover class.
       */

    }, {
      key: "_dragEnd",
      value: function _dragEnd(e) {
        if (this._targetDrag && this._targetDrop) {
          var here = null;
          var from = null;

          for (var index = 0; index < this.items.length; index++) {
            var item = this.items[index];

            if (item.id === this._targetDrop.getAttribute('data-item-id')) {
              here = index;
            }

            if (item.id === this._targetDrag.getAttribute('data-item-id')) {
              from = index;
            }
          }

          if (from !== null && here !== null) {
            if (!this.items[from].new) {
              this.items[from].modified = true;
            }

            this.items[from].order = this.items[here].order; // if 1st in a hierarchy we have to go ahead of it

            if (this.items[from].order === 0) {
              this.items[from].order = -1;
            }

            this.items[from].indent = this.items[here].indent;
            this.items[from].parent = this.items[here].parent;

            if (this.hasChildren(this.items[from].id)) {
              this.items[from].collapsed = false;
            }
          }

          this._targetDrag = null;
          this._targetDrop = null;
          this.setAttribute('stop-animation', 'true');

          this.__syncUIAndDataModel();
        }
      }
      /**
       * Drag start so we know what target to set
       */

    }, {
      key: "_dragStart",
      value: function _dragStart(e) {
        if (e.target.getAttribute('disabled') == null) {
          var target = e.target.closest("[data-item-id]");
          this._targetDrop = null;
          this._targetDrag = target;

          this._mouseDownDrag(e);

          if (e.dataTransfer) {
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.dropEffect = "move";
            e.dataTransfer.setDragImage(target, 24, 16);
          }

          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      } // properties available to the custom element for data binding

    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this14 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(OutlineDesigner.prototype), "updated", this).call(this, changedProperties);
        changedProperties.forEach(function (oldValue, propName) {
          if (propName === 'fidelity' && _this14[propName]) {
            // @todo these are just conceptual for the moment
            // need requirements / discussion with group to inform low vs high operations
            // and the names could correspond more closely with the process someone is engaged in
            switch (_this14[propName]) {
              case 'low':
                // remove everything except pages
                // button for seeing content of page but not allowed to delve into it
                break;

              case 'medium':
                // allow rendering contents, but only headings, no edit operations
                break;

              case 'high':
                // allow rendering contents, as well as edit operations
                break;
            }
          }

          if (propName === 'activePreview' && oldValue) {
            oldValue.classList.remove('active-preview-item');
          }

          if (propName === 'activePreview' && _this14[propName]) {
            _this14[propName].classList.add('active-preview-item');
          }
        });
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        var _this15 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(OutlineDesigner.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(OutlineDesigner.prototype), "firstUpdated", this).call(this, changedProperties);
        } // avoid some misordering on 1st paint after making lots of things


        if (this.items) {
          setTimeout(function () {
            _this15.__syncUIAndDataModel();
          }, 0);
        }
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       */

    }, {
      key: "addItemToTop",
      value: // modifier for adding to the top of the stack
      function addItemToTop() {
        this.setAttribute('stop-animation', 'true');
        this.addNewItem('top');

        this.__syncUIAndDataModel();
      }
      /**
       * Return all data associated with the current tree
       * @note this makes more sense when we allow manipulation via this object and its options
       */

    }, {
      key: "getData",
      value: function () {
        var _getData = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var eventData, parentId, targetSelector, count;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  eventData = this.eventData;
                  eventData.items = babelHelpers.toConsumableArray(this.items); // if we're pulling in the store to do re-parenting on the fly
                  // like in the case of the import UI

                  if (!this.storeTools) {
                    _context2.next = 8;
                    break;
                  }

                  parentId = this.shadowRoot.querySelector("#itemselector").value;
                  targetSelector = this.shadowRoot.querySelector("#targetselector").value;
                  count = 0;
                  _context2.next = 8;
                  return eventData.items.map( /*#__PURE__*/function () {
                    var _ref = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(item, index) {
                      var parentItem;
                      return _regeneratorRuntime().wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              if (!(parentId && item.parent == null)) {
                                _context.next = 16;
                                break;
                              }

                              // helps in supporting multiple imports at a time
                              count++;
                              _context.next = 4;
                              return _haxcmsSiteStore.store.findItemAsObject(parentId);

                            case 4:
                              parentItem = _context.sent;
                              _context.t0 = targetSelector;
                              _context.next = _context.t0 === 'below' ? 8 : _context.t0 === 'above' ? 11 : _context.t0 === 'children' ? 14 : 16;
                              break;

                            case 8:
                              eventData.items[index].parent = parentItem.parent;
                              eventData.items[index].order = parseInt(parentItem.order) + count;
                              return _context.abrupt("break", 16);

                            case 11:
                              eventData.items[index].parent = parentItem.parent; // @todo this is currently the reverse order desired if
                              // multiple top level children existed on the import

                              eventData.items[index].order = parseInt(parentItem.order) - count;
                              return _context.abrupt("break", 16);

                            case 14:
                              eventData.items[index].parent = parentId;
                              return _context.abrupt("break", 16);

                            case 16:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee);
                    }));

                    return function (_x, _x2) {
                      return _ref.apply(this, arguments);
                    };
                  }());

                case 8:
                  return _context2.abrupt("return", eventData);

                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getData() {
          return _getData.apply(this, arguments);
        }

        return getData;
      }()
    }, {
      key: "isLocked",
      value: function isLocked(index) {
        if (index !== false && this.items[index] && this.items[index].metadata && this.items[index].metadata.locked) {
          return true;
        }

        return false;
      } // add a new page or duplicate

    }, {
      key: "addNewItem",
      value: function addNewItem(targetItemIndex) {
        var _this16 = this;

        var duplicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var newItems = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        var orderAddon = 1;

        if (targetItemIndex === 'top') {
          targetItemIndex = 0;
          orderAddon = -1;
        }

        var item = {
          indent: 0,
          parent: null,
          order: 0 // edge case, new outline with nothing in it or traget is invalid

        };

        if (this.items && this.items.length > 0 && this.items[targetItemIndex]) {
          item = this.items[targetItemIndex];
        }

        var newItem = new _jsonOutlineSchemaItem.JSONOutlineSchemaItem();
        newItem.order = item.order + orderAddon;
        newItem.parent = item.parent;
        newItem.indent = item.indent; // slug and location NOT set because backend will fill these in

        newItem.metadata.locked = false;
        newItem.new = true;

        if (duplicate) {
          newItem.title = "".concat(this.t.copyOf, " ").concat(item.title);
          newItem.contents = item.contents; // reference to what called for this to be created

          newItem.duplicate = item.id;
        } else {
          newItem.contents = "<p></p>";
        }

        newItems.push(newItem); // if we were told to duplicate and we have kids, do the whole tree

        if (this.items && this.items.length > 0 && this.items[targetItemIndex] && this.hasChildren(this.items[targetItemIndex].id) && duplicate) {
          // map old id to new one
          var map = {};
          map[this.items[targetItemIndex].id] = newItem.id;
          newItems = this.recurseCopyChildren(this.items[targetItemIndex].id, map, newItems);
        } // splice back into the items array just below where we issued the split


        if (this.items && this.items.length > 0) {
          newItems.forEach(function (spItem, spIndex) {
            return _this16.items.splice(targetItemIndex + spIndex + 1, 0, spItem);
          });
        } else {
          newItems.forEach(function (spItem) {
            return _this16.items.push(spItem);
          });
        }
      }
    }, {
      key: "recurseCopyChildren",
      value: function recurseCopyChildren(itemId, map, newItems) {
        // deep copy
        var children = this.items.filter(function (item) {
          return item.parent == itemId;
        });

        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          var newItem = new _jsonOutlineSchemaItem.JSONOutlineSchemaItem();
          newItem.order = child.order; // map old parentID to new one

          newItem.parent = map[child.parent];
          newItem.indent = child.indent; // slug and location NOT set because backend will fill these in

          newItem.metadata.locked = false;
          newItem.new = true;
          newItem.title = "".concat(this.t.copyOf, " ").concat(child.title);
          newItem.contents = child.contents; // maintain collapsed state for clarity in larger structures

          newItem.collapsed = child.collapsed; // store a reference to where this came from

          newItem.duplicate = children[i].id; // map old id to new one

          map[children[i].id] = newItem.id;
          newItems.push(newItem);

          if (this.hasChildren(children[i].id)) {
            this.recurseCopyChildren(children[i].id, map, newItems);
          }
        }

        return newItems;
      } // apply an action recursively to children of children

    }, {
      key: "recurseAction",
      value: function recurseAction(itemId, action) {
        var _this17 = this;

        var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var children = this.items.filter(function (item) {
          return item.parent == itemId;
        });

        var _loop = function _loop(i) {
          _this17.items.map(function (item, index) {
            if (item.id === children[i].id) {
              switch (action) {
                case 'delete':
                  _this17.items[index].delete = value;
                  break;

                case 'lock':
                  _this17.items[index].metadata.locked = value;
                  break;
              }
            }
          });

          if (_this17.hasChildren(children[i].id)) {
            _this17.recurseAction(children[i].id, action, value);
          }
        };

        for (var i = 0; i < children.length; i++) {
          _loop(i);
        }

        return true;
      } // operations that can be clicked individually per item

    }, {
      key: "itemOp",
      value: function itemOp(index, action) {
        var _this18 = this;

        if (index !== false && this.items[index] && action) {
          // verify this is not locked
          if (!this.items[index].metadata.locked) {
            switch (action) {
              case "lock":
                this.items[index].metadata.locked = true;

                if (this.hasChildren(this.items[index].id)) {
                  this.recurseAction(this.items[index].id, action, this.items[index].metadata.locked);
                }

                break;

              case "delete":
                if (this.items[index].delete) {
                  this.items[index].delete = false;
                } else {
                  this.items[index].delete = true;
                }

                if (this.hasChildren(this.items[index].id)) {
                  this.recurseAction(this.items[index].id, action, this.items[index].delete);
                }

                break;

              case "add":
                this.setAttribute('stop-animation', 'true');
                this.addNewItem(index);
                break;

              case "duplicate":
                this.setAttribute('stop-animation', 'true');
                this.addNewItem(index, true);
                break;

              case "in":
                // move below sibling just before it
                if (index !== 0 && this.items[index].parent != this.items[index - 1].id) {
                  var parent = this.items[index - 1];
                  this.items[index].parent = parent.id; // this is being made a child of the closest item to it in the array so therefore it's the 1st child

                  this.items[index].order = 0;
                  this.items[index].indent = parseInt(parent.indent) + 1;

                  if (!this.items[index].new) {
                    this.items[index].modified = true;
                  }
                }

                break;

              case "out":
                if (this.items[index].parent !== null) {
                  // move just after parent and take on it's parent
                  var sibling = this.items.find(function (item) {
                    return _this18.items[index].parent === item.id;
                  });
                  this.items[index].parent = sibling.parent; // @todo order needs to be more complex than this potentially

                  this.items[index].order = parseInt(sibling.order) + 1;
                  this.items[index].indent = parseInt(sibling.indent);

                  if (!this.items[index].new) {
                    this.items[index].modified = true;
                  }
                }

                break;

              case "up":
              case "down":
                this.setAttribute('stop-animation', 'true'); // thing in question

                var element = this.items[index]; // find siblings of the current one by finding same parent

                var siblings = [];
                this.items.map(function (thing) {
                  if (thing.parent === element.parent) {
                    siblings.push(thing);
                  }
                }); // sort order at this level

                siblings.sort(function (a, b) {
                  if (a.order < b.order) {
                    return -1;
                  } else if (a.order > b.order) {
                    return 1;
                  }

                  return 0;
                });
                var swapSibling = null; // find item just before us; can't use find bc its active 1 only
                // or just after us

                siblings.map(function (thing, i) {
                  if (action === "up" && i > 0 && thing.id === element.id) {
                    swapSibling = siblings[i - 1];
                  } else if (action === "down" && i < siblings.length - 1 && thing.id === element.id) {
                    swapSibling = siblings[i + 1];
                  }
                }); // ensure we found something

                if (swapSibling) {
                  // store this before we overwrite it
                  var swapOrder = parseInt(swapSibling.order + '.0');
                  var elOrder = parseInt(element.order + '.0');
                  this.items.map(function (thing, i) {
                    if (thing.id === swapSibling.id) {
                      _this18.items[i].order = elOrder;

                      if (!_this18.items[i].new) {
                        _this18.items[i].modified = true;
                      }
                    } else if (thing.id === element.id) {
                      _this18.items[i].order = swapOrder;

                      if (!_this18.items[i].new) {
                        _this18.items[i].modified = true;
                      }
                    }
                  });
                }

                break;
            } // has to be on its own bc we block ALL actions if we are locked

          } else if (action === "lock") {
            this.items[index].metadata.locked = false;

            if (this.hasChildren(this.items[index].id)) {
              this.recurseAction(this.items[index].id, action, this.items[index].metadata.locked);
            }
          }

          this.__syncUIAndDataModel();
        }
      } // this forces the indent value for how far in to render
      // to be accurate based on parent depth. If you have
      // 4 ancestors above you you are at the 4th level
      // as we start at 0.
      // @note this exists because of the concept of depth being
      // different from the actual rendered hierarchy but we've
      // never actually used this ability

    }, {
      key: "_recurseUpdateIndent",
      value: function _recurseUpdateIndent() {
        var _this19 = this;

        var topItem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          id: null
        };
        var incr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.items.map(function (item, deepIndex) {
          if (item.parent == topItem.id) {
            _this19.items[deepIndex].indent = incr;

            _this19._recurseUpdateIndent(_this19.items[deepIndex], incr + 1);
          }
        });
      } // force item's schema to be ordered correctly
      // this takes the current data and completely rebuilds it
      // by faking a HTML data structure and then flattening it again
      // this also forces the linear and order property of items to be accurate

    }, {
      key: "_schemaOrderUpdate",
      value: function _schemaOrderUpdate() {
        // fake a schema so we can force an order update to JOS format
        // this way the above will ALWAYS order correctly if the data model change is accurate
        var site = new _jsonOutlineSchema.JsonOutlineSchema(); // we already have our items, pass them in

        var nodes = site.itemsToNodes(this.items); // smash outline into flat to get the correct order

        var correctOrder = site.nodesToItems(nodes);
        var newItems = []; // build a new array in the correct order by pushing the old items around
        // delete "children" key as we deal in JOS only here

        for (var key in correctOrder) {
          var newItem = this.items.find(function (element) {
            return element.id === correctOrder[key].id;
          });

          if (newItem) {
            delete newItem.children;
            newItems.push(newItem);
          }
        }

        this.items = newItems;
      }
    }], [{
      key: "styles",
      get: function get() {
        return [(0, _index.css)(_templateObject13_abc0b1f08e0011ed99ce491205e67b1d || (_templateObject13_abc0b1f08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      :host {\n        display: block;\n      }\n      simple-icon-button[hidden] {\n        visibility: hidden !important;\n        opacity: 0;\n        pointer-events: none;\n        padding: 0;\n        margin: 0;\n        height: 0;\n        border: 0;\n      }\n      .controls {\n        position: sticky;\n        top: -32px;\n        background-color: white;\n        z-index: 1;\n        padding: 16px 0 8px 0;\n      }\n      .controls .control {\n        border: 1px solid black;\n        border-radius: 0;\n        padding: 4px;\n      }\n      simple-popover {\n        --simple-popover-max-height: 300px;\n      }\n      simple-popover *:not(.close-btn) {\n        max-width: 40vw;\n      }\n      simple-popover::part(simple-popover-content) {\n        overflow: auto;\n      }\n      .close-btn {\n        z-index: 1000;\n        background-color: white;\n        border: 0px;\n        border-radius: 50%;\n        position: absolute;\n        top: 24px;\n        right: 0;\n      }\n      .container {\n        text-align: left;\n      }\n      ul {\n        list-style: none;\n        padding: 0;\n        margin: 0;\n      }\n      ul li {\n        margin: 0;\n        padding: 0;\n      }\n      .operation {\n        display: inline-flex;\n        --simple-icon-width: 24px;\n        --simple-icon-height: 24px;\n        margin: 0 4px;\n      }\n      .content-adding-operations .operation {\n        display: inline-flex;\n        --simple-icon-width: 24px;\n        --simple-icon-height: 24px;\n        margin: 0 4px;\n        border: 1px solid black;\n        border-radius: 0;\n        padding: 4px;\n      }\n      .lock {\n        margin-right: 16px !important;\n        visibility: var(--outline-designer-lock-visibility);\n      }\n      .del {\n        margin-left: 32px !important;\n      }\n      .add {\n        margin-left: 16px !important;\n      }\n      li .operations {\n        justify-content: space-evenly;\n        display: flex;\n      }\n      .content-operation {\n        display: inline-flex;\n        opacity: 0;\n        visibility: hidden;\n        --simple-icon-width: 24px;\n        --simple-icon-height: 24px;\n        margin: 0 4px;\n      }\n      .content-operations {\n        justify-content: space-evenly;\n        display: flex;\n      }\n      li.content-child:hover .content-operation {\n        visibility: visible;\n        opacity: 1;\n      }\n      li[class*=\"collapsed-by-\"] {\n        opacity: 0;\n        height: 0px !important;\n        visibility: hidden;\n        padding: 0px !important;\n        margin: 0px !important;\n        width: 0px !important;\n        padding: 0px !important;\n        margin: 0px !important;\n        border: 0px !important;\n        pointer-events: none;\n        z-index: -1;\n      }\n      /* content not rendered if hidden but in case we change that */\n      li[data-contents-collapsed] {\n        opacity: 0;\n        height: 0px !important;\n        visibility: hidden;\n        padding: 0px !important;\n        margin: 0px !important;\n        width: 0px !important;\n        padding: 0px !important;\n        margin: 0px !important;\n        border: 0px !important;\n        pointer-events: none;\n        z-index: -1;\n      }\n      li simple-icon-button:hover {\n        background-color: #f5f5f5;\n      }\n      .active-preview-item {\n        outline: 1px solid grey;\n        outline-offset: -1px;\n      }\n      .label,\n      .label-edit  {\n        display: none;\n      }\n      span[disabled].label {\n        pointer-events: none;\n        opacity: .6;\n      }\n      .shown {\n        display: inline-block;\n      }\n      .outline-designer-hovered {\n        outline: 2px solid black;\n        outline-offset: -1px;\n        background-color: #e5e5e5;\n      }\n      .make-child-btn {\n        transition: .3s all ease-in-out;\n        visibility: hidden;\n        opacity: 0;\n      }\n      .outline-designer-hovered .make-child-btn {\n        visibility: visible;\n        opacity: .6;\n      }\n      .outline-designer-hovered .make-child-btn:hover {\n        opacity: 1;\n      }\n      .modified .label::after {\n        content: \"*\";\n        color: red;\n        font-size: 20px;\n        line-height: 20px;\n      }\n      .new {\n        --simple-icon-width: 16px;\n        --simple-icon-height: 16px;\n        background-color: black;\n        display: block;\n        margin: -14px 0 0 4px;\n      }\n      :host([stop-animation]) .item {\n        transition: none !important;\n      }\n      .item {\n        display: -webkit-box;\n        border: 1px solid;\n        border-color: grey;\n        margin: 0;\n        padding: 4px;\n        cursor: pointer;\n        opacity: 1;\n        visibility: visible;\n        height: 42px;\n        transition: .3s padding ease-in-out, .3s border ease-in-out,.3s margin ease-in-out;\n        overflow: hidden;\n        align-items: center;\n        justify-content: left;\n        display: flex;\n      }\n      .collapse-btn {\n        visibility: hidden;\n      }\n      .item[data-has-children] .collapse-btn {\n        visibility: visible;\n      }\n      .item[data-about-to-delete] {\n        background-color: #ffa5a5;\n        opacity: .5;\n        border-color: red;\n      }\n      .item[data-about-to-delete][hidden] {\n        visibility: hidden !important;\n        opacity: 0 !important;\n        padding: 0;\n        margin: 0;\n        height: 0;\n        border: 0;\n      }\n      .item:hover,\n      .item:focus {\n        background-color: #f5f5f5;\n      }\n      ul {\n        list-style: none;\n      }\n      .item .label-edit,\n      .item .label {\n        cursor: text;\n        font-size: 14px;\n        font-weight: bold;\n        min-width: 200px;\n        margin-right: 8px;\n        max-width: 40%;\n        line-height: 1.2;\n        padding: 0 4px;\n      }\n\n      .content-child {\n        margin-left: 46px;\n        padding: 8px;\n        height: 24px;\n        border-top: none;\n        border-bottom: none;\n      }\n      .content-heading,\n      .content-non-heading {\n        margin-left: 32px;\n      }\n      .indent-0 {\n        padding-left: 0;\n      }\n      .indent-1 {\n        padding-left: 16px;\n      }\n      .indent-2 {\n        padding-left: calc(16px*2);\n      }\n      .indent-3 {\n        padding-left: calc(16px*3);\n      }\n      .indent-4 {\n        padding-left: calc(16px*4);\n      }\n      .indent-5 {\n        padding-left: calc(16px*5);\n      }\n      .indent-6 {\n        padding-left: calc(16px*6);\n      }\n      .indent-7 {\n        padding-left: calc(16px*7);\n      }\n      .indent-8 {\n        padding-left: calc(16px*8);\n      }\n      .indent-9 {\n        padding-left: calc(16px*9);\n      }\n      .indent-10 {\n        padding-left: calc(16px*10);\n      }\n      .indent-11 {\n        padding-left: calc(16px*11);\n      }\n      .indent-12 {\n        padding-left: calc(16px*12);\n      }\n      .indent-13 {\n        padding-left: calc(16px*13);\n      }\n      .indent-14 {\n        padding-left: calc(16px*14);\n      }\n      .indent-15 {\n        padding-left: calc(16px*15);\n      }\n      .indent-16 {\n        padding-left: calc(16px*16);\n      }\n      .indent-17 {\n        padding-left: calc(16px*17);\n      }\n      .indent-18 {\n        padding-left: calc(16px*18);\n      }\n      .indent-19 {\n        padding-left: calc(16px*19);\n      }\n      .indent-20 {\n        padding-left: calc(16px*20);\n      }\n    "])))];
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          haxGizmos: {
            type: Array
          },
          hideDelete: {
            type: Boolean
          },
          activeItemForActions: {
            type: String
          },
          storeTools: {
            type: Boolean
          },
          eventData: {
            type: Object
          },
          items: {
            type: Array
          },
          appReady: {
            type: Boolean
          },
          activePreview: {
            type: Object
          },
          activePreviewIndex: {
            type: Number
          },
          hideContentOps: {
            type: Boolean,
            reflect: true,
            attribute: "hide-content-ops"
          },
          fidelity: {
            type: String
          }
        };
      }
    }, {
      key: "tag",
      get: function get() {
        return "outline-designer";
      }
    }]);
    return OutlineDesigner;
  }((0, _I18NMixin2.I18NMixin)(_index.LitElement));

  _exports.OutlineDesigner = OutlineDesigner;
  customElements.define(OutlineDesigner.tag, OutlineDesigner);
});