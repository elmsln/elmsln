define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.pageBreakManager = _exports.PageBreakManagerEl = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var PageBreakManagerEl = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(PageBreakManagerEl, _HTMLElement);

    var _super = _createSuper(PageBreakManagerEl);

    function PageBreakManagerEl() {
      var _this;

      babelHelpers.classCallCheck(this, PageBreakManagerEl);
      _this = _super.call(this);
      _this.target = null;
      _this.breaks = [];
      _this._timer = 0;
      return _this;
    } // return current parent node, or the node that would happen
    // on indent or outdent
    // @todo these detections need audited in the context of real material
    // in order to figure out which states are incorrect
    // indent and outdent are inconsistent at best


    babelHelpers.createClass(PageBreakManagerEl, [{
      key: "getParent",
      value: function getParent(el) {
        var rel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var prevNode = null,
            targetNode = null;

        if (this.target) {
          if (rel === "indent") {
            // get prev sibling
            this.target.querySelectorAll("page-break").forEach(function (node) {
              if (node === el) {
                targetNode = prevNode;
              }

              prevNode = node;
            });
          } else if (rel === "outdent") {
            // get parent
            if (this.target.querySelector("page-break[path=\"".concat(el.parent, "\"]"))) {
              targetNode = this.target.querySelector("page-break[path=\"".concat(el.parent, "\"]")); // get parent of parent

              if (this.target.querySelector("page-break[path=\"".concat(targetNode.parent, "\"]"))) {
                targetNode = this.target.querySelector("page-break[path=\"".concat(targetNode.parent, "\"]"));
              }

              {
                targetNode = null;
              }
            }
          } else {
            // get parent
            if (this.target.querySelector("page-break[path=\"".concat(el.parent, "\"]"))) {
              targetNode = this.target.querySelector("page-break[path=\"".concat(el.parent, "\"]"));
            }
          }
        }

        return targetNode;
      }
      /**
       * get all elements between a target and a selector; inspired by
       * (c) 2017 Chris Ferdinandi, MIT License, https://gomakethings.com
       */

    }, {
      key: "elementsBetween",
      value: function elementsBetween(elem) {
        var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "page-break";
        var filter = arguments.length > 2 ? arguments[2] : undefined;
        var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "nextElementSibling";
        // Setup siblings array
        var siblings = []; // Get the next sibling element

        elem = elem[direction]; // As long as a sibling exists

        while (elem) {
          // If we've reached our match, bail
          if (elem.matches(selector)) break; // If filtering by a selector, check if the sibling matches

          if (filter && !elem.matches(filter)) {
            elem = elem[direction];
            continue;
          } // Otherwise, push it to the siblings array


          siblings.push(elem); // Get the sibling element

          elem = elem[direction];
        }

        return siblings;
      }
      /**
       * Return the previous page-break relative to a target element.
       * This is useful for finding the page-break associated with an element in the page
       */

    }, {
      key: "associatedPageBreak",
      value: function associatedPageBreak(elem) {
        // Get the next sibling element
        elem = elem.previousElementSibling; // As long as a sibling exists

        while (elem) {
          // If we've reached our match, bail
          if (elem.matches("page-break")) break; // Get the prev sibling element

          elem = elem.previousElementSibling;
        }

        return elem;
      } // common between element queries

    }, {
      key: "betweenElementsQuery",
      value: function betweenElementsQuery() {
        var _this2 = this;

        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "all";
        var allEl = [];

        switch (type) {
          case "headings":
            this.breaks.forEach(function (element) {
              allEl = [].concat(babelHelpers.toConsumableArray(allEl), babelHelpers.toConsumableArray(_this2.elementsBetween(element, "page-break", "h1,h2,h3,h4,h5,h6")));
            });
            break;

          case "noheadings":
            this.breaks.forEach(function (element) {
              allEl = [].concat(babelHelpers.toConsumableArray(allEl), babelHelpers.toConsumableArray(_this2.elementsBetween(element, "page-break", ":not(h1,h2,h3,h4,h5,h6)")));
            });
            break;

          case "titles":
            this.breaks.forEach(function (element) {
              allEl = [].concat(babelHelpers.toConsumableArray(allEl), babelHelpers.toConsumableArray(_this2.elementsBetween(element, "page-break", "[data-page-break-title]")));
            });
            break;

          case "notitles":
            this.breaks.forEach(function (element) {
              allEl = [].concat(babelHelpers.toConsumableArray(allEl), babelHelpers.toConsumableArray(_this2.elementsBetween(element, "page-break", ":not([data-page-break-title])")));
            });
            break;

          case "all":
            this.breaks.forEach(function (element) {
              allEl = [].concat(babelHelpers.toConsumableArray(allEl), babelHelpers.toConsumableArray(_this2.elementsBetween(element)));
            });
            break;
        }

        return allEl;
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        window.addEventListener("page-break-registration", this.registerPageBreak.bind(this));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("page-break-registration", this.registerPageBreak.bind(this));
      } // push an item into history from a page-break's path based on visibility
      // the elements will self report their visibility status and then this callback
      // will just pick the top most visible item and claim it is the route

    }, {
      key: "updateVisibleAsActive",
      value: function updateVisibleAsActive() {
        clearTimeout(this._timer);
        this._timer = setTimeout(function () {
          if (document.querySelector("page-break[element-visible]")) {
            window.history.pushState({}, null, document.querySelector("page-break[element-visible]").path);
          }
        }, 500);
      }
    }, {
      key: "registerPageBreak",
      value: function registerPageBreak(e) {
        var _this3 = this;

        if (e.detail.action === "add") {
          // ensure this isn't already in there
          if (!this.breaks.find(function (value) {
            return value === e.detail.value;
          })) {
            this.breaks.push(e.detail.value);
          }
        } else {
          this.breaks.map(function (value, index) {
            if (value === e.detail.value) {
              _this3.breaks.splice(index, 1);
            }
          });
        }

        if (this.breaks.length === 1) {
          this.target = e.detail.value.parentNode;
        } else if (this.breaks.length === 0) {
          this.target = null;
        }

        if (!this.__lock) {
          this.__lock = true;
          setTimeout(function () {
            // breaks updated, so we need to recalculate all headings we find
            _this3.breaks.forEach(function (element) {
              _this3.elementsBetween(element, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                var tagNumber = (el.getAttribute("data-original-level") ? new Number(el.getAttribute("data-original-level").replace("H", "")) : new Number(el.tagName.replace("H", ""))) + element.depth;
                tagNumber = tagNumber > 6 ? 6 : tagNumber;
                var newH = document.createElement("h".concat(tagNumber));
                newH.setAttribute("data-original-level", el.tagName);

                for (var i = 0, l = el.attributes.length; i < l; ++i) {
                  newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                }

                newH.innerHTML = el.innerHTML;
                el.parentNode.replaceChild(newH, el);
                element.target = newH;
              });
            }); // update the depth values based on building a "tree"


            if (_this3.target && _this3.target.children && _this3.target.children.length > 0) {
              // wipe inner
              var parents = []; // loop children

              var kids = _this3.target.querySelectorAll("page-break");

              for (var i = 0; i < kids.length; i++) {
                var el = kids[i]; // see if our parent is the active parent

                if (parents.length > 0) {
                  if (el.parent && parents.indexOf(el.parent) !== -1) {
                    while (parents.indexOf(el.parent) !== -1) {
                      parents.shift();
                    }
                  } // missing parent in the hierarchy
                  else if (el.parent && parents.indexOf(el.parent) === -1) {// do nothing; something messed up so let's act like it
                      // didn't happen and just render as we have been
                    } else {
                      // no parent, shift all the way down to nothing
                      while (parents.length > 0) {
                        parents.shift();
                      }
                    }

                  var depth = 0;

                  if (i !== 0 && el.parent && _this3.target.querySelector("page-break[path=\"".concat(el.parent, "\"]"))) {
                    depth = _this3.target.querySelector("page-break[path=\"".concat(el.parent, "\"]")).depth + 1;
                  } // set back into the element how deep it is; weird I know but the element doesn't
                  // know this, the tree builder would though


                  el.depth = depth; // see if WE have children

                  if (i != kids.length && kids[i + 1] && kids[i + 1].parent === el.path) {
                    if (el.parent) {
                      parents.unshift(el.parent);
                    }
                  }
                }
              }
            }

            _this3.__lock = false;
          }, 10);
        }
      }
    }]);
    return PageBreakManagerEl;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement)); // register globally so we can make sure there is only one


  _exports.PageBreakManagerEl = PageBreakManagerEl;
  window.PageBreakManager = window.PageBreakManager || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same modal

  window.PageBreakManager.requestAvailability = function () {
    if (!window.PageBreakManager.instance) {
      window.PageBreakManager.instance = document.createElement("page-break-manager");
      document.body.appendChild(window.PageBreakManager.instance);
    }

    return window.PageBreakManager.instance;
  };

  window.customElements.define("page-break-manager", PageBreakManagerEl);
  var pageBreakManager = window.PageBreakManager.requestAvailability();
  _exports.pageBreakManager = pageBreakManager;
});