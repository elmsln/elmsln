define(["exports", "meta", "../../../../wired-elements/lib/wired-lib.js", "../../../../wired-elements/lib/wired-toggle.js", "../../../../lit/index.js"], function (_exports, meta, _wiredLib, _wiredToggle, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.WiredDarkmodeToggle = void 0;
  meta = _interopRequireWildcard(meta);

  var _templateObject_df6055108e0011ed99ce491205e67b1d, _templateObject2_df6055108e0011ed99ce491205e67b1d;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  // need to highjack in order to alter the scale so we can fit our icon
  // for states
  var sun = new URL("./images/sun.svg", meta.url).href;
  var moon = new URL("./images/moon.svg", meta.url).href;

  var WiredDarkmodeToggle = /*#__PURE__*/function (_WiredToggle) {
    babelHelpers.inherits(WiredDarkmodeToggle, _WiredToggle);

    var _super = _createSuper(WiredDarkmodeToggle);

    function WiredDarkmodeToggle() {
      var _this;

      babelHelpers.classCallCheck(this, WiredDarkmodeToggle);
      _this = _super.call(this);
      _this.checked = false;
      _this.label = "Dark mode";
      return _this;
    } // eslint-disable-next-line class-methods-use-this


    babelHelpers.createClass(WiredDarkmodeToggle, [{
      key: "canvasSize",
      value: function canvasSize() {
        return [100, 48];
      }
    }, {
      key: "draw",
      value: function draw(svg, size) {
        var rect = (0, _wiredLib.rectangle)(svg, 0, 0, size[0], 48, this.seed);
        rect.classList.add("toggle-bar");
        this.knob = (0, _wiredLib.svgNode)("g");
        this.knob.classList.add("knob");
        svg.appendChild(this.knob);
        var knobFill = (0, _wiredLib.hachureEllipseFill)(26, 26, 40, 40, this.seed);
        knobFill.classList.add("knobfill");
        this.knob.appendChild(knobFill);
        (0, _wiredLib.ellipse)(this.knob, 26, 26, 40, 40, this.seed);
      }
    }, {
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_df6055108e0011ed99ce491205e67b1d || (_templateObject_df6055108e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <div style=\"position: relative;\">\n        <svg id=\"svg\"></svg>\n        <label for=\"input\">", "</label>\n        <input\n          id=\"input\"\n          type=\"checkbox\"\n          .checked=\"", "\"\n          ?disabled=\"", "\"\n          @change=\"", "\"\n        />\n      </div>\n    "])), this.label, this.checked, this.disabled, this.onChange);
      }
    }], [{
      key: "tag",
      get: function get() {
        return "wired-darkmode-toggle";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          checked: {
            type: Boolean,
            reflect: true
          },
          disabled: {
            type: Boolean,
            reflect: true
          },
          label: {
            type: String
          }
        };
      }
    }, {
      key: "styles",
      get: function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(WiredDarkmodeToggle), "styles", this)), [(0, _index.css)(_templateObject2_df6055108e0011ed99ce491205e67b1d || (_templateObject2_df6055108e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          opacity: 1;\n          display: inline-flex;\n          vertical-align: top;\n        }\n        :host div {\n          background-image: url(\"", "\");\n          background-repeat: no-repeat;\n          --wired-toggle-off-color: var(--simple-colors-fixed-theme-amber-7);\n          --wired-toggle-on-color: var(\n            --simple-colors-fixed-theme-light-blue-9\n          );\n          background-position-x: 50px;\n          width: 100px;\n          display: inline-flex;\n        }\n        :host([checked]) div {\n          background-image: url(\"", "\");\n          background-position: left;\n        }\n        input {\n          width: 100px;\n          height: 48px;\n          padding: 0;\n          margin: 0;\n        }\n        label {\n          clip: rect(0 0 0 0);\n          clip-path: inset(50%);\n          height: 1px;\n          overflow: hidden;\n          position: absolute;\n          white-space: nowrap;\n          width: 1px;\n        }\n      "])), (0, _index.unsafeCSS)(sun), (0, _index.unsafeCSS)(moon))]);
      }
    }]);
    return WiredDarkmodeToggle;
  }(_wiredToggle.WiredToggle);

  _exports.WiredDarkmodeToggle = WiredDarkmodeToggle;
  customElements.define(WiredDarkmodeToggle.tag, WiredDarkmodeToggle);
});