define(["exports", "meta", "../../lit/index.js", "../simple-colors/simple-colors.js", "../schema-behaviors/schema-behaviors.js", "../media-behaviors/media-behaviors.js", "../intersection-element/lib/IntersectionObserverMixin.js", "../a11y-media-player/a11y-media-player.js", "../i18n-manager/lib/I18NMixin.js"], function (_exports, meta, _index, _simpleColors, _schemaBehaviors, _mediaBehaviors, _IntersectionObserverMixin, _a11yMediaPlayer, _I18NMixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.VideoPlayer = void 0;
  meta = _interopRequireWildcard(meta);

  var _templateObject_729807a0809211edaa2833647dc78c6c, _templateObject2_729807a0809211edaa2833647dc78c6c, _templateObject3_729807a0809211edaa2833647dc78c6c, _templateObject4_729807a0809211edaa2833647dc78c6c, _templateObject5_729807a0809211edaa2833647dc78c6c, _templateObject6_729807a0809211edaa2833647dc78c6c, _templateObject7_729807a0809211edaa2833647dc78c6c, _templateObject8_729807a0809211edaa2833647dc78c6c, _templateObject9_729807a0809211edaa2833647dc78c6c, _templateObject10_729807a0809211edaa2833647dc78c6c, _templateObject11_729807a0809211edaa2833647dc78c6c;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `video-player`
   * `A simple responsive video player with ridiculously powerful backing`
   *
   * @microcopy - language worth noting:
   * - `video source` - url / link to video file
   *
   * @demo demo/index.html
   * @element video-player
   */
  var VideoPlayer = /*#__PURE__*/function (_IntersectionObserver) {
    babelHelpers.inherits(VideoPlayer, _IntersectionObserver);

    var _super = _createSuper(VideoPlayer);

    function VideoPlayer() {
      var _this;

      babelHelpers.classCallCheck(this, VideoPlayer);
      _this = _super.call(this);
      _this.sourceType = "";
      _this.crossorigin = "anonymous";
      _this.dark = false;
      _this.darkTranscript = false;
      _this.disableInteractive = false;
      _this.hideTimestamps = false;
      _this.hideTranscript = false;
      _this.hideYoutubeLink = false;
      _this.lang = "en";
      _this.playing = false;
      _this.__setVisChange = false;
      _this.allowBackgroundPlay = false;
      _this.learningMode = false;
      _this.linkable = false;
      _this.sources = [];
      _this.stickyCorner = "none";
      _this.tracks = [];
      _this.source = "";

      _this.observer.observe(babelHelpers.assertThisInitialized(_this), {
        childList: true,
        subtree: false
      });

      _this.t = _this.t || {};
      _this.t = _objectSpread(_objectSpread({}, _this.t), {}, {
        embeddedMedia: "embedded media"
      });

      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        localesPath: new URL("./locales", meta.url).href,
        locales: ["es"]
      });

      return _this;
    }
    /**
     * life cycle, element is removed from the DOM
     */


    babelHelpers.createClass(VideoPlayer, [{
      key: "render",
      value: // render function
      function render() {
        return (0, _index.html)(_templateObject_729807a0809211edaa2833647dc78c6c || (_templateObject_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral([" ", ""])), this.elementVisible ? (0, _index.html)(_templateObject2_729807a0809211edaa2833647dc78c6c || (_templateObject2_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["", ""])), !this.isA11yMedia ? (0, _index.html)(_templateObject3_729807a0809211edaa2833647dc78c6c || (_templateObject3_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral([" <div\n                class=\"responsive-video-container\"\n                .lang=\"", "\"\n              >\n                ", "\n                ", "\n              </div>\n              <div id=\"videocaption\" class=\"video-caption\">\n                <p>\n                  ", "\n                  <span class=\"media-type print-only\"\n                    >(", ")</span\n                  >\n                </p>\n                <slot name=\"caption\"></slot>\n              </div>\n              <slot hidden></slot>"])), this.lang || undefined, this.sandboxed ? (0, _index.html)(_templateObject4_729807a0809211edaa2833647dc78c6c || (_templateObject4_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral([""]))) : (0, _index.html)(_templateObject5_729807a0809211edaa2833647dc78c6c || (_templateObject5_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral([" <webview\n                      resource=\"", "-video\"\n                      .src=\"", "\"\n                      .width=\"", "\"\n                      .height=\"", "\"\n                      frameborder=\"0\"\n                    >\n                    </webview>"])), this.schemaResourceID, this.sourceData && this.sourceData[0] && this.sourceData[0].src || undefined, this.width || undefined, this.height || undefined), !(!this.sandboxed && this.iframed) ? (0, _index.html)(_templateObject6_729807a0809211edaa2833647dc78c6c || (_templateObject6_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral([""]))) : (0, _index.html)(_templateObject7_729807a0809211edaa2833647dc78c6c || (_templateObject7_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n                      <iframe\n                        loading=\"lazy\"\n                        resource=\"", "-video\"\n                        .src=\"", "\"\n                        width=\"", "\"\n                        height=\"", "\"\n                        frameborder=\"0\"\n                        webkitallowfullscreen=\"\"\n                        mozallowfullscreen=\"\"\n                        allowfullscreen=\"\"\n                      ></iframe>\n                    "])), this.schemaResourceID, this.sourceData && this.sourceData[0] && this.sourceData[0].src || undefined, this.width, this.height), this.mediaTitle, this.t.embeddedMedia) : (0, _index.html)(_templateObject8_729807a0809211edaa2833647dc78c6c || (_templateObject8_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral([" <a11y-media-player\n                accent-color=\"", "\"\n                ?audio-only=\"", "\"\n                ?dark=\"", "\"\n                ?dark-transcript=\"", "\"\n                ?disable-interactive=\"", "\"\n                ?hide-timestamps=\"", "\"\n                ?hide-transcript=\"", "\"\n                ?hide-youtube-link=\"", "\"\n                id=\"", "\"\n                @play=\"", "\"\n                @pause=\"", "\"\n                lang=\"", "\"\n                ?learning-mode=\"", "\"\n                ?linkable=\"", "\"\n                preload=\"metadata\"\n                media-title=\"", "\"\n                .sources=\"", "\"\n                ?stand-alone=\"", "\"\n                sticky-corner=\"", "\"\n                .thumbnail-src=\"", "\"\n                .tracks=\"", "\"\n                .crossorigin=\"", "\"\n                .width=\"", "\"\n                .height=\"", "\"\n                youtube-id=\"", "\"\n              >\n              </a11y-media-player\n              ><slot hidden></slot>"])), this.accentColor, this.audioOnly, this.dark, this.darkTranscript, this.disableInteractive, this.hideTimestamps, this.hideTranscript, this.hideYoutubeLink, this.playerId, this.playEvent, this.pauseEvent, this.lang || "en", this.learningMode, this.linkable, this.mediaTitle || "", this.sourceProperties, this.standAlone, this.stickyCorner || "none", this.thumbnailSrc, this.trackProperties, this.crossorigin || "anonymous", this.width, this.height, this.youtubeId)) : "");
      } // haxProperty definition

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        if (this.__setVisChange) {
          this.__setVisChange = false;
          document.removeEventListener("visibilitychange", this._visChange.bind(this));
        }

        if (this.observer && this.observer.disconnect) this.observer.disconnect();
        babelHelpers.get(babelHelpers.getPrototypeOf(VideoPlayer.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * gets the HTML5 `audio` or `video` children
       * @readonly
       * @returns {object} HTML template
       */

    }, {
      key: "html5",
      get: function get() {
        return (0, _index.html)(_templateObject9_729807a0809211edaa2833647dc78c6c || (_templateObject9_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n      ", "\n      ", "\n    "])), this.sourceData.filter(function (item) {
          return item.type !== "youtube";
        }).map(function (sd) {
          (0, _index.html)(_templateObject10_729807a0809211edaa2833647dc78c6c || (_templateObject10_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n            <source\n              .src=\"", "\"\n              .type=\"", "\"\n            />\n          "])), sd.src || undefined, sd.type || undefined);
        }), this.trackData.map(function (track) {
          "<track\n           .src=\"".concat(track.src || undefined, "\"\n           .kind=\"").concat(track.kind || undefined, "\"\n           .label=\"").concat(track.label || undefined, "\"\n           .srclang=\"").concat(track.lang || undefined, "\"\n         />");
        }));
      }
      /**
       * Computes whether uses iframe
       * @readonly
       * @returns {Boolean}
       */

    }, {
      key: "iframed",
      get: function get() {
        // make sure we take into account sandboxing as well
        // so that we can manage state effectively
        if (this.sourceData && this.sourceData.length > 0 && this.sourceData[0] !== undefined && window.MediaBehaviors.Video._sourceIsIframe(this.sourceData[0].src) && !this.sandboxed) {
          return true;
        }

        return false;
      }
      /**
       * Determines if compatible with `a11y-media-player`
       * @readonly
       * @returns {Boolean}
       */

    }, {
      key: "isA11yMedia",
      get: function get() {
        if (!this.sandboxed && (this.sourceType == "youtube" || this.sourceType == "local" || this.sourceData.length < 1)) {
          return true;
        }

        return false;
      }
      /**
       * mutation observer for tabs
       * @readonly
       * @returns {object}
       */

    }, {
      key: "observer",
      get: function get() {
        var _this2 = this;

        var callback = function callback() {
          return _this2.setSourceData();
        };

        return new MutationObserver(callback);
      }
      /**
       * Compute sandboxed status
       * @readonly
       * @returns {Boolean}
       */

    }, {
      key: "sandboxed",
      get: function get() {
        // we have something that would require an iframe
        // see if we have a local system that would want to sandbox instead
        if (this.sourceData && this.sourceData.length > 0 && babelHelpers.typeof(this.sourceData[0]) !== undefined && window.MediaBehaviors.Video._sourceIsIframe(this.sourceData[0].src)) {
          // fake creation of a webview element to see if it's valid
          // or not.
          var test = document.createElement("webview"); // if this function exists it means that our deploy target
          // is in a sandboxed environment and is not able to run iframe
          // content with any real stability. This is beyond edge case but
          // as this is an incredibly useful tag we want to make sure it
          // can mutate to work in chromium and android environments
          // which support such sandboxing

          if (typeof test.reload === "function") {
            return true;
          }
        }

        return false;
      }
      /**
       * Gets cleaned source list from source and sources properties
       * @readonly
       * @returns {Array} Eg. `[{ "src": "path/to/media.mp3", "type": "audio/mp3"}]`
       */

    }, {
      key: "sourceProperties",
      get: function get() {
        var _this3 = this;

        var temp = typeof this.sources === "string" ? JSON.parse(this.sources) : (this.sources || []).slice();
        if (this.source) temp.unshift({
          src: this.source
        });
        if (temp && temp.length > 0) temp.forEach(function (item) {
          item.type = item.type || _this3._computeMediaType(item.src);
          item.src = _this3._computeSRC(item.src, item.type);
        });
        return temp;
      }
      /**
       * Gets cleaned track list from track and tracks properties
       * @readonly
       * @returns {Array} Eg. `[{ "src": "path/to/track.vtt", "label": "English", "srclang": "en", "kind": "subtitles"}]`
       */

    }, {
      key: "trackProperties",
      get: function get() {
        var _this4 = this;

        var temp = typeof this.tracks === "string" ? JSON.parse(this.tracks) : (this.tracks || []).slice();
        if (this.track) temp.unshift({
          src: this.track
        });
        if (temp && temp.length > 0) temp.forEach(function (item) {
          item.srclang = item.srclang || _this4.lang;
          item.kind = item.kind || "subtitles";
          item.label = item.label || item.kind || item.lang;
        });
        return temp;
      }
      /**
       * Source properties and slotted sources
       * @readonly
       * @returns {Array} List of source objects
       */

    }, {
      key: "sourceData",
      get: function get() {
        var _this5 = this;

        var temp = (this.sourceProperties || []).slice(),
            slotted = this.querySelectorAll("video source, audio source, iframe");
        slotted.forEach(function (slot) {
          if (_this5.sources.filter(function (source) {
            return source.src === slot.src;
          }).length < 1) _this5.sources.unshift({
            src: slot.src,
            type: slot.type || _this5._computeMediaType(slot.src)
          });
        });
        return temp;
      }
    }, {
      key: "audioOnly",
      get: function get() {
        var videos = this.sourceData.filter(function (item) {
          return item.type.indexOf("audio") > -1;
        });
        return videos.length > 1;
      }
    }, {
      key: "standAlone",
      get: function get() {
        return this.trackData === undefined || this.trackData === null || this.trackData.length < 1;
      }
      /**
       * Gets cleaned track list
       * @readonly
       * @returns {Array} Eg. `[{ "src": "path/to/track.vtt", "label": "English", "srclang": "en", "kind": "subtitles",}]`
       */

    }, {
      key: "trackData",
      get: function get() {
        var _this6 = this;

        var temp = typeof this.tracks === "string" ? (JSON.parse(this.tracks) || []).slice() : (this.tracks || []).slice(),
            slotted = this.querySelectorAll("video track, audio track");
        slotted.forEach(function (slot) {
          if (_this6.tracks.filter(function (track) {
            return track.src === slot.src;
          }).length < 1) {
            var track = {
              src: slot.src
            };
            if (slot.lang) track.lang = slot.lang;
            if (slot.srclang) track.srclang = slot.srclang;
            if (slot.label) track.label = slot.label;
            if (slot.kind) track.kind = slot.kind;

            _this6.tracks.unshift(track);
          }

          slot.remove();
        });
        if (this.track !== undefined && this.track !== null && this.track !== "") temp.push({
          src: this.track,
          srclang: this.lang,
          label: this.lang === "en" ? "English" : this.lang,
          kind: "subtitles"
        });
        return temp;
      }
      /**
       * Gets Youtube ID from source string
       * @readonly
       * @returns {String}
       */

    }, {
      key: "youtubeId",
      get: function get() {
        if (this.sourceData && this.sourceData[0] && this.sourceType === "youtube") {
          return this._computeSRC(this.sourceData[0].src).replace(/.*\/embed\//, "");
        }

        return;
      }
      /**
       * gets an id for a11y-media-player
       * @readonly
       * @returns {string} an id for player
       */

    }, {
      key: "playerId",
      get: function get() {
        return "".concat(this.id || this.schemaResourceID, "-media");
      }
      /**
       * Compute media type based on source, i.e. 'audio/wav' for '.wav'
       */

    }, {
      key: "_computeMediaType",
      value: function _computeMediaType(source) {
        var audio = ["aac", "flac", "mp3", "oga", "wav"],
            video = ["mov", "mp4", "ogv", "webm"],
            type = "",
            findType = function findType(text, data) {
          data.forEach(function (item) {
            if (type === "" && babelHelpers.typeof(source) !== undefined && source !== null && source.toLowerCase().indexOf("." + item) > -1) {
              type = text + "/" + item;
            }
          });
        };

        findType("audio", audio);
        findType("video", video);
        return type;
      }
      /**
       * Compute src from type / source combo.
       * Type is set by source so this ensures a waterfall
       * of valid values.
       */

    }, {
      key: "_computeSRC",
      value: function _computeSRC(source, type) {
        if (source !== null && babelHelpers.typeof(source) !== undefined) {
          // ensure that this is a valid url / cleaned up a bit
          type = type || window.MediaBehaviors.Video.getVideoType(source);
          source = window.MediaBehaviors.Video.cleanVideoSource(source, type);

          if (type == "vimeo") {
            if (this.vimeoTitle) {
              source += "?title=1";
            } else {
              source += "?title=0";
            }

            if (this.vimeoByline) {
              source += "&byline=1";
            } else {
              source += "&byline=0";
            }

            if (this.vimeoPortrait) {
              source += "&portrait=1";
            } else {
              source += "&portrait=0";
            }
          } else if (type == "dailymotion") {
            source += "&ui-start-screen-info=false";
            source += "&ui-logo=false";
            source += "&sharing-enable=false";
            source += "&endscreen-enable=false";
          }
        }

        return source;
      }
      /**
       * Implements haxHooks to tie into life-cycle if hax exists.
       */

    }, {
      key: "haxHooks",
      value: function haxHooks() {
        return {
          postProcessNodeToContent: "haxpostProcessNodeToContent"
        };
      }
      /**
       * postProcesshaxNodeToContent - clean up so we don't have empty array data
       */

    }, {
      key: "haxpostProcessNodeToContent",
      value: function haxpostProcessNodeToContent(content) {
        content = content.replace(' sources="[]",', "");
        content = content.replace(' tracks="[]",', "");
        return content;
      }
      /**
       * triggers an update of sourceData property when slot changes
       *
       * @memberof VideoPlayer
       */

    }, {
      key: "setSourceData",
      value: function setSourceData() {
        var temp = this.source;
        this.source = "";
        this.source = temp;
      }
    }, {
      key: "playEvent",
      value: function playEvent(e) {
        this.playing = e.detail.__playing;
      }
    }, {
      key: "pauseEvent",
      value: function pauseEvent(e) {
        this.playing = e.detail.__playing;
      }
      /**
       * LitElement lifecycle
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        var _this7 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(VideoPlayer.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(VideoPlayer.prototype), "firstUpdated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (propName === "allowBackgroundPlay" && _this7[propName] && _this7.__setVisChange) {
            _this7.__setVisChange = false;
            document.removeEventListener("visibilitychange", _this7._visChange.bind(_this7));
          } else if (propName === "allowBackgroundPlay" && !_this7[propName] && !_this7.__setVisChange) {
            _this7.__setVisChange = true;
            document.addEventListener("visibilitychange", _this7._visChange.bind(_this7));
          }
        }); // set source type based on available data

        if (this.sourceData && this.sourceData.length > 0 && this.sourceData[0] !== undefined && babelHelpers.typeof(this.sourceData[0].src) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.sourceType = window.MediaBehaviors.Video.getVideoType(this.sourceData[0].src);
        }
      }
    }, {
      key: "_visChange",
      value: function _visChange(e) {
        if (document.visibilityState === "visible" && !this.playing && this.__forcePaused) {
          this.__forcePaused = false; // resume the video bc it has focus and we stopped it playing previously

          this.shadowRoot.querySelector("a11y-media-player").togglePlay();
        } else if (document.visibilityState === "hidden" && this.playing) {
          // force pause the video; we're in learning mode and they swtiched tabs
          this.__forcePaused = true;
          this.shadowRoot.querySelector("a11y-media-player").togglePlay();
        }
      }
    }], [{
      key: "styles",
      get: //styles function
      function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(VideoPlayer), "styles", this)), [(0, _index.css)(_templateObject11_729807a0809211edaa2833647dc78c6c || (_templateObject11_729807a0809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          margin: 0 0 15px;\n          line-height: 16px !important;\n          font-size: 16px !important;\n        }\n\n        .video-caption {\n          font-style: italic;\n          margin: 0;\n          padding: 8px;\n        }\n      "])))]);
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return {
          canScale: {
            min: 25,
            step: 12.5
          },
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Video player",
            description: "This can present video in a highly accessible manner regardless of source.",
            icon: "av:play-circle-filled",
            color: "red",
            groups: ["Video", "Media"],
            handles: [{
              type: "video",
              type_exclusive: true,
              source: "source",
              title: "caption",
              caption: "caption",
              description: "caption",
              color: "primaryColor"
            }],
            meta: {
              author: "HAXTheWeb core team",
              outlineDesigner: true
            }
          },
          settings: {
            configure: [{
              property: "source",
              title: "Source",
              description: "The URL for this media.",
              inputMethod: "haxupload",
              noCamera: true,
              noVoiceRecord: true,
              validationType: "url"
            }, {
              property: "track",
              title: "Closed captions",
              description: "The URL for the captions file.",
              inputMethod: "haxupload",
              noCamera: true,
              noVoiceRecord: true,
              validationType: "url"
            }, {
              property: "thumbnailSrc",
              title: "Thumbnail image",
              description: "Optional. The URL for a thumbnail/poster image.",
              inputMethod: "haxupload",
              noVoiceRecord: true,
              validationType: "url"
            }, {
              property: "mediaTitle",
              title: "Title",
              description: "Simple title for under video",
              inputMethod: "textfield",
              validationType: "text"
            }, {
              property: "accentColor",
              title: "Accent color",
              description: "Select the accent color for the player.",
              inputMethod: "colorpicker"
            }, {
              property: "dark",
              title: "Dark theme",
              description: "Enable dark theme for the player.",
              inputMethod: "boolean"
            }],
            advanced: [{
              property: "crossorigin",
              title: "Crossorigin",
              description: "Indicates whether to use CORS.",
              inputMethod: "select",
              options: {
                "": "",
                anonymous: "anonymous",
                "use-credentials": "use-credentials"
              }
            }, {
              property: "allowBackgroundPlay",
              title: "Allow background playback",
              description: "Videos pause / play automatically when tab loses focus; this enables video to play without tab having focus",
              inputMethod: "boolean"
            }, {
              property: "learningMode",
              title: "Enable learning mode",
              description: "Disables fast forward and rewind.",
              inputMethod: "boolean"
            }, {
              property: "darkTranscript",
              title: "Dark theme for transcript",
              description: "Enable dark theme for the transcript.",
              inputMethod: "boolean"
            }, {
              property: "disableInteractive",
              title: "Disable Interactive",
              description: "Disable interactive mode that makes transcript clickable.",
              inputMethod: "boolean"
            }, {
              property: "height",
              title: "Height",
              inputMethod: "textfield",
              required: false,
              validationType: "text"
            }, {
              property: "hideTimestamps",
              title: "Hide timestamps",
              description: "Hide the time stamps on the transcript.",
              inputMethod: "boolean"
            }, {
              property: "hideTranscript",
              title: "Hide Transcript",
              description: "Hide transcript by default.",
              inputMethod: "boolean"
            }, {
              property: "lang",
              title: "Language",
              description: "Language of the media.",
              inputMethod: "textfield",
              validationType: "text"
            }, {
              property: "linkable",
              title: "Include a share link?",
              description: "Provides a link to share the video.",
              inputMethod: "boolean"
            }, {
              property: "hideYoutubeLink",
              title: "Remove open on YouTube button",
              description: "Removes the button for opening the video on YouTube.",
              inputMethod: "boolean"
            }, {
              property: "stickyCorner",
              title: "Sticky Corner",
              description: "Set the corner where a video plays when scrolled out of range, or choose none to disable sticky video.",
              inputMethod: "select",
              options: {
                none: "none",
                "top-left": "top-left",
                "top-right": "top-right",
                "bottom-left": "bottom-left",
                "bottom-right": "bottom-right"
              }
            }, {
              property: "sources",
              title: "Other sources",
              description: "List of other sources",
              inputMethod: "array",
              properties: [{
                property: "src",
                title: "Source",
                description: "The URL for this source.",
                inputMethod: "haxupload",
                required: true,
                noCamera: true,
                noVoiceRecord: true,
                validationType: "url"
              }, {
                property: "type",
                title: "Type",
                description: "Media type data",
                inputMethod: "select",
                options: {
                  "audio/aac": "acc audio",
                  "audio/flac": "flac audio",
                  "audio/mp3": "mp3 audio",
                  "video/mp4": "mp4 video",
                  "video/mov": "mov video",
                  "audio/ogg": "ogg audio",
                  "video/ogg": "ogg video",
                  "audio/wav": "wav audio",
                  "audio/webm": "webm audio",
                  "video/webm": "webm video"
                }
              }]
            }, {
              property: "tracks",
              title: "Track list",
              description: "Tracks of different languages of closed captions",
              inputMethod: "array",
              properties: [{
                property: "kind",
                title: "Kind",
                description: "Kind of track",
                inputMethod: "select",
                options: {
                  subtitles: "subtitles"
                }
              }, {
                property: "label",
                title: "Label",
                description: 'The human-readable name for this track, eg. "English Subtitles"',
                inputMethod: "textfield"
              }, {
                property: "src",
                title: "Source",
                description: "The source for the captions file.",
                inputMethod: "haxupload",
                required: false,
                noCamera: true,
                noVoiceRecord: false,
                validationType: "url"
              }, {
                property: "srclang",
                title: 'Two letter, language code, eg. \'en\' for English, "de" for German, "es" for Spanish, etc.',
                description: "Label",
                inputMethod: "textfield"
              }]
            }, {
              property: "width",
              title: "width",
              inputMethod: "textfield",
              required: false,
              validationType: "text"
            }]
          },
          saveOptions: {
            unsetAttributes: ["__utils", "__stand-alone", "colors"]
          },
          demoSchema: [{
            tag: "video-player",
            properties: {
              accentColor: "orange",
              dark: true,
              crossorigin: "anonymous",
              source: "https://www.youtube.com/watch?v=LrS7dqokTLE",
              track: "https://haxtheweb.org/files/HAXshort.vtt"
            },
            content: ""
          }]
        };
      } // properties available to the custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(VideoPlayer), "properties", this)), {}, {
          sourceType: {
            type: String
          },

          /**
           * Optional accent color for controls,
           * using these colors:
           * `red`, `pink`, `purple`, `deep-purple`, `indigo`, `blue`,
           * `light-blue`, `cyan`, `teal`, `green`, `light-green`, `lime`,
           * `yellow`, `amber`, orange, deep-orange, and brown.
           * Default is null.
           */
          accentColor: {
            type: String,
            attribute: "accent-color",
            reflect: true
          },

          /**
           * Cross origin flag for transcripts to load
           */
          crossorigin: {
            type: String,
            attribute: "crossorigin",
            reflect: true
          },

          /**
           * Enables darker player.
           */
          dark: {
            type: Boolean,
            attribute: "dark",
            reflect: true
          },

          /**
           * Use dark theme on transcript? Default is false, even when player is dark.
           */
          darkTranscript: {
            type: Boolean
          },

          /**
           * disable interactive mode that makes transcript clickable
           */
          disableInteractive: {
            type: Boolean
          },

          /**
           * Height of media player.
           */
          height: {
            type: String
          },

          /**
           * show cue's start and end time
           */
          hideTimestamps: {
            type: Boolean,
            attribute: "hide-timestamps"
          },

          /**
           * Hide transcript by default
           */
          hideTranscript: {
            type: Boolean,
            attribute: "hide-transcript"
          },

          /**
           * Unique id
           */
          id: {
            type: String,
            attribute: "id",
            reflect: true
          },

          /**
           * Learning mode
           */
          learningMode: {
            type: Boolean,
            attribute: "learning-mode"
          },

          /**
           * Language of media
           */
          lang: {
            type: String
          },

          /**
           * Include a share link?
           */
          linkable: {
            type: Boolean
          },

          /**
           * Simple caption for video
           */
          mediaTitle: {
            type: String,
            attribute: "media-title",
            reflect: true
          },

          /**
           * Open on YouTube button
           */
          hideYoutubeLink: {
            type: Boolean,
            attribute: "hide-youtube-link"
          },

          /**
           * Single sources of video
           */
          source: {
            type: String,
            reflect: true
          },

          /**
           * Array of multiple video sources
           */
          sources: {
            type: Array
          },

          /**
           * When playing but scrolled off screen, to which corner does it "stick":
           * `top-left`, `top-right`, `bottom-left`, `bottom-right`, or `none`?
           * Default is `top-right`. `None` disables stickiness.
           */
          stickyCorner: {
            type: String,
            attribute: "sticky-corner",
            reflect: true
          },

          /**
           * Url for a single subtitle track
           */
          track: {
            type: String
          },

          /**
           * Array of text tracks, eg. `[{ "src": "path/to/track.vtt", "label": "English", "srclang": "en", "kind": "subtitles", }]`
           */
          tracks: {
            type: Array
          },

          /**
           * Source of optional thumbnail image
           */
          thumbnailSrc: {
            type: String,
            attribute: "thumbnail-src",
            reflect: true
          },

          /**
           * Width of media player for non-a11y-media.
           */
          width: {
            type: String
          },

          /**
           * Data reactivity for play status from a11y-media-player
           */
          playing: {
            type: Boolean,
            reflect: true
          },

          /**
           * Option to allow playing while not active tab
           */
          allowBackgroundPlay: {
            type: Boolean,
            reflect: true,
            attribute: "allow-background-play"
          }
        });
      }
      /**
       * Store tag name to make it easier to obtain directly.
       * @notice function name must be here for tooling to operate correctly
       */

    }, {
      key: "tag",
      get: function get() {
        return "video-player";
      }
    }]);
    return VideoPlayer;
  }((0, _IntersectionObserverMixin.IntersectionObserverMixin)((0, _mediaBehaviors.MediaBehaviorsVideo)((0, _schemaBehaviors.SchemaBehaviors)((0, _I18NMixin.I18NMixin)(_simpleColors.SimpleColors)))));

  _exports.VideoPlayer = VideoPlayer;
  customElements.define(VideoPlayer.tag, VideoPlayer);
});