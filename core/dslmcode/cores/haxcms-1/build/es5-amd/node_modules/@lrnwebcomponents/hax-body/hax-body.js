define(["exports", "meta", "require", "../../lit/index.js", "../simple-colors/simple-colors.js", "../undo-manager/undo-manager.js", "./lib/hax-store.js", "../../mobx/dist/mobx.esm.js", "./lib/hax-text-editor-toolbar.js", "../utils/utils.js", "./lib/hax-ui-styles.js", "../i18n-manager/lib/I18NMixin.js", "../absolute-position-behavior/absolute-position-behavior.js", "../simple-icon/lib/simple-icons.js", "../simple-icon/lib/simple-iconset.js", "./lib/hax-context-behaviors.js", "./lib/hax-plate-context.js", "../grid-plate/grid-plate.js"], function (_exports, meta, _require, _index, _simpleColors, _undoManager, _haxStore, _mobxEsm, _haxTextEditorToolbar, _utils, _haxUiStyles, _I18NMixin2, _absolutePositionBehavior, _simpleIcons, _simpleIconset, _haxContextBehaviors, _haxPlateContext, _gridPlate) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxBody = void 0;
  meta = _interopRequireWildcard(meta);
  _require = _interopRequireWildcard(_require);

  var _templateObject_1a621140942811ecb1937969798b231a, _templateObject2_1a621140942811ecb1937969798b231a, _templateObject3_1a621140942811ecb1937969798b231a;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  // BURN A THOUSAND FIREY DEATHS SAFARI
  if (!Element.prototype.replaceWith) {
    Element.prototype.replaceWith = _utils.ReplaceWithPolyfill;
  }

  if (!CharacterData.prototype.replaceWith) {
    CharacterData.prototype.replaceWith = _utils.ReplaceWithPolyfill;
  }

  if (!DocumentType.prototype.replaceWith) {
    DocumentType.prototype.replaceWith = _utils.ReplaceWithPolyfill;
  } // polyfill for replaceAll, I hate you Safari / really old stuff


  if (!String.prototype.replaceAll) {
    String.prototype.replaceAll = function (find, replace) {
      return this.split(find).join(replace);
    };
  } // END OF 1000 DEATHS
  // variables required as part of the gravity drag and scroll


  var gravityScrollTimer = null;
  var maxStep = 25;
  var edgeSize = 200;
  /**
   * `hax-body`
   * Manager of the body area that can be modified
   * 
  ### Styling
  `<hax-bodys>` provides following custom properties
  for styling:
  
  Custom property | Description | Default
  ----------------|-------------|--------
  --haxcms-base-styles-body-font-size |   | 16px
  --haxcms-base-styles-body-font-family, 'Noto Serif' |   | serif
  --haxcms-base-styles-body-line-height |   | 1.8
  --haxcms-base-styles-body-letter-spacing |   | .5px
  --hax-ui-headings |   | #d4ff77;
  --hax-color-text | default text color | #000
  --hax-contextual-action-text-color |  | --simple-colors-default-theme-grey-1
  --hax-contextual-action-color |  | --simple-colors-default-theme-cyan-7
  --hax-contextual-action-hover-color |  | 
  --hax-body-target-background-color: --simple-colors-default-theme-cyan-2
  --hax-body-possible-target-background-color: --simple-colors-default-theme-grey-2
  
  ####Outlines
  Custom property | Description | Default
  ----------------|-------------|--------
  --hax-body-editable-outline |   | 1px solid --simple-colors-default-theme-deep-orange
  --hax-body-active-outline-hover: 1px solid --hax-contextual-action-color
  --hax-body-active-outline: 3px solid  --hax-contextual-action-color
  
  ####Headings
  Custom property | Description | Default
  ----------------|-------------|--------
  --hax-base-styles-h1-font-size |   | 2.5em
  --hax-base-styles-h1-line-height |   | 2.5em
  --hax-base-styles-h2-font-size |   | 2em
  --hax-base-styles-h3-font-size |   | 1.75em
  --hax-base-styles-h4-font-size |   | 1.5em
  --hax-base-styles-h5-font-size |   | 1.25em
  --hax-base-styles-h6-font-size |   | 1.25em
  --hax-base-styles-p-min-height |   | 43px
  --hax-base-styles-p-font-size |   | 24px
  --hax-base-styles-p-line-height |   | 1.8
  --hax-base-styles-p-letter-spacing |   | 0.5px
  
  ####Links
  Custom property | Description | Default
  ----------------|-------------|--------
  --hax-base-styles-a-color |  | --simple-colors-default-theme-grey-12
  --hax-base-styles-a-font-size |   | 24px
  --hax-base-styles-a-font-weight |   | normal
  --hax-base-styles-a-color-visited |   | --simple-colors-default-theme-light-blue
  --hax-base-styles-a-color-active |   | --simple-colors-default-theme-light-blue
  --hax-base-styles-a-font-weight-active |   | normal
  
  ####Lists
  Custom property | Description | Default
  ----------------|-------------|--------
  --hax-base-styles-list-padding-bottom |   | 1.5em
  --hax-base-styles-list-line-height |   | 40px
  --hax-base-styles-list-font-size |   | 24px
  --hax-base-styles-list-last-child-padding-bottom |   | 1em
  --hax-base-styles-list-padding-left |   | 20px
  --hax-base-styles-list-margin-left |   | 20px
   * 
   * @microcopy - the mental model for this element
   *  - body is effectively a body of content that can be manipulated in the browser. This is for other HAX elements ultimately to interface with and reside in. It is the controller of input and output for all of HAX as it exists in a document. body is not the <body> tag but we need a similar mental model container for all our other elements.
   *  - text-context - the context menu that shows up when an item is active so it can have text based operations performed to it.
   *  - plate/grid plate - a plate or grid plate is a container that we can operate on in HAX. it can also have layout / "global" type of body operations performed on it such as delete, duplicate and higher level format styling.
   * 
   * @demo demo/index.html
   * @LitElement
   * @element hax-body
   */

  var HaxBody = /*#__PURE__*/function (_I18NMixin) {
    babelHelpers.inherits(HaxBody, _I18NMixin);

    var _super = _createSuper(HaxBody);

    /**
     * HTMLElement
     */
    function HaxBody() {
      var _this;

      babelHelpers.classCallCheck(this, HaxBody);
      _this = _super.call(this); // lock to ensure we don't flood events on hitting the up / down arrows
      // as we use a mutation observer to manage draggable bindings

      _this.__ignoreActive = false;
      _this.__dragMoving = false;
      _this.___moveLock = false;
      _this.viewSourceToggle = false;
      _this.editMode = false;
      _this.haxMover = false;
      _this.activeNode = null;
      _this.__lockIconPath = _simpleIconset.SimpleIconsetStore.getIcon("icons:lock");
      _this.part = "hax-body";
      _this.t = {
        addContent: "Add Content"
      }; // primary registration for the namespace so all tags under hax
      // can leverage this data

      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        namespace: "hax"
      });

      if (!window.HaxUiStyles) {
        window.HaxUiStyles = document.createElement("div");

        var s = document.createElement("style"),
            _css = _haxUiStyles.HaxUiBaseStyles.map(function (st) {
          return st.cssText;
        }).join("");

        s.setAttribute("data-hax", true);
        s.setAttribute("type", "text/css");

        if (s.styleSheet) {
          // IE
          s.styleSheet.cssText = _css;
        } else {
          // the world
          s.appendChild(document.createTextNode(_css));
        }

        document.getElementsByTagName("head")[0].appendChild(s);
      }

      setTimeout(function () {
        _this.polyfillSafe = _haxStore.HAXStore.computePolyfillSafe();

        _this.addEventListener("place-holder-replace", _this.replacePlaceholder.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("focusin", _this._focusIn.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("mousemove", _this._mouseMove.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("mouseleave", _this._mouseLeave.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("touchstart", _this._mouseMove.bind(babelHelpers.assertThisInitialized(_this)), {
          passive: true
        });

        _this.addEventListener("mousedown", _this._mouseDown.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("mouseup", _this._mouseUp.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("dragenter", _this.dragEnterBody.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("dragend", _this.dragEndBody.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("drop", _this.dropEvent.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      (0, _mobxEsm.autorun)(function () {
        _this.editMode = (0, _mobxEsm.toJS)(_haxStore.HAXStore.editMode);
      });
      (0, _mobxEsm.autorun)(function () {
        _this.elementAlign = (0, _mobxEsm.toJS)(_haxStore.HAXStore.elementAlign);
      });
      (0, _mobxEsm.autorun)(function () {
        _this.trayStatus = (0, _mobxEsm.toJS)(_haxStore.HAXStore.trayStatus);
        _this.trayDetail = (0, _mobxEsm.toJS)(_haxStore.HAXStore.trayDetail);
      });
      (0, _mobxEsm.autorun)(function () {
        _this.activeNode = (0, _mobxEsm.toJS)(_haxStore.HAXStore.activeNode);
      });
      (0, _mobxEsm.autorun)(function () {
        var activeEditingElement = (0, _mobxEsm.toJS)(_haxStore.HAXStore.activeEditingElement);
      });
      return _this;
    }

    babelHelpers.createClass(HaxBody, [{
      key: "isGridActive",
      get: function get() {
        return _haxStore.HAXStore.isGridPlateElement(activeNode);
      }
      /**
       * When we end dragging ensure we remove the mover class.
       */

    }, {
      key: "dragEndBody",
      value: function dragEndBody(e) {
        this.__manageFakeEndCap(false);

        _haxStore.HAXStore._lockContextPosition = false;
        this.querySelectorAll(".hax-hovered").forEach(function (el) {
          el.classList.remove("hax-hovered");
        });
      }
    }, {
      key: "_mouseLeave",
      value: function _mouseLeave(e) {
        if (this.editMode && _haxStore.HAXStore.ready) {
          clearTimeout(this.__mouseQuickTimer);
          clearTimeout(this.__mouseTimer);
          this.__activeHover = null;
        }
      }
    }, {
      key: "_mouseMove",
      value: function _mouseMove(e) {
        var _this2 = this;

        if (this.editMode && _haxStore.HAXStore.ready) {
          var eventPath = (0, _utils.normalizeEventPath)(e);
          clearTimeout(this.__mouseQuickTimer);
          this.__mouseQuickTimer = setTimeout(function () {
            if (_this2.__activeHover && _this2.__activeHover != eventPath[0].closest("[data-hax-ray]:not(li)")) {
              _this2.__activeHover = null;
            }
          }, 300);
          clearTimeout(this.__mouseTimer);
          this.__mouseTimer = setTimeout(function () {
            _this2.__addActiveVisible();

            var target = eventPath[0].closest("[data-hax-ray]:not(li)");

            if (target) {
              _this2.__activeHover = target;
            } else if (eventPath[0].closest("[data-move-order]") && eventPath[3] && eventPath[3].closest("[data-hax-layout]")) {
              // weird but we need the structure of grid plate here unfortunately
              // if it has nodes in the column we are active on then we need
              // to defer to the grid level because you could always force a node
              if (!eventPath[0].closest("[data-move-order]:not(.has-nodes")) {
                // way out of a column to the host of the template
                _this2.__activeHover = eventPath[0].closest("[data-move-order]").parentNode.parentNode.host;
              } else {
                // to avoid a later loop, we force this to "false"
                _this2.__addAbove = false; // this is a grid column so get it's ID to understand it's slot
                // this leverages our internal __slot hack that gets picked up
                // by our MO in order to automatically set __slot on a node anywhere
                // it's inserted in the body area leveraging alternative logic to
                // figure out which it should place where

                _this2.__slot = eventPath[0].closest("[data-move-order]").getAttribute("id").replace("col", "col-"); // based on what we learned we don't have nodes in the path column
                // but we KNOW there MUST be an element somewhere in this

                if (eventPath[0].closest("[data-move-order]").parentNode.parentNode.host.children.length == 0) {
                  var p = document.createElement("p");
                  eventPath[0].closest("[data-move-order]").parentNode.parentNode.host.appendChild(p);
                }

                _this2.__activeHover = eventPath[0].closest("[data-move-order]").parentNode.parentNode.host.children[0];
              }
            } else if (eventPath[0].closest("#bodycontainer")) {
              _this2.__activeHover = null;
            }
          }, 400);
        }
      }
    }, {
      key: "_mouseDown",
      value: function _mouseDown(e) {
        if (this.editMode) {
          this.__mouseDown = true;
          var target = e.target; // resolve to the closest ediable element if possible
          // otherwise keep the target we had
          // @todo need to test more situations for this..

          if (target.closest("[draggable]")) {
            target = target.closest("[draggable]");
          } else if (target.closest("[slot]")) {
            target = target.closest("[slot]");
          } else if (target.closest("[data-hax-ray]")) {
            target = target.closest("[data-hax-ray]");
          } else if (target.closest("[contenteditable]")) {
            target = target.closest("[contenteditable]");
          } else if (_haxStore.HAXStore.validTagList.includes(target.tagName.toLowerCase())) {// tagName is in the valid tag list so just let it get selected
          } else if (target.tagName !== "HAX-BODY" && !target.haxUIElement) {
            // this is a usecase we didn't think of...
            console.warn(target);
          }

          if (!target.haxUIElement && this.__focusLogic(target)) {
            e.stopPropagation();
            e.stopImmediatePropagation();
          }
        }
      }
      /**
       * On mouse release, dump any scroller and the end cap element
       */

    }, {
      key: "_mouseUp",
      value: function _mouseUp(e) {
        var _this3 = this;

        // this helps w/ ensuring that the "focusin" event doesn't
        // fire when a mousedown is executed
        setTimeout(function () {
          _this3.__mouseDown = false;
        }, 0); // failsafe to clear to the gravity scrolling

        clearTimeout(gravityScrollTimer);

        this.__manageFakeEndCap(false);
      }
    }, {
      key: "clickEvent",
      value: function clickEvent(e) {
        // failsafe to clear to the gravity scrolling
        clearTimeout(gravityScrollTimer);
      }
    }, {
      key: "blurEvent",
      value: function blurEvent(e) {
        if (this.editMode) {
          // specialized element / item interaction that generated a blur
          // event which could imply we clicked on an iframe and "left" the
          // scope of the current browsing document. Example of
          // what can cause this is monaco-editor
          // @todo implement a possible hook here
          if (_haxStore.HAXStore.activeEditingElement) {}
        }
      }
      /**
       * Make a fake end cap element so we can drop in the last position
       * @note This is much easier logic than the alternatives to account for.
       */

    }, {
      key: "__manageFakeEndCap",
      value: function __manageFakeEndCap() {
        var create = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (create && !this.__fakeEndCap) {
          var fake = document.createElement("fake-hax-body-end");
          fake.style.width = "100%";
          fake.style.height = "20px";
          fake.style.zIndex = "2";
          fake.style.display = "block";
          this.__fakeEndCap = fake;
          this.haxMover = true;
          this.appendChild(this.__fakeEndCap);

          this.__applyNodeEditableState(this.__fakeEndCap, true);
        } else if (!create && this.__fakeEndCap) {
          this.__fakeEndCap.remove();

          this.haxMover = false;
          this.__fakeEndCap = null;
        }
      }
      /**
       * Activation allowed from outside this grid as far as drop areas
       */

    }, {
      key: "dragEnterBody",
      value: function dragEnterBody(e) {
        // insert a fake child at the end
        this.__manageFakeEndCap(true);
      }
      /**
       * LitElement render
       */

    }, {
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_1a621140942811ecb1937969798b231a || (_templateObject_1a621140942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n      <style id=\"hax-body-style-element\"></style>\n      <div\n        id=\"bodycontainer\"\n        class=\"ignore-activation\"\n        element-align=\"", "\"\n      >\n        <slot id=\"body\"></slot>\n      </div>\n      <absolute-position-behavior\n        id=\"topcontext\"\n        fit-to-visible-bounds\n        justify\n        position=\"top\"\n        allow-overlap\n        auto\n        sticky\n        data-node-type=\"", "\"\n        .target=\"", "\"\n        .trayStatus=\"", "\"\n        ?hidden=\"", "\"\n      >\n        <div id=\"topcontextmenu\">\n          <hax-plate-context\n            always-expanded\n            id=\"platecontextmenu\"\n            class=\"hax-context-menu ignore-activation\"\n            .activeNode=\"", "\"\n            .trayDetail=\"", "\"\n            .trayStatus=\"", "\"\n            ?viewSource=\"", "\"\n            ?canMoveElement=\"", "\"\n          ></hax-plate-context>\n          <hax-text-editor-toolbar\n            id=\"textcontextmenu\"\n            class=\"hax-context-menu ignore-activation ", "\"\n            .activeNode=\"", "\"\n            show=\"always\"\n          >\n          </hax-text-editor-toolbar>\n        </div>\n      </absolute-position-behavior>\n    "])), this.elementAlign || "right", !this.activeNode ? "" : this.viewSourceToggle ? this.activeNode.parentNode.tagName : this.activeNode.tagName, !this.activeNode ? document.body : this.viewSourceToggle ? this.activeNode.parentNode : this.activeNode, this.trayStatus, !this.activeNode, this.activeNode, this.trayDetail, this.trayStatus, this.viewSourceToggle, this.canMoveElement, !this.activeNode || this.activeNode.getAttribute("data-hax-lock") || this.activeNode.parentNode && this.activeNode.parentNode.getAttribute("data-hax-lock") || !_haxStore.HAXStore.isTextElement(this.activeNode) && !_haxStore.HAXStore.isSingleSlotElement(this.activeNode) ? "not-text" : "is-text", this.activeNode);
      }
      /**
       * LitElement / popular convention
       */

    }, {
      key: "HAXBODYStyleSheetContent",
      value: function HAXBODYStyleSheetContent() {
        var styles = [];
        styles.push((0, _index.css)(_templateObject2_1a621140942811ecb1937969798b231a || (_templateObject2_1a621140942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n      :host([edit-mode]) #bodycontainer ::slotted(*[data-hax-lock])::after {\n        background-image: url(\"", "\");\n      }\n    "])), (0, _index.unsafeCSS)(this.__lockIconPath)));
        return styles;
      }
      /**
       * LitElement life cycle - ready
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        var _this4 = this;

        (0, _index.render)(this.HAXBODYStyleSheetContent(), this.shadowRoot.querySelector("#hax-body-style-element"));
        this.dispatchEvent(new CustomEvent("hax-register-body", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: this
        })); // try to normalize paragraph insert on enter

        try {
          document.execCommand("enableObjectResizing", false, false);
          document.execCommand("defaultParagraphSeparator", false, "p");
        } catch (e) {
          console.warn(e);
        }

        this.contextMenus = {
          text: this.shadowRoot.querySelector("#textcontextmenu"),
          plate: this.shadowRoot.querySelector("#platecontextmenu"),
          parent: this.shadowRoot.querySelector("#topcontext")
        }; // track and store range on mouse up. this helps w/ Safari focus selection
        // issues as well as any "tap" event from a phone knowing what text
        // WAS selected prior to an operation that might lose focus / selection
        // during the workflow like replacing an element in context / inline

        this.shadowRoot.querySelector("slot").addEventListener("mouseup", function (e) {
          if (_this4.editMode) {
            setTimeout(function () {
              var tmp = _haxStore.HAXStore.getSelection();

              _haxStore.HAXStore._tmpSelection = tmp;
              _haxStore.HAXStore.haxSelectedText = tmp.toString();

              try {
                var range = _haxStore.HAXStore.getRange();

                if (range.cloneRange) {
                  _haxStore.HAXStore._tmpRange = range.cloneRange();
                }
              } catch (e) {
                console.warn(e);
              }
            }, 10);
          }
        }); // in case we miss this on the initial setup. possible in auto opening environments.

        this.editMode = _haxStore.HAXStore.editMode; // ensure this resets every append

        this.__tabTrap = false;
        this.ready = true;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "firstUpdated", this).call(this, changedProperties);
        }
      }
      /**
       * LitElement life cycle - properties changed callback
       */

    }, {
      key: "updated",
      value: function () {
        var _updated = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(changedProperties) {
          var _this5 = this;

          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  changedProperties.forEach( /*#__PURE__*/function () {
                    var _ref = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(oldValue, propName) {
                      return regeneratorRuntime.wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              if (propName == "editMode" && oldValue !== undefined) {
                                // microtask delay to allow store to establish child nodes appropriately
                                setTimeout( /*#__PURE__*/babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                                  return regeneratorRuntime.wrap(function _callee$(_context) {
                                    while (1) {
                                      switch (_context.prev = _context.next) {
                                        case 0:
                                          _this5._editModeChanged(_this5[propName], oldValue);

                                          if (!_this5[propName]) {
                                            _context.next = 7;
                                            break;
                                          }

                                          _context.next = 4;
                                          return _this5._activeNodeChanged(_this5.activeNode, null);

                                        case 4:
                                          _this5.activeNode.focus();

                                          _context.next = 9;
                                          break;

                                        case 7:
                                          _context.next = 9;
                                          return _this5._activeNodeChanged(null, _this5.activeNode);

                                        case 9:
                                        case "end":
                                          return _context.stop();
                                      }
                                    }
                                  }, _callee);
                                })), 0);
                              }

                              if (!(propName == "activeNode" && _this5.ready)) {
                                _context2.next = 4;
                                break;
                              }

                              _context2.next = 4;
                              return _this5._activeNodeChanged(_this5[propName], oldValue);

                            case 4:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2);
                    }));

                    return function (_x2, _x3) {
                      return _ref.apply(this, arguments);
                    };
                  }());

                  if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "updated", this)) {
                    babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "updated", this).call(this, changedProperties);
                  }

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function updated(_x) {
          return _updated.apply(this, arguments);
        }

        return updated;
      }()
      /**
       * HTMLElement
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this6 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "connectedCallback", this).call(this); // mutation observer that ensures state of hax applied correctly

        this._observer = new MutationObserver(function (mutations) {
          var mutFind = false;

          if (!_this6.__ignoreActive && !_this6.__dragMoving && !_this6.undoStackIgnore && !_this6.__fakeEndCap) {
            mutations.forEach(function (mutation) {
              if (mutation.addedNodes.length > 0) {
                var _iterator = _createForOfIteratorHelper(mutation.addedNodes),
                    _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var node = _step.value;

                    if (_this6._validElementTest(node)) {
                      // no empty HTML primative tags w/ just a BR in it for spacing purposes
                      if (!_this6.__delHit && node.tagName === "BR" && node.parentElement && _haxStore.HAXStore.__validGridTags().includes(node.parentElement.tagName.toLowerCase()) && node === node.parentElement.childNodes[node.parentElement.childNodes.length - 1]) {
                        var p = node.parentElement;
                        node.remove(); // add space to end of text content if it exists

                        if (p.childNodes.length > 0) {
                          var txt = p.childNodes[p.childNodes.length - 1];
                          txt.textContent += "\u200B";

                          _haxStore.HAXStore._positionCursorInNode(txt, txt.length);
                        }

                        continue;
                      }

                      _this6.__delHit = false; // P should not be in a P; parent detects it

                      if (node.tagName === "P" && node.children.length > 0 && node.children[0].tagName === "P") {
                        (0, _utils.unwrap)(node);
                        continue;
                      } // P should not be in a P; kid detects it


                      if (node.tagName === "P" && node.parentElement && node.parentElement.tagName === "P") {
                        (0, _utils.unwrap)(node.parentElement);
                        continue;
                      } // ensure no slot issue w/ this element as parent
                      // timing issues or faulty elements being imported can trip this
                      // which should never be possible


                      if (node.getAttribute("slot") != null && node.parentElement === _this6) {
                        node.removeAttribute("slot");
                        continue;
                      } // weird edge clean up from pasting operations
                      // span tag popping up when doing keyboard based indent operations in a list


                      if (node.tagName === "LI" && node.children.length > 0 && node.children[0].tagName === "SPAN") {
                        if (_this6.activeNode === node.children[0] || _this6.activeNode === node) {
                          _this6.activeNode = node;
                        }

                        (0, _utils.unwrap)(node.children[0]);
                        continue;
                      } // list tag that isn't in a list


                      if (node.tagName === "LI" && node.parentElement && !["UL", "OL"].includes(node.parentElement.tagName)) {
                        (0, _utils.unwrap)(node);
                        continue;
                      } // some browsers can accidentally cause this in certain situations


                      if (node.tagName === "P" && node.children.length > 0 && ["P", "LI"].includes(node.children[0].tagName)) {
                        (0, _utils.unwrap)(node.children[0]);
                        continue;
                      } // notice the slot being set during an enter event
                      // and ensure we replicate it


                      if (_this6.__slot) {
                        node.setAttribute("slot", _this6.__slot);
                        _this6.__slot = null;
                      } // trap for user hitting the outdent / indent keys or tabbing
                      // browser will try and wrap text in a span when it's added to
                      // the top level of the document (for no reason)


                      if (_this6.__indentTrap) {
                        // span should not be created, we want a paragraph for this
                        if (node.tagName === "SPAN") {
                          if (node.parentNode === _this6) {
                            _this6.haxChangeTagName(node, "p", true);
                          } else if (node.parentNode.tagName === "LI") {
                            node.parentNode.innerHTML = node.textContent;
                          }
                        } // we don't want BR's injected at top of body area
                        else if (node.tagName === "BR") {
                            node.remove();
                            continue;
                          }
                      } // edge case, thing is moved around in the dom so let's do the opposite
                      // this is something that has PART of these applies
                      // let's make sure that we maintain state associated with contenteditable


                      if (_this6.editMode && (node.getAttribute("contenteditable") == "true" || node.getAttribute("contenteditable") === true || node.getAttribute("contenteditable") == "contenteditable")) {
                        _this6.__applyNodeEditableState(node, !_this6.editMode);
                      }

                      _this6.__applyNodeEditableState(node, _this6.editMode); // now test for this being a grid plate element which implies
                      // we need to ensure this is applied deep into its children


                      if (_haxStore.HAXStore.isGridPlateElement(node)) {
                        // more lazy selector that will pull ANYTHING in the grid plate element
                        var grandKids = node.querySelectorAll("*");

                        for (var j = 0; j < grandKids.length; j++) {
                          // sanity check for being a valid element / not a "hax" element
                          if (_this6._validElementTest(grandKids[j])) {
                            // correctly add or remove listeners
                            _this6.__applyNodeEditableState(grandKids[j], _this6.editMode);
                          }
                        }
                      } // special support for Header tags showing up w.o. identifiers
                      // this way it's easier to anchor to them in the future


                      if (["H1", "H2", "H3", "H4", "H5", "H6"].includes(node.tagName) && node.getAttribute("id") == null) {
                        node.setAttribute("id", (0, _utils.generateResourceID)("header-"));
                      } // set new nodes to be the active one
                      // only if we didn't just do a grid plate move
                      // if multiple mutations, only accept the 1st one in a group
                      // special trap for BR being added into the page
                      // this avoids empty elements however we don't want it to trigger
                      // active to change


                      if (!_this6.___moveLock && !mutFind) {
                        mutFind = true;
                        _haxStore.HAXStore.activeNode = node;

                        if (node.tagName === "BR") {
                          var tmp = _haxStore.HAXStore.getSelection();

                          _haxStore.HAXStore._tmpSelection = tmp;
                          _haxStore.HAXStore.haxSelectedText = tmp.toString();

                          var rng = _haxStore.HAXStore.getRange();

                          if (rng.collapsed && _this6.activeNode.tagName === "BR" && _this6.activeNode.parentNode === rng.commonAncestorContainer && _this6.activeNode.innerText === "") {
                            _haxStore.HAXStore.activeNode = _this6.activeNode.parentNode;
                          }
                        }
                      } else {
                        _this6.___moveLock = false;
                      }
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                if (_this6.__indentTrap) {
                  setTimeout(function () {
                    _this6.__indentTrap = false;
                  }, 0);
                }
              } // ensure we are never 100% empty but only if actively editing
              // this way we can't delete... EVERYTHING
              else if (_this6.ready && _this6.editMode && _haxStore.HAXStore.ready && mutation.addedNodes.length === 0 && mutation.removedNodes.length > 0 && _this6.shadowRoot && _this6.shadowRoot.querySelector("#body").assignedNodes({
                  flatten: true
                }).length === 0) {
                  // we saw that we had nothing, but let's ensure the DOM really stayed empty
                  // some projects might lag 1 cycle here and really this is just to ensure
                  // that we don't end up w/ a busted UX pattern AFTER the user makes a mistake
                  // this helps ensure common operations like importing content don't accidentally
                  // activate this 0 content case
                  setTimeout(function () {
                    if (_this6.shadowRoot.querySelector("#body").assignedNodes({
                      flatten: true
                    }).length === 0) {
                      _this6.appendChild(document.createElement("p"));
                    }
                  }, 100);
                }
            });
          } // our undo/redo history is being applied. Make sure events
          // are bound but that we don't actively track other changes
          // or it'll poisen our undo stack
          else if (_this6.undoStackIgnore) {
              mutations.forEach(function (mutation) {
                if (mutation.addedNodes.length > 0) {
                  mutation.addedNodes.forEach(function (node) {
                    // valid element to apply state to
                    if (_this6._validElementTest(node)) {
                      // make it editable / drag/drop capable
                      setTimeout(function () {
                        _this6.__applyNodeEditableState(node, _this6.editMode);
                      }, 0);
                    }
                  });
                }
              });
            } // regardless, we just processed mutations, let's ensure we are not ignoring things


          if (_this6.__ignoreActive) {
            _this6.__ignoreActive = false;
          }

          _haxStore.HAXStore.haxTray.updateMap();
        });

        this._observer.observe(this, {
          childList: true,
          subtree: true
        });

        window.addEventListener("hax-context-item-selected", this._haxContextOperation.bind(this));
        window.addEventListener("hax-toggle-active-node-lock", this._toggleNodeLocking.bind(this));
        window.addEventListener("click", this.clickEvent.bind(this));
        window.addEventListener("blur", this.blurEvent.bind(this));
        window.addEventListener("keydown", this._onKeyDown.bind(this));
        window.addEventListener("keypress", this._onKeyPress.bind(this));
        document.body.addEventListener("hax-store-property-updated", this._haxStorePropertyUpdated.bind(this));
        window.addEventListener("scroll", this._keepContextVisible.bind(this), {
          passive: true
        });
        window.addEventListener("resize", this._keepContextVisible.bind(this), {
          passive: true
        });
      }
      /**
       * HTMLElement
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("hax-toggle-active-node-lock", this._toggleNodeLocking.bind(this));
        window.removeEventListener("click", this.clickEvent.bind(this));
        window.removeEventListener("blur", this.blurEvent.bind(this));
        window.removeEventListener("keydown", this._onKeyDown.bind(this));
        window.removeEventListener("keypress", this._onKeyPress.bind(this));
        document.body.removeEventListener("hax-store-property-updated", this._haxStorePropertyUpdated.bind(this));
        window.removeEventListener("scroll", this._keepContextVisible.bind(this));
        window.removeEventListener("resize", this._keepContextVisible.bind(this));
        window.removeEventListener("hax-context-item-selected", this._haxContextOperation.bind(this));

        this._observer.disconnect();

        babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "disconnectedCallback", this).call(this);
      } // we were told node was locked or unlocked, toggle to ensure we rerender
      // since it's an attribute setting

    }, {
      key: "_toggleNodeLocking",
      value: function _toggleNodeLocking(e) {
        if (!e.detail.lock) {
          this.contextMenus.plate.disableDuplicate = false;
          this.contextMenus.plate.disableOps = false;
          this.contextMenus.plate.disableItemOps = false;
          this.contextMenus.plate.canMoveElement = this.canMoveElement;
          e.detail.node.setAttribute("contenteditable", true);
          this.setAttribute("contenteditable", true);
        } else {
          this.contextMenus.plate.disableDuplicate = true;
          this.contextMenus.plate.disableOps = true;
          this.contextMenus.plate.disableItemOps = true;
          this.contextMenus.plate.canMoveElement = false;
          e.detail.node.removeAttribute("contenteditable");
          this.removeAttribute("contenteditable");
        }

        this.requestUpdate();
      }
      /**
       * Keep the context menu visible if needed
       */

    }, {
      key: "_keepContextVisible",
      value: function _keepContextVisible() {
        var _this7 = this;

        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (this.editMode) {
          clearTimeout(this.__contextVisibleLock);
          this.__contextVisibleLock = setTimeout(function () {
            // see if the text context menu is visible
            var el = false;

            if (_this7.contextMenus.plate.classList.contains("hax-context-visible")) {
              el = _this7.contextMenus.plate;
            } // if we see it, ensure we don't have the pin


            if (el) {
              _this7.positionContextMenus();
            }
          }, 100);
        }
      }
    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(e) {
        var _this8 = this;

        // make sure we don't have an open drawer, and editing, and we are not focused on tray
        if (this.editMode && document.activeElement.tagName !== "HAX-TRAY" && document.activeElement.tagName !== "BODY" && document.activeElement.tagName !== "SIMPLE-MODAL") {
          // if we are NOT editing and delete key is hit, delete the element
          if (this.getAttribute("contenteditable")) {
            this.__dropActiveVisible();

            this.__manageFakeEndCap(false);

            var sel = _haxStore.HAXStore.getSelection();

            if (sel.anchorNode != null) {
              switch (e.key) {
                case "Z":
                case "z":
                  // trab for undo / redo
                  if (e.ctrlKey) {
                    if (e.shiftKey) {
                      this.redo();
                    } else {
                      this.undo();
                    }

                    if (e.detail.keyboardEvent) {
                      e.detail.keyboardEvent.preventDefault();
                      e.detail.keyboardEvent.stopPropagation();
                      e.detail.keyboardEvent.stopImmediatePropagation();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                  }

                  break;

                case "Tab":
                  if (_haxStore.HAXStore.isTextElement(this.activeNode)) {
                    if (e.detail.keyboardEvent) {
                      e.detail.keyboardEvent.preventDefault();
                      e.detail.keyboardEvent.stopPropagation();
                      e.detail.keyboardEvent.stopImmediatePropagation();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();

                    if (e.shiftKey) {
                      this._tabBackKeyPressed();
                    } else {
                      this._tabKeyPressed();
                    }
                  }

                  break;

                case "Enter":
                  if (this.activeNode) {
                    this.__slot = this.activeNode.getAttribute("slot");
                  }

                  if (this.activeNode && this.activeNode.tagName === "P" && ["1", "#", "`", ">", "-", "!"].includes(this.activeNode.textContent[0])) {
                    // ensure the "whitespace character" has been replaced w/ a normal space
                    var guess = this.activeNode.textContent.replaceAll(/Â /g, " "); // ensures that the user has done a matching action and a " " spacebar to ensure they
                    // are ready to commit the action

                    this.keyboardShortCutProcess(guess);
                  }

                  break;
                // extra trap set for this in case we care that we are in the act of deleting

                case "Backspace":
                case "Delete":
                  this.__delHit = true;
                  break;

                case "ArrowUp":
                case "ArrowDown":
                case "ArrowLeft":
                case "ArrowRight":
                  setTimeout(function () {
                    var tmp = _haxStore.HAXStore.getSelection();

                    _haxStore.HAXStore._tmpSelection = tmp;
                    _haxStore.HAXStore.haxSelectedText = tmp.toString();

                    var rng = _haxStore.HAXStore.getRange();

                    if (rng.commonAncestorContainer && _this8.activeNode !== rng.commonAncestorContainer && typeof rng.commonAncestorContainer.focus === "function") {
                      if (rng.commonAncestorContainer.tagName !== "HAX-BODY") {
                        _this8.__focusLogic(rng.commonAncestorContainer, false);
                      }
                    } // need to check on the parent too if this was a text node
                    else if (rng.commonAncestorContainer && rng.commonAncestorContainer.parentNode && _this8.activeNode !== rng.commonAncestorContainer.parentNode && typeof rng.commonAncestorContainer.parentNode.focus === "function") {
                        if (rng.commonAncestorContainer.parentNode.tagName !== "HAX-BODY") {
                          _this8.__focusLogic(rng.commonAncestorContainer.parentNode, false);
                        } else {
                          _this8.__focusLogic(rng.commonAncestorContainer, false);
                        }
                      }
                  }, 0);
                  break;

                default:
                  // we only care about contextual ops in a paragraph
                  // delay a micro-task to ensure activenode's innerText is set
                  setTimeout(function () {
                    if (_this8.activeNode && _this8.activeNode.tagName === "P" && ["1", "#", "`", ">", "-", "!"].includes(_this8.activeNode.textContent[0])) {
                      // ensure the "whitespace character" has been replaced w/ a normal space
                      var _guess = _this8.activeNode.textContent.replaceAll(/Â /g, " "); // ensures that the user has done a matching action and a " " spacebar to ensure they
                      // are ready to commit the action


                      if (_guess[_guess.length - 1] === " ") {
                        _this8.keyboardShortCutProcess(_guess);
                      }
                    }
                  }, 0);
                  break;
              }
            }
          }
        }
      }
      /**
       * Process input to see if it matches any defined keyboard shortcuts
       */

    }, {
      key: "keyboardShortCutProcess",
      value: function keyboardShortCutProcess(guess) {
        // see if our map matches
        if (_haxStore.HAXStore.keyboardShortcuts[guess.replace(" ", "")]) {
          var el = (0, _utils.haxElementToNode)(_haxStore.HAXStore.keyboardShortcuts[guess.replace(" ", "")]);
          this.haxReplaceNode(this.activeNode, el);

          this.__focusLogic(el); // breaks should jump just PAST the break
          // and add a p since it's a divider really


          if (el.tagName === "HR") {
            // then insert a P which will assume active status
            this.haxInsert("p", "", {});
          }
        } // @todo handle this differently
        // look for wildcard / web component pro insert mode
        else if (guess[0] === "!") {
            var tag = guess.replace("!", "").replaceAll(/ /g, ""); // see if this exists

            if (_haxStore.HAXStore.elementList[tag]) {
              // generate schema from the tag
              var schema = _haxStore.HAXStore.haxSchemaFromTag(tag);

              var target;

              if (schema.gizmo.tag && schema.demoSchema && schema.demoSchema[0]) {
                target = (0, _utils.haxElementToNode)(schema.demoSchema[0]);
              } else {
                target = document.createElement(tag);
              }

              this.haxReplaceNode(this.activeNode, target);

              this.__focusLogic(target);
            } else {
              // do nothing, we tried to be a pro but failed :(
              _haxStore.HAXStore.toast("".concat(tag, " is not a valid tag"));
            }
          }
      }
    }, {
      key: "_onKeyPress",
      value: function _onKeyPress(e) {
        var _this9 = this;

        var next = this.activeNode && this.activeNode.nextElementSibling ? this.activeNode.nextElementSibling : null;
        if (next && e.key === "Enter") this.setActiveNode(this.activeNode.nextElementSibling); //needed so that you can add new paragraphs before and element

        setTimeout(function () {
          if (_this9.activeNode && _this9.activeNode === next && _this9.editMode && _this9.activeNode.previousElementSibling) {
            _this9.haxInsert("p", "", {}, _this9.activeNode.previousElementSibling);
          }
        }, 1);
      }
      /**
       * sets active node
       *
       * @param {*} node
       * @memberof HaxBody
       */

    }, {
      key: "setActiveNode",
      value: function setActiveNode(node) {
        var _this10 = this;

        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (node && this.editMode && this.activeNode && (_haxStore.HAXStore.isTextElement(this.activeNode) || force)) {
          this.activeNode = node; // If the user has paused for awhile, show the menu

          clearTimeout(this.__positionContextTimer);
          this.__positionContextTimer = setTimeout(function () {
            // always on active if we were just typing
            _this10.__addActiveVisible();

            _this10.positionContextMenus();
          }, 2000);
        }
      }
      /**
       * Only true if we are scrolling and part way through an element
       */

    }, {
      key: "elementMidViewport",
      value: function elementMidViewport() {
        var y = this.activeNode.getBoundingClientRect().y;
        return y < 0 && y > -1 * this.activeNode.offsetHeight + 140;
      }
      /**
       * Replace place holder after an event has called for it in the element itself
       */

    }, {
      key: "replacePlaceholder",
      value: function replacePlaceholder(e) {
        // generate a paragraph of text here on click
        if (e.detail === "text") {
          // make sure text just escalates to a paragraph tag
          var p = document.createElement("p");
          this.haxReplaceNode(this.activeNode, p);

          this.__focusLogic(p);

          if (this.activeNode.parentNode) {
            this.activeNode.parentNode.setAttribute("contenteditable", true);
          }
        } else {
          this.replaceElementWorkflow();
        }
      }
    }, {
      key: "canTansformNode",
      value: function () {
        var _canTansformNode = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
          var node,
              _args4 = arguments;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  node = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : null;
                  _context4.next = 3;
                  return this.replaceElementWorkflow(node, true).length;

                case 3:
                  _context4.t0 = _context4.sent;

                  if (!(_context4.t0 > 0)) {
                    _context4.next = 8;
                    break;
                  }

                  _context4.t1 = true;
                  _context4.next = 9;
                  break;

                case 8:
                  _context4.t1 = false;

                case 9:
                  return _context4.abrupt("return", _context4.t1);

                case 10:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function canTansformNode() {
          return _canTansformNode.apply(this, arguments);
        }

        return canTansformNode;
      }()
      /**
       * Whole workflow of replacing something in place contextually.
       * This can fire for things like events needing this workflow to
       * invoke whether it's a "convert" event or a "replace placeholder" event
       */

    }, {
      key: "insertElementWorkflow",
      value: function () {
        var _insertElementWorkflow = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
          var activeNode,
              testOnly,
              _args5 = arguments;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  activeNode = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : null;
                  testOnly = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : false;

                case 2:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        function insertElementWorkflow() {
          return _insertElementWorkflow.apply(this, arguments);
        }

        return insertElementWorkflow;
      }()
      /**
       * Whole workflow of replacing something in place contextually.
       * This can fire for things like events needing this workflow to
       * invoke whether it's a "convert" event or a "replace placeholder" event
       */

    }, {
      key: "primitiveTextBlocks",
      get: function get() {
        return ["p", "div", "pre", "h1", "h2", "h3", "h4", "h5", "h6"];
      }
      /**
       *
       * gets configuration for all of given grid's slots
       *
       * @param {object} grid
       * @returns {array}
       */

    }, {
      key: "getAllSlotConfig",
      value: function getAllSlotConfig(node) {
        if (!node) return;
        var grid = this.getParentGrid(node);
        return !!grid && !!grid.tag ? this.getSlotConfig(_haxStore.HAXStore.elementList[grid.tag], slot) : undefined;
      }
      /**
       *
       * gets parent grid if given node is slotted content
       *
       * @param {object} node
       * @returns {object}
       */

    }, {
      key: "getParentGrid",
      value: function getParentGrid(node) {
        node = node || this.activeNode;
        var slot = !!node ? node.slot : undefined;
        return !!slot ? (0, _utils.nodeToHaxElement)(node.parentNode) : undefined;
      }
      /**
       *
       * gets slot configuration for a given slot from haxProperties given
       *
       * @param {string} slotId
       * @param {object} props
       * @returns {object}
       */

    }, {
      key: "getSlotConfig",
      value: function getSlotConfig() {
        var slotId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var settings = props.settings,
            matchingSlots = !!settings ? Object.keys(settings || {}).map(function (group) {
          return settings[group].filter(function (setting) {
            return !!setting.slot && (!slotId || setting.slot === slotId);
          });
        }).flat() : undefined;
        return matchingSlots && matchingSlots.length > 0 ? matchingSlots[0] : undefined;
      }
    }, {
      key: "replaceElementWorkflow",
      value: function () {
        var _replaceElementWorkflow = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
          var activeNode,
              testOnly,
              element,
              type,
              skipPropMatch,
              slot,
              grid,
              props,
              gizmo,
              i,
              prop,
              haxElements,
              slots,
              exclusions,
              inclusions,
              tag,
              humanName,
              _args6 = arguments;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  activeNode = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : null;
                  testOnly = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : false;

                  // support for tests with things other than activeNode
                  if (activeNode == null) {
                    activeNode = this.activeNode;
                  }

                  _context6.next = 5;
                  return (0, _utils.nodeToHaxElement)(activeNode, null);

                case 5:
                  element = _context6.sent;

                  if (element) {
                    _context6.next = 8;
                    break;
                  }

                  return _context6.abrupt("return");

                case 8:
                  type = "*";
                  skipPropMatch = false;
                  slot = (activeNode || {}).slot;
                  grid = this.getParentGrid(activeNode); // special support for place holder which defines exactly
                  // what the user wants this replaced with

                  if (element.tag === "place-holder" && babelHelpers.typeof(element.properties["type"]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    type = element.properties["type"];
                    skipPropMatch = true;
                  } else if (this.primitiveTextBlocks.includes(element.tag)) {
                    skipPropMatch = true;
                  }

                  props = !!element.content ? {
                    innerHTML: element.content
                  } : {}; // see if we have a gizmo as it's not a requirement to registration
                  // as well as having handlers since mapping is not required either

                  if (babelHelpers.typeof(_haxStore.HAXStore.elementList[element.tag]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && _haxStore.HAXStore.elementList[element.tag].gizmo !== false && babelHelpers.typeof(_haxStore.HAXStore.elementList[element.tag].gizmo.handles) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && _haxStore.HAXStore.elementList[element.tag].gizmo.handles.length > 0) {
                    // get the haxProperties for this item
                    gizmo = _haxStore.HAXStore.elementList[element.tag].gizmo; // walk through each handler

                    for (i = 0; i < gizmo.handles.length; i++) {
                      // walk the properties defined as they would be to the
                      // left side of the ledger and tell us which property to
                      // mesh with. This effectively rehydrates / inverts that
                      // relationship where we have an element and want to say
                      // "oh ya, but what could have handled this" so that we
                      // can use that translation to offer up convertion to a
                      // new element. This is insane.
                      if (!!element.properties.innerHTML) props["innerHTML"] = element.properties.innerHTML;

                      for (prop in gizmo.handles[i]) {
                        // type is a reserved handler but any other property
                        // which we actually have in our element let's go for it
                        if (prop !== "type" && babelHelpers.typeof(element.properties[gizmo.handles[i][prop]]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                          // The cake is a lie... oh wait... no it's not.
                          // This will completely bend your mind when it comes to
                          // what HTML is, how it should operate and what universe
                          // we can now contort as a result. This effectively allows
                          // reverse engineering any element on the page into any
                          // other compatible element based on the properties in
                          // each element claiming to be compatible.
                          props[prop] = element.properties[gizmo.handles[i][prop]];
                        }
                      }
                    }
                  }

                  haxElements = _haxStore.HAXStore.guessGizmo(type, props, skipPropMatch); //if element is in a grid, only allow changes that the slot allows

                  slots = !!grid ? this.getSlotConfig(slot, _haxStore.HAXStore.elementList[grid.tag]) : undefined;
                  exclusions = !!grid && grid.tag === "grid-plate" ? ["grid-plate"] : !!slots ? slots.excludedSlotWrappers : undefined;
                  inclusions = !!slots ? slots.allowedSlotWrappers : undefined;
                  if (!!exclusions || !!inclusions) haxElements = haxElements.filter(function (el) {
                    return !exclusions.includes(el.tag) && (!inclusions || inclusions.includes(el.tag));
                  }); // see if we got anything

                  if (haxElements.length > 0) {
                    // hand off to hax-app-picker to deal with the rest of this
                    tag = activeNode.tagName.toLowerCase();
                    humanName = tag.replace("-", " ");

                    if (babelHelpers.typeof(_haxStore.HAXStore.elementList[tag]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && _haxStore.HAXStore.elementList[tag].gizmo !== false) {
                      humanName = _haxStore.HAXStore.elementList[tag].gizmo.title;
                    }

                    if (!testOnly) {
                      _haxStore.HAXStore.activePlaceHolder = this.activeNode;

                      _haxStore.HAXStore.haxAppPicker.presentOptions(haxElements, "__convert", "Change ".concat(humanName, " to..."), "gizmo");
                    }
                  } else {
                    if (!testOnly) {
                      _haxStore.HAXStore.toast("Sorry, this can not be transformed!", 5000);
                    }
                  }

                  return _context6.abrupt("return", haxElements);

                case 22:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function replaceElementWorkflow() {
          return _replaceElementWorkflow.apply(this, arguments);
        }

        return replaceElementWorkflow;
      }()
      /**
       * Store updated, sync.
       */

    }, {
      key: "_haxStorePropertyUpdated",
      value: function _haxStorePropertyUpdated(e) {
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property) {
          this[e.detail.property] = e.detail.value;
        }
      }
      /**
       * Clear area.
       */

    }, {
      key: "haxClearBody",
      value: function haxClearBody() {
        var confirm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var status = true; // only confirm if asked so we can support wipes without it

        if (confirm) {
          status = prompt("Are you sure you want to delete all content?");
        } // ensure they said yes


        if (status) {
          (0, _utils.wipeSlot)(this);
        }
      }
      /**
       * Insert new tag + content into the local DOM as a node.
       */

    }, {
      key: "haxInsert",
      value: function haxInsert(tag, content) {
        var _this11 = this;

        var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var active = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.activeNode;
        var child = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        // verify this tag is a valid one
        // create a new element fragment w/ content in it
        // if this is a custom-element it won't expand though
        var frag = document.createElement(tag); // set text forcibly
        //frag.innerText = content;
        // now set html forcibly which would overwrite the other one

        frag.innerHTML = content; // clone the fragment which will force an escalation to full node

        var newNode = frag.cloneNode(true); // support for properties if they exist

        for (var property in properties) {
          var attributeName = (0, _utils.camelToDash)(property);

          if (properties.hasOwnProperty(property)) {
            // special supporting for boolean because html is weird :p
            if (properties[property] === true) {
              newNode.setAttribute(attributeName, attributeName);
            } else if (properties[property] === false) {
              newNode.removeAttribute(attributeName);
            } else if (properties[property] != null && properties[property].constructor === Array) {
              if (newNode.properties && newNode.properties[property].readOnly) {} else {
                if (newNode.set) {
                  newNode.set(attributeName, properties[property]);
                } else {
                  newNode[attributeName] = properties[property];
                }
              }
            } else if (properties[property] != null && properties[property].constructor === Object) {
              if (newNode.properties && newNode.properties[property].readOnly) {} else {
                if (newNode.set) {
                  newNode.set(attributeName, properties[property]);
                } else {
                  newNode[attributeName] = properties[property];
                }
              }
            } else {
              newNode.setAttribute(attributeName, properties[property]);
            }
          }
        } // special support for a drag and drop into a place-holder tag
        // as this is a more aggressive operation then the others


        if (_haxStore.HAXStore.activePlaceHolder !== null && babelHelpers.typeof(_haxStore.HAXStore.activePlaceHolder.style) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // replicate styles so that it doesn't jar the UI
          newNode.style.width = _haxStore.HAXStore.activePlaceHolder.style.width;
          newNode.style.float = _haxStore.HAXStore.activePlaceHolder.style.float;
          newNode.style.margin = _haxStore.HAXStore.activePlaceHolder.style.margin;
          newNode.style.display = _haxStore.HAXStore.activePlaceHolder.style.display;
          this.haxReplaceNode(_haxStore.HAXStore.activePlaceHolder, newNode);
          _haxStore.HAXStore.activePlaceHolder = null;
        } // insert at active insert point if we have one
        else if (active && active.parentNode) {
            // allow for inserting things into things but not grid plate
            if (!!this.__isLayout(active.parentNode)) {
              if (active.getAttribute("slot") != null) {
                newNode.setAttribute("slot", active.getAttribute("slot"));
              } // special in context add for grids


              if (this.__addAbove) {
                active.parentNode.insertBefore(newNode, active);
              } else {
                active.parentNode.insertBefore(newNode, active.nextElementSibling);
              }
            } else {
              if (active.parentNode && active.parentNode.nextElementSibling) {
                active.parentNode.nextElementSibling.parentNode.insertBefore(newNode, active.parentNode.nextElementSibling);
              } else if (active.parentNode && active.nextElementSibling) {
                if (this.__addAbove) {
                  active.parentNode.insertBefore(newNode, active);
                } else {
                  active.parentNode.insertBefore(newNode, active.nextElementSibling);
                } // test for the LAST item in a group, insert at top and it'll flow to the end

              } else if (active.parentNode && active.parentNode.children[active.parentNode.children.length - 1] === active) {
                if (this.__addAbove) {
                  active.parentNode.insertBefore(newNode, active);
                } else {
                  active.parentNode.appendChild(newNode);
                }
              } else if (active.parentNode) {
                active.parentNode.insertBefore(newNode, active);
              } else {
                // something odd happened let's just make sure we insert this safely
                this.appendChild(newNode);
              }
            }
          } else {
            // send this into the root, which should filter it back down into the slot
            this.appendChild(newNode);
          }

        this.contextMenus.text.hasSelectedText = false;
        setTimeout(function () {
          _this11.__focusLogic(newNode); // wait so that the DOM can have the node to then attach to


          _this11.scrollHere(newNode);
        }, 0);
        return newNode;
      }
      /**
       * Return the current hax content area as text that could be
       * inserted into something.
       */

    }, {
      key: "haxToContent",
      value: function () {
        var _haxToContent = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
          var __active, children, content, i, tmp, parentTag, string, re, tags;

          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  this.hideContextMenus();
                  __active = this.activeNode; // null this to drop hax based classes

                  _haxStore.HAXStore.activeNode = null;
                  children = this.shadowRoot.querySelector("#body").localName === "slot" ? this.shadowRoot.querySelector("#body").assignedNodes({
                    flatten: true
                  }) : [];
                  content = "";
                  i = 0;

                case 6:
                  if (!(i < children.length)) {
                    _context7.next = 43;
                    break;
                  }

                  if (!this._validElementTest(children[i])) {
                    _context7.next = 18;
                    break;
                  }

                  this.__applyDragDropState(children[i], false); // remove some of the protected classes though they shouldn't leak through


                  children[i].classList.remove("hax-hovered");
                  children[i].contentEditable = false;
                  _context7.t0 = content;
                  _context7.next = 14;
                  return _haxStore.HAXStore.nodeToContent(children[i]);

                case 14:
                  content = _context7.t0 += _context7.sent;

                  if (!!this.__isLayout(children[i])) {
                    this._applyContentEditable(this.editMode, children[i]);
                  }

                  _context7.next = 40;
                  break;

                case 18:
                  if (!(children[i].nodeType === 8)) {
                    _context7.next = 22;
                    break;
                  }

                  content += "<!-- " + children[i].textContent + " -->";
                  _context7.next = 40;
                  break;

                case 22:
                  if (!(children[i].haxUIElement && children[i].children && children[i].children[0])) {
                    _context7.next = 39;
                    break;
                  }

                  _context7.next = 25;
                  return _haxStore.HAXStore.runHook(children[i], "activeElementChanged", [this.activeNode, false]);

                case 25:
                  tmp = _context7.sent;

                  if (!(tmp && tmp !== children[i])) {
                    _context7.next = 33;
                    break;
                  }

                  _context7.t1 = content;
                  _context7.next = 30;
                  return _haxStore.HAXStore.nodeToContent(tmp);

                case 30:
                  content = _context7.t1 += _context7.sent;
                  _context7.next = 37;
                  break;

                case 33:
                  _context7.t2 = content;
                  _context7.next = 36;
                  return _haxStore.HAXStore.nodeToContent(children[i].children[0]);

                case 36:
                  content = _context7.t2 += _context7.sent;

                case 37:
                  _context7.next = 40;
                  break;

                case 39:
                  // keep everything NOT an element at this point, this helps
                  // preserve whitespace because we're crazy about accuracy
                  if (children[i].nodeType !== 1 && babelHelpers.typeof(children[i].textContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && children[i].textContent !== "undefined") {
                    content += children[i].textContent;
                  } else {
                    console.warn(children[i]);
                  }

                case 40:
                  i++;
                  _context7.next = 6;
                  break;

                case 43:
                  // remove the contenteditable attribute
                  content = content.replace(/\scontenteditable=\"false\"/g, "");
                  content = content.replace(/\scontenteditable/g, "");
                  content = content.replace(/\sdraggable/g, ""); // clean up stray hax-ray leftovers

                  content = content.replace(/\sdata-hax-ray=\".*?\"/g, ""); // hax-grid marker as well

                  content = content.replace(/\sdata-hax-grid/g, ""); // remove HAX specific classes / scoping classes

                  if (this.parentNode.tagName) {
                    parentTag = this.parentNode.tagName.toLowerCase();
                    string = "style-scope " + parentTag + " x-scope";
                    re = new RegExp(string, "g");
                    content = content.replace(re, ""); // remove without the deeeper scope as well for primitives

                    string = "style-scope " + parentTag;
                    re = new RegExp(string, "g");
                    content = content.replace(re, ""); // remove the last common one unpacked

                    string = "x-scope " + parentTag + "-0";
                    re = new RegExp(string, "g");
                    content = content.replace(re, ""); // now all tags we have defined as valid

                    tags = _haxStore.HAXStore.validTagList;

                    for (i in tags) {
                      string = "style-scope " + tags[i];
                      re = new RegExp(string, "g");
                      content = content.replace(re, "");
                      string = "x-scope " + tags[i] + "-0 ";
                      re = new RegExp(string, "g");
                      content = content.replace(re, "");
                      string = "x-scope " + tags[i] + "-0";
                      re = new RegExp(string, "g");
                      content = content.replace(re, "");
                    }
                  } // remove empty class structures


                  content = content.replace(/\sclass=\"\"/g, "");
                  content = content.replace(/\sclass=\"\s\"/g, ""); // re-apply contenteditable if needed

                  this._applyContentEditable(this.editMode);

                  _haxStore.HAXStore.activeNode = __active; // oh one last thing. escape all script/style tags

                  content = (0, _utils.encapScript)(content);
                  return _context7.abrupt("return", content);

                case 55:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function haxToContent() {
          return _haxToContent.apply(this, arguments);
        }

        return haxToContent;
      }()
      /**
       * Duplicate node into the local DOM below the current item if we can.
       */

    }, {
      key: "haxDuplicateNode",
      value: function () {
        var _haxDuplicateNode = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(node) {
          var haxElement, nodeClone;
          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _context8.next = 2;
                  return (0, _utils.nodeToHaxElement)(node, null);

                case 2:
                  haxElement = _context8.sent;

                  if (!_haxStore.HAXStore.testHook(node, "preProcessInsertContent")) {
                    _context8.next = 7;
                    break;
                  }

                  _context8.next = 6;
                  return _haxStore.HAXStore.runHook(node, "preProcessInsertContent", [haxElement, this.activeNode]);

                case 6:
                  haxElement = _context8.sent;

                case 7:
                  if (haxElement.content == haxElement.properties.innerHTML) {
                    delete haxElement.properties.innerHTML;
                  } // convert it back to a clone, seems odd I'm sure but this ensures that all props are copied
                  // correctly and that we get a brand new object


                  nodeClone = (0, _utils.haxElementToNode)({
                    tag: haxElement.tag,
                    content: haxElement.content,
                    properties: haxElement.properties
                  });

                  if (nodeClone.tagName.toLowerCase() === "webview" && _haxStore.HAXStore._isSandboxed && babelHelpers.typeof(nodeClone.guestinstance) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    delete nodeClone.guestinstance;
                  } // shouldn't be possible but might as well check


                  if (node !== null) {
                    node.parentNode.insertBefore(nodeClone, node.nextSibling);
                  } else {
                    node.parentNode.appendChild(nodeClone);
                  }

                  _haxStore.HAXStore.activeNode = nodeClone;
                  return _context8.abrupt("return", true);

                case 13:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function haxDuplicateNode(_x4) {
          return _haxDuplicateNode.apply(this, arguments);
        }

        return haxDuplicateNode;
      }()
      /**
       * Hide all context menus.
       */

    }, {
      key: "hideContextMenus",
      value: function hideContextMenus() {
        var hidePlate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        // clear the timeouts for anything that could cause these to reapear
        clearTimeout(gravityScrollTimer);
        clearTimeout(this.__contextVisibleLock);
        clearTimeout(this.__positionContextTimer); // primary context menus

        this._hideContextMenu(this.contextMenus.text); //TODO


        this.__activeHover = null; // secondary menus and clean up areas
        //TODO

        if (hidePlate) {
          this._hideContextMenu(this.contextMenus.plate);
        }
      }
      /**
       * Reposition context menus to match an element.
       */

    }, {
      key: "positionContextMenus",
      value: function positionContextMenus() {
        var _this12 = this;

        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.activeNode;

        //console.warn(node);
        // special case for node not matching container yet it being editable
        if (node && node.tagName && this.ready) {
          var tag = node.tagName.toLowerCase();

          if (_haxStore.HAXStore.elementList && _haxStore.HAXStore.elementList[tag] && _haxStore.HAXStore.elementList[tag].contentEditable && node.getAttribute("data-hax-lock") === null && node.parentNode && node.parentNode.getAttribute("data-hax-lock") === null) {
            node.setAttribute("contenteditable", true);
          } else {
            node.removeAttribute("contenteditable");
          } // sanity chekc and ensure we are not told to lock position of all menus


          clearTimeout(this.__positionContextTimer);
          this.__positionContextTimer = setTimeout(function () {
            if (!_haxStore.HAXStore._lockContextPosition) {
              // menu width starts out w/ the plate context which is a set size
              var _tag = node.tagName.toLowerCase();

              if (_haxStore.HAXStore._isSandboxed && _tag === "webview") {
                _tag = "iframe";
              }

              var props = _haxStore.HAXStore.elementList[_tag];

              if (!!node) {
                _this12._showContextMenu(_this12.contextMenus.plate);
              } else {
                _this12._hideContextMenu(_this12.contextMenus.plate);
              } // try and work against anything NOT a P tag


              if (babelHelpers.typeof(props) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && !_haxStore.HAXStore.isTextElement(node)) {
                //TODO hide text
                _this12._hideContextMenu(_this12.contextMenus.text);

                props.element = node;
              } else {
                _this12._showContextMenu(_this12.contextMenus.text); // text menu can expand based on selection

              }

              var gizmo = (props || {}).gizmo || {},
                  inlineGizmo = props && props.gizmo && (props.gizmo.handles || []).filter(function (handle) {
                return (handle || {}).type === "inline";
              }).length > 0;

              if (!props || props.editingElement == "core") {
                // hide menu if we have active on a list item
                // special case because it should not be moved anywhere or have these
                // operations shown as it only makes sense as part of something larger
                // ul / ol which I believe is the ONLY tag that works this way
                if (_this12.activeNode && (_this12.activeNode.tagName === "LI" || _this12._HTMLInlineTextDecorationTest(_this12.activeNode))) {
                  _this12.canMoveElement = false;
                } else {
                  _this12.canMoveElement = true;
                }
              } else {
                setTimeout(function () {
                  if (node && node.parentNode || !inlineGizmo) {
                    _this12.canMoveElement = true;
                  }
                }, 250);
              }
            }

            _this12.contextMenus.parent.setPosition();
          }, 50);
        }
      }
      /**
       * No idea how to describe these name wise but basically we want to only
       * show the menus when we need them. This toggle allows us the ability
       * to hide the context menus while the user is engaged in typing or
       * other actions where the in-context menus are distracting
       */

    }, {
      key: "__addActiveVisible",
      value: function __addActiveVisible() {
        for (var i in this.contextMenus) {
          if (i != "add" || this.__activeHover) {
            this.contextMenus[i].classList.add("hax-context-menu-active");
          }
        }
      }
    }, {
      key: "__dropActiveVisible",
      value: function __dropActiveVisible() {
        for (var i in this.contextMenus) {
          this.contextMenus[i].classList.remove("hax-context-menu-active");
        } // force hiding add menu


        this.__activeHover = null;
      }
      /**
       * Move grid plate around
       */

    }, {
      key: "haxMoveGridPlate",
      value: function haxMoveGridPlate(node) {
        var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        // menu is actually in the element for render purposes
        // support moving things multiple directions
        this.___moveLock = true;
        var parent = !node ? undefined : node.parentNode,
            target = direction > 0 ? node.nextElementSibling : node.previousElementSibling,
            slots = this.__layoutSlots(parent) || [],
            slot = node.getAttribute("slot"),
            index = slot ? slots.indexOf(slot) : -1,
            move = slots[index + direction],
            sameSlot = !!target && (!slot || slot === target.getAttribute("slot"));

        if (!!target && (!slot || slot === target.getAttribute("slot"))) {
          //move within a slot
          parent.insertBefore(node, direction > 0 ? target.nextElementSibling : target);
        } else if (!!move) {
          //move slot
          node.setAttribute("slot", move);
        } else if (node && parent && parent !== this) {
          //move out of layout
          target = direction > 0 ? parent.nextElementSibling : parent, move = parent.getAttribute("slot");

          if (target) {
            parent.parentNode.insertBefore(node, target);
            if (!!move) node.setAttribute("slot", move);
          }
        }

        this.scrollHere(node);
        this.positionContextMenus(node);
        return true;
      }
      /**
       * Inject / modify a grid plate where something currently lives
       */

    }, {
      key: "haxGridPlateOps",
      value: function () {
        var _haxGridPlateOps = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
          var add,
              side,
              node,
              changed,
              cloneEl,
              right,
              rightremove,
              grid,
              col,
              tmp,
              _args9 = arguments;
          return regeneratorRuntime.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  add = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : true;
                  side = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : "right";
                  node = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : this.activeNode;
                  // allow splitting the grid plate that is already there
                  changed = false;

                  if (!(node.tagName === "GRID-PLATE")) {
                    _context9.next = 50;
                    break;
                  }

                  if (!add) {
                    _context9.next = 26;
                    break;
                  }

                  _context9.t0 = node.layout;
                  _context9.next = _context9.t0 === "1" ? 9 : _context9.t0 === "1-1" ? 12 : _context9.t0 === "1-1-1" ? 15 : _context9.t0 === "1-1-1-1" ? 18 : _context9.t0 === "1-1-1-1-1" ? 21 : 24;
                  break;

                case 9:
                  node.layout = "1-1";
                  changed = true;
                  return _context9.abrupt("break", 24);

                case 12:
                  node.layout = "1-1-1";
                  changed = true;
                  return _context9.abrupt("break", 24);

                case 15:
                  node.layout = "1-1-1-1";
                  changed = true;
                  return _context9.abrupt("break", 24);

                case 18:
                  node.layout = "1-1-1-1-1";
                  changed = true;
                  return _context9.abrupt("break", 24);

                case 21:
                  node.layout = "1-1-1-1-1-1";
                  changed = true;
                  return _context9.abrupt("break", 24);

                case 24:
                  _context9.next = 47;
                  break;

                case 26:
                  _context9.t1 = node.layout;
                  _context9.next = _context9.t1 === "1-1" ? 29 : _context9.t1 === "1-1-1" ? 35 : _context9.t1 === "1-1-1-1" ? 38 : _context9.t1 === "1-1-1-1-1" ? 41 : _context9.t1 === "1-1-1-1-1-1" ? 44 : 47;
                  break;

                case 29:
                  _context9.next = 31;
                  return node.childNodes.forEach(function (el) {
                    // verify its a tag
                    if (el.tagName) {
                      // remove slot name
                      cloneEl = el.cloneNode(true);

                      if (node.getAttribute("slot")) {
                        cloneEl.setAttribute("slot", node.getAttribute("slot"));
                      } else {
                        cloneEl.removeAttribute("slot");
                      }

                      node.parentNode.insertBefore(cloneEl, node);
                    }
                  });

                case 31:
                  // whatever was moved out last use as active now
                  _haxStore.HAXStore.activeNode = cloneEl;
                  setTimeout(function () {
                    node.remove();
                  }, 0);
                  changed = true;
                  return _context9.abrupt("break", 47);

                case 35:
                  node.layout = "1-1";
                  changed = true;
                  return _context9.abrupt("break", 47);

                case 38:
                  node.layout = "1-1-1";
                  changed = true;
                  return _context9.abrupt("break", 47);

                case 41:
                  node.layout = "1-1-1-1";
                  changed = true;
                  return _context9.abrupt("break", 47);

                case 44:
                  node.layout = "1-1-1-1-1";
                  changed = true;
                  return _context9.abrupt("break", 47);

                case 47:
                  // if left, nudge everything over 1, right simple
                  if (changed) {
                    //TODO
                    right = this.contextMenus.plate.shadowRoot.querySelector("#right");
                    rightremove = this.contextMenus.plate.shadowRoot.querySelector("#rightremove");
                    right.disabled = false;
                    rightremove.disabled = false;

                    if (node.layout == "1-1-1-1-1-1") {
                      right.disabled = true;
                    }

                    if (side == "left") {
                      node.childNodes.forEach(function (el) {
                        if (el.tagName) {
                          var s = parseInt(el.getAttribute("slot").replace("col-", ""), 10) + 1;
                          el.setAttribute("slot", "col-".concat(s));
                        }
                      });
                    }
                  }

                  _context9.next = 61;
                  break;

                case 50:
                  // make a new grid plate, default to 2 col and disable
                  // responsive by default as this is what many will expect
                  grid = document.createElement("grid-plate");
                  grid.layout = "1-1";
                  grid.disableResponsive = true;

                  if (node.getAttribute("slot")) {
                    grid.setAttribute("slot", node.getAttribute("slot"));
                  }

                  col = "2";

                  if (side == "right") {
                    col = "1";
                  }

                  tmp = node.cloneNode(true);
                  tmp.setAttribute("slot", "col-" + col);
                  grid.appendChild(tmp);
                  node.parentNode.insertBefore(grid, node);
                  setTimeout(function () {
                    node.remove();
                  }, 0);

                case 61:
                  _context9.next = 63;
                  return _haxStore.HAXStore.refreshActiveNodeForm();

                case 63:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function haxGridPlateOps() {
          return _haxGridPlateOps.apply(this, arguments);
        }

        return haxGridPlateOps;
      }()
      /**
       * Convert an element from one tag to another.
       */

    }, {
      key: "haxReplaceNode",
      value: function haxReplaceNode(node, replacement) {
        // Switch, try loop in case we screwed up elsewhere
        try {
          if (node == null) {
            node = this.__oldActiveNode;
          }

          if (!node.replaceWith && _haxStore.HAXStore._tmpRange) {
            node = _haxStore.HAXStore._tmpRange;
            _haxStore.HAXStore._tmpRange = null;
          } // test for slots to match


          if (node && node.getAttribute && node.getAttribute("slot") != null) {
            replacement.setAttribute("slot", node.getAttribute("slot"));
          }

          node.replaceWith(replacement);
        } catch (e) {
          console.warn(e);
        }

        return replacement;
      }
      /**
       * Convert an element from one tag to another.
       */

    }, {
      key: "haxChangeTagName",
      value: function haxChangeTagName(node, tagName) {
        var maintainContent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        // Create a replacement tag of the desired type
        var replacement = document.createElement(tagName); // Grab all of the original's attributes, and pass them to the replacement

        for (var i = 0, l = node.attributes.length; i < l; ++i) {
          var nodeName = node.attributes.item(i).nodeName;
          var value = node.attributes.item(i).value;

          try {
            replacement.setAttribute(nodeName, value);
          } catch (e) {
            console.warn(node.attributes);
            console.warn(e);
          }
        } // Persist contents
        // account for empty list and ordered list items


        if (maintainContent) {
          replacement.innerHTML = node.innerHTML.trim();
        }

        if (tagName == "ul" || tagName == "ol") {
          if (replacement.innerHTML == "<br />") {
            replacement.innerHTML = "<li><br /></li>";
          } else if (!(node.tagName.toLowerCase() == "ul" || node.tagName.toLowerCase() == "ol")) {
            replacement.innerHTML = "<li>" + node.innerHTML.trim().replace(/<br\/>/g, "</li>\n<li>").replace(/<br>/g, "</li>\n<li>") + "</li>";
          }
        } else if (node.tagName.toLowerCase() == "ul" || node.tagName.toLowerCase() == "ol") {
          // if we're coming from ul or ol strip out the li tags
          replacement.innerHTML = replacement.innerHTML.replace(/<ul>/g, "").replace(/<\/ul>/g, "").replace(/<li><\/li>/g, "").replace(/<li>/g, "").replace(/<\/li>/g, "<br/>");
        } // Switch!


        try {
          node.replaceWith(replacement);

          if (maintainContent) {
            // focus on the thing switched to
            setTimeout(function () {
              var children = replacement.children; // see if there's a child element and focus that instead if there is

              if (children[0] && children.tagName) {
                children[0].focus();
              } else {
                replacement.focus();
              }
            }, 10);
          }
        } catch (e) {
          console.warn(e);
          console.warn(replacement);
          console.warn(node);
        }

        return replacement;
      }
      /**
       * Delete the node passed in
       */

    }, {
      key: "haxDeleteNode",
      value: function haxDeleteNode(node) {
        if (node.previousElementSibling) {
          _haxStore.HAXStore.activeNode = node.previousElementSibling;
        } else if (node.nextElementSibling) {
          _haxStore.HAXStore.activeNode = node.nextElementSibling;
        } else {
          // implies nothing; let's not allow NOTHING as it breaks user context
          this.haxInsert("p", "", {});

          try {
            var range = document.createRange();

            var sel = _haxStore.HAXStore.getSelection();

            range.setStart(this.activeNode, 0);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
            this.activeNode.focus();
          } catch (e) {
            console.warn(e);
          }
        }

        try {
          return node.remove();
        } catch (e) {
          console.warn(e);
        }
      }
      /**
       * Bulk import HTML with option to clear what is currently
       * in the slot of this tag. This also validates tags
       * that are being inserted for security based on the
       * internal whitelist.
       */

    }, {
      key: "importContent",
      value: function importContent(html) {
        var _this13 = this;

        var clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        // kill the slot of the active body, all of it
        if (clear) {
          (0, _utils.wipeSlot)(this, "*");
        }

        setTimeout(function () {
          html = (0, _utils.encapScript)(html);
          var fragment = document.createElement("div");
          fragment.insertAdjacentHTML("beforeend", html);

          while (fragment.firstChild !== null) {
            if (babelHelpers.typeof(fragment.firstChild.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              // ensure import doesn't import non-sandbox safe things!
              if (_haxStore.HAXStore._isSandboxed && fragment.firstChild.tagName.toLowerCase() === "iframe") {
                // Create a replacement tag of the desired type
                var replacement = document.createElement("webview"); // Grab all of the original's attributes, and pass them to the replacement

                for (var j = 0, l = fragment.firstChild.attributes.length; j < l; ++j) {
                  var nodeName = fragment.firstChild.attributes.item(j).nodeName;
                  var value = fragment.firstChild.attributes.item(j).value;

                  if (nodeName === "height" || nodeName === "width") {
                    replacement.style[nodeName] == value;
                  }

                  replacement.setAttribute(nodeName, value);
                }

                _this13.appendChild(replacement);
              } else {
                _this13.appendChild(fragment.firstChild);
              }
            } else {
              // @todo might want to support appending or keeping track of comments / non tags
              // but this is not a must have
              fragment.removeChild(fragment.firstChild);
            }
          }
        }, 0);
      }
      /**
       * ensures that all slots in a grid follow the expected order
       * @param {object} grid
       * @returns
       */

    }, {
      key: "sortGridSlots",
      value: function sortGridSlots() {
        var grid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.activeNode;

        var schema = _haxStore.HAXStore.haxSchemaFromTag(grid.tagName);

        if (schema.type !== "grid") return;
        var slots = grid.tagName === "GRID-PLATE" ? grid.layout.split("-").map(function (col, i) {
          return "col-".concat(i);
        }) : _haxStore.HAXStore.slotsFromSchema(schema).map(function (slot) {
          return slot.slot;
        });
        slots.reverse().forEach(function (slot, i) {
          if (i == 0) {
            grid.querySelectorAll("[slot=".concat(slot, "]")).forEach(function (node) {
              return grid.append(node);
            });
          } else {
            babelHelpers.toConsumableArray(grid.querySelectorAll("[slot=".concat(slot, "]"))).reverse().forEach(function (node) {
              return grid.insertBefore(node, grid.firstChild);
            });
          }
        });
      }
      /**
       * Respond to hax operations.
       */

    }, {
      key: "_haxContextOperation",
      value: function () {
        var _haxContextOperation2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(e) {
          var _this14 = this;

          var detail, eventPath, slot, p, _p, target, data, _target, _slot, _i, grid, editMode, invisible, focusTarget, nodePosition, _data, replacement, oldSchema, i, _replacement, _oldSchema;

          return regeneratorRuntime.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  detail = e.detail, eventPath = (0, _utils.normalizeEventPath)(e), slot = !eventPath || !eventPath[0] ? undefined : eventPath[0].getAttribute("data-slot"); // support a simple insert event to bubble up or everything else

                  _context10.t0 = detail.eventName;
                  _context10.next = _context10.t0 === "insert-above-active" ? 4 : _context10.t0 === "insert-below-active" ? 6 : _context10.t0 === "move-to-slot" ? 8 : _context10.t0 === "insert-into-active" ? 10 : _context10.t0 === "hax-select-grid" ? 12 : _context10.t0 === "hax-select-grid-item" ? 14 : _context10.t0 === "hax-edit-element-toggle" ? 16 : _context10.t0 === "hax-source-view-toggle" ? 18 : _context10.t0 === "hax-full-text-editor-toggle" ? 53 : _context10.t0 === "text-tag" ? 70 : _context10.t0 === "text-tag-ul" ? 73 : _context10.t0 === "text-tag-ol" ? 77 : _context10.t0 === "text-align-left" ? 81 : _context10.t0 === "hax-transform-node" ? 83 : _context10.t0 === "hax-plate-create-right" ? 85 : _context10.t0 === "hax-plate-remove-right" ? 87 : _context10.t0 === "hax-plate-duplicate" ? 89 : _context10.t0 === "hax-plate-delete" ? 91 : _context10.t0 === "hax-plate-up" ? 93 : _context10.t0 === "hax-plate-down" ? 95 : _context10.t0 === "content-edit" ? 97 : 100;
                  break;

                case 4:
                  if (this.activeNode && this.activeNode.previousElementSibling) {
                    this.haxInsert("p", "", {}, this.activeNode.previousElementSibling);
                  } else {
                    // would imply top of document
                    p = document.createElement("p");
                    this.insertBefore(p, this.activeNode);
                  }

                  return _context10.abrupt("break", 100);

                case 6:
                  this.haxInsert("p", "", {});
                  return _context10.abrupt("break", 100);

                case 8:
                  if (slot && this.activeNode && _haxStore.HAXStore.isGridPlateElement(this.activeNode.parentNode)) {
                    this.activeNode.slot = slot;
                    this.sortGridSlots(this.activeNode.parentNode);
                  }

                  return _context10.abrupt("break", 100);

                case 10:
                  if (slot && this.activeNode && _haxStore.HAXStore.isGridPlateElement(this.activeNode)) {
                    _p = document.createElement("p");
                    _p.slot = slot;
                    this.activeNode.append(_p);
                    this.haxInsert("p", "", {
                      slot: slot
                    }, _p);

                    _p.remove();

                    this.sortGridSlots();
                  }

                  return _context10.abrupt("break", 100);

                case 12:
                  if (eventPath[0] && eventPath[0].eventData) {
                    target = eventPath[0].eventData;
                    this.setActiveNode(target, true);
                    this.positionContextMenus(target);
                  }

                  return _context10.abrupt("break", 100);

                case 14:
                  if (eventPath[0] && eventPath[0].eventData) {
                    data = eventPath[0].eventData, _target = data.target, _slot = data.slot, _i = data.index, grid = data.grid, editMode = data.editMode, invisible = data.invisible, focusTarget = invisible ? grid : babelHelpers.toConsumableArray(grid.children).filter(function (child) {
                      return !_slot || _slot === "" ? !child.slot || child.slot === "" : child.slot === _slot;
                    })[_i] || _target, nodePosition = function nodePosition() {
                      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _target;

                      _this14.setActiveNode(node, true);

                      _this14.positionContextMenus(node);
                    }; //some slots may not always be visible and
                    //require temporary changes to parent grid's properties
                    //so they can be visible and editable

                    if (grid && editMode) {
                      this.setSlotEditMode(grid, editMode, focusTarget); //make sure we target correct slot after dom changes
                      //setTimeout(targetItem(), 500);
                    } else {
                      this.setActiveNode(node, true);
                      this.positionContextMenus(node);
                    }
                  }

                  return _context10.abrupt("break", 100);

                case 16:
                  if (eventPath[0] && eventPath[0].eventData) {
                    _data = eventPath[0].eventData;
                    if (_data && _data.target && _data.editMode) this.toggleElementEditMode(_data.target, _data.editMode);
                  }

                  return _context10.abrupt("break", 100);

                case 18:
                  if (this.activeNode.__haxSourceView) {
                    _context10.next = 41;
                    break;
                  }

                  this.activeNode.__haxSourceView = true;
                  _haxStore.HAXStore.activeEditingElement = document.createElement("code-editor");
                  _haxStore.HAXStore.activeEditingElement.language = "html";
                  _haxStore.HAXStore.activeEditingElement.title = "";
                  _haxStore.HAXStore.activeEditingElement.theme = "vs";
                  _haxStore.HAXStore.activeEditingElement.fontSize = 12;
                  _haxStore.HAXStore.activeEditingElement.wordWrap = true;
                  this.viewSourceToggle = true; // could be 1st time this shows up so ensure we import

                  new Promise(function (res, rej) {
                    return _require.default(["../code-editor/code-editor.js"], res, rej);
                  }); // test for slots to match to ensure this is maintained

                  if (this.activeNode.getAttribute && this.activeNode.getAttribute("slot") != null) {
                    _haxStore.HAXStore.activeEditingElement.setAttribute("slot", this.activeNode.getAttribute("slot"));
                  }

                  this.__ignoreActive = true;
                  this.activeNode.removeAttribute("contenteditable");

                  this.__applyDragDropState(this.activeNode, false);

                  this.activeNode.classList.remove("hax-active"); // this is converting it to HTML, even if temporarily
                  // so make sure we treat it like HTML
                  // @see haxHooks: preProcessNodeToContent

                  if (!_haxStore.HAXStore.testHook(this.activeNode, "preProcessNodeToContent")) {
                    _context10.next = 37;
                    break;
                  }

                  _context10.next = 36;
                  return _haxStore.HAXStore.runHook(this.activeNode, "preProcessNodeToContent", [this.activeNode]);

                case 36:
                  this.activeNode = _context10.sent;

                case 37:
                  (0, _utils.wrap)(this.activeNode, _haxStore.HAXStore.activeEditingElement);

                  _haxStore.HAXStore.activeEditingElement.focus();

                  _context10.next = 52;
                  break;

                case 41:
                  this.activeNode.__haxSourceView = false; // run internal state hook if it exist and if we get a response

                  _context10.next = 44;
                  return _haxStore.HAXStore.runHook(_haxStore.HAXStore.activeEditingElement, "activeElementChanged", [this.activeNode, false]);

                case 44:
                  replacement = _context10.sent;
                  oldSchema = _haxStore.HAXStore.haxSchemaFromTag(this.activeNode.tagName.toLowerCase()); // test for slots to match to ensure this is maintained

                  if (this.activeNode && this.activeNode.getAttribute && this.activeNode.getAttribute("slot") != null) {
                    replacement.setAttribute("slot", this.activeNode.getAttribute("slot"));
                  } // clean up from possible clone of settings we don't allow cloning
                  // haxProperties supports element saying what internals it needs
                  // garbage collected


                  if (oldSchema.saveOptions && oldSchema.saveOptions.unsetAttributes && oldSchema.saveOptions.unsetAttributes.length) {
                    for (i in oldSchema.saveOptions.unsetAttributes) {
                      replacement.removeAttribute(oldSchema.saveOptions.unsetAttributes[i]);
                    }
                  } // this implies there was a replacement had AND that this response HTML object
                  // is different than what was passed in. In this instance we will end up
                  // firing the unwrap to unpeal the element w/ the new content but
                  // we need to ensure that the event binding is correctly applied


                  this.__applyNodeEditableState(replacement, this.editMode);

                  (0, _utils.unwrap)(_haxStore.HAXStore.activeEditingElement);
                  _haxStore.HAXStore.activeEditingElement = null;
                  this.viewSourceToggle = false;

                case 52:
                  return _context10.abrupt("break", 100);

                case 53:
                  if (this.activeNode.__haxSourceView) {
                    _context10.next = 58;
                    break;
                  }

                  this.activeNode.__haxSourceView = true; // could be 1st time this shows up so ensure we import

                  new Promise(function (res, rej) {
                    return _require.default(["../rich-text-editor/rich-text-editor.js"], res, rej);
                  }).then(function () {
                    _haxStore.HAXStore.activeEditingElement = document.createElement("rich-text-editor");
                    _haxStore.HAXStore.activeEditingElement.type = "rich-text-editor-toolbar-full"; // test for slots to match to ensure this is maintained

                    if (_this14.activeNode.getAttribute && _this14.activeNode.getAttribute("slot") != null) {
                      _haxStore.HAXStore.activeEditingElement.setAttribute("slot", _this14.activeNode.getAttribute("slot"));
                    }

                    _this14.__ignoreActive = true;

                    _this14.activeNode.removeAttribute("contenteditable");

                    _this14.__applyDragDropState(_this14.activeNode, false);

                    _this14.activeNode.classList.remove("hax-active");

                    (0, _utils.wrap)(_this14.activeNode, _haxStore.HAXStore.activeEditingElement);
                    _this14.viewSourceElement = _haxStore.HAXStore.activeEditingElement;
                  });
                  _context10.next = 69;
                  break;

                case 58:
                  this.activeNode.__haxSourceView = false; // run internal state hook if it exist and if we get a response

                  _context10.next = 61;
                  return _haxStore.HAXStore.runHook(_haxStore.HAXStore.activeEditingElement, "activeElementChanged", [this.activeNode, false]);

                case 61:
                  _replacement = _context10.sent;
                  _oldSchema = _haxStore.HAXStore.haxSchemaFromTag(this.activeNode.tagName.toLowerCase()); // test for slots to match to ensure this is maintained

                  if (this.activeNode && this.activeNode.getAttribute && this.activeNode.getAttribute("slot") != null) {
                    _replacement.setAttribute("slot", this.activeNode.getAttribute("slot"));
                  } // clean up from possible clone of settings we don't allow cloning
                  // haxProperties supports element saying what internals it needs
                  // garbage collected


                  if (_oldSchema.saveOptions && _oldSchema.saveOptions.unsetAttributes && _oldSchema.saveOptions.unsetAttributes.length) {
                    for (i in _oldSchema.saveOptions.unsetAttributes) {
                      _replacement.removeAttribute(_oldSchema.saveOptions.unsetAttributes[i]);
                    }
                  } // this implies there was a replacement had AND that this response HTML object
                  // is different than what was passed in. In this instance we will end up
                  // firing the unwrap to unpeal the element w/ the new content but
                  // we need to ensure that the event binding is correctly applied


                  this.__applyNodeEditableState(_replacement, this.editMode);

                  (0, _utils.unwrap)(_haxStore.HAXStore.activeEditingElement);
                  _haxStore.HAXStore.activeEditingElement = null;
                  this.viewSourceElement = _haxStore.HAXStore.activeEditingElement;

                case 69:
                  return _context10.abrupt("break", 100);

                case 70:
                  // trigger the default selected value in context menu to match
                  _haxStore.HAXStore.activeNode = this.haxChangeTagName(this.activeNode, detail.value);
                  this.positionContextMenus();
                  return _context10.abrupt("break", 100);

                case 73:
                  // trigger the default selected value in context menu to match
                  this.contextMenus.text.realSelectedValue = "ul";
                  _haxStore.HAXStore.activeNode = this.haxChangeTagName(this.activeNode, "ul");
                  this.positionContextMenus();
                  return _context10.abrupt("break", 100);

                case 77:
                  // trigger the default selected value in context menu to match
                  this.contextMenus.text.realSelectedValue = "ol";
                  _haxStore.HAXStore.activeNode = this.haxChangeTagName(this.activeNode, "ol");
                  this.positionContextMenus();
                  return _context10.abrupt("break", 100);

                case 81:
                  this.activeNode.style.textAlign = null;
                  return _context10.abrupt("break", 100);

                case 83:
                  this.replaceElementWorkflow();
                  return _context10.abrupt("break", 100);

                case 85:
                  this.haxGridPlateOps();
                  return _context10.abrupt("break", 100);

                case 87:
                  this.haxGridPlateOps(false);
                  return _context10.abrupt("break", 100);

                case 89:
                  this.haxDuplicateNode(this.activeNode);
                  return _context10.abrupt("break", 100);

                case 91:
                  if (this.activeNode != null) {
                    this.haxDeleteNode(this.activeNode);
                  }

                  return _context10.abrupt("break", 100);

                case 93:
                  this.haxMoveGridPlate(this.activeNode, -1);
                  return _context10.abrupt("break", 100);

                case 95:
                  this.haxMoveGridPlate(this.activeNode);
                  return _context10.abrupt("break", 100);

                case 97:
                  if (_haxStore.HAXStore.haxTray.trayDetail === "content-edit") _haxStore.HAXStore.haxTray.collapsed = !_haxStore.HAXStore.haxTray.collapsed;
                  _haxStore.HAXStore.haxTray.trayDetail = "content-edit";
                  return _context10.abrupt("break", 100);

                case 100:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        function _haxContextOperation(_x5) {
          return _haxContextOperation2.apply(this, arguments);
        }

        return _haxContextOperation;
      }()
      /**
       * Item has gained focus, change active element to match
       */

    }, {
      key: "_focusIn",
      value: function _focusIn(e) {
        if (!this.__mouseDown) {
          if (this.__focusLogic(e.target)) {
            e.stopPropagation();
            e.stopImmediatePropagation();
          }
        }
      }
      /**
       * Focus a target and update the data model to reflect this.
       * This helps ensure that keyboard and non click based focusing
       * registers the same as click events
       * @param target object - dom node to focus on
       * @param autoFocus boolean - whether to auto focus / place cursor
       */

    }, {
      key: "__focusLogic",
      value: function __focusLogic(target) {
        var _this15 = this;

        var autoFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var stopProp = false; // only worry about these when we are in edit mode
        // and there is no drawer open

        if (this.editMode && !this.__tabTrap) {
          var containerNode = target; // edge case, thing selected is inside a paragraph tag
          // HTML is stupid and allows this

          if (containerNode.tagName === "SPAN" && _haxStore.HAXStore.isTextElement(containerNode.parentNode) && containerNode.parentNode.getAttribute("slot") == "") {
            containerNode = target.parentNode;
          }

          var _activeNode = null; // ensure this is valid

          if (this._validElementTest(containerNode) && containerNode.parentNode && containerNode.parentNode.tagName) {
            // keep looking til we are juuuust below the container
            // @notice this is where we force a selection on highest level
            // of the document unless we have a special common case
            // where we have a valid element yet the parent is a paragraph
            if (containerNode.parentNode.tagName === "P" && containerNode.parentNode.getAttribute("slot") == "") {
              _activeNode = containerNode;
              stopProp = true;
            } else {
              while (containerNode.parentNode && containerNode.parentNode.tagName && containerNode.parentNode.tagName != "HAX-BODY") {
                // make sure active is set after closest legit element
                if (_activeNode === null && containerNode.tagName !== "B" && containerNode.tagName !== "I" && containerNode.tagName !== "STRONG" && containerNode.tagName !== "EM") {
                  _activeNode = containerNode;
                }

                containerNode = containerNode.parentNode;
              } // case with simple element


              if (_activeNode === null) {
                _activeNode = containerNode;
              } // we only allow disconnected node from container when
              // the container is a grid plate
              else if (!_haxStore.HAXStore.isGridPlateElement(containerNode)) {
                  /*activeNode = containerNode;*/
                }
            } // ensure this is a tag we care about / have support for and
            // that it is a new value


            if (this.activeNode && this.activeNode.parentNode !== containerNode && !containerNode.classList.contains("ignore-activation")) {
              stopProp = true;
            } else if (containerNode.haxUIElement || containerNode.classList.contains("ignore-activation")) {
              stopProp = true;
            } // test for ignore edge case


            if (!_activeNode.haxUIElement && !_activeNode.classList.contains("ignore-activation")) {
              _haxStore.HAXStore.activeNode = _activeNode;
              this.activeNode = _activeNode;
              setTimeout(function () {
                if (autoFocus && !_this15.__mouseDown && _haxStore.HAXStore.isTextElement(_activeNode)) {
                  try {
                    var range = document.createRange();

                    var sel = _haxStore.HAXStore.getSelection();

                    range.setStart(_this15.activeNode, 0);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);

                    _this15.activeNode.focus();
                  } catch (e) {
                    console.warn(e);
                  }
                }

                _this15.positionContextMenus(_activeNode);
              }, 0);
              stopProp = true;
            }
          }
        } else {
          this.__tabTrap = false;
        }

        return stopProp;
      }
      /**
       * Simple utility to do nice scrolling or only scroll if we can't see it
       * as that is better behavior but not in all browsers
       */

    }, {
      key: "scrollHere",
      value: function scrollHere(node) {
        // scroll to it w/ timing delay as this uses resources
        // and we want to ensure it's in the next micro-task
        setTimeout(function () {
          if (typeof node.scrollIntoViewIfNeeded === "function") {
            node.scrollIntoViewIfNeeded(true);
          } else {
            node.scrollIntoView({
              behavior: "smooth",
              inline: "center",
              block: "nearest"
            });
          }
        }, 0);
      }
    }, {
      key: "undo",
      value: function undo() {
        var _this16 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "undo", this).call(this);
        setTimeout(function () {
          var active = _this16.querySelector(".hax-active");

          if (active) {
            _this16.__focusLogic(active);

            _this16.scrollHere(active);
          } else {
            _this16.hideContextMenus();
          }
        }, 0);
      }
    }, {
      key: "redo",
      value: function redo() {
        var _this17 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "redo", this).call(this);
        setTimeout(function () {
          var active = _this17.querySelector(".hax-active");

          if (active) {
            _this17.__focusLogic(active);

            _this17.scrollHere(active);
          } else {
            _this17.hideContextMenus();
          }
        }, 0);
      }
      /**
       * Notice the change between states for editing.
       */

    }, {
      key: "_editModeChanged",
      value: function () {
        var _editModeChanged2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(newValue, oldValue) {
          var _this18 = this;

          var range, sel, activeKids, i, el, children;
          return regeneratorRuntime.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  // fire above that we have changed states so things can react if needed
                  if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    this._applyContentEditable(newValue);

                    if (newValue) {
                      // minor timeout here to see if we have children or not. the slight delay helps w/
                      // timing in scenarios where this is inside of other systems which are setting default
                      // attributes and what not
                      if (this.children && this.children[0] && this.children[0].focus) {
                        this.__focusLogic(this.children[0]);
                      } else {
                        this.haxInsert("p", "", {});

                        try {
                          range = document.createRange();
                          sel = _haxStore.HAXStore.getSelection();
                          range.setStart(this.activeNode, 0);
                          range.collapse(true);
                          sel.removeAllRanges();
                          sel.addRange(range);
                          this.activeNode.focus();
                        } catch (e) {
                          console.warn(e);
                        }
                      }
                    } else {
                      //make sure ective node is not still in edit mode
                      if (!!this.activeNode) {
                        this.unsetSlotEditMode(this.activeNode);
                        this.unsetElementEditMode(this.activeNode);
                      }
                    } // force a reset when we start editing
                    // the delay gives HAX / HAX endpoints some room to manipulate the DOM first


                    setTimeout(function () {
                      _this18.undoStack.undoStackLimit = 50;
                      _this18.undoStack.undoStackPosition = -1;
                      _this18.undoStack.commands = []; // execute once just to get these values

                      _this18.undoStack.changed(); // reset initial value to avoid some state management issues


                      _this18.undoStackInitialValue = _this18.innerHTML;
                      _this18.undoStackPrevValue = _this18.undoStackInitialValue;
                    }, 0);
                  } // hide menus when state changes


                  if (newValue == false) {
                    // this effectively removes the editing element
                    (0, _utils.unwrap)(_haxStore.HAXStore.activeEditingElement);
                    _haxStore.HAXStore.activeEditingElement = null;
                    this.removeAttribute("contenteditable");
                    this.hideContextMenus(); // clean up for nested items we might miss

                    activeKids = this.querySelectorAll("[contenteditable],.hax-active");

                    for (i = 0; i < activeKids.length; i++) {
                      el = activeKids[i];
                      el.removeAttribute("contenteditable");
                      el.classList.remove("hax-active");
                    }
                  } // support for elements caring about the state change


                  children = this.shadowRoot.querySelector("#body").localName === "slot" ? this.shadowRoot.querySelector("#body").assignedNodes({
                    flatten: true
                  }) : []; // fallback for content nodes if not polymer managed nodes above

                  if (children.length === 0) {
                    children = this.shadowRoot.querySelector("#body").children;
                  } // see if anyone cares about editMode changing; some link based things do


                  i = 0;

                case 5:
                  if (!(i < children.length)) {
                    _context11.next = 11;
                    break;
                  }

                  _context11.next = 8;
                  return _haxStore.HAXStore.runHook(children[i], "editModeChanged", [newValue]);

                case 8:
                  i++;
                  _context11.next = 5;
                  break;

                case 11:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, this);
        }));

        function _editModeChanged(_x6, _x7) {
          return _editModeChanged2.apply(this, arguments);
        }

        return _editModeChanged;
      }()
      /**
       * Test if this is a HAX element or not
       */

    }, {
      key: "_haxResolvePreviousElement",
      value: function _haxResolvePreviousElement(node) {
        node = node.previousElementSibling;

        while (node != null && babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.tagName.substring(0, 4) === "HAX-") {
          node = node.previousElementSibling;
        }

        return node;
      }
      /**
       * Test if this is a HAX element or not
       * true means its a valid element for selection
       * We have special support for the hax-logo because it's hax.
       */

    }, {
      key: "_validElementTest",
      value: function _validElementTest(node) {
        // ignore hax internal tags
        // search results can be drag'ed from their panel for exact placement
        // special place holder in drag and drop
        if (!node.haxUIElement && node.tagName && !["TEMPLATE", "HAX-BODY", "RICH-TEXT-EDITOR-CLIPBOARD", "RICH-TEXT-EDITOR-PROMPT", "RICH-TEXT-EDITOR-HIGHLIGHT", "HAX-APP-SEARCH-RESULT", "FAKE-HAX-BODY-END"].includes(node.tagName)) {
          // special case of SPAN as it can often get embedded places without actually
          // being the thing that should grad actual block level focus
          // this would be like a B or I tag grabbing focus as well
          if (this._HTMLInlineTextDecorationTest(node) && node.parentNode != "HAX-BODY") {
            return false;
          }

          return true;
        }

        return false;
      }
      /**
       * test for inline tags
       */

    }, {
      key: "_HTMLInlineTextDecorationTest",
      value: function _HTMLInlineTextDecorationTest(node) {
        return ["span", "b", "strong", "i", "em"].concat(babelHelpers.toConsumableArray(Object.keys(window.HaxTextEditorToolbarConfig.inlineGizmos || {}))).includes(node.tagName.toLowerCase());
      }
      /**
       * Test if this is an HTML primative
       */

    }, {
      key: "_HTMLPrimativeTest",
      value: function _HTMLPrimativeTest(node) {
        if (node != null && babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.tagName.indexOf("-") == -1) {
          return true;
        }

        return false;
      }
      /**
       * Walk everything we find and either enable or disable editable state.
       */

    }, {
      key: "_applyContentEditable",
      value: function _applyContentEditable(status) {
        var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shadowRoot.querySelector("#body");
        // this is just direct children so 1st level of the body
        var children = target.localName === "slot" ? target.assignedNodes({
          flatten: true
        }) : []; // fallback for content nodes if not polymer managed nodes above

        if (children.length === 0) {
          children = target.children;
        }

        for (var i = 0; i < children.length; i++) {
          // sanity check for being a valid element / not a "hax" element
          if (this._validElementTest(children[i])) {
            // correctly add or remove listeners
            if (!status || children[i].getAttribute("contenteditable") !== true && children[i].getAttribute("contenteditable") != "true" && children[i].getAttribute("contenteditable") != "contenteditable") {
              this.__applyNodeEditableState(children[i], status);
            }
          } // now test for this being a grid plate element which implies
          // we need to ensure this is applied deep into its children


          if (_haxStore.HAXStore.isGridPlateElement(children[i])) {
            // more lazy selector that will pull ANYTHING in the grid plate element
            var grandKids = children[i].querySelectorAll("*");

            for (var j = 0; j < grandKids.length; j++) {
              // sanity check for being a valid element / not a "hax" element
              if (this._validElementTest(grandKids[j])) {
                // correctly add or remove listeners
                this.__applyNodeEditableState(grandKids[j], status);
              }
            }
          }
        }
      }
    }, {
      key: "__layoutDropEvent",
      value: function __layoutDropEvent(e, node) {
        babelHelpers.toConsumableArray(node.querySelectorAll(".active")).forEach(function (el) {
          el.classList.remove("active");
        });
        babelHelpers.toConsumableArray(node.shadowRoot.querySelectorAll(".active")).forEach(function (el) {
          el.classList.remove("active");
        });
      }
    }, {
      key: "__layoutDragEnter",
      value: function __layoutDragEnter(e) {
        e.target.classList.add("active");
      }
    }, {
      key: "__layoutDragLeave",
      value: function __layoutDragLeave(e) {
        e.target.classList.remove("active");
      }
    }, {
      key: "__layoutMonitor",
      value: function __layoutMonitor(e) {
        // sanity, we have a local slot
        var eventPath = (0, _utils.normalizeEventPath)(e);

        if (eventPath[0] && eventPath[0].assignedNodes && eventPath[0].assignedNodes().length && eventPath[0].parentNode) {
          // has nodes so we can make sure to track this elsewhere
          eventPath[0].parentNode.classList.add("has-nodes");
        } else if (eventPath[0].parentNode) {
          eventPath[0].parentNode.classList.remove("has-nodes");
        }
      }
    }, {
      key: "__getLayoutOrder",
      value: function __getLayoutOrder(target, layout) {
        if (!layout.shadowRoot) return false;
        var slot = target.getAttribute("slot"),
            container = layout.shadowRoot.querySelector("[slot=".concat(slot, "]")),
            containers = babelHelpers.toConsumableArray(layout.shadowRoot.querySelectorAll("[slot]")).map(function (node) {
          return node.parentNode;
        }),
            order = containers.indexOf(container) || -1;
        return order;
      }
      /**
       * Determines if the item can move a set number of slots.
       *
       * @param {object} the item
       * @param {number} -1 for left or +1 for right
       * @returns {boolean} if the item can move a set number of slots
       */

    }, {
      key: "__layoutCanMove",
      value: function __layoutCanMove(target, layout, before) {
        if (!layout.shadowRoot) return false;
        var container = layout.shadowRoot.querySelector("[slot=".concat(slot, "]")),
            containers = babelHelpers.toConsumableArray(layout.shadowRoot.querySelectorAll("[slot]")).map(function (node) {
          return node.parentNode;
        }),
            order = containers.indexOf(container) || -1,
            dest = order + (before ? -1 : 1);
        return dest >= containers[0] && dest <= containers[containers.length - 1];
      }
      /**
       * Moves an item a set number of slots.
       *
       * @param {object} the item
       * @param {number} -1 for left or +1 for right
       */

    }, {
      key: "__layoutMove",
      value: function __layoutMove(target, layout, before) {
        if (!layout.shadowRoot) return false;
        var container = layout.shadowRoot.querySelector("[slot=".concat(slot, "]")),
            containers = babelHelpers.toConsumableArray(layout.shadowRoot.querySelectorAll("[slot]")).map(function (node) {
          return node.parentNode;
        }),
            order = containers.indexOf(container) || -1,
            dest = order + (before ? -1 : 1),
            slot = containers[dest];
        if (slot) target.setAttribute("slot", slot);
      }
    }, {
      key: "__sortLayoutChildren",
      value: function () {
        var _sortLayoutChildren = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(layout) {
          var _this19 = this;

          var children;
          return regeneratorRuntime.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  layout.setAttribute("hax-layout-sorting", true);
                  _context12.prev = 1;
                  // select all direct children w/ a slot attribute and convert to an Array
                  children = Array.prototype.reduce.call(layout.querySelectorAll("[slot]"), function (acc, e) {
                    return acc;
                  }, []); // sort the children by slot id being low to high

                  children = children.sort(function (a, b) {
                    if (this.__getLayoutOrder(a, layout) < this.__getLayoutOrder(b, layout)) {
                      return -1;
                    }

                    return 1;
                  }); // loop through and append these back into the grid plate.
                  // which will put them in the right order

                  _context12.next = 6;
                  return children.forEach(function (el) {
                    // sanity check that we only move things that are a direct child
                    if (el.parentNode === _this19) {
                      layout.appendChild(el);
                    }
                  });

                case 6:
                  _context12.next = 11;
                  break;

                case 8:
                  _context12.prev = 8;
                  _context12.t0 = _context12["catch"](1);
                  console.warn(_context12.t0);

                case 11:
                  layout.removeAttribute("hax-layout-sorting");

                case 12:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12, null, [[1, 8]]);
        }));

        function __sortLayoutChildren(_x8) {
          return _sortLayoutChildren.apply(this, arguments);
        }

        return __sortLayoutChildren;
      }()
      /**
       * Validate the slot name
       */

    }, {
      key: "__layoutSlotValid",
      value: function __layoutSlotValid(target, layout) {
        return this.__layoutSlots(layout).includes(target.getAttribute("slot"));
      }
      /**
       * gets a layout's valud slots
       */

    }, {
      key: "__layoutSlots",
      value: function __layoutSlots(layout) {
        return layout.shadowRoot ? babelHelpers.toConsumableArray(layout.shadowRoot.querySelectorAll("[slot]")).map(function (container) {
          return container.getAttribute("name");
        }) : [];
      }
    }, {
      key: "__applyDragDropState",
      value: function __applyDragDropState(layout, haxRay) {
        var _this20 = this;

        var events = {
          drop: function drop(e) {
            return _this20.__layoutDropEvent.bind(_this20)(e, layout);
          },
          dragenter: this.__layoutDragEnter.bind(this),
          dragleave: this.__layoutDragEnter.bind(this),
          slotchange: this.__layoutMonitor.bind(this)
        };
        layout.setAttribute("data-hax-layout", true);
        if (_haxStore.HAXStore.isGridPlateElement(layout)) layout.setAttribute("data-hax-grid", true);
        if (haxRay) layout.setAttribute("data-hax-ray", haxRay);

        if (haxRay && layout.shadowRoot) {
          // apply handlers to the columns themselves
          layout.addEventListener("drop", events.drop);
          var containers = babelHelpers.toConsumableArray(layout.shadowRoot.querySelectorAll("drag-enabled")),
              slots = babelHelpers.toConsumableArray(layout.shadowRoot.querySelectorAll("slot"));
          containers.forEach(function (container) {
            container.addEventListener("dragenter", events.dragenter);
            container.addEventListener("dragleave", events.dragleave);
          });
          slots.forEach(function (slot) {
            return slot.addEventListener("slotchange", events.slotchange);
          });
          layout.haxLayoutObserver = new MutationObserver(function (mutations) {
            if (!layout.getAttribute("hax-layout-sorting")) {
              mutations.forEach(function (mutation) {
                // this implies something was added dynamically or drag and drop
                // from outside this element or dragging between grid plates
                // so we need to disconnect the handlers from here and pick them
                // up in the new plate
                mutation.addedNodes.forEach(function (node) {
                  if (node.tagName && node !== _this20) {
                    // verify this has a slot set otherwise we need to set one on the fly
                    // otherwise this won't show up. This could be incorrectly formed HTML
                    // DOM that was pushed in via an outside system or edge cases of things
                    // dropping in without a slot set in anyway
                    // validate slot name, otherwise force it to col-1
                    if (node.parentElement && node.parentElement.tagName !== "HAX-BODY" && !_this20.__layoutSlotValid(node, layout) && _this20.__layoutSlots(layout).length > 0) {
                      node.setAttribute("slot", _this20.__layoutSlots(layout)[0]);
                    }
                  }
                });
              });

              _this20.__sortLayoutChildren(layout);
            }
          });
          layout.haxLayoutObserver.observe(this, {
            childList: true
          });
        } else if (layout.shadowRoot) {
          if (layout.haxLayoutObserver) {
            layout.haxLayoutObserver.disconnect();
          }

          this.removeEventListener("drop", events.drop);

          var _containers = babelHelpers.toConsumableArray(layout.shadowRoot.querySelectorAll("drag-enabled")),
              _slots = babelHelpers.toConsumableArray(layout.shadowRoot.querySelectorAll("slot"));

          _containers.forEach(function (container) {
            container.removeEventListener("dragenter", events.dragenter);
            container.removeEventListener("dragleave", events.dragleave);
          });

          _slots.forEach(function (slot) {
            return slot.removeEventListener("slotchange", events.slotchange);
          });

          layout.removeAttribute("data-hax-ray");
        }
      }
    }, {
      key: "__isLayout",
      value: function __isLayout(el) {
        return el && _haxStore.HAXStore.haxSchemaFromTag(el.tagName) && _haxStore.HAXStore.haxSchemaFromTag(el.tagName).type === "grid";
      }
      /**
       * Apply the node editable state correctly so we can do drag and drop / editing uniformly
       */

    }, {
      key: "__applyNodeEditableState",
      value: function __applyNodeEditableState(node) {
        var _this21 = this;

        var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var listenerMethod; // sanity check a dom node

        if (!node.tagName) {
          return false;
        } // create the hax-ray x ray googles thing


        var haxRay = node.tagName.replace("-", " ").toLowerCase();
        var i = (0, _mobxEsm.toJS)(_haxStore.HAXStore.gizmoList).findIndex(function (j) {
          if (j) {
            return j.tag === node.tagName.toLowerCase();
          }
        });

        if (i !== -1) {
          haxRay = (0, _mobxEsm.toJS)(_haxStore.HAXStore.gizmoList)[i].title;
        } // force images to NOT be draggable as we will manage D&D


        if (node.tagName == "IMG") {
          node.setAttribute("draggable", false);
        } // oooooo snap, drag and drop..


        if (status) {
          this.__applyDragDropState(node, haxRay);

          listenerMethod = "addEventListener";
        } else {
          this.__applyDragDropState(node, false);

          listenerMethod = "removeEventListener";
        }

        node[listenerMethod]("drop", this.dropEvent.bind(this));
        node[listenerMethod]("dragenter", this.dragEnter.bind(this));
        node[listenerMethod]("dragleave", this.dragLeave.bind(this));
        node[listenerMethod]("dragover", function (e) {
          _this21.__dragMoving = true;
          e.preventDefault();
        }); // additional things for text based elements

        if (this._HTMLPrimativeTest(node)) {
          if (status) {
            node.setAttribute("contenteditable", status);
          } else {
            node.removeAttribute("contenteditable");
          }

          if (node.querySelectorAll("a").length > 0) {
            var links = node.querySelectorAll("a");

            for (var j = 0, len2 = links.length; j < len2; j++) {
              if (status) {
                links[j].setAttribute("contenteditable", status);
              } else {
                links[j].removeAttribute("contenteditable");
              }

              links[j][listenerMethod]("click", function (e) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
              });
            }
          }
        }
      }
      /**
       * Refine the stack logic so that visual class markers
       * do not bleed over into state changes
       */

    }, {
      key: "undoManagerStackLogic",
      value: function undoManagerStackLogic(mutations) {
        if (!this.__dragMoving) {
          this.querySelectorAll(".hax-hovered").forEach(function (el) {
            el.classList.remove("hax-hovered");
          });
          babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "undoManagerStackLogic", this).call(this, mutations);
        }
      }
      /**
       * Drop an item onto another
       */

    }, {
      key: "dropEvent",
      value: function dropEvent(e) {
        if (this.editMode) {
          this.__dragMoving = false; // make sure that IF we had mutations they don't fire till AFTER
          // this prevents issues where the mutation record was combined
          // and then blocked because of being moved

          this.undoManagerStackLogic({}); // esnure we clear the gravity scrolling drag effect

          clearTimeout(gravityScrollTimer);
          _haxStore.HAXStore._lockContextPosition = false; // trick the tray into forcing active to be Configure

          _haxStore.HAXStore.haxTray.activeTab = "item-1";
          var target = null;
          var eventPath = (0, _utils.normalizeEventPath)(e);

          if (e.target.closest("[data-hax-layout]") && e.target.parentNode != e.target.closest("[data-hax-layout]")) {
            target = e.target.closest("[data-hax-layout]");
          } else if (e.target.closest("[contenteditable],img")) {
            target = e.target.closest("[contenteditable],img");
          } else if (e.originalTarget) {
            target = e.originalTarget;
          } else {
            target = e.target;
          } // account for a possibly locked drop target


          if (target.getAttribute("data-hax-lock") !== null) {
            // exit early
            return false;
          } // account for slot drop on a place holder


          if (eventPath[0].classList.contains("column")) {
            this.__slot = eventPath[0].getAttribute("id").replace("col", "col-");
          } else if (target.getAttribute("slot")) {
            this.__slot = target.getAttribute("slot");
          } // establish an activeNode /container based on drop poisition


          _haxStore.HAXStore.activeNode = target; // walk the children and remove the draggable state needed

          this.querySelectorAll(".hax-hovered").forEach(function (el) {
            el.classList.remove("hax-hovered");
          }); // remove [data-hax-layout] drops

          this.querySelectorAll(".active").forEach(function (el) {
            el.classList.remove("active");
          }); // var for the local drop target

          var local; // this helps ensure that what gets drag and dropped is a file
          // this prevents issues with selecting and dragging text (which triggers drag/drop)
          // as well as compatibility with things that are legit in a draggable state

          try {
            // see if we are dropping a file
            if (_haxStore.HAXStore.__dragTarget === null && e.dataTransfer && e.dataTransfer.items && e.dataTransfer.items.length > 0 && e.dataTransfer.items[0].kind === "file") {
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation(); // inject a placeholder P tag which we will then immediately replace

              var tmp = document.createElement("p");

              if (e.target.closest("[data-hax-layout]") && e.target.parentNode != e.target.closest("[data-hax-layout]")) {
                local = e.target.closest("[data-hax-layout]");
              } else if (e.target.closest("[contenteditable],img")) {
                local = e.target.closest("[contenteditable],img");
              }

              if (local && (local.tagName && local.tagName !== "HAX-BODY" || !local.getAttribute("data-hax-layout")) || this.__isLayout(eventPath[0])) {
                if (local.getAttribute("slot")) {
                  tmp.setAttribute("slot", local.getAttribute("slot"));
                } else if (eventPath[0].classList.contains("column")) {
                  tmp.setAttribute("slot", eventPath[0].getAttribute("id").replace("col", "col-"));
                } else {
                  tmp.removeAttribute("slot");
                }

                local.parentNode.insertBefore(tmp, local);
              } else {
                if (eventPath[0].classList.contains("column")) {
                  tmp.setAttribute("slot", eventPath[0].getAttribute("id").replace("col", "col-"));
                } // account for drop target of main body yet still having a slot attr
                else if (local && local.tagName === "HAX-BODY" && tmp.getAttribute("slot")) {
                    tmp.removeAttribute("slot");
                  }

                if (local) {
                  local.appendChild(tmp);
                } else {
                  this.appendChild(tmp);
                }
              } // this placeholder will be immediately replaced


              e.placeHolderElement = tmp; // fire this specialized event up so things like HAX can intercept

              this.dispatchEvent(new CustomEvent("place-holder-file-drop", {
                bubbles: true,
                cancelable: true,
                composed: true,
                detail: e
              }));
            } else {
              // set taget based on drag target
              target = _haxStore.HAXStore.__dragTarget;
              local = e.target;

              if (e.target.closest("[data-hax-layout]") && e.target.parentNode != e.target.closest("[data-hax-layout]")) {
                local = e.target.closest("[data-hax-layout]");
              } else if (e.target.closest("[contenteditable],img")) {
                local = e.target.closest("[contenteditable],img");
              } // if we have a slot on what we dropped into then we need to mirror that item
              // and place ourselves below it in the DOM


              if (local && target && this._validElementTest(target) && target !== local) {
                // incase this came from a grid plate, drop the slot so it works
                try {
                  if (local.tagName !== "HAX-BODY" && !this.__isLayout(local) || this.__isLayout(eventPath[0])) {
                    if (local.getAttribute("slot")) {
                      target.setAttribute("slot", local.getAttribute("slot"));
                    } else if (eventPath[0].classList.contains("column")) {
                      target.setAttribute("slot", eventPath[0].getAttribute("id").replace("col", "col-"));
                    } else {
                      target.removeAttribute("slot");
                    }

                    local.parentNode.insertBefore(target, local);
                  } else {
                    if (eventPath[0].classList.contains("column")) {
                      target.setAttribute("slot", eventPath[0].getAttribute("id").replace("col", "col-"));
                    } // account for drop target of main body yet still having a slot attr
                    else if (local.tagName === "HAX-BODY" && target.getAttribute("slot")) {
                        target.removeAttribute("slot");
                      }

                    local.appendChild(target);
                  }
                } catch (e) {
                  console.warn(e);
                } // ensure that if we caught this event we process it


                e.preventDefault();
                e.stopPropagation();
              } // position arrows / set focus in case the DOM got updated above


              if (target && this._validElementTest(target) && typeof target.focus === "function") {
                _haxStore.HAXStore.activeNode = target; // @see haxHooks: trayDragNDropToNode

                if (_haxStore.HAXStore.testHook(_haxStore.HAXStore.activeNode, "trayDragNDropToNode")) {
                  _haxStore.HAXStore.runHook(_haxStore.HAXStore.activeNode, "trayDragNDropToNode", [_haxStore.HAXStore.activeNode]);
                } // fire event saying that we dropped an item and gained
                // focus which should prioritize certain actions over a
                // normal focus shift


                this.dispatchEvent(new CustomEvent("hax-drop-focus-event", {
                  bubbles: true,
                  cancelable: true,
                  composed: true,
                  detail: this.activeNode
                }));
                this.scrollHere(this.activeNode);
                this.positionContextMenus();
              }
            }
          } catch (e) {
            console.warn(e);
          }
        } // reset this after the drop happens


        _haxStore.HAXStore.__dragTarget = null;

        this.__manageFakeEndCap(false);
      }
      /**
       * Enter an element, meaning we've over it while dragging
       */

    }, {
      key: "dragEnter",
      value: function dragEnter(e) {
        if (this.editMode && e.target && _haxStore.HAXStore.__dragTarget) {
          this.__dragMoving = true;
          e.preventDefault();

          if (e.target && e.target.classList) {
            e.target.classList.add("hax-hovered");
          } // perform check for edge of screen


          this.handleMousemove(e);
        }
      } // refactored from https://github.com/bennadel/JavaScript-Demos/blob/master/demos/window-edge-scrolling/index.htm
      // I adjust the window scrolling in response to the given mousemove event.

    }, {
      key: "handleMousemove",
      value: function handleMousemove(e) {
        // NOTE: Much of the information here, with regard to document dimensions,
        // viewport dimensions, and window scrolling is derived from JavaScript.info.
        // I am consuming it here primarily as NOTE TO SELF.
        // --
        // Read More: https://javascript.info/size-and-scroll-window
        // --
        // CAUTION: The viewport and document dimensions can all be CACHED and then
        // recalculated on window-resize events (for the most part). I am keeping it
        // all here in the mousemove event handler to remove as many of the moving
        // parts as possible and keep the demo as simple as possible.
        // Get the viewport-relative coordinates of the mousemove event.
        var viewportX = e.clientX;
        var viewportY = e.clientY; // Get the viewport dimensions.

        var viewportWidth = document.documentElement.clientWidth;
        var viewportHeight = document.documentElement.clientHeight; // Next, we need to determine if the mouse is within the "edge" of the
        // viewport, which may require scrolling the window. To do this, we need to
        // calculate the boundaries of the edge in the viewport (these coordinates
        // are relative to the viewport grid system).

        var edgeTop = edgeSize;
        var edgeLeft = edgeSize;
        var edgeBottom = viewportHeight - edgeSize;
        var edgeRight = viewportWidth - edgeSize;
        var isInLeftEdge = viewportX < edgeLeft;
        var isInRightEdge = viewportX > edgeRight;
        var isInTopEdge = viewportY < edgeTop;
        var isInBottomEdge = viewportY > edgeBottom; // If the mouse is not in the viewport edge, there's no need to calculate
        // anything else.

        if (!(isInLeftEdge || isInRightEdge || isInTopEdge || isInBottomEdge)) {
          clearTimeout(gravityScrollTimer);
          return;
        } // If we made it this far, the user's mouse is located within the edge of the
        // viewport. As such, we need to check to see if scrolling needs to be done.
        // Get the document dimensions.
        // --
        // NOTE: The various property reads here are for cross-browser compatibility
        // as outlined in the JavaScript.info site (link provided above).


        var documentWidth = Math.max(document.body.scrollWidth, document.body.offsetWidth, document.body.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth, document.documentElement.clientWidth);
        var documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.body.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight); // Calculate the maximum scroll offset in each direction. Since you can only
        // scroll the overflow portion of the document, the maximum represents the
        // length of the document that is NOT in the viewport.

        var maxScrollX = documentWidth - viewportWidth;
        var maxScrollY = documentHeight - viewportHeight; // As we examine the mousemove event, we want to adjust the window scroll in
        // immediate response to the event; but, we also want to continue adjusting
        // the window scroll if the user rests their mouse in the edge boundary. To
        // do this, we'll invoke the adjustment logic immediately. Then, we'll setup
        // a timer that continues to invoke the adjustment logic while the window can
        // still be scrolled in a particular direction.
        // --
        // NOTE: There are probably better ways to handle the ongoing animation
        // check. But, the point of this demo is really about the math logic, not so
        // much about the interval logic.

        (function checkForWindowScroll() {
          clearTimeout(gravityScrollTimer);

          if (adjustWindowScroll()) {
            gravityScrollTimer = setTimeout(checkForWindowScroll, 30);
          }
        })(); // Adjust the window scroll based on the user's mouse position. Returns True
        // or False depending on whether or not the window scroll was changed.


        function adjustWindowScroll() {
          // Get the current scroll position of the document.
          var currentScrollX = window.pageXOffset;
          var currentScrollY = window.pageYOffset; // Determine if the window can be scrolled in any particular direction.

          var canScrollUp = currentScrollY > 0;
          var canScrollDown = currentScrollY < maxScrollY;
          var canScrollLeft = currentScrollX > 0;
          var canScrollRight = currentScrollX < maxScrollX; // Since we can potentially scroll in two directions at the same time,
          // let's keep track of the next scroll, starting with the current scroll.
          // Each of these values can then be adjusted independently in the logic
          // below.

          var nextScrollX = currentScrollX;
          var nextScrollY = currentScrollY; // As we examine the mouse position within the edge, we want to make the
          // incremental scroll changes more "intense" the closer that the user
          // gets the viewport edge. As such, we'll calculate the percentage that
          // the user has made it "through the edge" when calculating the delta.
          // Then, that use that percentage to back-off from the "max" step value.
          // Should we scroll left?

          if (isInLeftEdge && canScrollLeft) {
            var intensity = (edgeLeft - viewportX) / edgeSize;
            nextScrollX = nextScrollX - maxStep * intensity; // Should we scroll right?
          } else if (isInRightEdge && canScrollRight) {
            var intensity = (viewportX - edgeRight) / edgeSize;
            nextScrollX = nextScrollX + maxStep * intensity;
          } // Should we scroll up?


          if (isInTopEdge && canScrollUp) {
            var intensity = (edgeTop - viewportY) / edgeSize;
            nextScrollY = nextScrollY - maxStep * intensity; // Should we scroll down?
          } else if (isInBottomEdge && canScrollDown) {
            var intensity = (viewportY - edgeBottom) / edgeSize;
            nextScrollY = nextScrollY + maxStep * intensity;
          } // Sanitize invalid maximums. An invalid scroll offset won't break the
          // subsequent .scrollTo() call; however, it will make it harder to
          // determine if the .scrollTo() method should have been called in the
          // first place.


          nextScrollX = Math.max(0, Math.min(maxScrollX, nextScrollX));
          nextScrollY = Math.max(0, Math.min(maxScrollY, nextScrollY));

          if (nextScrollX !== currentScrollX || nextScrollY !== currentScrollY) {
            window.scrollTo(nextScrollX, nextScrollY);
            return true;
          } else {
            return false;
          }
        }
      }
      /**
       * Leaving an element while dragging.
       */

    }, {
      key: "dragLeave",
      value: function dragLeave(e) {
        if (this.editMode && e.target && e.target.classList) {
          this.__dragMoving = true;
          e.target.classList.remove("hax-hovered");
        }
      }
    }, {
      key: "toggleElementEditMode",
      value: function toggleElementEditMode(node, editProp) {
        if (!!node[editProp]) {
          this.unsetElementEditMode(node, editProp);
        } else {
          this.setElementEditMode(node, editProp);
        }
      }
    }, {
      key: "unsetElementEditMode",
      value: function unsetElementEditMode() {
        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.activeNode;
        if (!node) return;
        var editProp = node.getAttribute("data-element-edit-mode") || "editMode";
        node[editProp] = false;

        this.__applyNodeEditableState(node, this.editMode);

        _haxStore.HAXStore.activeEditingElement = null;
        this.editElementToggled = false;
        this.__ignoreActive = false;
      }
    }, {
      key: "setElementEditMode",
      value: function setElementEditMode(node) {
        var editProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "editMode";
        node.setAttribute("data-element-edit-mode", editProp);
        node[editProp] = true;
        _haxStore.HAXStore.activeEditingElement = node;
        this.editElementToggled = false;
        this.__ignoreActive = true;
        this.activeNode.removeAttribute("contenteditable");
        this.activeNode.classList.remove("hax-active");

        this.__applyDragDropState(this.activeNode, false);

        _haxStore.HAXStore.activeEditingElement.focus();
      }
      /**
       * removes edit mode from grid by reverting to properties saved before editing
       *
       * @param {object} node node that could be a grid
       * @memberof HaxBody
       */

    }, {
      key: "unsetSlotEditMode",
      value: function unsetSlotEditMode(node) {
        var settings = !node.getAttribute("data-grid-saved-settings") ? undefined : JSON.parse(node.getAttribute("data-grid-saved-settings"));
        Object.keys(settings || {}).forEach(function (key) {
          return node[key] = settings[key];
        });
        node.removeAttribute("data-grid-saved-settings");
      }
      /**
       * saves grid settings before applying edit mode settings
       *
       * @param {object} node node that could be a grid
       * @memberof HaxBody
       */

    }, {
      key: "setSlotEditMode",
      value: function setSlotEditMode(node, settings, focusTarget) {
        var saved = !node.getAttribute("data-grid-saved-settings") ? {} : JSON.parse(node.getAttribute("data-grid-saved-settings")),
            keys = Object.keys(saved);
        Object.keys(settings || {}).forEach(function (key) {
          //only save a setting if it hasn't alreay been saved by a sibling slot
          if (!keys.includes(key)) saved[key] = node[key];
          node[key] = settings[key];
        });
        node.setAttribute("data-grid-saved-settings", JSON.stringify(saved));
      }
      /**
       * React to a new node being set to active.
       */

    }, {
      key: "_activeNodeChanged",
      value: function () {
        var _activeNodeChanged2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(newValue, oldValue) {
          var tag, oldSchema, replacement, i, newSchema, basePath;
          return regeneratorRuntime.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  // close any open popover items
                  window.SimplePopoverManager.requestAvailability().opened = false;
                  this.contextMenus.plate.disableDuplicate = false;
                  this.contextMenus.plate.disableOps = false;
                  this.contextMenus.plate.disableItemOps = false;
                  this.contextMenus.plate.canMoveElement = this.canMoveElement; // remove anything currently with the active class

                  _context13.next = 7;
                  return this.querySelectorAll(".hax-active").forEach(function (el) {
                    el.classList.remove("hax-active");
                  });

                case 7:
                  //prevent mutation
                  if (!!newValue && !!oldValue && _haxStore.HAXStore.isGridPlateElement(newValue)) {
                    this.__ignoreActive = true;
                  }

                  if (this.editMode && babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue !== null && newValue.parentNode) {
                    tag = newValue.tagName.toLowerCase(); // remove the menu, establish the new active, then reapply
                    // this is nessecary because the context menu gets appended into
                    // the document
                    // only hide if we change containers

                    newValue.classList.add("hax-active");

                    if ((_haxStore.HAXStore.isTextElement(newValue) || newValue.tagName === "HR" || _haxStore.HAXStore.isGridPlateElement(newValue)) && newValue.getAttribute("data-hax-lock") === null && newValue.parentNode.getAttribute("data-hax-lock") === null) {
                      newValue.setAttribute("contenteditable", true);
                      this.setAttribute("contenteditable", true);
                    } else {
                      newValue.removeAttribute("contenteditable");
                      this.removeAttribute("contenteditable");
                    }

                    this._keepContextVisible(); // hack, show the icon of the item in the context menu without menu tapping store


                    this.contextMenus.text.realSelectedValue = tag;
                  } // just hide menus if we don't have an active item
                  else if (newValue === null) {
                      this.hideContextMenus();
                      this.__oldActiveNode = oldValue;
                    } // attempt old value processing on element changed
                  // @see haxHooks activeElementChanged


                  _context13.t0 = this.editMode;

                  if (!_context13.t0) {
                    _context13.next = 14;
                    break;
                  }

                  _context13.next = 13;
                  return _haxStore.HAXStore.runHook(oldValue, "activeElementChanged", [oldValue, false]);

                case 13:
                  _context13.t0 = _context13.sent;

                case 14:
                  if (!_context13.t0) {
                    _context13.next = 16;
                    break;
                  }

                  this.__ignoreActive = true;

                case 16:
                  _context13.t1 = this.editMode;

                  if (!_context13.t1) {
                    _context13.next = 21;
                    break;
                  }

                  _context13.next = 20;
                  return _haxStore.HAXStore.runHook(newValue, "activeElementChanged", [newValue, true]);

                case 20:
                  _context13.t1 = _context13.sent;

                case 21:
                  if (!_context13.t1) {
                    _context13.next = 23;
                    break;
                  }

                  this.__ignoreActive = true;

                case 23:
                  if (!(this.editMode && oldValue)) {
                    _context13.next = 33;
                    break;
                  }

                  oldSchema = _haxStore.HAXStore.haxSchemaFromTag(oldValue.tagName.toLowerCase()); // account for other things injecting a UI that needs removed on loss of focus

                  if (!(oldSchema.editingElement != "core" || oldValue.parentNode && oldValue.parentNode.haxUIElement && oldValue.parentNode === _haxStore.HAXStore.activeEditingElement)) {
                    _context13.next = 33;
                    break;
                  }

                  this.__ignoreActive = true; // run internal state hook if it exist and if we get a response

                  _context13.next = 29;
                  return _haxStore.HAXStore.runHook(_haxStore.HAXStore.activeEditingElement, "activeElementChanged", [oldValue, false]);

                case 29:
                  replacement = _context13.sent;

                  if (replacement && replacement !== oldValue) {
                    // test for slots to match to ensure this is maintained
                    if (oldValue && oldValue.getAttribute && oldValue.getAttribute("slot") != null) {
                      replacement.setAttribute("slot", oldValue.getAttribute("slot"));
                    } // clean up from possible clone of settings we don't allow cloning
                    // haxProperties supports element saying what internals it needs
                    // garbage collected


                    if (oldSchema.saveOptions && oldSchema.saveOptions.unsetAttributes && oldSchema.saveOptions.unsetAttributes.length) {
                      for (i in oldSchema.saveOptions.unsetAttributes) {
                        replacement.removeAttribute(oldSchema.saveOptions.unsetAttributes[i]);
                      }
                    } // this implies there was a replacement had AND that this response HTML object
                    // is different than what was passed in. In this instance we will end up
                    // firing the unwrap to unpeal the element w/ the new content but
                    // we need to ensure that the event binding is correctly applied


                    this.__applyNodeEditableState(replacement, this.editMode);
                  } // this effectively removes the editing element


                  (0, _utils.unwrap)(_haxStore.HAXStore.activeEditingElement);
                  _haxStore.HAXStore.activeEditingElement = null;

                case 33:
                  if (!(this.editMode && newValue)) {
                    _context13.next = 47;
                    break;
                  }

                  newSchema = _haxStore.HAXStore.haxSchemaFromTag(newValue.tagName);

                  if (!(newSchema && newSchema.editingElement && newSchema.editingElement != "core")) {
                    _context13.next = 47;
                    break;
                  }

                  if (!newSchema.editingElement.import) {
                    _context13.next = 40;
                    break;
                  }

                  basePath = new URL("./../../", meta.url).href;
                  _context13.next = 40;
                  return new Promise(function (res, rej) {
                    return _require.default(["".concat(basePath).concat(newSchema.editingElement.import)], res, rej);
                  });

                case 40:
                  _haxStore.HAXStore.activeEditingElement = document.createElement(newSchema.editingElement.tag); // test for slots to match to ensure this is maintained

                  if (newValue.getAttribute && newValue.getAttribute("slot") != null) {
                    _haxStore.HAXStore.activeEditingElement.setAttribute("slot", newValue.getAttribute("slot"));
                  } // support for a callback on insert to do any additional work it wants
                  // this is useful for setting default properties for example


                  if (newSchema.editingElement.callback) {
                    newSchema.editingElement.callback(_haxStore.HAXStore.activeEditingElement);
                  }

                  this.__ignoreActive = true;
                  (0, _utils.wrap)(newValue, _haxStore.HAXStore.activeEditingElement); // @see haxHooks activeElementChanged, this is run on the editing element too

                  _context13.next = 47;
                  return _haxStore.HAXStore.runHook(_haxStore.HAXStore.activeEditingElement, "activeElementChanged", [newValue, true]);

                case 47:
                  if (oldValue && oldValue.parentNode && (!newValue || !newValue.parentNode || newValue.parentNode !== oldValue.parentNode)) this.unsetSlotEditMode(oldValue.parentNode);
                  this.unsetElementEditMode(oldValue);

                case 49:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13, this);
        }));

        function _activeNodeChanged(_x9, _x10) {
          return _activeNodeChanged2.apply(this, arguments);
        }

        return _activeNodeChanged;
      }()
      /**
       * Get position from top and left of the page based on position:relative; being
       * set in a parent.
       *
       * @notice This only works correctly across browsers because hax-body
       * is position:relative in :host.
       */

    }, {
      key: "_getPosition",
      value: function _getPosition(element) {
        var xPosition = element.offsetLeft - element.scrollLeft + element.clientLeft;
        var yPosition = element.offsetTop - element.scrollTop + element.clientTop;
        return {
          x: xPosition,
          y: yPosition
        };
      }
      /**
       * Handle display and position of the context menu
       */

    }, {
      key: "_showContextMenu",
      value: function _showContextMenu(menu) {
        menu.setAttribute("on-screen", "on-screen");
        menu.classList.add("hax-context-visible", "hax-context-menu-active");
      }
      /**
       * gets context container
       */

    }, {
      key: "_getContextContainer",
      value: function _getContextContainer(el) {
        var parent = !el || !el.parentNode ? undefined : el.parentNode,
            container = !parent || !parent.nodeType ? undefined : parent.nodeType == 1 ? parent : parent.host;
        return container;
      }
      /**
       * Simple hide / reset of whatever menu it's handed.
       */

    }, {
      key: "_hideContextMenu",
      value: function _hideContextMenu(menu) {
        if (!menu) return;
        menu.removeAttribute("on-screen");
        menu.classList.remove("hax-context-visible");
        menu.classList.remove("hax-context-menu-active");
      }
      /**
       * Find the next thing to tab forward to.
       */

    }, {
      key: "_tabKeyPressed",
      value: function _tabKeyPressed() {
        // try selection / tab block since range can cause issues
        if (this.activeNode && _haxStore.HAXStore.getRange().cloneRange) {
          try {
            var focus = false;
            var _node = this.activeNode.parentNode;
            var activeNodeTagName = this.activeNode.parentNode.tagName;

            var range = _haxStore.HAXStore.getRange().cloneRange();

            var tagTest = range.commonAncestorContainer.tagName;

            if (babelHelpers.typeof(tagTest) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              tagTest = range.commonAncestorContainer.parentNode.tagName;
            }

            if (["UL", "OL", "LI"].includes(activeNodeTagName) || ["UL", "OL", "LI"].includes(tagTest)) {
              if (this.polyfillSafe) {
                this.__tabTrap = true;
                this.__indentTrap = true;
                document.execCommand("indent");
              }
            } else {
              while (!focus) {
                // do nothing
                if (_node.nextSibling == null) {
                  focus = true;
                } else if (_node.nextSibling.focus === "function") {
                  _node.nextSibling.focus();

                  focus = true;
                } else {
                  _node = _node.nextSibling;
                }
              }
            }
          } catch (e) {
            console.warn(e);
          }
        }
      }
      /**
       * Move back through things when tab back pressed
       */

    }, {
      key: "_tabBackKeyPressed",
      value: function _tabBackKeyPressed() {
        // try selection / tab block since range can cause issues
        if (this.activeNode && _haxStore.HAXStore.getRange().cloneRange) {
          try {
            var _node2 = this.activeNode.parentNode;
            var activeNodeTagName = this.activeNode.parentNode.tagName;

            var range = _haxStore.HAXStore.getRange().cloneRange();

            var tagTest = range.commonAncestorContainer.tagName;

            if (babelHelpers.typeof(tagTest) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              tagTest = range.commonAncestorContainer.parentNode.tagName;
            }

            if (["UL", "OL", "LI"].includes(activeNodeTagName) || ["UL", "OL", "LI"].includes(tagTest)) {
              if (this.polyfillSafe) {
                this.__tabTrap = true;
                this.__indentTrap = true;
                document.execCommand("outdent");
              }
            } else {
              if (_node2 != null) {
                // step back ignoring hax- prefixed elements
                while (_node2 != null && !this._validElementTest(_node2)) {
                  _node2 = _node2.previousSibling;
                }
              }

              if (_node2 != null) {
                setTimeout(function () {
                  _node2.focus();
                }, 50);
              }
            }
          } catch (e) {
            console.warn(e);
          }
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "hax-body";
      }
      /**
       * LitElement constructable styles enhancement
       */

    }, {
      key: "styles",
      get: function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody), "styles", this)), [(0, _index.css)(_templateObject3_1a621140942811ecb1937969798b231a || (_templateObject3_1a621140942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n        :host([edit-mode]),\n        :host([edit-mode]) * ::slotted(*) {\n          line-height: 1.8;\n        }\n        :host([edit-mode]) ul,\n        :host([edit-mode]) ol {\n          padding-left: 20px;\n          margin-left: 20px;\n        }\n        :host([edit-mode]) ul {\n          list-style-type: disc;\n        }\n        :host([edit-mode]) code {\n          padding: 0.2em 0.4em;\n          margin: 0;\n          font-size: 12px;\n          background-color: var(\n            --hax-base-styles-code-background-color,\n            rgba(175, 184, 193, 0.2)\n          );\n          border-radius: 6px;\n          font-family: var(\n            --hax-base-styles-code-font-family,\n            ui-monospace,\n            monospace\n          );\n        }\n        :host([edit-mode]) pre {\n          padding: 16px;\n          overflow: auto;\n          line-height: 1.45;\n          background-color: var(\n            --hax-base-styles-pre-background-color,\n            rgba(175, 184, 193, 0.2)\n          );\n          border-radius: 6px;\n          margin-bottom: 0;\n          word-break: normal;\n          word-wrap: normal;\n          margin-top: 0;\n          font-family: var(\n            --hax-base-styles-pre-font-family,\n            ui-monospace,\n            monospace\n          );\n          font-size: 12px;\n        }\n        :host([edit-mode]) li {\n          margin-bottom: 6px;\n        }\n        :host([edit-mode][tray-status=\"full-panel\"]) #bodycontainer {\n          display: none;\n        }\n        :host {\n          display: block;\n          position: relative;\n          min-height: 32px;\n          min-width: 32px;\n          outline: none;\n          --hax-contextual-action-text-color: var(--hax-ui-background-color);\n          --hax-contextual-action-hover-color: var(--hax-ui-color-accent);\n          --hax-contextual-action-color: var(--hax-ui-color-accent-secondary);\n          --hax-body-editable-outline: 1px solid\n            var(--hax-ui-disabled-color, #ddd);\n          --hax-body-active-outline-hover: 1px solid\n            var(--hax-ui-color-faded, #444);\n          --hax-body-active-outline: 1px solid var(--hax-ui-color-focus, #000);\n          --hax-body-active-drag-outline: 1px solid\n            var(--hax-ui-color-accent, #009dc7);\n          --hax-body-target-background-color: var(\n            --hax-ui-background-color-accent\n          );\n          --hax-body-possible-target-background-color: inherit;\n        }\n        #topcontext {\n          z-index: calc(var(--hax-ui-focus-z-index) - 2);\n          min-width: 280px;\n        }\n        #topcontextmenu {\n          width: auto;\n          max-width: 100%;\n          position: absolute;\n          bottom: 0;\n        }\n        .hax-context-menu {\n          display: none;\n          z-index: 1;\n        }\n        .hax-context-menu:hover {\n          z-index: calc(var(--hax-ui-focus-z-index) + 1);\n          transition: 0s z-index ease-in-out;\n        }\n        .hax-context-visible,\n        .hax-context-menu-active {\n          display: flex;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted([contenteditable]) {\n          -webkit-appearance: textfield;\n          cursor: text;\n          -moz-user-select: text;\n          -khtml-user-select: text;\n          -webkit-user-select: text;\n          -o-user-select: text;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted([contenteditable][data-hax-ray]:empty)::before {\n          content: attr(data-hax-ray);\n          opacity: 0.2;\n          transition: 0.2s all ease-in-out;\n        }\n\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted([contenteditable][data-hax-ray]:hover:empty)::before {\n          opacity: 0.4;\n          cursor: text;\n        }\n\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted([contenteditable][data-hax-ray]:empty:focus)::before {\n          content: \"\";\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(p) {\n          min-height: var(--hax-base-styles-p-min-height, 1rem);\n          font-size: var(--hax-base-styles-p-font-size);\n          line-height: var(--hax-base-styles-p-line-height);\n          letter-spacing: var(--hax-base-styles-p-letter-spacing);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(a) {\n          color: var(--hax-base-styles-a-color);\n          font-size: var(\n            --hax-base-styles-a-font-size,\n            var(--hax-base-styles-p-font-size)\n          );\n          font-weight: var(--hax-base-styles-a-font-weight);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(a:visited) {\n          color: var(--hax-base-styles-a-color-visited);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(a:active),\n        :host([edit-mode]) #bodycontainer ::slotted(a:focus),\n        :host([edit-mode]) #bodycontainer ::slotted(a:hover) {\n          color: var(--hax-base-styles-a-color-active);\n          font-weight: var(--hax-base-styles-a-font-weight-active);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(ol),\n        :host([edit-mode]) #bodycontainer ::slotted(ul),\n        :host([edit-mode]) #bodycontainer ::slotted(li) {\n          padding-bottom: var(--hax-base-styles-list-padding-bottom);\n          line-height: var(\n            --hax-base-styles-list-line-height,\n            var(--hax-base-styles-p-line-height)\n          );\n          font-size: var(\n            --hax-base-styles-list-font-size,\n            var(--hax-base-styles-p-font-size)\n          );\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(ol > li:last-child),\n        :host([edit-mode]) #bodycontainer ::slotted(ul > li:last-child) {\n          padding-bottom: var(--hax-base-styles-list-last-child-padding-bottom);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(img[contenteditable]) {\n          max-width: 100%;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*[contenteditable]) {\n          outline: none;\n          caret-color: auto;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*.blinkfocus) {\n          outline: 2px solid var(--hax-contextual-action-hover-color);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*[data-hax-lock]) {\n          background-color: #fffafa;\n          opacity: 0.5;\n          transition: 0.2s all ease-in-out;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*[data-hax-lock]:hover) {\n          opacity: 0.9;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*[data-hax-lock])::after {\n          width: 28px;\n          height: 28px;\n          content: \"\";\n          display: flex;\n          float: right;\n          z-index: 1;\n          position: relative;\n          background-position: center;\n          background-repeat: no-repeat;\n          background-color: #fffafa;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*:not([data-hax-layout])[contenteditable]:hover) {\n          outline: var(--hax-body-active-outline-hover);\n          caret-color: auto;\n        }\n        :host(.hax-add-content-visible[edit-mode])\n          #bodycontainer\n          ::slotted(*.hax-active) {\n          margin-bottom: 30px;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*.hax-active[contenteditable]:hover) {\n          cursor: text !important;\n          caret-color: auto;\n          outline: var(--hax-body-active-outline-hover);\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*:not([data-hax-layout])[contenteditable]\n            .hax-active:hover) {\n          cursor: text !important;\n          caret-color: auto;\n          outline: var(--hax-body-active-outline-hover);\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(code.hax-active[contenteditable]) {\n          display: block;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*.hax-active[contenteditable]) {\n          outline: var(--hax-body-active-outline) !important;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(hr[contenteditable]) {\n          height: 2px;\n          background-color: #eeeeee;\n          padding-top: 4px;\n          padding-bottom: 4px;\n        }\n        /** Fix to support safari as it defaults to none */\n        :host([edit-mode]) #bodycontainer ::slotted(*[contenteditable]) {\n          -webkit-user-select: text;\n          cursor: pointer;\n        }\n\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[contenteditable]::-moz-selection),\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[contenteditable] *::-moz-selection) {\n          background-color: var(--hax-body-highlight, #ffffac);\n          color: black;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[contenteditable]::selection),\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[contenteditable] *::selection) {\n          background-color: var(--hax-body-highlight, #ffffac);\n          color: black;\n        }\n        #bodycontainer {\n          -webkit-user-select: text;\n          user-select: text;\n        }\n        absolute-position-behavior:not(:defined),\n        .hax-context-menu:not(:defined) {\n          display: none;\n        }\n        /* drag and drop */\n        :host([edit-mode][hax-mover]) #bodycontainer ::slotted(*)::before {\n          background-color: var(--hax-body-possible-target-background-color);\n          content: \" \";\n          width: 100%;\n          display: block;\n          position: relative;\n          margin: -12px 0 0 0;\n          z-index: 2;\n          height: 12px;\n          transition: 0.2s all ease-in-out;\n        }\n        :host([edit-mode][hax-mover]) #bodycontainer ::slotted(img) {\n          outline: var(--hax-body-editable-outline);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(img.hax-hovered),\n        :host([edit-mode]) #bodycontainer ::slotted(*.hax-hovered)::before {\n          background-color: var(--hax-body-target-background-color) !important;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(img.hax-hovered) {\n          border-top: 8px\n            var(--hax-contextual-action-hover-color, var(--hax-ui-color-accent));\n          margin-top: -8px;\n        }\n        [hidden],\n        :host([hidden]),\n        #textcontextmenu.not-text {\n          display: none !important;\n        }\n        /** This is mobile layout for controls */\n        @media screen and (max-width: 800px) {\n          .hax-context-menu {\n            height: 0px;\n          }\n          .hax-context-visible {\n            height: auto;\n          }\n          :host(:not([tray-status=\"collapsed\"])) {\n            z-index: -1;\n          }\n          :host([edit-mode]) #bodycontainer,\n          :host([edit-mode]) #bodycontainer[element-align=\"left\"],\n          :host([edit-mode]) #bodycontainer[element-align=\"right\"] {\n            margin: calc(100px + var(--hax-tray-menubar-min-height)) 0 0 0;\n          }\n        }\n\n        @media screen and (min-color-index: 0) and(-webkit-min-device-pixel-ratio:0) {\n          /*\n            Define here the CSS styles applied only to Safari browsers\n            (any version and any device) via https://solvit.io/bcf61b6\n          */\n          :host([edit-mode][hax-mover]) #bodycontainer ::slotted(*) {\n            outline: var(--hax-body-editable-outline);\n            background-color: var(--hax-body-possible-target-background-color);\n          }\n          :host([edit-mode]) #bodycontainer ::slotted(*.hax-hovered) {\n            background-color: var(\n              --hax-body-target-background-color\n            ) !important;\n            outline: var(--hax-body-active-outline);\n          }\n        }\n      "])))]);
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody), "properties", this)), {}, {
          /** enabldes link targets */
          allowLinkTarget: {
            type: Boolean
          },
          haxMover: {
            type: Boolean,
            attribute: "hax-mover",
            reflect: true
          },

          /**
           * State of if we are editing or not.
           */
          editMode: {
            type: Boolean,
            reflect: true,
            attribute: "edit-mode"
          },

          /**
           * element align
           */
          elementAlign: {
            type: String,
            reflect: true,
            attribute: "element-align"
          },

          /**
           * is hax tray collapsed, side-panel, or full-panel
           */
          trayDetail: {
            type: String,
            reflect: true,
            attribute: "tray-detail"
          },

          /**
           * is hax tray collapsed, side-panel, or full-panel
           */
          trayStatus: {
            type: String,
            reflect: true,
            attribute: "tray-status"
          },

          /**
           * A reference to the active node in the slot.
           */
          activeNode: {
            type: Object
          },

          /**
           * activeNode can be moved
           */
          canMoveElement: {
            type: Boolean
          },

          /**
           *Is active node in view source mode?
           */
          viewSourceToggle: {
            type: Boolean,
            reflect: true
          }
        });
      }
    }]);
    return HaxBody;
  }((0, _I18NMixin2.I18NMixin)((0, _undoManager.UndoManagerBehaviors)(_simpleColors.SimpleColors)));

  _exports.HaxBody = HaxBody;
  window.customElements.define(HaxBody.tag, HaxBody);
});