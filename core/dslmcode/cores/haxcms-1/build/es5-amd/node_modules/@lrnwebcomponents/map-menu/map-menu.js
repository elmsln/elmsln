define(["exports", "../../lit/index.js", "./lib/map-menu-builder.js", "./lib/map-menu-container.js", "../utils/utils.js"], function (_exports, _index, _mapMenuBuilder, _mapMenuContainer, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.MapMenu = void 0;

  var _templateObject_aadfeee08e0011ed99ce491205e67b1d, _templateObject2_aadfeee08e0011ed99ce491205e67b1d;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `map-menu`
   * `A series of elements that generate a hierarchical menu`
   *
   * @demo demo/index.html
   * @element map-menu
   */
  var MapMenu = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(MapMenu, _LitElement);

    var _super = _createSuper(MapMenu);

    /**
     * HTMLElement
     */
    function MapMenu() {
      var _this;

      babelHelpers.classCallCheck(this, MapMenu);
      _this = _super.call(this);
      _this.disabled = false;
      _this.title = "Content outline";
      _this.data = null;
      _this.items = [];
      _this.autoScroll = false;
      _this.activeIndicator = false;
      setTimeout(function () {
        _this.addEventListener("link-clicked", _this.__linkClickedHandler.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("toggle-updated", _this.__toggleUpdated.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("active-item", _this.__activeItemHandler.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("map-meu-item-hidden-check", _this._mapMeuItemHiddenCheckHandler.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      return _this;
    }
    /**
     * LitElement life cycle - render
     */


    babelHelpers.createClass(MapMenu, [{
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_aadfeee08e0011ed99ce491205e67b1d || (_templateObject_aadfeee08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <div id=\"itemslist\">\n        <map-menu-container>\n          <div id=\"activeindicator\"></div>\n          <map-menu-builder\n            id=\"builder\"\n            .items=\"", "\"\n            .selected=\"", "\"\n          ></map-menu-builder>\n        </map-menu-container>\n      </div>\n    "])), this.items, this.selected);
      }
    }, {
      key: "updated",
      value:
      /**
       * LitElement life cycle - properties changed
       */
      function updated(changedProperties) {
        var _this2 = this;

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "data") {
            _this2._dataChanged(_this2[propName]);
          }

          if (propName == "manifest") {
            _this2._manifestChanged(_this2[propName]);
          }

          if (propName == "activeItem") {
            _this2.refreshActiveChildren(_this2[propName], oldValue);
          } // notify


          if (["manifest", "items", "selected"].includes(propName)) {
            _this2.dispatchEvent(new CustomEvent("".concat(propName, "-changed"), {
              detail: {
                value: _this2[propName]
              }
            }));
          }
        });
      }
    }, {
      key: "__activeItemHandler",
      value: function __activeItemHandler(e) {
        this.activeItem = e.detail;
      }
    }, {
      key: "_mapMeuItemHiddenCheckHandler",
      value: function _mapMeuItemHiddenCheckHandler(e) {
        var action = e.detail.action;
        var hiddenChild = e.detail.hiddenChild;

        if (action === "closed" && hiddenChild === true) {
          this.__updateActiveIndicator(this.activeItem, true);
        } else {
          this.__updateActiveIndicator(this.activeItem, false);
        }
      }
      /**
       * Set and unset active properties on children
       * @param {string} activeItem
       */

    }, {
      key: "refreshActiveChildren",
      value: function refreshActiveChildren(newValue, oldValue) {
        if (newValue) {
          // set the new active attribute to the item
          newValue.setAttribute("active", "active"); // move the highlight thingy

          if (this.activeIndicator) {
            this.__updateActiveIndicator(newValue);
          } // if auto scroll enabled then scroll element into view


          if (this.autoScroll) {
            // kick off smooth scroll
            this.__scrollHandler(newValue, {
              duration: 50,
              delay: 0,
              scrollElement: this
            });
          }
        }

        if (oldValue) {
          oldValue.removeAttribute("active");

          this.__updateActiveIndicator(newValue);
        }
      }
    }, {
      key: "__scrollHandler",
      value: function __scrollHandler(target, options) {
        // define default options
        var defaultOptions = {
          align: "top",
          delay: 0,
          duration: 300,
          scrollElement: window
        }; // combine default and user defined options

        var _options = Object.assign({}, defaultOptions, options); // get the bound client


        var targetPosition = target.getBoundingClientRect(); // get the scroll Element position

        var scrollElementPosition = _options.scrollElement.getBoundingClientRect(); // get the height of the scroll Element


        var scrollElementHeight = _options.scrollElement.getBoundingClientRect().bottom - _options.scrollElement.getBoundingClientRect().top; // get the height of the element target


        var targetHeight = targetPosition.bottom - targetPosition.top; // get the offset of the scroll Element

        var startPosition = _options.scrollElement.scrollTop; // get the distance between the top of the scroll and the top of the bounding rectangles

        var distance = target.getBoundingClientRect().top - _options.scrollElement.getBoundingClientRect().top;
        /**
         * @todo weird trick to position the scroll over the target
         * I'm still not sure why this works :)
         */


        distance = distance - scrollElementHeight / 2; // see where the user wants to align the scroll

        switch (_options.align) {
          case "center":
            distance = distance + targetHeight / 2;
            break;

          case "bottom":
            distance = distance + targetHeight;
            break;

          default:
            break;
        } // record start time


        var startTime = null; // internal animation function

        function animation(currentTime) {
          if (startTime === null) startTime = currentTime;
          var timeElapsed = currentTime - startTime;
          var run = ease(timeElapsed, startPosition, distance, _options.duration);
          _options.scrollElement.scrollTop = run;
          if (timeElapsed < _options.duration) requestAnimationFrame(animation);
        } // define a ease-in-out


        function ease(t, b, c, d) {
          if ((t /= d / 2) < 1) return c / 2 * t * t + b;
          return -c / 2 * (--t * (t - 2) - 1) + b;
        } // start animation


        requestAnimationFrame(animation);
      }
    }, {
      key: "_manifestChanged",
      value: function _manifestChanged(newValue) {
        if (newValue) {
          this.data = newValue.items;
        }
      }
      /**
       * Convert data from a linear array
       * to a nested array for template rendering
       */

    }, {
      key: "_dataChanged",
      value: function _dataChanged(data) {
        var _this3 = this;

        var items = [];
        if (!data) return; // find parents

        data.forEach(function (element) {
          // find top level parents
          if (!element.parent) {
            items.push(element);
          }
        }); // Recursively find and set children

        items.forEach(function (item, i) {
          _this3._setChildren(item, data);
        }); // Update items array

        this.items = [].concat(items);
      }
      /**
       * Recursively search through a data to find children
       * of a specified item.
       * @param {object} item item of an array to search on. Passed by reference.
       * @param {array} data linear array of the data set.
       * @return {void}
       */

    }, {
      key: "_setChildren",
      value: function _setChildren(item, data) {
        var _this4 = this;

        // find all children
        var children = data.filter(function (d) {
          return item.id === d.parent;
        });
        item.children = children;

        if (item.children.length > 0) {
          item.children.forEach(function (child) {
            // recursively call itself
            _this4._setChildren(child, data);
          });
        }
      }
      /**
       * Determine if a menu item has children
       */

    }, {
      key: "__hasChildren",
      value: function __hasChildren(item) {
        return item.children.length > 0;
      }
      /**
       * asdf
       */

    }, {
      key: "__linkClickedHandler",
      value: function __linkClickedHandler(e) {
        this.selected = e.detail.id;
        this.dispatchEvent(new CustomEvent("selected", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: e.detail.id
        }));
      }
      /**
       * When a user clicks the toggle button to collapse or
       * expand a submenu, this event gets triggered after
       * the animation has been triggered
       */

    }, {
      key: "__toggleUpdated",
      value: function __toggleUpdated(e) {
        var action = e.detail.opened ? "opened" : "closed";
        var target = (0, _utils.normalizeEventPath)(e)[0];

        if (typeof this.activeItem !== "undefined") {
          this.__updateActiveIndicator(this.activeItem, false);

          this.activeItem.dispatchEvent(new CustomEvent("map-menu-item-hidden-check", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: Object.assign({}, {
              action: action,
              target: target
            })
          }));
        }
      }
      /**
       * Find out if
       */

    }, {
      key: "__isInViewport",
      value: function __isInViewport(element) {
        var scrollParent = this.__getScrollParent(element);

        if (!scrollParent) return false;
        var elementTop = element.offsetTop;
        var elementBottom = elementTop + element.offsetHeight;
        var viewportTop = scrollParent.offsetTop;
        var viewportBottom = viewportTop + scrollParent.offsetHeight;
        return elementBottom > viewportTop && elementTop < viewportBottom;
      }
      /**
       * Get scroll parent
       */

    }, {
      key: "__getScrollParent",
      value: function __getScrollParent(node) {
        if (node == null) {
          return null;
        }

        if (node.scrollHeight > node.clientHeight) {
          return node;
        } else {
          return this.__getScrollParent(node.parentNode);
        }
      }
      /**
       * Move the highlight widget over active element
       */

    }, {
      key: "__updateActiveIndicator",
      value: function __updateActiveIndicator(element) {
        var _this5 = this;

        var hidden = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        // run it through to set time just to let stuff set up
        setTimeout(function () {
          var activeindicator = _this5.shadowRoot.querySelector("#activeindicator");

          var left = element.offsetLeft;
          var top = element.offsetTop;
          var width = element.offsetWidth; // if the element is hidden the set the indicator height to zero to make it disapear

          var height = !hidden ? element.offsetHeight : 0;
          activeindicator.setAttribute("style", "width:".concat(width, "px;height:").concat(height, "px;top:").concat(top, "px;left:").concat(left, "px"));
        }, 200);
      }
      /**
       * Find out if any parents of the item are collapsed
       */

    }, {
      key: "__parentsHidden",
      value: function __parentsHidden(node) {
        // get the parent node
        var parent = node.parentNode; // bail if we have no node to work with

        if (parent == null) return null; // if we found a submenu check if it is hidden

        if (parent.tagName === "MAP-MENU-SUBMENU") {
          // if open is set to false then we have
          // found a hidden parent
          if (!parent.opened) return true;
        } // wrap up and exit if we came all the way back to map-menu


        if (parent.tagName === "MAP-MENU") return false; // if we got all the way here then we need recursively run this
        // against the parent node

        return this.__parentsHidden(parent);
      }
    }], [{
      key: "styles",
      get:
      /**
       * LitElement constructable styles enhancement
       */
      function get() {
        return [(0, _index.css)(_templateObject2_aadfeee08e0011ed99ce491205e67b1d || (_templateObject2_aadfeee08e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          --map-menu-active-color: rgba(0, 0, 0, 0.1);\n          --map-menu-size: 1;\n          display: block;\n          overflow-y: scroll;\n          position: relative;\n          height: 100%;\n          transition: all 0.1s ease-in-out;\n          opacity: 1;\n          background-color: transparent;\n        }\n        #itemslist {\n          display: var(--map-menu-items-list-display);\n          flex-direction: var(--map-menu-items-list-flex-direction);\n          flex: var(--map-menu-items-list-flex);\n        }\n        #activeindicator {\n          background: var(--map-menu-active-color);\n          transition: all 0.1s ease-in-out;\n          position: absolute;\n          pointer-events: none;\n        }\n\n        map-menu-container {\n          padding: var(--map-menu-container-padding, 0);\n          display: var(--map-menu-container-display);\n          flex-direction: var(--map-menu-container-flex-direction);\n          flex: var(--map-menu-container-flex);\n          background-color: var(--map-menu-container-background-color);\n          color: var(--map-menu-container-color);\n        }\n\n        /* turn default active color if indicator is on */\n        :host([active-indicator]) map-menu-builder {\n          --map-menu-active-color: transparent;\n        }\n      "])))];
      }
    }, {
      key: "tag",
      get: function get() {
        return "map-menu";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          disabled: {
            type: Boolean,
            reflect: true
          },
          title: {
            type: String
          },
          data: {
            type: Array
          },

          /**
           * Support for JSON Outline Schema manifest format
           */
          manifest: {
            type: Object
          },
          items: {
            type: Array
          },

          /**
           * Current selected item.
           */
          selected: {
            type: String
          },
          activeItem: {
            type: Object
          },

          /**
           * Auto scroll an active element if not in view
           */
          autoScroll: {
            type: Boolean,
            attribute: "auto-scroll"
          },

          /**
           * Show active indicator animation
           */
          activeIndicator: {
            type: Boolean,
            reflect: true,
            attribute: "active-indicator"
          }
        };
      }
    }]);
    return MapMenu;
  }(_index.LitElement);

  _exports.MapMenu = MapMenu;
  customElements.define(MapMenu.tag, MapMenu);
});