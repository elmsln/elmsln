define(["exports","../../lit-element/lit-element.js","./lib/map-menu-builder.js","./lib/map-menu-container.js"],function(_exports,_litElement,_mapMenuBuilder,_mapMenuContainer){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.MapMenu=void 0;function _templateObject2_719a67c07ae711ea9f6d454984daed83(){var data=babelHelpers.taggedTemplateLiteral(["\n      <div id=\"itemslist\">\n        <map-menu-container>\n          <div id=\"activeindicator\"></div>\n          <map-menu-builder\n            id=\"builder\"\n            .items=\"","\"\n            .selected=\"","\"\n          ></map-menu-builder>\n        </map-menu-container>\n      </div>\n    "]);_templateObject2_719a67c07ae711ea9f6d454984daed83=function _templateObject2_719a67c07ae711ea9f6d454984daed83(){return data};return data}function _templateObject_719a67c07ae711ea9f6d454984daed83(){var data=babelHelpers.taggedTemplateLiteral(["\n        :host {\n          --map-menu-active-color: rgba(0, 0, 0, 0.1);\n          --map-menu-size: 1;\n          --map-menu-font-size: 16px;\n          display: block;\n          overflow-y: scroll;\n          position: relative;\n          height: 100%;\n          transition: 0.1s linear all;\n          opacity: 1;\n          background-color: transparent;\n        }\n        #itemslist {\n          display: var(--map-menu-items-list-display);\n          flex-direction: var(--map-menu-items-list-flex-direction);\n          flex: var(--map-menu-items-list-flex);\n        }\n        #activeindicator {\n          background: var(--map-menu-active-color);\n          transition: all 0.1s ease-in-out;\n          position: absolute;\n        }\n\n        map-menu-container {\n          padding: var(--map-menu-container-padding, 0);\n          display: var(--map-menu-container-display);\n          flex-direction: var(--map-menu-container-flex-direction);\n          flex: var(--map-menu-container-flex);\n        }\n\n        /* turn default active color if indicator is on */\n        :host([active-indicator]) map-menu-builder {\n          --map-menu-active-color: transparent;\n        }\n      "]);_templateObject_719a67c07ae711ea9f6d454984daed83=function _templateObject_719a67c07ae711ea9f6d454984daed83(){return data};return data}/**
 * `map-menu`
 * `A series of elements that generate a hierarchical menu`
 *
 * @demo demo/index.html
 * @element map-menu
 */var MapMenu=/*#__PURE__*/function(_LitElement){babelHelpers.inherits(MapMenu,_LitElement);babelHelpers.createClass(MapMenu,null,[{key:"styles",/**
   * LitElement constructable styles enhancement
   */get:function get(){return[(0,_litElement.css)(_templateObject_719a67c07ae711ea9f6d454984daed83())]}/**
   * HTMLElement
   */}]);function MapMenu(){var _this;babelHelpers.classCallCheck(this,MapMenu);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(MapMenu).call(this));_this.disabled=!1;_this.title="Content outline";_this.data=null;_this.items=[];_this.autoScroll=!1;_this.activeIndicator=!1;setTimeout(function(){_this.addEventListener("link-clicked",_this.__linkClickedHandler.bind(babelHelpers.assertThisInitialized(_this)));_this.addEventListener("toggle-updated",_this.__toggleUpdated.bind(babelHelpers.assertThisInitialized(_this)));_this.addEventListener("active-item",_this.__activeItemHandler.bind(babelHelpers.assertThisInitialized(_this)));_this.addEventListener("map-meu-item-hidden-check",_this._mapMeuItemHiddenCheckHandler.bind(babelHelpers.assertThisInitialized(_this)))},0);return _this}/**
   * LitElement life cycle - render
   */babelHelpers.createClass(MapMenu,[{key:"render",value:function render(){return(0,_litElement.html)(_templateObject2_719a67c07ae711ea9f6d454984daed83(),this.items,this.selected)}},{key:"updated",/**
   * LitElement life cycle - properties changed
   */value:function updated(changedProperties){var _this2=this;changedProperties.forEach(function(oldValue,propName){if("data"==propName){_this2._dataChanged(_this2[propName])}if("manifest"==propName){_this2._manifestChanged(_this2[propName])}if("activeItem"==propName){_this2.refreshActiveChildren(_this2[propName],oldValue)}// notify
if(["manifest","items","selected"].includes(propName)){_this2.dispatchEvent(new CustomEvent("".concat(propName,"-changed"),{detail:{value:_this2[propName]}}))}})}},{key:"__activeItemHandler",value:function __activeItemHandler(e){this.activeItem=e.detail}},{key:"_mapMeuItemHiddenCheckHandler",value:function _mapMeuItemHiddenCheckHandler(e){var action=e.detail.action,hiddenChild=e.detail.hiddenChild;if("closed"===action&&!0===hiddenChild){this.__updateActiveIndicator(this.activeItem,!0)}else{this.__updateActiveIndicator(this.activeItem,!1)}}/**
   * Set and unset active properties on children
   * @param {string} activeItem
   */},{key:"refreshActiveChildren",value:function refreshActiveChildren(newValue,oldValue){if(newValue){// set the new active attribute to the item
newValue.setAttribute("active","active");// move the highlight thingy
if(this.activeIndicator){this.__updateActiveIndicator(newValue)}// if auto scroll enabled then scroll element into view
if(this.autoScroll){// kick off smooth scroll
this.__scrollHandler(newValue,{duration:100,scrollElement:this})}}if(oldValue){oldValue.removeAttribute("active");this.__updateActiveIndicator(newValue)}}},{key:"__scrollHandler",value:function __scrollHandler(target,options){// define default options
var defaultOptions={align:"top",delay:0,duration:300,scrollElement:window},_options=Object.assign({},defaultOptions,options),targetPosition=target.getBoundingClientRect(),scrollElementPosition=_options.scrollElement.getBoundingClientRect(),scrollElementHeight=_options.scrollElement.getBoundingClientRect().bottom-_options.scrollElement.getBoundingClientRect().top,targetHeight=targetPosition.bottom-targetPosition.top,startPosition=_options.scrollElement.scrollTop,distance=target.getBoundingClientRect().top-_options.scrollElement.getBoundingClientRect().top;// combine default and user defined options
/**
     * @todo weird trick to position the scroll over the target
     * I'm still not sure why this works :)
     */distance=distance-scrollElementHeight/2;// see where the user wants to align the scroll
switch(_options.align){case"center":distance=distance+targetHeight/2;break;case"bottom":distance=distance+targetHeight;break;default:break;}// record start time
var startTime=null;// internal animation function
function animation(currentTime){if(null===startTime)startTime=currentTime;var timeElapsed=currentTime-startTime,run=ease(timeElapsed,startPosition,distance,_options.duration);_options.scrollElement.scrollTop=run;if(timeElapsed<_options.duration)requestAnimationFrame(animation)}// define a ease-in-out
function ease(t,b,c,d){if(1>(t/=d/2))return c/2*t*t+b;return-c/2*(--t*(t-2)-1)+b}// start animation
requestAnimationFrame(animation)}},{key:"_manifestChanged",value:function _manifestChanged(newValue){if(newValue){this.data=newValue.items}}/**
   * LitElement life cycle - ready
   */},{key:"firstUpdated",value:function firstUpdated(changedProperties){if(this.activeItem){this.refreshActiveChildren(this.activeItem,!1)}}/**
   * Convert data from a linear array
   * to a nested array for template rendering
   */},{key:"_dataChanged",value:function _dataChanged(data){var _this3=this,items=[];if(!data)return;// find parents
data.forEach(function(element){// find top level parents
if(!element.parent){items.push(element)}});// Recursively find and set children
items.forEach(function(item,i){_this3._setChildren(item,data)});// Update items array
this.items=[].concat(items)}/**
   * Recursively search through a data to find children
   * of a specified item.
   * @param {object} item item of an array to search on. Passed by reference.
   * @param {array} data linear array of the data set.
   * @return {void}
   */},{key:"_setChildren",value:function _setChildren(item,data){var _this4=this,children=data.filter(function(d){return item.id===d.parent});item.children=children;if(0<item.children.length){item.children.forEach(function(child){// recursively call itself
_this4._setChildren(child,data)})}}/**
   * Determine if a menu item has children
   */},{key:"__hasChildren",value:function __hasChildren(item){return 0<item.children.length}/**
   * asdf
   */},{key:"__linkClickedHandler",value:function __linkClickedHandler(e){this.selected=e.detail.id;this.dispatchEvent(new CustomEvent("selected",{bubbles:!0,cancelable:!0,composed:!0,detail:e.detail.id}))}/**
   * When a user clicks the toggle button to collapse or
   * expand a submenu, this event gets triggered after
   * the animation has been triggered
   */},{key:"__toggleUpdated",value:function __toggleUpdated(e){var action=e.detail.opened?"opened":"closed",target=e.path[0];if("undefined"!==typeof this.activeItem){this.__updateActiveIndicator(this.activeItem,!1);this.activeItem.dispatchEvent(new CustomEvent("map-menu-item-hidden-check",{bubbles:!0,cancelable:!0,composed:!0,detail:Object.assign({},{action:action,target:target})}))}}/**
   * Find out if
   */},{key:"__isInViewport",value:function __isInViewport(element){var scrollParent=this.__getScrollParent(element);if(!scrollParent)return!1;var elementTop=element.offsetTop,elementBottom=elementTop+element.offsetHeight,viewportTop=scrollParent.offsetTop,viewportBottom=viewportTop+scrollParent.offsetHeight;return elementBottom>viewportTop&&elementTop<viewportBottom}/**
   * Get scroll parent
   */},{key:"__getScrollParent",value:function __getScrollParent(node){if(null==node){return null}if(node.scrollHeight>node.clientHeight){return node}else{return this.__getScrollParent(node.parentNode)}}/**
   * Move the highlight widget over active element
   */},{key:"__updateActiveIndicator",value:function __updateActiveIndicator(element){var _this5=this,hidden=1<arguments.length&&arguments[1]!==void 0?arguments[1]:!1;// run it through to set time just to let stuff set up
setTimeout(function(){var activeindicator=_this5.shadowRoot.querySelector("#activeindicator"),left=element.offsetLeft,top=element.offsetTop,width=element.offsetWidth,height=!hidden?element.offsetHeight:0;activeindicator.setAttribute("style","width:".concat(width,"px;height:").concat(height,"px;top:").concat(top,"px;left:").concat(left,"px"))},200)}/**
   * Find out if any parents of the item are collapsed
   */},{key:"__parentsHidden",value:function __parentsHidden(node){// get the parent node
var parent=node.parentNode;// bail if we have no node to work with
if(null==parent)return null;// if we found a submenu check if it is hidden
if("MAP-MENU-SUBMENU"===parent.tagName){// if open is set to false then we have
// found a hidden parent
if(!parent.opened)return!0}// wrap up and exit if we came all the way back to map-menu
if("MAP-MENU"===parent.tagName)return!1;// if we got all the way here then we need recursively run this
// against the parent node
return this.__parentsHidden(parent)}}],[{key:"tag",get:function get(){return"map-menu"}},{key:"properties",get:function get(){return{disabled:{type:Boolean,reflect:!0},title:{type:String},data:{type:Array},/**
       * Support for JSON Outline Schema manifest format
       */manifest:{type:Object},items:{type:Array},/**
       * Current selected item.
       */selected:{type:String},activeItem:{type:Object},/**
       * Auto scroll an active element if not in view
       */autoScroll:{type:Boolean,attribute:"auto-scroll"},/**
       * Show active indicator animation
       */activeIndicator:{type:Boolean,reflect:!0,attribute:"active-indicator"}}}}]);return MapMenu}(_litElement.LitElement);_exports.MapMenu=MapMenu;window.customElements.define(MapMenu.tag,MapMenu)});