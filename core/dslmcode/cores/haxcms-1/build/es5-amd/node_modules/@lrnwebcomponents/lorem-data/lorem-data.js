define(["exports", "../../lit/index.js", "./lib/lorem-data-behaviors.js"], function (_exports, _index, _loremDataBehaviors) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LoremData = void 0;

  var _templateObject_a6b7c9008e0011ed99ce491205e67b1d, _templateObject2_a6b7c9008e0011ed99ce491205e67b1d, _templateObject3_a6b7c9008e0011ed99ce491205e67b1d;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `lorem-data`
   * a threaded discussions component
   * 
  ### Styling
  
  `<lorem-data>` provides the following custom properties
  for styling:
  
  Custom property | Description | Default
  ----------------|-------------|----------
  `--lorem-data-FontSize` | default font-size | 14px
   *
   * @element lorem-data
   * @demo ./demo/index.html demo
   */
  var LoremData = /*#__PURE__*/function (_LoremDataBehaviors) {
    babelHelpers.inherits(LoremData, _LoremDataBehaviors);

    var _super = _createSuper(LoremData);

    function LoremData() {
      var _this;

      babelHelpers.classCallCheck(this, LoremData);
      _this = _super.call(this);
      _this.schemas = {};
      return _this;
    }

    babelHelpers.createClass(LoremData, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        console.warn(this.data);
        return (0, _index.html)(_templateObject_a6b7c9008e0011ed99ce491205e67b1d || (_templateObject_a6b7c9008e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <button @click=\"", "\">Save All</button>\n      ", "\n      <button @click=\"", "\">Save All</button>\n    "])), this.saveAll, Object.keys(this.schemas || []).map(function (key) {
          return (0, _index.html)(_templateObject2_a6b7c9008e0011ed99ce491205e67b1d || (_templateObject2_a6b7c9008e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n          <p>\n            <label>\n              <a href=\"", "\" download=\"", "\"\n                >", ":\n              </a>\n              <br />\n              <textarea>", "</textarea>\n            </label>\n          </p>\n        "])), _this2.saveDataUrl(_this2.schemas[key]), key, key, _this2.getJson(_this2.schemas[key]));
        }), this.saveAll);
      }
      /**
       * downloads all generated schema JSON files
       *
       * @memberof LoremData
       */

    }, {
      key: "saveAll",
      value: function saveAll() {
        if (this.shadowRoot && this.shadowRoot.querySelectorAll("a") && confirm("Save the following: ".concat(Object.keys(this.schemas).join(", "), "?"))) {
          this.shadowRoot.querySelectorAll("a").forEach(function (a) {
            return a.click();
          });
        }
      }
      /**
       * converts generated schema to JSON
       *
       * @memberof LoremData
       * @param {object} schema
       * @returns {string}
       */

    }, {
      key: "getJson",
      value: function getJson(schema) {
        return JSON.stringify(this.randomType(schema));
      }
      /**
       * genertates a url to download schema JSON
       *
       * @param {object} schema
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "saveDataUrl",
      value: function saveDataUrl(schema) {
        var json = this.getJson(schema),
            blob = new Blob([json], {
          type: "octet/stream"
        });
        return window.URL.createObjectURL(blob);
      }
    }, {
      key: "data",
      get: function get() {
        var _this3 = this;

        var data = {};
        Object.keys(this.schemas || []).forEach(function (key) {
          return data[key] = _this3.randomType(_this3.schemas[key]);
        });
        return data;
      }
      /**
       * colors from Simple Colors
       * @returns {array} color names
       * @memberof LoremData
       */

    }, {
      key: "colors",
      get: function get() {
        var simple = window.SimpleColorsSharedStyles.requestAvailability();
        return simple && simple.colors ? Object.keys(simple.colors) : false;
      }
    }, {
      key: "filterQuery",
      value: function filterQuery(records, filter) {
        return records.filter(record, function (index) {
          return filter(record, index);
        });
      }
      /**
       * gets date x days from start date
       * @param {date} start starting date
       * @param {number} days number of weeks
       * @returns {date}
       */

    }, {
      key: "addDays",
      value: function addDays() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        var amt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return new Date(Date.parse(start) + amt * 86400000);
      }
      /**
       * gets date x days from start date
       * @param {date} start starting date
       * @param {number} days number of weeks
       * @returns {date}
       */

    }, {
      key: "addHours",
      value: function addHours() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        var amt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return new Date(Date.parse(start) + amt * 3600000);
      }
      /**
       * gets date x days from start date
       * @param {date} start starting date
       * @param {number} days number of weeks
       * @returns {date}
       */

    }, {
      key: "addMinutes",
      value: function addMinutes() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        var amt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return new Date(Date.parse(start) + amt * 60000);
      }
      /**
       * gets date x days from start date
       * @param {date} start starting date
       * @param {number} days number of weeks
       * @returns {date}
       */

    }, {
      key: "addSeconds",
      value: function addSeconds() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        var amt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return new Date(Date.parse(start) + amt * 1000);
      }
      /**
       * gets date x weeks from start date
       * @param {date} start starting date
       * @param {number} weeks number of weeks
       * @returns {date}
       */

    }, {
      key: "addWeeks",
      value: function addWeeks() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        var amt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return new Date(Date.parse(start) + amt * 604800000);
      }
      /**
       * gets date x years from start date
       * @param {date} start starting date
       * @param {number} years number of years
       * @returns {date}
       */

    }, {
      key: "addYears",
      value: function addYears() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
        var amt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return new Date(Date.parse(start) + amt * 31536000000);
      }
      /**
       * gets formatted date
       * @param {object} date
       * @param {format} long (Weekday, Month, Day, Year), short (Month, Day), or default (Month, Day, Year)
       * @returns {string} date as string
       */

    }, {
      key: "dateFormat",
      value: function dateFormat(d, format) {
        if (typeof d === "string") d = new Date(d);
        return !d ? "" : format === "long" ? d.toLocaleDateString(undefined, {
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "numeric"
        }) : format === "short" ? d.toLocaleDateString(undefined, {
          month: "long",
          day: "numeric"
        }) : d.toLocaleDateString(undefined, {
          year: "numeric",
          month: "long",
          day: "numeric"
        });
      }
      /**
       * draws x-y items from shuffled array
       * @param {array} arr array
       * @param {number} min minimum number of items
       * @param {number} max max number of items
       * @returns {array} shuffled array of x items
       */

    }, {
      key: "draw",
      value: function draw() {
        var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min;
        var range = max - min,
            rand = Math.random() * range,
            offset = Math.floor(rand),
            len = min + offset,
            slice = Math.max(0, len);
        return this.shuffle(arr).slice(0, slice);
      }
      /**
       * generates an array based on a schema and nim/max number of items
       *
       * @param {object} [children={}] schema each generated array item should follow
       * @param {number} [min=1] minimum number of array items
       * @param {number} [max=4] maximum number of array items
       * @returns {array}
       * @memberof LoremData
       */

    }, {
      key: "randomArray",
      value: function randomArray() {
        var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
        var arr = [];

        for (var i = this.randomNumber(min, max, 1); i > 0; i--) {
          arr.push(this.randomType(children));
        }

        return arr;
      }
      /**
       * generates a string representing a random aspect ratio
       *
       * @param {number} [minwidth=200] minimum aspect height
       * @param {number} [maxwidth=1000] minimum aspect width
       * @param {number} [minheight=200] maximum aspect height
       * @param {number} [maxheight=1000] maximum aspect width
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomAspect",
      value: function randomAspect() {
        var minwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;
        var maxwidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
        var minheight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
        var maxheight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;
        var w = this.randomNumber(minwidth, maxwidth, 1),
            h = this.randomNumber(minheight, maxheight, 1);
        return "".concat(w, "/").concat(h);
      }
      /**
       * randomly true or false
       * @returns {boolean}
       */

    }, {
      key: "randomBool",
      value: function randomBool() {
        return Math.random() >= 0.5;
      }
      /**
       * random color from Simple Colors
       * @returns {string}
       */

    }, {
      key: "randomColor",
      value: function randomColor() {
        return this.randomOption(this.colors);
      }
      /**
       * random color from Simple Colors
       * @returns {string}
       */

    }, {
      key: "randomDate",
      value: function randomDate() {
        var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();
        var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "years";
        var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -3;
        var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3;
        var amt = units === "milliseconds" ? this.randomNumber(min, max) : units === "seconds" ? this.randomNumber(min * 1000, max * 1000) : units === "minutes" ? this.randomNumber(min * 60000, max * 60000) : units === "hours" ? this.randomNumber(min * 3600000, max * 3600000) : units === "days" ? this.randomNumber(min * 86400000, max * 86400000) : units === "weeks" ? this.randomNumber(min * 604800000, max * 604800000) : this.randomNumber(min * 31536000000, max * 31536000000);
        return start + amt;
      }
      /**
       * random color as hex code
       * @returns {string}
       */

    }, {
      key: "randomHex",
      value: function randomHex() {
        var _this4 = this;

        return "#".concat([0, 0, 0].map(function (i) {
          return _this4.randomNumber(i, 255).toString(16);
        }).map(function (i) {
          return i.length < 2 ? "0".concat(i) : "".concat(i);
        }).join(""));
      }
      /**
       * gets a random icon for an iconpicker
       *
       * @param {boolean} [includeNull=false] include a 50/50 change of no icon?
       * @returns string
       */

    }, {
      key: "randomIcon",
      value: function randomIcon() {
        var includeNull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var random = this.randomOption(this.icons);
        return includeNull ? this.randomOption([].concat(babelHelpers.toConsumableArray(random), [""])) : random;
      }
      /**
       * generates URL for random image from placeimg.com
       *
       * @param {string} aspect aspect ration as w/h
       * @param {string} filter optional 'greyscale' or 'sepia' filter
       * @param {string} [topic="any"] optional topic image, as in 'places'
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomPlaceImg",
      value: function randomPlaceImg(aspect, filter) {
        var topic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "any";
        filter = filter || this.randomWeightedOption([{
          value: "",
          weight: 12
        }, {
          value: "greyscale",
          weight: 4
        }, {
          value: "sepia",
          weight: 1
        }]);
        aspect = aspect || this.randomAspect();
        return "//placeimg.com/".concat(aspect, "/").concat(topic).concat(filter === "greyscale" ? "/greyscale" : filter === "sepia" ? "/sepia" : "");
      }
      /**
       * generates URL for random image from picsum.photos
       *
       * @param {string} aspect aspect ration as w/h
       * @param {boolean} greyscale whether image should be greyscale
       * @param {number} [blur=0] level of blurring filter to apply
       * @param {string} id specific image identifier
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomPicsum",
      value: function randomPicsum(aspect, greyscale) {
        var blur = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var id = arguments.length > 3 ? arguments[3] : undefined;
        var params = greyscale || this.randomWeightedOption([{
          value: false,
          weight: 3
        }, {
          value: true,
          weight: 1
        }]) ? ["greyscale"] : [];
        if (blur > 0) params.push("blur=".concat(blur));
        aspect = aspect || this.randomAspect();
        return "https://picsum.photos/".concat(id > -1 ? "id/".concat(id) : "", "/").concat(aspect, "/").concat(params.length == 0 ? "" : "?".concat(params.join("&")));
      }
      /**
       * generates URL for random image from placekitten.com
       *
       * @param {string} aspect aspect ration as w/h
       * @param {boolean} greyscale whether image should be greyscale
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomKitten",
      value: function randomKitten(aspect, greyscale) {
        if (babelHelpers.typeof(greyscale) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) greyscale = this.randomWeightedOption([{
          value: false,
          weight: 3
        }, {
          value: true,
          weight: 1
        }]);
        aspect = aspect || this.randomAspect();
        return "//placekitten.com".concat(greyscale ? "/g" : "", "/").concat(aspect);
      }
      /**
       *
       * generates URL for random image from loremflickr.com
       * @param {string} aspect aspect ration as w/h
       * @param {*} [searchTerms=[]] array of search terms for finding image
       * @param {boolean} [searchAll=false] whether results must meet all search terms
       * @param {*} [multiple=-1] gives image a unique URL so that image isn't cached everywhere
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomFlickr",
      value: function randomFlickr(aspect) {
        var searchTerms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var searchAll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var multiple = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
        aspect = aspect || this.randomAspect();
        return "https://loremflickr.com/".concat(aspect).concat(searchTerms.length === 0 ? "" : "/".concat(searchTerms.join(",")).concat(searchAll ? "/all" : "")).concat(multiple > -1 ? "?random=".concat(multiple) : "");
      }
      /**
       * selects a url from an image generator based on params and the generator APIs
       *
       * @param {string} aspect aspect ration as w/h
       * @param {boolean} greyscale whether image should be greyscale
       * @param {string} [topic="any"] optional topic image, as in 'places'
       * @param {*} [multiple=-1] gives image a unique URL so that image isn't cached everywhere
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomImage",
      value: function randomImage(aspect, greyscale, topic, multiple) {
        return topic && ["man", "woman", "person"].includes(topic) ? this.randomProfileImage(aspect, topic) : babelHelpers.typeof(multiple) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) ? this.randomPlaceImg(aspect, greyscale, topic) : topic === "any" ? this.randomPicsum(aspect, greyscale, undefined, multiple) : this.randomFlickr(aspect, [topic], false, multiple);
      }
      /**
       * generates object with randome image src, alt, and longdesc
       *
       * @param {string} aspect aspect ration as w/h
       * @param {boolean} greyscale whether image should be greyscale
       * @param {string} [topic="any"] optional topic image, as in 'places'
       * @param {*} [multiple=-1] gives image a unique URL so that image isn't cached everywhere
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomImageData",
      value: function randomImageData(aspect, greyscale, topic, multiple) {
        return {
          src: this.randomImage(aspect, greyscale, topic, multiple),
          alt: "Random ".concat(topic ? "".concat(topic, " ") : "", "image").concat(!multiple ? "" : " #".concat(multiple)),
          longdesc: "This is a long description for image".concat(!multiple ? "" : " #".concat(multiple), ". ").concat(this.randomParagraph(1, 5))
        };
      }
      /**
       * generates a random profile image
       *
       * @param {string} aspect aspect ration as w/h
       * @param {string} topic "man", "woman", etc
       * @param {*} [multiple=-1] gives image a unique URL so that image isn't cached everywhere
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomProfileImage",
      value: function randomProfileImage(aspect, topic, multiple) {
        var aspects = aspect.split("/"),
            area = parseInt(aspects[0]) * parseInt(aspects[1]),
            size = area < 250 ? "thumb/" : area < 640 ? "med/" : "",
            random = Math.random() < 0.5 ? "men" : "women",
            person = topic === "man" ? "men" : topic === "woman" ? "women" : random;
        return "https://randomuser.me/api/portraits/".concat(size).concat(person, "/").concat(multiple || this.randomNumber(1, 90), ".jpg");
      }
      /**
       * generates random link data
       * @returns {object} link as { url, text, type }
       * */

    }, {
      key: "randomLink",
      value: function randomLink(type) {
        var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
        var w = this.draw(this.words, min, max),
            file = type || this.randomOption(["url", "pdf"]),
            base = this.randomOption(this.words),
            extension = file !== "url" ? ".".concat(file) : "",
            url = "http://".concat(base, ".com/").concat(w.join("/")).concat(extension),
            text = w.length > 0 ? w.join(" ") : base;
        return {
          url: url,
          text: text,
          type: file
        };
      }
      /**
       * random number within a range
       * @param {number} min lowest value
       * @param {number} max highest value
       * @param {number} step
       * @returns {number}
       */

    }, {
      key: "randomNumber",
      value: function randomNumber() {
        var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100 + min;
        var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        return min + Math.floor(Math.random() * Math.floor((max - min) / step)) * step;
      }
      /**
       * generates a random data object based oin a schema for that object
       *
       * @param {object} [schema={}] schema for object data
       * @returns {object}
       * @memberof LoremData
       */

    }, {
      key: "randomObject",
      value: function randomObject() {
        var _this5 = this;

        var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var obj = {};
        Object.keys(schema).forEach(function (key) {
          return obj[key] = _this5.randomType(schema[key]);
        });
        return obj;
      }
      /**
       * random option from and array of options
       * @param {array} options
       * @returns {*}
       */

    }, {
      key: "randomOption",
      value: function randomOption() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return options.length > 0 ? options[Math.floor(Math.random() * Math.floor(options.length))] : undefined;
      }
      /**
       * generates a random paragraph
       *
       * @param {number} [min=3] minimum number of sentences
       * @param {number} [max=7] maximum number of sentences
       * @param {number} wordMinPerSent minimum number of words per sentence
       * @param {number} wordMaxPerSent maximum number of words per sentence
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomParagraph",
      value: function randomParagraph() {
        var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
        var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;
        var wordMinPerSent = arguments.length > 2 ? arguments[2] : undefined;
        var wordMaxPerSent = arguments.length > 3 ? arguments[3] : undefined;
        var paragraph = [];

        for (var i = this.randomNumber(min, max); i > 0; i--) {
          paragraph.push(this.randomSentence(wordMinPerSent, wordMaxPerSent));
        }

        return "".concat(paragraph.join(" "));
      }
      /**
       * generates a random paragraph
       *
       * @param {number} [min=3] minimum number of words
       * @param {number} [max=15] maximum number of words
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "randomSentence",
      value: function randomSentence() {
        var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
        var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 15;
        var sentence = [],
            punctuation = this.randomWeightedOption([{
          value: ".",
          weight: 10
        }, {
          value: "?",
          weight: 3
        }, {
          value: "!",
          weight: 1
        }]);

        for (var i = this.randomNumber(min, max); i > 0; i--) {
          sentence.push(this.randomWord());
        }

        if (sentence[0]) sentence[0] = this.titleCase(sentence[0]);
        return "".concat(sentence.join(" ")).concat(punctuation);
      }
      /**
       * generates random data based on schema
       *
       * @param {object} schema
       * @returns
       * @memberof LoremData
       */

    }, {
      key: "randomType",
      value: function randomType(schema) {
        var val;
        if (schema.type) switch (schema.type) {
          case "array":
            val = this.randomArray(schema.children, schema.min, schema.max);
            break;

          case "boolean":
            val = this.randomBool();
            break;

          case "color":
            val = this.randomColor();
            break;

          case "data":
            return schema.data;
            break;

          case "date":
            val = this.randomDate(schema.start, schema.units, schema.min, schema.max);
            break;

          case "hex":
            val = this.randomHex();
            break;

          case "icon":
            val = this.randomIcon(schema.includeNull);
            break;

          case "image":
            val = this.randomImage(schema.aspect || this.randomAspect(), schema.greyscale, schema.topic, schema.multiple);
            break;

          case "imageData":
            val = this.randomImageData(schema.aspect, schema.greyscale, schema.topic, schema.multiple);
            break;

          case "letter":
            val = this.randomOption("abcdefghijklmnopqrstuvwxyz");
            break;

          case "link":
            val = this.randomLink(schema.filetype, schema.minPath, schema.maxPath);
            break;

          case "number":
            val = this.randomNumber(schema.min, schema.max, schema.step);
            break;

          case "object":
            val = this.randomObject(schema.schema);
            break;

          case "option":
            return schema.weightedOptions ? this.randomWeightedOption(schema.weightedOptions) : this.randomOption(schema.options);
            break;

          case "paragraph":
            val = this.randomParagraph(schema.min, schema.max, schema.wordMinPerSent, schema.wordMaxPerSent);
            break;

          case "sentence":
            val = this.randomSentence(schema.min, schema.max);
            break;

          case "word":
            val = this.randomWord();
            break;

          default:
            val = this.randomWord();
            break;
        }
        return val;
      }
      /**
       * given array of objects with weight and value, selects random value based on its weight
       *
       * @param {array} [arr=[]] array of objects with weight and value, eg. [{value: true, weight: 80%},{value: false, weight: 20%}]
       * @returns
       * @memberof LoremData
       */

    }, {
      key: "randomWeightedOption",
      value: function randomWeightedOption() {
        var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return this.randomOption(arr.map(function (item) {
          var arr2 = [];

          for (var i = 0; i < item.weight; i++) {
            arr2.push(item.value);
          }

          return arr2;
        }).flat());
      }
      /**
       * returns a random word
       *
       * @returns
       * @memberof LoremData
       */

    }, {
      key: "randomWord",
      value: function randomWord() {
        return this.randomOption(this.words);
      }
      /**
       * gets shuffled array
       * @param {array} arr array
       * @returns {arr} shuffled array
       */

    }, {
      key: "shuffle",
      value: function shuffle() {
        var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return arr.sort(function (a, b) {
          return Math.random() - Math.random();
        });
      }
      /**
       * sorts array by most recent (or by oldest)
       * @param {array} arr array
       * @param {boolean} sort by most recent? (default is true)
       * @returns {arr} sorted array
       */

    }, {
      key: "sortDates",
      value: function sortDates(arr) {
        var oldest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return arr.sort(function (a, b) {
          var aa = typeof a.date === "string" ? Date.parse(a.date) : a.date,
              bb = typeof b.date === "string" ? Date.parse(b.date) : b.date;
          return !oldest ? bb - aa : aa - bb;
        });
      }
      /**
       * converts text to title case
       *
       * @param {string} str
       * @returns {string}
       * @memberof LoremData
       */

    }, {
      key: "titleCase",
      value: function titleCase(str) {
        return str.toLowerCase().split(" ").map(function (word) {
          return word.replace(word[0], word[0].toUpperCase());
        }).join(" ");
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(LoremData.prototype), "updated", this)) babelHelpers.get(babelHelpers.getPrototypeOf(LoremData.prototype), "updated", this).call(this, changedProperties);
        changedProperties.forEach(function (oldValue, propName) {});
      }
    }], [{
      key: "styles",
      get: function get() {
        return [(0, _index.css)(_templateObject3_a6b7c9008e0011ed99ce491205e67b1d || (_templateObject3_a6b7c9008e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n        label {\n          font-size: 80%;\n          font-family: sans-serif;\n        }\n        textarea {\n          width: 100%;\n          height: 200px;\n        }\n      "])))];
      }
    }, {
      key: "tag",
      get: function get() {
        return "lorem-data";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          schemas: {
            type: Object
          }
        };
      }
    }]);
    return LoremData;
  }((0, _loremDataBehaviors.LoremDataBehaviors)(_index.LitElement));

  _exports.LoremData = LoremData;
  customElements.define(LoremData.tag, LoremData);
});