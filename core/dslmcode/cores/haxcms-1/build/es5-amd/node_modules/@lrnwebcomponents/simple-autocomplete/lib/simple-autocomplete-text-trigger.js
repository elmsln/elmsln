define(["exports", "../../../lit/index.js", "../../utils/utils.js", "../simple-autocomplete.js"], function (_exports, _index, _utils, _simpleAutocomplete) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SimpleAutocompleteTextTrigger = void 0;

  var _templateObject_6bce7d20942811ecb1937969798b231a;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var SimpleAutocompleteTextTrigger = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(SimpleAutocompleteTextTrigger, _LitElement);

    var _super = _createSuper(SimpleAutocompleteTextTrigger);

    /**
     * HTMLElement life cycle
     */
    function SimpleAutocompleteTextTrigger() {
      var _this;

      babelHelpers.classCallCheck(this, SimpleAutocompleteTextTrigger);
      _this = _super.call(this);
      _this.haxUIElement = true;
      _this.target = null;
      _this.triggers = {};
      _this.value = "";
      return _this;
    }
    /**
     * LitElement life cycle
     */


    babelHelpers.createClass(SimpleAutocompleteTextTrigger, [{
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_6bce7d20942811ecb1937969798b231a || (_templateObject_6bce7d20942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["<simple-autocomplete\n        @item-selected=\"", "\"\n        selection-position\n        hide-input\n      ></simple-autocomplete\n      ><slot></slot>"])), this.valueChanged);
      }
      /**
       * Convention we use
       */

    }, {
      key: "valueChanged",
      value: // link value below w/ this so we can bubble our own event from here
      function valueChanged(e) {
        this.value = e.detail.value;
      }
      /**
       * LitElement life cycle - property changed
       */

    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        changedProperties.forEach(function (oldValue, propName) {
          // if our value changes then mirror that into the target elsewhere
          if (propName == "value" && _this2.value != "" && _this2.target) {
            // clear what's there and insert matching value
            var old = _this2.getTargetValue();

            _this2.setTargetValue(old.substring(0, _this2._triggerStart - 1) + _this2.value + old.substring(_this2._triggerEnd)); // set cursor for better UX


            if (["TEXTAREA", "INPUT"].includes(_this2.target.tagName)) {
              _this2.target.setSelectionRange(_this2._triggerStart - 1 + _this2.value.length, _this2._triggerStart - 1 + _this2.value.length);
            } else if (_this2.target.getAttribute("contenteditable") != null) {
              // set range appropriately for cursor placement
              var range = document.createRange();

              var sel = _this2.getSelection();

              range.setStart(_this2.target.childNodes[0], _this2._triggerStart - 1 + _this2.value.length);
              range.collapse(true);
              sel.removeAllRanges();
              sel.addRange(range);
            }

            _this2.target.focus();

            _this2._triggerStart = null;
            _this2._triggerEnd = null;
          }
        });
      }
      /**
       * Manage events on the target which is external to this element
       */

    }, {
      key: "connectTargetEvents",
      value: function connectTargetEvents() {
        var enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (enable) {
          window.addEventListener("keydown", this.targetKeyDownMonitor.bind(this));
          window.addEventListener("keyup", this.targetKeyMonitor.bind(this));
        } else {
          window.removeEventListener("keydown", this.targetKeyDownMonitor.bind(this));
          window.removeEventListener("keyup", this.targetKeyMonitor.bind(this));
        }
      }
      /**
       * Selection normalizer
       */

    }, {
      key: "getSelection",
      value: function getSelection() {
        // try and obtain the selection from the nearest shadow
        // which would give us the selection object when running native ShadowDOM
        // with fallback support for the entire window which would imply Shady
        if (this.target) {
          // native API
          if (this.target.getSelection) {
            return this.target.getSelection();
          } // ponyfill from google
          else if ((0, _utils.getRange)(this.target)) {
              return (0, _utils.getRange)(this.target);
            }
        } // missed on both, hope the normal one will work


        return window.getSelection();
      }
      /**
       * Get a normalized range based on current selection
       */

    }, {
      key: "getRange",
      value: function getRange() {
        var sel = this.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          return sel.getRangeAt(0);
        } else if (sel) {
          return sel;
        } else false;
      }
      /**
       * process in the autocompletes handling of this
       */

    }, {
      key: "targetKeyDownMonitor",
      value: function targetKeyDownMonitor(e) {
        // run through the autocomplete key handlers as well for consistency
        this.$autocomplete.a11yInputKeys(e);
      }
      /**
       * Monitor keys in the target to look for a tigger key so we can start paying attention
       */

    }, {
      key: "targetKeyMonitor",
      value: function targetKeyMonitor(e) {
        var _this3 = this;

        // you monster you...
        if (Object.keys(this.triggers).includes(e.key)) {
          var items = []; // resolve difference between psuedo elements w/o real positioning from contenteditable

          if (["TEXTAREA", "INPUT"].includes(this.target.tagName)) {
            this._triggerStart = this.target.selectionStart;
          } else if (this.target.getAttribute("contenteditable") != null) {
            this._triggerStart = this.getRange().startOffset;
          } // crazy... see if we have a function or an array response


          if (typeof this.triggers[e.key] === "function") {
            items = this.triggers[e.key](this);
          } else {
            items = this.triggers[e.key];
          }

          this.$autocomplete.items = babelHelpers.toConsumableArray(items);
        } // should ensure that each new character does this


        if (this._triggerStart) {
          // resolve difference between psuedo elements w/o real positioning from contenteditable
          if (["TEXTAREA", "INPUT"].includes(this.target.tagName)) {
            this._triggerEnd = this.target.selectionEnd;
          } else if (this.target.getAttribute("contenteditable") != null) {
            // @todo need to get the cursor position in a contenteditable area
            this._triggerEnd = this.getRange().endOffset;
          }
        } // update value in the autocomplete to match our target value the +1 ensures we don't pick up the trigger


        if (this._triggerStart != this._triggerEnd) {
          this.$autocomplete.opened = true; // delay so the range can be set

          setTimeout(function () {
            _this3.$autocomplete.setValue(_this3.getTargetValue().substring(_this3._triggerStart, _this3._triggerEnd));
          }, 1);
        } // if we just got a space, it's time to cut the value


        if (e.code === "Space") {
          this._triggerStart = null;
          this._triggerEnd = null;
          this.$autocomplete.opened = false;
        }
      }
      /**
       * Set target correctly between inputs and contenteditable
       */

    }, {
      key: "setTargetValue",
      value: function setTargetValue(value) {
        if (this.target) {
          if (["TEXTAREA", "INPUT"].includes(this.target.tagName)) {
            this.target.value = value;
          } else if (this.target.getAttribute("contenteditable") != null) {
            this.target.innerText = value;
          }
        }
      }
      /**
       * Resolve target value between contenteditable and native inputs
       */

    }, {
      key: "getTargetValue",
      value: function getTargetValue() {
        if (this.target) {
          if (["TEXTAREA", "INPUT"].includes(this.target.tagName)) {
            return this.target.value;
          } else if (this.target.getAttribute("contenteditable") != null) {
            return this.target.innerText;
          }
        }

        return false;
      }
      /**
       * LitElement life cycle for shadowRoot being available
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(SimpleAutocompleteTextTrigger.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(SimpleAutocompleteTextTrigger.prototype), "firstUpdated", this).call(this, changedProperties);
        }

        this.$autocomplete = this.shadowRoot.querySelector("simple-autocomplete"); // progressive enhancement by wrapping field, test again if not already set

        if (!this.target && this.children && this.children.length === 1) {
          this.target = this.children[0];
        }
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(SimpleAutocompleteTextTrigger.prototype), "connectedCallback", this).call(this);
        this.connectTargetEvents();
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.connectTargetEvents(false);
        babelHelpers.get(babelHelpers.getPrototypeOf(SimpleAutocompleteTextTrigger.prototype), "disconnectedCallback", this).call(this);
      }
    }], [{
      key: "tag",
      get: function get() {
        return "simple-autocomplete-text-trigger";
      }
      /**
       * LitElement convention
       */

    }, {
      key: "properties",
      get: function get() {
        return {
          target: {
            type: Object
          },
          triggers: {
            type: Object
          },
          value: {
            type: String
          }
        };
      }
    }]);
    return SimpleAutocompleteTextTrigger;
  }(_index.LitElement);

  _exports.SimpleAutocompleteTextTrigger = SimpleAutocompleteTextTrigger;
  customElements.define(SimpleAutocompleteTextTrigger.tag, SimpleAutocompleteTextTrigger);
});