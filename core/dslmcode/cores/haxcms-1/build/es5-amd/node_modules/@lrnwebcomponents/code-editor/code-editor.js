define(["exports", "meta", "require", "../../lit/index.js", "../schema-behaviors/schema-behaviors.js", "./lib/monaco-element/monaco-element.js", "../utils/utils.js"], function (_exports, meta, _require, _index, _schemaBehaviors, _monacoElement, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.CodeEditor = void 0;
  meta = _interopRequireWildcard(meta);
  _require = _interopRequireWildcard(_require);

  var _templateObject_a00faf008e0011ed99ce491205e67b1d, _templateObject2_a00faf008e0011ed99ce491205e67b1d, _templateObject3_a00faf008e0011ed99ce491205e67b1d;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  if (!Element.prototype.replaceWith) {
    Element.prototype.replaceWith = _utils.ReplaceWithPolyfill;
  }

  if (!CharacterData.prototype.replaceWith) {
    CharacterData.prototype.replaceWith = _utils.ReplaceWithPolyfill;
  }

  if (!DocumentType.prototype.replaceWith) {
    DocumentType.prototype.replaceWith = _utils.ReplaceWithPolyfill;
  }
  /**
   * `code-editor`
   * `Wrapper on top of a code editor`
   *
   * @demo demo/index.html
   * @demo demo/updating.html Update contents
   * @microcopy - the mental model for this element
   * - monaco is the VS code editor
   * @element code-editor
   */


  var CodeEditor = /*#__PURE__*/function (_SchemaBehaviors) {
    babelHelpers.inherits(CodeEditor, _SchemaBehaviors);

    var _super = _createSuper(CodeEditor);

    /**
     * HTMLElement
     */
    function CodeEditor() {
      var _this;

      babelHelpers.classCallCheck(this, CodeEditor);
      _this = _super.call(this);
      _this.haxUIElement = true;
      _this.showCodePen = false;
      _this.readOnly = false;
      _this.theme = "vs-dark";
      _this.language = "javascript";
      _this.fontSize = 16;
      _this.wordWrap = false;
      _this.tabSize = 2;
      _this.autofocus = false;
      _this.hideLineNumbers = false;
      _this.focused = false; // helps in local testing and some edge cases of CDNs

      if (window.WCGlobalBasePath) {
        _this.libPath = window.WCGlobalBasePath;
      } else {
        _this.libPath = new URL("./../../", meta.url).href;
      }

      _this.libPath += "monaco-editor/min/vs";
      setTimeout(function () {
        _this.addEventListener("monaco-element-ready", _this.editorReady.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      return _this;
    }
    /**
     * LitElement render
     */


    babelHelpers.createClass(CodeEditor, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        return (0, _index.html)(_templateObject_a00faf008e0011ed99ce491205e67b1d || (_templateObject_a00faf008e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <label for=\"codeeditor\" ?hidden=\"", "\" part=\"label\"\n        >", "</label\n      >\n      <monaco-element\n        id=\"codeeditor\"\n        ?data-hidden=\"", "\"\n        ?autofocus=\"", "\"\n        ?hide-line-numbers=\"", "\"\n        lib-path=\"", "\"\n        language=\"", "\"\n        tab-size=\"", "\"\n        theme=\"", "\"\n        @value-changed=\"", "\"\n        font-size=\"", "\"\n        ?word-wrap=\"", "\"\n        ?read-only=\"", "\"\n        @code-editor-focus=\"", "\"\n        @code-editor-blur=\"", "\"\n        @monaco-element-ready=\"", "\"\n        part=\"code\"\n      >\n      </monaco-element>\n      <pre\n        id=\"loading\"\n        ?hidden=\"", "\"\n        style=\"font-size:", "px\"\n        part=\"preview\"\n      ><code>\n  ", "</code></pre>\n      <slot hidden></slot>\n      ", "\n    "])), !this.title, this.title, !this.ready, this.autofocus, this.hideLineNumbers, this.libPath, this.language, this.tabSize, this.getTheme(this.theme), this._editorDataChanged, this.fontSize, this.wordWrap, this.readOnly, this._handleFocus, this._handleBlur, function (e) {
          return _this2.ready = true;
        }, this.ready, this.fontSize, this.placeholder, this.showCodePen ? (0, _index.html)(_templateObject2_a00faf008e0011ed99ce491205e67b1d || (_templateObject2_a00faf008e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["<div class=\"code-pen-container\" part=\"code-pen\">\n            <span>Check it out on code pen: </span\n            ><code-pen-button .data=\"", "\"></code-pen-button>\n          </div>"])), this.codePenData) : "");
      }
    }, {
      key: "getTheme",
      value: function getTheme(theme) {
        var watch = window.matchMedia && theme == "auto",
            dark = watch && window.matchMedia("(prefers-color-scheme: dark)").matches,
            light = watch && window.matchMedia("(prefers-color-scheme: light)").matches,
            other = !theme || theme == "auto" ? "vs-dark" : theme,
            color = dark ? "vs-dark" : light ? "vs" : other;
        this.setAttribute("theme-colors", color);
        return color;
      }
    }, {
      key: "placeholder",
      get: function get() {
        var content = "".concat(this.editorValue || this.innerHTML);
        return content.replace(/\s*<\/?template.*>\s*/gm, "");
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this3 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(CodeEditor.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(CodeEditor.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "editorValue") {
            _this3._editorValueChanged(_this3[propName]);
          }

          if (propName == "mode") {
            _this3._modeChanged(_this3[propName], oldValue);
          }

          if (propName === "showCodePen") {
            // notify
            _this3.dispatchEvent(new CustomEvent("show-code-pen-changed", {
              detail: {
                value: _this3[propName]
              }
            }));

            if (_this3[propName] && !window.customElements.get("code-pen-button")) {
              new Promise(function (res, rej) {
                return _require.default(["./lib/code-pen-button.js"], res, rej);
              });
            }
          }

          if (propName === "value") {
            // notify
            _this3.dispatchEvent(new CustomEvent("value-changed", {
              detail: {
                value: _this3[propName]
              }
            }));
          }

          if (propName === "focused") {
            // notify
            _this3.dispatchEvent(new CustomEvent("focused-changed", {
              detail: {
                focused: _this3[propName]
              }
            }));
          }

          if (["title", "value"].includes(propName)) {
            _this3.codePenData = _this3._computeCodePenData(_this3.title, _this3.value);
          }
        });
      }
      /**
       * Update the post data whenever the editor has been updated
       */

    }, {
      key: "_computeCodePenData",
      value: function _computeCodePenData(title, editorValue) {
        return {
          title: title,
          html: editorValue,
          head: "<script>window.WCGlobalCDNPath=\"https://cdn.webcomponents.psu.edu/cdn/\";</script><script src=\"https://cdn.webcomponents.psu.edu/cdn/build.js\"></script>"
        };
      }
      /**
       * sets focused attribute when monaco-elements's focus event fires
       * @param {event} e the monaco-elements's focus event
       */

    }, {
      key: "_handleFocus",
      value: function _handleFocus(e) {
        this.focused = true;
      }
      /**
       * unsets focused attribute when monaco-elements's blur event fires
       * @param {event} e the monaco-elements's blur event
       */

    }, {
      key: "_handleBlur",
      value: function _handleBlur(e) {
        this.focused = false;
      }
      /**
       * LEGACY: pass down mode to language if that api is used
       */

    }, {
      key: "_modeChanged",
      value: function _modeChanged(newValue) {
        this.language = this.mode;
      }
      /**
       * Notice code editor changes and reflect them into this element
       */

    }, {
      key: "_editorDataChanged",
      value: function _editorDataChanged(e) {
        // value coming up off of thiss
        this.value = e.detail;
      }
      /**
       * Calculate what's in slot currently and then inject it into the editor.
       */

    }, {
      key: "updateEditorValue",
      value: function updateEditorValue() {
        var content = "";
        var children = this.children;

        if (this.childNodes[0] && this.childNodes[0].tagName !== "TEMPLATE") {
          children = this.childNodes;

          if (children.length > 0) {
            // loop through everything found in the slotted area and put it back in
            for (var j = 0, len2 = children.length; j < len2; j++) {
              if (children[j].tagName) {
                content += children[j].outerHTML;
              } else {
                content += children[j].textContent;
              }
            }
          }
        } else if (children[0]) {
          content = children[0].innerHTML;
        }

        if (content) {
          if (this.language === "html") {
            content = (0, _utils.formatHTML)(content);
          }

          this.shadowRoot.querySelector("#codeeditor").value = content.trim();
        }
      }
    }, {
      key: "_editorValueChanged",
      value: function _editorValueChanged(newValue) {
        if (newValue) {
          this.innerHTML = "";
          this.innerHTML = "<template>".concat(newValue, "</template>");
          this.updateEditorValue();
        }
      }
      /**
       * Implements haxHooks to tie into life-cycle if hax exists.
       */

    }, {
      key: "haxHooks",
      value: function haxHooks() {
        return {
          preProcessNodeToContent: "haxpreProcessNodeToContent",
          activeElementChanged: "haxactiveElementChanged"
        };
      }
      /**
       * allow HAX to toggle edit state when activated
       */

    }, {
      key: "haxactiveElementChanged",
      value: function haxactiveElementChanged(el, val) {
        // overwrite the HAX dom w/ what our editor is supplying
        if (!val) {
          var replacement = this.getValueAsNode(el);

          if (el) {
            el.replaceWith(replacement);
          }

          el = replacement;
        }

        return el;
      }
      /**
       * Ensure fields don't pass through to HAX if in that context
       */

    }, {
      key: "haxpreProcessNodeToContent",
      value: function haxpreProcessNodeToContent(node) {
        node.editorValue = null;
        node.codePenData = null;
        node.value = null;
        node.removeAttribute("value");
        node.removeAttribute("code-pen-data");
        return node;
      }
      /**
       * return HTML object of table data
       * @returns {object} HTML object for managed table
       */

    }, {
      key: "getValueAsNode",
      value: function getValueAsNode() {
        var wrap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (wrap == null) {
          wrap = document.createElement("p");
        }

        if (this.value) {
          wrap.innerHTML = (0, _utils.formatHTML)(this.value);
        } // implies we were actually modifying the thing in question
        // which we wanted to leverage. Example, code-sample won't have code-sample as
        // an immediate child. This implies the wrap is there for editing the ENTIRE item
        // where as if the wrapper was code-sample and the tagName of the 1st child
        // was template, then we'd know this should be the inner material


        if (wrap.firstElementChild && wrap.children.length === 1 && wrap.firstElementChild.tagName === wrap.tagName) {
          return wrap.firstElementChild;
        }

        return wrap;
      }
      /**
       * attached life cycle
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this4 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(CodeEditor.prototype), "connectedCallback", this).call(this); // mutation observer that ensures state of hax applied correctly

        this._observer = new MutationObserver(function (mutations) {
          _this4.updateEditorValue();
        });
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        if (this._observer) {
          this._observer.disconnect();

          this._observer = null;
        }

        babelHelpers.get(babelHelpers.getPrototypeOf(CodeEditor.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "editorReady",
      value: function editorReady(e) {
        if (this.editorValue) {
          this.shadowRoot.querySelector("#codeeditor").value = this.editorValue;
        } else {
          this.updateEditorValue();
        }

        if (this._observer) {
          this._observer.observe(this, {
            childList: true,
            subtree: true,
            characterData: true,
            attributes: true
          });
        }
      }
    }], [{
      key: "styles",
      get:
      /**
       * LitElement constructable styles enhancement
       */
      function get() {
        return [(0, _index.css)(_templateObject3_a00faf008e0011ed99ce491205e67b1d || (_templateObject3_a00faf008e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: flex;\n          flex-direction: column;\n          font-family: unset;\n          align-items: stretch;\n          margin: var(--code-pen-margin, 16px 0);\n          width: calc(100% - 2px);\n          background-color: #1e1e1e;\n          color: #c6c6c6;\n          border: var(--code-editor-code-border);\n          border-radius: var(--code-editor-code-border-radius);\n          border: 1px solid var(--code-editor-label-color, #ddd);\n        }\n        :host([theme-colors=\"vs-dark\"]) {\n          background-color: #1e1e1e;\n          color: #c6c6c6;\n          border: 1px solid var(--code-editor-label-color, #000);\n        }\n        :host([theme-colors=\"vs\"]) {\n          background-color: #fffffe;\n          color: #000;\n          border: 1px solid var(--code-editor-label-color, #ddd);\n        }\n        :host([hidden]) {\n          display: none !important;\n        }\n        .code-pen-container:not([hidden]) {\n          width: calc(100% - 2 * var(--code-editor-margin, 12px));\n          display: flex;\n          height: 40px;\n          justify-content: flex-end;\n          align-items: center;\n          margin: var(--code-editor-margin, 12px);\n        }\n        .code-pen-container span {\n          display: inline-flex;\n          line-height: 16px;\n          font-size: 16px;\n          padding: 12px 0;\n        }\n        code-pen-button {\n          float: right;\n          height: 40px;\n          flex: 0 0 40px;\n        }\n        :host([theme-colors=\"vs\"]) code-pen-button::part(button) {\n          filter: invert(1);\n        }\n        label {\n          color: var(--code-editor-label-color, #444);\n          transition: all 0.5s;\n          flex: 0 0 auto;\n          margin: var(--code-editor-margin, 12px);\n        }\n        :host([theme-colors=\"vs\"]) label {\n          color: var(--code-editor-label-color, #444);\n        }\n        :host([theme-colors=\"vs-dark\"]) label {\n          color: var(--code-editor-label-color, #bbb);\n        }\n        :host([hidden]) {\n          display: none !important;\n        }\n\n        :host([focused]) label {\n          color: var(\n            --code-editor-float-label-active-color,\n            var(--code-editor-label-color, currentColor)\n          );\n        }\n\n        #loading {\n          padding: 0 74px;\n          flex: 1 1 auto;\n          overflow: hidden;\n          white-space: pre-wrap;\n          text-overflow: ellipsis;\n          font-family: monospace;\n        }\n        #codeeditor {\n          flex: 1 1 auto;\n          height: 100%;\n        }\n        #codeeditor[data-hidden] {\n          height: 0px;\n        }\n\n        :host([focused]) #codeeditor {\n          border: var(--code-editor-focus-code-border);\n        }\n      "])))];
      }
    }, {
      key: "tag",
      get: function get() {
        return "code-editor";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(CodeEditor), "properties", this)), {}, {
          libPath: {
            type: String
          },

          /**
           * Title
           */
          title: {
            type: String
          },

          /**
           * Show codePen button to fork it to there to run
           */
          showCodePen: {
            type: Boolean,
            reflect: true,
            attribute: "show-code-pen"
          },

          /**
           * Readonly setting for the editor
           */
          readOnly: {
            type: Boolean,
            reflect: true,
            attribute: "read-only"
          },

          /**
           * Code pen data, computed based on the HTML editor
           */
          codePenData: {
            type: Object,
            attribute: "code-pen-data"
          },

          /**
           * contents of the editor
           */
          editorValue: {
            type: String,
            attribute: "editor-value"
          },

          /**
           * value of the editor after the fact
           */
          value: {
            type: String
          },

          /**
           * Theme for the Ace editor.
           */
          theme: {
            type: String,
            reflect: true,
            attribute: "theme"
          },

          /**
           * Mode / language for editor
           */
          mode: {
            type: String
          },

          /**
           * Language to present color coding for
           */
          language: {
            type: String
          },

          /**
           * font size for the editor
           */
          fontSize: {
            type: Number,
            attribute: "font-size"
          },
          wordWrap: {
            type: Boolean,
            attribute: "word-wrap"
          },

          /**
           * automatically set focus on the editor
           */
          autofocus: {
            type: Boolean,
            reflect: true
          },

          /**
           * hide the line numbers
           */
          hideLineNumbers: {
            type: Boolean,
            attribute: "hide-line-numbers"
          },

          /**
           * does the monaco-editor have focus
           */
          focused: {
            type: Boolean,
            reflect: true
          },

          /**
           * number of characters for tabs
           */
          tabSize: {
            type: Number,
            attribute: "tab-size"
          },
          ready: {
            type: Boolean
          }
        });
      }
    }]);
    return CodeEditor;
  }((0, _schemaBehaviors.SchemaBehaviors)(_index.LitElement));

  _exports.CodeEditor = CodeEditor;
  customElements.define(CodeEditor.tag, CodeEditor);
});