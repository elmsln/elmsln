define(["exports", "require", "../../lit-element/lit-element.js", "../utils/utils.js", "../../@polymer/iron-a11y-keys/iron-a11y-keys.js", "../json-outline-schema/json-outline-schema.js"], function (_exports, _require, _litElement, _utils, _ironA11yKeys, _jsonOutlineSchema) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.EditableOutline = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject2_9835a1f07b6011eab03027de610f5ad8() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          font-family: \"Noto Serif\", serif;\n        }\n\n        :host([hidden]) {\n          display: none;\n        }\n\n        .button-wrapper {\n          line-height: 36px;\n          position: -webkit-sticky;\n          position: sticky;\n          top: 0px;\n          background-color: white;\n          display: block;\n          justify-content: space-evenly;\n        }\n        @media (max-width: 1000px) {\n          button span {\n            opacity: 0;\n            visibility: hidden;\n            position: absolute;\n            left: -9999px;\n          }\n        }\n        button {\n          height: 32px;\n          font-size: 10px;\n          margin: 0;\n          padding: 0 8px;\n        }\n\n        button span {\n          padding-left: 4px;\n          pointer-events: none;\n        }\n\n        #outline {\n          margin: 0;\n        }\n        ul {\n          font-size: 16px;\n          line-height: 32px;\n          padding-left: 32px;\n          visibility: visible;\n          opacity: 1;\n          overflow: hidden;\n          height: auto;\n          transition: 0.2s ease-in-out all;\n        }\n        li {\n          font-size: 16px;\n          line-height: 32px;\n          padding: 4px;\n          transition: 0.2s linear all;\n        }\n        ul:hover {\n          outline: 1px solid #eeeeee;\n        }\n        li.collapsed-title {\n          background-color: #dddddd;\n        }\n        li.collapsed-title:after {\n          content: \"    ( Double-click to expand )\";\n        }\n        li:after {\n          transition: 0.4s ease-in-out all;\n          opacity: 0;\n          font-size: 11px;\n          visibility: hidden;\n        }\n        li.collapsed-title:hover:after {\n          font-style: italic;\n          opacity: 1;\n          visibility: visible;\n        }\n        ul.collapsed-content {\n          visibility: hidden;\n          opacity: 0;\n          height: 0;\n        }\n        li:focus,\n        li:active,\n        li:hover {\n          background-color: #eeeeee;\n          outline: 1px solid #cccccc;\n        }\n\n        iron-icon {\n          pointer-events: none;\n        }\n      "]);

    _templateObject2_9835a1f07b6011eab03027de610f5ad8 = function _templateObject2_9835a1f07b6011eab03027de610f5ad8() {
      return data;
    };

    return data;
  }

  function _templateObject_9835a1f07b6011eab03027de610f5ad8() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <iron-a11y-keys\n        keys=\"enter\"\n        @keys-pressed=\"", "\"\n        stop-keyboard-event-propagation\n      ></iron-a11y-keys>\n      <iron-a11y-keys\n        keys=\"up\"\n        @keys-pressed=\"", "\"\n        stop-keyboard-event-propagation\n      ></iron-a11y-keys>\n      <iron-a11y-keys\n        keys=\"down\"\n        @keys-pressed=\"", "\"\n        stop-keyboard-event-propagation\n      ></iron-a11y-keys>\n      <div class=\"button-wrapper\">\n        <button @click=\"", "\" id=\"add\" title=\"Add a new node\">\n          <iron-icon icon=\"icons:add\"></iron-icon><span>Add</span>\n        </button>\n        <button\n          @click=\"", "\"\n          id=\"collapse\"\n          title=\"Toggle active node collapsed status\"\n        >\n          <iron-icon icon=\"icons:swap-vert\"></iron-icon\n          ><span>Toggle active</span>\n        </button>\n        <button\n          @click=\"", "\"\n          id=\"collapseall\"\n          title=\"Collapse all nodes\"\n        >\n          <iron-icon icon=\"icons:swap-vert\"></iron-icon\n          ><span>Collapse all</span>\n        </button>\n        <button\n          @click=\"", "\"\n          id=\"expandall\"\n          title=\"Expand all nodes\"\n        >\n          <iron-icon icon=\"icons:swap-vert\"></iron-icon><span>Expand all</span>\n        </button>\n        <button\n          @click=\"", "\"\n          id=\"down\"\n          title=\"Move active node down\"\n        >\n          <iron-icon icon=\"icons:arrow-downward\"></iron-icon\n          ><span>Move down</span>\n        </button>\n        <button\n          @click=\"", "\"\n          id=\"up\"\n          title=\"Move active node up\"\n        >\n          <iron-icon icon=\"icons:arrow-upward\"></iron-icon><span>Move up</span>\n        </button>\n        <button\n          @click=\"", "\"\n          id=\"outdent\"\n          title=\"Outdent active node\"\n        >\n          <iron-icon icon=\"editor:format-indent-decrease\"></iron-icon\n          ><span>Outdent</span>\n        </button>\n        <button\n          @click=\"", "\"\n          id=\"indent\"\n          title=\"Indent active node\"\n        >\n          <iron-icon icon=\"editor:format-indent-increase\"></iron-icon\n          ><span>Indent</span>\n        </button>\n        <button\n          @click=\"", "\"\n          id=\"duplicate\"\n          title=\"Duplicate active node tree\"\n        >\n          <iron-icon icon=\"icons:content-copy\"></iron-icon\n          ><span>Duplicate</span>\n        </button>\n      </div>\n      <ul id=\"outline\"></ul>\n    "]);

    _templateObject_9835a1f07b6011eab03027de610f5ad8 = function _templateObject_9835a1f07b6011eab03027de610f5ad8() {
      return data;
    };

    return data;
  }

  /**
   * `editable-outline`
   * `a simple outline thats contenteditable in nature`
   * @demo demo/index.html
   * @element editable-outline
   */
  var EditableOutline =
  /*#__PURE__*/
  function (_LitElement) {
    babelHelpers.inherits(EditableOutline, _LitElement);
    babelHelpers.createClass(EditableOutline, [{
      key: "render",
      // render function
      value: function render() {
        return (0, _litElement.html)(_templateObject_9835a1f07b6011eab03027de610f5ad8(), this._enterPressed, this._upPressed, this._downPressed, this.buttonEvents, this.buttonEvents, this.buttonEvents, this.buttonEvents, this.buttonEvents, this.buttonEvents, this.buttonEvents, this.buttonEvents, this.buttonEvents);
      } // properties available to the custom element for data binding

    }], [{
      key: "styles",
      //styles function
      get: function get() {
        return [(0, _litElement.css)(_templateObject2_9835a1f07b6011eab03027de610f5ad8())];
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(EditableOutline), "properties", this), {
          /**
           * A items list of JSON Outline Schema Items
           */
          items: {
            type: Array
          },

          /**
           * Edit mode
           */
          editMode: {
            type: Boolean,
            attribute: "edit-mode"
          },

          /**
           * Outline node for keyboard key binding
           */
          __outlineNode: {
            type: Object
          }
        });
      }
    }]);

    function EditableOutline() {
      var _this;

      babelHelpers.classCallCheck(this, EditableOutline);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(EditableOutline).call(this));
      _this.items = [];
      _this.editMode = false;
      _this.jos = window.JSONOutlineSchema.requestAvailability();
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icon/iron-icon.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/iron-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/editor-icons.js"], res, rej);
      });
      setTimeout(function () {
        _this.addEventListener("dblclick", _this._collapseClickHandler.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      return _this;
    }
    /**
     * Store the tag name to make it easier to obtain directly.
     * @notice function name must be here for tooling to operate correctly
     */


    babelHelpers.createClass(EditableOutline, [{
      key: "_collapse",

      /**
       * Collapse button callback
       */
      value: function _collapse(e) {
        var node = this.getSelectionNode();

        if (node && node.tagName === "LI" && node.nextElementSibling && node.nextElementSibling.tagName === "UL") {
          node.classList.toggle("collapsed-title");
          node.nextElementSibling.classList.toggle("collapsed-content");
        }
      }
      /**
       * Expand all items
       */

    }, {
      key: "_expandall",
      value: function _expandall(e) {
        this.shadowRoot.querySelectorAll("li").forEach(function (el) {
          el.classList.remove("collapsed-title");
        });
        this.shadowRoot.querySelectorAll("ul").forEach(function (el) {
          el.classList.remove("collapsed-content");
        });
      }
      /**
       * Collapse all items
       */

    }, {
      key: "_collapseall",
      value: function _collapseall(e) {
        this.shadowRoot.querySelectorAll("li").forEach(function (el) {
          if (el.nextElementSibling && el.nextElementSibling.tagName === "UL") {
            el.classList.add("collapsed-title");
            el.nextElementSibling.classList.add("collapsed-content");
          }
        });
      }
    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(e) {
        if (this.editMode) {
          switch (e.key) {
            case "Tab":
              if (e.shiftKey) {
                this._tabBackKeyPressed(e);
              } else {
                this._tabKeyPressed(e);
              }

              break;
          }
        }
      }
      /**
       * Click handler method needs to walk a little different then normal collapse
       */

    }, {
      key: "_collapseClickHandler",
      value: function _collapseClickHandler(e) {
        var el;
        var i = 0;
        var notFound = true;

        while (notFound && e.path.length > i + 1) {
          el = e.path[i];

          if (el.tagName === "LI" && el.nextElementSibling && el.nextElementSibling.tagName === "UL") {
            el.classList.toggle("collapsed-title");
            el.nextElementSibling.classList.toggle("collapsed-content");
            notFound = false;
          }

          i++;
        }
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated() {
        var _this2 = this;

        this.__outlineNode = this.shadowRoot.querySelector("#outline");
        this.shadowRoot.querySelectorAll("iron-a11y-keys").forEach(function (el) {
          el.target = _this2.__outlineNode;
        });

        this.__outlineNode.addEventListener("keydown", this._onKeyDown.bind(this));

        this._observer = new MutationObserver(this._observeRecord.bind(this));

        this._observer.observe(this.__outlineNode, {
          childList: true,
          subtree: true
        });
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this3 = this;

        changedProperties.forEach(function (oldValue, propName) {
          var notifiedProps = ["editMode", "items"];

          if (notifiedProps.includes(propName)) {
            // notify
            var eventName = "".concat(propName.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase(), "-changed");

            _this3.dispatchEvent(new CustomEvent(eventName, {
              detail: {
                value: _this3[propName]
              }
            }));
          }
        });
      }
      /**
       * Mutation observer callback
       * @todo current issue if you copy and paste into the same node
       */

    }, {
      key: "_observeRecord",
      value: function _observeRecord(record) {
        var _this4 = this;

        for (var index in record) {
          var info = record[index]; // if we've got new nodes to react to that were not imported

          if (info.addedNodes.length > 0) {
            // special rules for an outdent event
            for (var i in info.addedNodes) {
              if (info.addedNodes[i].tagName) {
                if (info.addedNodes[i].tagName === "LI") {
                  if (this.__blockScrub) {
                    info.addedNodes[i].setAttribute("contenteditable", "true");
                  } else {
                    this.jos.scrubElementJOSData(info.addedNodes[i]);
                    info.addedNodes[i].setAttribute("contenteditable", "true");
                  }
                } // we have an unknown hest of items, scrub em all if we are in scrub mode
                else if (info.addedNodes[i].tagName === "UL") {
                    if (!this.__blockScrub) {
                      this.jos.scrubElementJOSData(info.addedNodes[i]);
                    }
                  }
              }
            }
          }
        }

        setTimeout(function () {
          _this4.__blockScrub = false;
        }, 100);
      }
      /**
       * Disconnected life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.__outlineNode.removeEventListener("keydown", this._onKeyDown.bind(this));

        this._observer.disconnect();

        babelHelpers.get(babelHelpers.getPrototypeOf(EditableOutline.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * Button events internally
       */

    }, {
      key: "buttonEvents",
      value: function buttonEvents(e) {
        switch (e.target.id) {
          case "add":
            this._add(e);

            break;

          case "collapse":
            this._collapse(e);

            break;

          case "collapseall":
            this._collapseall(e);

            break;

          case "expandall":
            this._expandall(e);

            break;

          case "indent":
            this._indent();

            break;

          case "outdent":
            this._outdent();

            break;

          case "up":
            this._move("up");

            break;

          case "down":
            this._move("down");

            break;

          case "duplicate":
            this._duplicate();

            break;
        }
      }
      /**
       * Duplicate whatever has selection
       */

    }, {
      key: "_duplicate",
      value: function _duplicate() {
        // get active item from where cursor is
        try {
          this.__blockScrub = false;
          var activeItem = this.getSelectionNode();

          if (activeItem && activeItem.tagName === "LI") {
            // clone the item's hierarchy as well
            if (activeItem.nextElementSibling !== null && activeItem.nextElementSibling.tagName === "UL") {
              // copy the UL and all children and insert it after the UL it's duplicating
              var clone2 = activeItem.nextElementSibling.cloneNode(true);
              activeItem.parentNode.insertBefore(clone2, activeItem.nextElementSibling.nextElementSibling); // clone the LI, placing it before the UL we just made

              var clone = activeItem.cloneNode(true);
              activeItem.parentNode.insertBefore(clone, activeItem.nextElementSibling.nextElementSibling);
            } else {
              var _clone = activeItem.cloneNode(true); // insert the clone AFTER the current selection


              activeItem.parentNode.insertBefore(_clone, activeItem.nextElementSibling);
            }
          }
        } catch (e) {
          console.log(e);
        }
      }
      /**
       * Move whatever has selection up or down
       */

    }, {
      key: "_move",
      value: function _move(direction) {
        // get active item from where cursor is
        try {
          var activeItem = this.getSelectionNode();
          var test = activeItem;
          var valid = false;

          if (activeItem == null) {
            return false;
          } // ensure this operation is executed in scope


          while (!valid && test.parentNode) {
            if (test.id === "outline") {
              valid = true;
            }

            test = test.parentNode;
          } // ensure from all that, we have something


          if (valid && activeItem && activeItem.tagName === "LI") {
            // move the things above us, below us
            if (direction === "up") {
              // ensure there's something above us
              if (activeItem.previousElementSibling !== null) {
                // see if we are moving us, or us and the hierarchy
                if (activeItem.nextElementSibling && activeItem.nextElementSibling.tagName === "UL") {
                  // see if the thing we have to move above has it's own structure
                  if (activeItem.previousElementSibling.tagName === "UL") {
                    // ensure we don't lose our metadata
                    this.__blockScrub = true; // insert the element currently above us, just before 2 places back; so behind our UL

                    activeItem.parentNode.insertBefore(activeItem.previousElementSibling, activeItem.nextElementSibling.nextElementSibling);
                  }

                  this.__blockScrub = true; // now insert the LI above us, 2 places back so it is in front of the UL

                  activeItem.parentNode.insertBefore(activeItem.previousElementSibling, activeItem.nextElementSibling.nextElementSibling);
                  activeItem.focus();
                } else {
                  // easier use case, we are moving ourselves only but above us is a UL
                  if (activeItem.previousElementSibling.tagName === "UL") {
                    this.__blockScrub = true; // move the UL after us

                    activeItem.parentNode.insertBefore(activeItem.previousElementSibling, activeItem.nextElementSibling);
                  }

                  this.__blockScrub = true; // now move the LI after us

                  activeItem.parentNode.insertBefore(activeItem.previousElementSibling, activeItem.nextElementSibling);
                  activeItem.focus();
                }
              }
            } else if (direction === "down") {
              // if nothing after us, we can't move
              if (activeItem.nextElementSibling !== null) {
                // account for having to hop over children
                if (activeItem.nextElementSibling && activeItem.nextElementSibling.tagName === "UL" && activeItem.nextElementSibling.nextElementSibling !== null) {
                  // an outline is just below us
                  if (activeItem.nextElementSibling.nextElementSibling.tagName === "LI" && activeItem.nextElementSibling.nextElementSibling.nextElementSibling !== null && activeItem.nextElementSibling.nextElementSibling.nextElementSibling.tagName === "UL") {
                    this.__blockScrub = true; // move the thing 2 down to just before us; so the UL

                    activeItem.parentNode.insertBefore(activeItem.nextElementSibling.nextElementSibling, activeItem);
                  }

                  this.__blockScrub = true; // now move the LI that is 2 below us just above us

                  activeItem.parentNode.insertBefore(activeItem.nextElementSibling.nextElementSibling, activeItem);
                  activeItem.focus();
                } else if (activeItem.nextElementSibling.tagName === "LI") {
                  // just moving 1 tag, see if we need to move 2 things about us or 1
                  if (activeItem.nextElementSibling.nextElementSibling !== null && activeItem.nextElementSibling.nextElementSibling.tagName === "UL") {
                    this.__blockScrub = true;
                    activeItem.parentNode.insertBefore(activeItem.nextElementSibling, activeItem);
                  }

                  this.__blockScrub = true; // work on the LI

                  activeItem.parentNode.insertBefore(activeItem.nextElementSibling, activeItem);
                  activeItem.focus();
                }
              }
            }
          }
        } catch (e) {
          console.log(e);
        }
      }
      /**
       * Take the current manifest and import it into an HTML outline
       */

    }, {
      key: "importJsonOutlineSchemaItems",
      value: function importJsonOutlineSchemaItems() {
        var _this5 = this;

        this.__blockScrub = true;
        setTimeout(function () {
          // wipe out the outline
          while (_this5.__outlineNode.firstChild) {
            _this5.__outlineNode.removeChild(_this5.__outlineNode.firstChild);
          }

          if (_this5.items.length === 0) {
            // get from JOS items if we have none currently
            _this5.items = babelHelpers.toConsumableArray(_this5.jos.items);
          }

          var outline = _this5.jos.itemsToNodes(_this5.items); // rebuild the outline w/ children we just found


          while (outline.firstChild) {
            _this5.__blockScrub = true;

            _this5.__outlineNode.appendChild(outline.firstChild);
          }

          _this5.shadowRoot.querySelectorAll("li").forEach(function (el) {
            el.setAttribute("contenteditable", "true");
          });
        }, 0);
        return outline;
      }
      /**
       * Take what's currently in the area and get JSON Outline Schema; optionally save
       */

    }, {
      key: "exportJsonOutlineSchemaItems",
      value: function exportJsonOutlineSchemaItems() {
        var save = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return this.jos.nodesToItems(this.__outlineNode, save);
      }
    }, {
      key: "_upPressed",
      value: function _upPressed(e) {
        var node = this.getSelectionNode();

        if (node && node.previousSibling && node.previousSibling.tagName === "LI") {
          node.previousSibling.focus();
        } else if (node && node.previousSibling && node.previousSibling.tagName === "UL" && node.previousSibling.firstChild && node.previousSibling.firstChild.tagName === "LI") {
          node.previousSibling.firstChild.focus();
        } else if (node && node.previousSibling == null && node.parentNode.tagName === "UL" && node.parentNode.previousSibling && node.parentNode.previousSibling.tagName === "LI") {
          node.parentNode.previousSibling.focus();
        }
      }
    }, {
      key: "_downPressed",
      value: function _downPressed(e) {
        var node = this.getSelectionNode();

        if (node && node.nextSibling && node.nextSibling.tagName === "LI") {
          node.nextSibling.focus();
        } else if (node && node.nextSibling && node.nextSibling.tagName === "UL" && node.nextSibling.firstChild && node.nextSibling.firstChild.tagName === "LI") {
          node.nextSibling.firstChild.focus();
        } else if (node && node.nextSibling == null && node.parentNode.tagName === "UL" && node.parentNode.nextSibling && node.parentNode.nextSibling.tagName === "LI") {
          node.parentNode.nextSibling.focus();
        }
      }
      /**
       * Find the next thing to tab forward to.
       */

    }, {
      key: "_tabKeyPressed",
      value: function _tabKeyPressed(e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();

        if (e.detail.keyboardEvent) {
          e.detail.keyboardEvent.preventDefault();
          e.detail.keyboardEvent.stopPropagation();
          e.detail.keyboardEvent.stopImmediatePropagation();
        }

        try {
          this._indent();
        } catch (e) {}
      }
      /**
       * Move back through things when tab back pressed
       */

    }, {
      key: "_tabBackKeyPressed",
      value: function _tabBackKeyPressed(e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();

        if (e.detail.keyboardEvent) {
          e.detail.keyboardEvent.preventDefault();
          e.detail.keyboardEvent.stopPropagation();
          e.detail.keyboardEvent.stopImmediatePropagation();
        }

        try {
          this._outdent();
        } catch (e) {}
      }
    }, {
      key: "_enterPressed",
      value: function _enterPressed(e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation(); // prevent the contenteditable stuff

        if (e.detail.keyboardEvent) {
          e.detail.keyboardEvent.preventDefault();
          e.detail.keyboardEvent.stopPropagation();
          e.detail.keyboardEvent.stopImmediatePropagation();
        }

        this._add();
      }
    }, {
      key: "_add",
      value: function _add() {
        var li = document.createElement("li");
        li.setAttribute("contenteditable", "true");
        var node = this.getSelectionNode();

        if (this.__outlineNode.querySelector("li") == null || !node || node.tagName && node.tagName != "UL" && node.tagName != "LI") {
          this.__outlineNode.appendChild(li);
        } else {
          if ((node.tagName == null || node.tagName != "LI") && node.parentNode) {
            node = node.parentNode;
          }

          if (node.nextSibling == null) {
            node.parentNode.appendChild(li);
          } else {
            node.parentNode.insertBefore(li, node.nextSibling);
          }

          try {
            li.focus();
          } catch (e) {// prevent issue on polyfill browsers potentially
          }
        }
      }
    }, {
      key: "_outdent",
      value: function _outdent() {
        this.__blockScrub = true;

        try {
          var node = this.getSelectionNode();

          if (node == null) {
            return false;
          } // need to hold this in case it's empty at the end


          var parent = node.parentNode;

          if (node.parentNode && node.parentNode != this.__outlineNode && node.parentNode.nextSibling != null) {
            node.parentNode.parentNode.insertBefore(node, node.parentNode.nextSibling);

            if (parent.children.length == 0) {
              parent.remove();
            }
          } else if (node.parentNode && node.parentNode != this.__outlineNode && node.parentNode.nextSibling == null) {
            node.parentNode.parentNode.appendChild(node);

            if (parent.children.length == 0) {
              parent.remove();
            }
          }

          node.focus();
        } catch (e) {
          console.warn(e);
        }
      }
    }, {
      key: "_indent",
      value: function _indent() {
        this.__blockScrub = true;

        try {
          var node = this.getSelectionNode();

          if (node == null) {
            return false;
          } // see if the previous tag is a LI, if so we can indent


          if (node.previousSibling != null && node.previousSibling.tagName === "LI") {
            var ul;

            if (node.nextSibling && node.nextSibling.tagName === "UL") {
              ul = node.nextSibling;
            } else {
              ul = document.createElement("ul");
              node.parentNode.insertBefore(ul, node);
            } // append a new list inside the child before the active node position
            // now append into that list the node that was active


            ul.appendChild(node);
            node.focus();
          } else if (node.previousSibling != null && node.previousSibling.tagName === "UL") {
            node.previousSibling.appendChild(node);
            node.focus();
          }
        } catch (e) {
          console.warn(e);
        }
      }
    }, {
      key: "getSelectionNode",
      value: function getSelectionNode() {
        var node = this.getDeepSelection().anchorNode;

        if (node && (node.tagName == null || node.tagName != "LI") && node.parentNode) {
          node = node.parentNode;
        }

        return node;
      }
      /**
       * Selection normalizer
       */

    }, {
      key: "getDeepSelection",
      value: function getDeepSelection() {
        // try and obtain the selection from the nearest shadow
        // which would give us the selection object when running native ShadowDOM
        // with fallback support for the entire window which would imply Shady
        // native API
        if (this.shadowRoot.getSelection) {
          return this.shadowRoot.getSelection();
        } // ponyfill from google
        else if ((0, _utils.getRange)(this.__outlineNode.parentNode)) {
            return (0, _utils.getRange)(this.__outlineNode.parentNode);
          } // missed on both, hope the normal one will work


        return window.getSelection();
      }
      /**
       * Get a normalized range based on current selection
       */

    }, {
      key: "getDeepRange",
      value: function getDeepRange() {
        var sel = this.getDeepSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          return sel.getRangeAt(0);
        } else if (sel) {
          return sel;
        } else false;
      }
    }], [{
      key: "tag",
      get: function get() {
        return "editable-outline";
      }
    }]);
    return EditableOutline;
  }(_litElement.LitElement);

  _exports.EditableOutline = EditableOutline;
  window.customElements.define(EditableOutline.tag, EditableOutline);
});