define(["exports", "require", "../../lit/index.js"], function (_exports, _require, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.createSWC = createSWC;
  _require = _interopRequireWildcard(_require);

  var _templateObject_22362820942811ecb1937969798b231a;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `simple-wc`
   * `A simple web component wrapper to simplify consistent patterns of element creation`
   * @demo demo/index.html
   * @element simple-wc
   */
  function camelCaseToDash(key) {
    return key.replace(/([A-Z])/g, function (g) {
      return "-".concat(g[0].toLowerCase());
    });
  }

  function createSWC(swc) {
    var MyComponent = /*#__PURE__*/function (_LitElement) {
      babelHelpers.inherits(SWC, _LitElement);

      var _super = _createSuper(SWC);

      /**
       * HTMLElement
       */
      function SWC() {
        var _this;

        babelHelpers.classCallCheck(this, SWC);
        _this = _super.call(this);

        for (var key in swc.callbacks) {
          _this[key] = swc.callbacks[key];
        } // internal var to access everywhere
        // set the values from defaults


        for (var _key in swc.data.values) {
          _this[_key] = swc.data.values[_key];
        } // dynamically import depedencies


        setTimeout(function () {
          swc.deps.map(function (i) {
            new Promise(function (res, rej) {
              return _require.default(["../../".concat(i)], res, rej);
            });
          });
        }, 0);
        return _this;
      }

      babelHelpers.createClass(SWC, [{
        key: "render",
        value:
        /**
         * LitElement render function
         */
        function render() {
          return swc.html(this, _index.html);
        }
        /**
         * LitElement style rendering
         */

      }, {
        key: "updated",
        value:
        /**
         * Updated attribute / property callback
         */
        function updated(changedProperties) {
          var _this2 = this;

          if (babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "updated", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "updated", this).call(this, changedProperties);
          }

          changedProperties.forEach(function (old, name) {
            if (swc.data.observe) {
              swc.data.observe.forEach(function (value, key) {
                // we have something we are observing
                if (value[0].includes(name)) {
                  var result; // theres 1 value so pass new and old vlaue

                  if (value[0].length === 1) {
                    result = swc.callbacks[value[1]](_this2[value[0][0]], old);
                  } else {
                    var _swc$callbacks;

                    // pass in all the current values looking off of this
                    var valueMap = [];
                    value[0].map(function (val) {
                      valueMap.push(_this2[val]);
                    }); // spread the value map so we get the values populated as args correctly

                    result = (_swc$callbacks = swc.callbacks)[value[1]].apply(_swc$callbacks, valueMap);
                  } // set the result to this value while also spreading
                  // array values to propagate data binding
                  // this only happens if we have a 3rd value which is what we are
                  // storing the result in otherwise the result is not used


                  if (value.length == 3) {
                    _this2[value[2]] = Array.isArray(result) ? babelHelpers.toConsumableArray(result) : result;
                  }
                }
              });
            } // notify changes


            if (swc.data.notify && swc.data.notify.includes(name)) {
              // notify
              _this2.dispatchEvent(new CustomEvent("".concat(camelCaseToDash(name), "-changed"), {
                detail: {
                  value: _this2[name]
                }
              }));
            }
          });
        }
        /**
         * Window events add and remove
         * @param {String} status
         */

      }, {
        key: "__applyWinEvents",
        value: function __applyWinEvents(status) {
          if (swc.events && swc.events.window) {
            for (var eName in swc.events.window) {
              window["".concat(status ? "add" : "remove", "EventListener")](eName, swc.callbacks[swc.events.window[eName]].bind(this));
            }
          }
        }
        /**
         * LitElement shadow dom ready
         */

      }, {
        key: "firstUpdated",
        value: function firstUpdated() {
          if (swc.events && swc.events.shadow) {
            for (var target in swc.events.shadow) {
              for (var eName in swc.events.shadow[target]) {
                this.shadowRoot.querySelector(target).addEventListener(eName, swc.callbacks[swc.events.shadow[target][eName]].bind(this));
              }
            }
          }
        }
        /**
         * HTMLElement connected element
         */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "connectedCallback", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "connectedCallback", this).call(this);
          }

          this.__applyWinEvents(true);
        }
        /**
         * HTMLElement disconnected element
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          this.__applyWinEvents(false);

          if (babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "disconnectedCallback", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "disconnectedCallback", this).call(this);
          }
        }
        /**
         * return HAX Schema for wiring to HAX
         * @todo build this on the fly from swc
         */

      }, {
        key: "haxProperties",
        value: function haxProperties() {
          return {};
        }
      }], [{
        key: "tag",
        get: function get() {
          return swc.name;
        }
      }, {
        key: "styles",
        get: function get() {
          return [(0, _index.css)(_templateObject_22362820942811ecb1937969798b231a || (_templateObject_22362820942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n          /* this style helps ease FOUC w/ dynamic imports */\n          :host *:not(:defined) {\n            display: none;\n          }\n        "]))), swc.css(this, _index.css)];
        }
        /**
         * LitElement / popular convention
         */

      }, {
        key: "properties",
        get: function get() {
          var props = {};

          for (var key in swc.data.values) {
            // set type
            props[key] = {
              type: babelHelpers.typeof(swc.data.values[key])
            };
            props[key].type = props[key].type.charAt(0).toUpperCase() + props[key].type.slice(1); // convert camel to attr name IF it doesnt match

            var attr = camelCaseToDash(key);

            if (attr !== key) {
              props[key].attribute = attr;
            } // LitElement syntax


            if (swc.data.reflect && swc.data.reflect.includes(key)) {
              props[key].reflect = true;
            }
          }

          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(SWC), "properties", this)), props);
        }
      }]);
      return SWC;
    }(_index.LitElement);

    customElements.define(MyComponent.tag, MyComponent);
    return MyComponent;
  }
});