define(["exports", "../../../../../lit/index.js", "../../core/haxcms-site-store.js", "../../../../utils/utils.js", "../../../../../mobx/dist/mobx.esm.js"], function (_exports, _index, _haxcmsSiteStore, _utils, _mobxEsm) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SiteQuery = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `site-query`
   * `Query the JSON Outline Schema manifest and return a resulting array`
   *
   * @demo demo/index.html
   */
  // helper to use strings for index in Objects
  Object.byString = function (o, s) {
    return (0, _utils.objectValFromStringPos)(o, s);
  };

  var SiteQuery = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(SiteQuery, _LitElement);

    var _super = _createSuper(SiteQuery);

    function SiteQuery() {
      var _this;

      babelHelpers.classCallCheck(this, SiteQuery);
      _this = _super.call(this);
      _this.entity = "node";
      _this.conditions = {};
      _this.random = false;
      _this.sort = {
        order: "ASC"
      };
      _this.forceRebuild = false;
      _this.limit = 0;
      _this.startIndex = 0;
      return _this;
    }

    babelHelpers.createClass(SiteQuery, [{
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        changedProperties.forEach(function (oldValue, propName) {
          var notifiedProps = ["result", "conditions", "sort", "forceRebuild"];

          if (notifiedProps.includes(propName)) {
            // notify
            var eventName = "".concat(propName.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase(), "-changed");

            _this2.dispatchEvent(new CustomEvent(eventName, {
              detail: {
                value: _this2[propName]
              }
            }));
          }

          if (["entity", "conditions", "sort", "routerManifest", "activeId", "limit", "startIndex", "random", "forceRebuild"].includes(propName)) {
            _this2.result = babelHelpers.toConsumableArray(_this2._computeResult(_this2.entity, _this2.conditions, _this2.sort, _this2.routerManifest, _this2.activeId, _this2.limit, _this2.startIndex, _this2.random, _this2.forceRebuild));
          }
        });
      }
      /**
       * Compute what we should present as a slice of the real deal
       */

    }, {
      key: "_computeResult",
      value: function _computeResult(entity, conditions, sorts, routerManifest, activeId, limit, startIndex, random, forceRebuild) {
        if (routerManifest && routerManifest.items) {
          // ensure no data references, clone object
          var items = babelHelpers.toConsumableArray((0, _mobxEsm.toJS)(routerManifest.items)); // ohhh.... boy.... let's completely alter how this thing works

          if (entity !== "node") {
            var newItems = [];

            for (var i in items) {
              // we found a match...
              // for example maybe this is metadata.files
              // so now you've got things files centric as opposed to item centric
              if (babelHelpers.typeof(Object.byString(items[i], entity)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                var tmp = void 0;
                var val = Object.byString(items[i], entity);

                if (babelHelpers.typeof(val) === "object" || typeof val === "array") {
                  tmp = Object.assign([], Object.byString(items[i], entity));
                } else {
                  tmp = val;
                }

                if (babelHelpers.typeof(tmp) === "object" || typeof tmp === "array") {
                  for (var i in tmp) {
                    // we can push this onto objects, meaning full entities
                    // if the user queries for something weird like by title
                    // it's still valid but can't push the node onto it in the
                    // same way
                    if (babelHelpers.typeof(tmp[i]) === "object" || typeof tmp[i] === "array") {
                      // check for singular keys which could be grouped
                      tmp[i]._node = Object.assign({}, items[i]);
                      newItems.push(tmp[i]);
                    } else {
                      var tmp2 = {
                        _node: Object.assign({}, items[i]),
                        value: tmp[i]
                      };
                      newItems.push(tmp2);
                    }
                  }
                } else {
                  var _tmp = {
                    _node: Object.assign({}, items[i]),
                    value: tmp
                  };
                  newItems.push(_tmp);
                }
              }
            }

            items = Object.assign([], newItems); // group things that are the same so that nodes can be merged together

            /*for (var i in newItems) {
              if (newItems[i].length === 2) {
                let tmpItemsFound = newItems.find(j => newItems[i][Object.keys(newItems[i])[0]] === j[Object.keys(newItems[i])[0]]);
                items[i] = Object.assign({}, tmpItemsFound);
              }
              else {
                items[i] = Object.assign({}, newItems[i]);
              }
            }*/
          } // if there are no conditions just do a 1 to 1 presentation


          if (conditions && items) {
            // apply conditions, this will automatically filter our items
            for (var i in conditions) {
              // test for object vs direct form of condition
              if (conditions[i] === null) {
                conditions[i] = {
                  value: [conditions[i]],
                  operator: "="
                };
              } else if (babelHelpers.typeof(conditions[i]) !== "object") {
                conditions[i] = {
                  value: conditions[i],
                  operator: "="
                };
              } // normalize special case evaluations


              var evaluate = conditions[i].value;

              if (conditions[i].value === "$activeId") {
                evaluate = activeId;
              } else if (conditions[i].value === "$firstId") {
                evaluate = items[0].id;
              } // apply the conditions in order


              items = items.filter(function (item) {
                switch (conditions[i].operator) {
                  case ">":
                    if (Object.byString(item, i) > evaluate) {
                      return true;
                    }

                    return false;
                    break;

                  case "<":
                    if (Object.byString(item, i) < evaluate) {
                      return true;
                    }

                    return false;
                    break;

                  case "!=":
                    if (babelHelpers.typeof(evaluate) === "object" && !evaluate.includes(Object.byString(item, i))) {
                      return true;
                    } else if (typeof evaluate === "string" && Object.byString(item, i) !== evaluate) {
                      return true;
                    }

                    return false;
                    break;
                  // most common

                  case "=":
                  default:
                    if (babelHelpers.typeof(evaluate) === "object" && !evaluate.includes(Object.byString(item, i))) {
                      return false;
                    } else if (typeof evaluate === "string" && Object.byString(item, i) !== evaluate) {
                      return false;
                    }

                    return true;
                    break;
                }
              });
            }
          } // @todo need to support multi-facetted sort
          // right now this will just sort one way then undo it with another


          if (sorts) {
            for (var i in sorts) {
              items.sort(function (item1, item2) {
                if (sorts[i] === "ASC") {
                  if (Object.byString(item1, i) < Object.byString(item2, i)) {
                    return -1;
                  } else if (Object.byString(item1, i) > Object.byString(item2, i)) {
                    return 1;
                  } else {
                    return 0;
                  }
                } else {
                  if (Object.byString(item1, i) > Object.byString(item2, i)) {
                    return -1;
                  } else if (Object.byString(item1, i) < Object.byString(item2, i)) {
                    return 1;
                  } else {
                    return 0;
                  }
                }
              });
            }
          } // randomize the results, this would goof up the usefulness of sorts


          if (random) {
            items.sort(function (item1, item2) {
              if (Math.random() < Math.random()) {
                return -1;
              } else if (Math.random() > Math.random()) {
                return 1;
              } else {
                return 0;
              }
            });
          } // Start at this index...


          if (startIndex !== 0 && items.length > startIndex) {
            //start-index=5
            // remove last item while there's more items then the limit
            while (startIndex > 0) {
              items.shift();
              startIndex--;
            }
          } else if (items.length < startIndex) {
            return [];
          } // reduce results if we need to


          if (limit !== 0) {
            // remove last item while there's more items then the limit
            while (items.length > limit) {
              items.pop();
            }
          }

          return items;
        }

        return [];
      }
      /**
       * Connected life cycle
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this3 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(SiteQuery.prototype), "connectedCallback", this).call(this);
        this.__disposer = (0, _mobxEsm.autorun)(function () {
          _this3.routerManifest = Object.assign({}, (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.routerManifest));
        });
        this.__disposer2 = (0, _mobxEsm.autorun)(function () {
          _this3.activeId = (0, _mobxEsm.toJS)(_haxcmsSiteStore.store.activeId);
        });
      }
      /**
       * Disconnected life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.__disposer();

        this.__disposer2();

        babelHelpers.get(babelHelpers.getPrototypeOf(SiteQuery.prototype), "disconnectedCallback", this).call(this);
      }
    }], [{
      key: "tag",
      get:
      /**
       * Store the tag name to make it easier to obtain directly.
       */
      function get() {
        return "site-query";
      }
      /**
       * Props
       */

    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Manifest with router / location enhancements
           */
          routerManifest: {
            type: Object
          },

          /**
           * activeId
           */
          activeId: {
            type: String,
            attribute: "active-id"
          },

          /**
           * result to help illustrate this only lives here
           */
          result: {
            type: Array
          },

          /**
           * Conditions that can be used to slice the data differently in the manifest
           */
          conditions: {
            type: Object
          },

          /**
           * Establish the order items should be displayed in
           */
          sort: {
            type: Object
          },

          /**
           * Boolean flag to force a repaint of what's in the item
           */
          forceRebuild: {
            type: Boolean,
            attribute: "force-rebuild"
          },

          /**
           * Limit the number of results returned
           */
          limit: {
            type: Number
          },

          /**
           * Where to start returning results from
           */
          startIndex: {
            type: Number,
            attribute: "start-index"
          },

          /**
           * Randomize results
           */
          random: {
            type: Boolean
          },

          /**
           * Entity to focus on
           */
          entity: {
            type: String
          }
        };
      }
    }]);
    return SiteQuery;
  }(_index.LitElement);

  _exports.SiteQuery = SiteQuery;
  customElements.define(SiteQuery.tag, SiteQuery);
});