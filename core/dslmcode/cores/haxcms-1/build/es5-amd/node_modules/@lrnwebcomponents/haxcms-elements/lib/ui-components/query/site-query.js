define(["exports","../../../../../lit-element/lit-element.js","../../core/haxcms-site-store.js","../../../../utils/utils.js","../../../../../mobx/lib/mobx.module.js"],function(_exports,_litElement,_haxcmsSiteStore,_utils,_mobxModule){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.SiteQuery=void 0;/**
 * Copyright 2019 The Pennsylvania State University
 * @license Apache-2.0, see License.md for full text.
 */ /**
 * `site-query`
 * `Query the JSON Outline Schema manifest and return a resulting array`
 *

 * @polymer
 * @demo demo/index.html
 */ // helper to use strings for index in Objects
Object.byString=function(o,s){return(0,_utils.objectValFromStringPos)(o,s)};var SiteQuery=/*#__PURE__*/function(_LitElement){babelHelpers.inherits(SiteQuery,_LitElement);babelHelpers.createClass(SiteQuery,null,[{key:"tag",/**
   * Store the tag name to make it easier to obtain directly.
   */get:function get(){return"site-query"}/**
   * Props
   */},{key:"properties",get:function get(){return{/**
       * Manifest with router / location enhancements
       */routerManifest:{type:Object},/**
       * activeId
       */activeId:{type:String,attribute:"active-id"},/**
       * result to help illustrate this only lives here
       */result:{type:Array},/**
       * Conditions that can be used to slice the data differently in the manifest
       */conditions:{type:Object},/**
       * Establish the order items should be displayed in
       */sort:{type:Object},/**
       * Boolean flag to force a repaint of what's in the item
       */forceRebuild:{type:Boolean,attribute:"force-rebuild"},/**
       * Limit the number of results returned
       */limit:{type:Number},/**
       * Where to start returning results from
       */startIndex:{type:Number,attribute:"start-index"},/**
       * Randomize results
       */random:{type:Boolean},/**
       * Entity to focus on
       */entity:{type:String}}}}]);function SiteQuery(){var _this;babelHelpers.classCallCheck(this,SiteQuery);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(SiteQuery).call(this));_this.entity="node";_this.conditions={};_this.random=!1;_this.sort={order:"ASC"};_this.forceRebuild=!1;_this.limit=0;_this.startIndex=0;return _this}babelHelpers.createClass(SiteQuery,[{key:"updated",value:function updated(changedProperties){var _this2=this;changedProperties.forEach(function(oldValue,propName){var notifiedProps=["result","conditions","sort","forceRebuild"];if(notifiedProps.includes(propName)){// notify
var eventName="".concat(propName.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g,"$1-$2").toLowerCase(),"-changed");_this2.dispatchEvent(new CustomEvent(eventName,{detail:{value:_this2[propName]}}))}if(["entity","conditions","sort","routerManifest","activeId","limit","startIndex","random","forceRebuild"].includes(propName)){_this2.result=babelHelpers.toConsumableArray(_this2._computeResult(_this2.entity,_this2.conditions,_this2.sort,_this2.routerManifest,_this2.activeId,_this2.limit,_this2.startIndex,_this2.random,_this2.forceRebuild))}})}/**
   * Compute what we should present as a slice of the real deal
   */},{key:"_computeResult",value:function _computeResult(entity,conditions,sorts,routerManifest,activeId,limit,startIndex,random,forceRebuild){if(routerManifest&&routerManifest.items){// ensure no data references, clone object
var items=babelHelpers.toConsumableArray((0,_mobxModule.toJS)(routerManifest.items));// ohhh.... boy.... let's completely alter how this thing works
if("node"!==entity){var newItems=[];for(var i in items){// we found a match...
// for example maybe this is metadata.files
// so now you've got things files centric as opposed to item centric
if(babelHelpers.typeof(Object.byString(items[i],entity))!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var tmp=void 0,val=Object.byString(items[i],entity);if("object"===babelHelpers.typeof(val)||"array"===typeof val){tmp=Object.assign([],Object.byString(items[i],entity))}else{tmp=val}if("object"===babelHelpers.typeof(tmp)||"array"===typeof tmp){for(var i in tmp){// we can push this onto objects, meaning full entities
// if the user queries for something weird like by title
// it's still valid but can't push the node onto it in the
// same way
if("object"===babelHelpers.typeof(tmp[i])||"array"===typeof tmp[i]){// check for singular keys which could be grouped
tmp[i]._node=Object.assign({},items[i]);newItems.push(tmp[i])}else{var tmp2={_node:Object.assign({},items[i]),value:tmp[i]};newItems.push(tmp2)}}}else{var _tmp={_node:Object.assign({},items[i]),value:tmp};newItems.push(_tmp)}}}items=Object.assign([],newItems);// group things that are the same so that nodes can be merged together
/*for (var i in newItems) {
          if (newItems[i].length === 2) {
            let tmpItemsFound = newItems.find(j => newItems[i][Object.keys(newItems[i])[0]] === j[Object.keys(newItems[i])[0]]);
            items[i] = Object.assign({}, tmpItemsFound);
          }
          else {
            items[i] = Object.assign({}, newItems[i]);
          }
        }*/}// if there are no conditions just do a 1 to 1 presentation
if(conditions&&items){// apply conditions, this will automatically filter our items
for(var i in conditions){// test for object vs direct form of condition
if(null===conditions[i]){conditions[i]={value:[conditions[i]],operator:"="}}else if("object"!==babelHelpers.typeof(conditions[i])){conditions[i]={value:conditions[i],operator:"="}}// normalize special case evaluations
var evaluate=conditions[i].value;if("$activeId"===conditions[i].value){evaluate=activeId}else if("$firstId"===conditions[i].value){evaluate=items[0].id}// apply the conditions in order
items=items.filter(function(item){switch(conditions[i].operator){case">":if(Object.byString(item,i)>evaluate){return!0}return!1;break;case"<":if(Object.byString(item,i)<evaluate){return!0}return!1;break;case"!=":if("object"===babelHelpers.typeof(evaluate)&&!evaluate.includes(Object.byString(item,i))){return!0}else if("string"===typeof evaluate&&Object.byString(item,i)!==evaluate){return!0}return!1;break;// most common
case"=":default:if("object"===babelHelpers.typeof(evaluate)&&!evaluate.includes(Object.byString(item,i))){return!1}else if("string"===typeof evaluate&&Object.byString(item,i)!==evaluate){return!1}return!0;break;}})}}// @todo need to support multi-facetted sort
// right now this will just sort one way then undo it with another
if(sorts){for(var i in sorts){items.sort(function(item1,item2){if("ASC"===sorts[i]){if(Object.byString(item1,i)<Object.byString(item2,i)){return-1}else if(Object.byString(item1,i)>Object.byString(item2,i)){return 1}else{return 0}}else{if(Object.byString(item1,i)>Object.byString(item2,i)){return-1}else if(Object.byString(item1,i)<Object.byString(item2,i)){return 1}else{return 0}}})}}// randomize the results, this would goof up the usefulness of sorts
if(random){items.sort(function(item1,item2){if(Math.random()<Math.random()){return-1}else if(Math.random()>Math.random()){return 1}else{return 0}})}// Start at this index...
if(0!==startIndex&&items.length>startIndex){//start-index=5
// remove last item while there's more items then the limit
while(0<startIndex){items.shift();startIndex--}}else if(items.length<startIndex){return[]}// reduce results if we need to
if(0!==limit){// remove last item while there's more items then the limit
while(items.length>limit){items.pop()}}return items}return[]}/**
   * Connected life cycle
   */},{key:"connectedCallback",value:function connectedCallback(){var _this3=this;babelHelpers.get(babelHelpers.getPrototypeOf(SiteQuery.prototype),"connectedCallback",this).call(this);this.__disposer=(0,_mobxModule.autorun)(function(){_this3.routerManifest=Object.assign({},(0,_mobxModule.toJS)(_haxcmsSiteStore.store.routerManifest))});this.__disposer2=(0,_mobxModule.autorun)(function(){_this3.activeId=(0,_mobxModule.toJS)(_haxcmsSiteStore.store.activeId)})}/**
   * Disconnected life cycle
   */},{key:"disconnectedCallback",value:function disconnectedCallback(){this.__disposer();this.__disposer2();babelHelpers.get(babelHelpers.getPrototypeOf(SiteQuery.prototype),"disconnectedCallback",this).call(this)}}]);return SiteQuery}(_litElement.LitElement);_exports.SiteQuery=SiteQuery;window.customElements.define(SiteQuery.tag,SiteQuery)});