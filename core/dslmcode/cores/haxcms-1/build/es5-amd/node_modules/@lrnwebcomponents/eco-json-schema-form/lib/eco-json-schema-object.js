define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/elements/dom-if.js", "../../../@polymer/app-localize-behavior/app-localize-behavior.js", "../../../@polymer/polymer/lib/legacy/class.js", "../../../@polymer/iron-flex-layout/iron-flex-layout-classes.js", "./eco-json-schema-array.js", "./eco-json-schema-fieldset.js", "./eco-json-schema-markup.js", "./eco-json-schema-tabs.js", "./eco-json-schema-boolean.js", "./eco-json-schema-enum.js", "./eco-json-schema-file.js", "./eco-json-schema-input.js"], function (_exports, _polymerElement, _domIf, _appLocalizeBehavior, _class, _ironFlexLayoutClasses, _ecoJsonSchemaArray, _ecoJsonSchemaFieldset, _ecoJsonSchemaMarkup, _ecoJsonSchemaTabs, _ecoJsonSchemaBoolean, _ecoJsonSchemaEnum, _ecoJsonSchemaFile, _ecoJsonSchemaInput) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.EcoJsonSchemaObject = void 0;

  var _templateObject_9d42ba90809211edaa2833647dc78c6c;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
  `eco-json-schema-object` takes in a JSON schema of type object and builds a form,
  exposing a `value` property that represents an object described by the schema.
  
  Given the element:
  
  ```
  <eco-json-schema-object schema="[[schema]]" value="{{value}}"></eco-json-schema-object>
  ```
  
  And a JSON schema:
  
  ```
  > this.schema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "Contact",
    "type": "object",
    "properties": {
      "name": {
        "title": "Name",
        "type": "string"
      }
    }
  }
  ```
  
  A form will be generated, with the elements `value` looking something like this:
  
  ```
  > this.value
  {
    "name": "Eric"
  }
  ```
  
  Deep / nested schemas are supported for type array and object:
  
  ```
  > this.schema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "Contact",
    "type": "object",
      "phoneNumbers": {
        "title": "Phone numbers",
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "type": {
              "title": "Type",
              "type": "string"
            },
            "phoneNumber": {
              "title": "Phone Number",
              "type": "string"
            }
          }
        }
      }
    }
  }
  ```
  
  Validation is handled for strings and number/integers by mapping JSON schema
  validation keywords to `paper-input` attributes; form elements will automatically
  try and validate themselves as users provide input:
  
  ```
  > this.schema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "Contact",
    "type": "object",
    "properties": {
      "name": {
        "title": "Name",
        "type": "string",
        "minLength": 2
      },
      "age": {
        "type": "integer",
        "minimum": 0,
        "exclusiveMinimum": true
      },
      "postalCode": {
        "title": "Postal/Zip Code",
        "type": "string",
        "pattern": "[a-zA-Z][0-9][a-zA-Z]\\s*[0-9][a-zA-Z][0-9]|[0-9]{5}(-[0-9]{4})?"
      },
      "email": {
        "title": "email",
        "type": "string",
        "format": "email"
      }
    }
  }
  ```
  
  Customizing components for schema properties is supported by extending your JSON
  schema. For any schema sub-property (`properties` for `"type": "object"` and
  `items` for `"type": "array"`) a `component` property may be specified, with
  the following options:
  
  - `component.name` - specifies the name of the custom component to use
  - `component.valueProperty` - specifies which property of the custom element
    represents its value
  - `component.properties` - properties that will be set on the element
  
  Example schema using custom components (note that `"valueProperty": "value"` is
  redundant in this case, `"valueProperty": "value"` will be the default if not specified):
  
  ```
  > this.schema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "Contact",
    "type": "object",
    "properties": {
      "phoneNumber": {
        "title": "Phone Number",
        "type": "string",
        "component": {
          "name": "gold-phone-input",
          "valueProperty": "value",
          "properties": {
            "countryCode": "1"
          }
        }
      }
    }
  }
  ```
  
  Items set in `component.properties` will override any attributes / properties set
  by `eco-json-schema-form` elements, making it possible to override JSON schema
  validation properties mapped to `paper-input` attributes:
  
  ```
  > this.schema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "Contact",
    "type": "object",
    "properties": {
      "postalCode": {
        "title": "Postal/Zip Code",
        "type": "string",
        "pattern": "[a-zA-Z][0-9][a-zA-Z]\\s*[0-9][a-zA-Z][0-9]|[0-9]{5}(-[0-9]{4})?",
        "component": {
          "properties": {
            "autoValidate": false
          }
        }
      }
    }
  }
  ```
  
  Putting it all together, this schema:
  
  ```
  > this.schema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "Contact",
    "type": "object",
    "properties": {
      "name": {
        "title": "Name",
        "type": "string",
        "minLength": 2
      },
      "age": {
        "type": "integer",
        "minimum": 0,
        "exclusiveMinimum": true
      },
      "postalCode": {
        "title": "Postal/Zip Code",
        "type": "string",
        "pattern": "[a-zA-Z][0-9][a-zA-Z]\\s*[0-9][a-zA-Z][0-9]|[0-9]{5}(-[0-9]{4})?",
        "component": {
          "properties": {
            "autoValidate": false
          }
        }
      },
      "phoneNumbers": {
        "title": "Phone numbers",
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "type": {
              "title": "Type",
              "type": "string"
            },
            "phoneNumber": {
              "title": "Phone Number",
              "type": "string",
              "component": {
                "name": "gold-phone-input",
                "valueProperty": "value",
                "properties": {
                  "countryCode": "1"
                }
              }
            }
          }
        }
      },
      "emailAddresses": {
        "title": "Emails",
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "type": {
              "title": "Type",
              "type": "string"
            },
            "email": {
              "title": "email",
              "type": "string",
              "format": "email"
            }
          }
        }
      }
    }
  }
  ```
  
  Will build a form describing an object:
  
  ```
  > this.value
  {
    "name": "Eric",
    "age": 28,
    "postalCode": "H1W 2C5",
    "phoneNumbers": [
      {
        "type": "Mobile",
        "phoneNumber": "123-456-7890"
      }
    ]
    "emailAddresses": [
      {
        "type": "Personal",
        "email": "eric@wat.com"
      }
    ]
  }
  ```
  
  External validation is supported via the `error` property. By providing an
  object tree with each leaf representing an error message for properties, the
  message will be attached to the appropriate element.
  
  Example, for the Contact schema:
  
  ```
  el.error = {
    "name": "String is too short (0 chars) minimum 2",
    "phoneNumbers": [
      {
        "phoneNumber": "String does not match required format"
      }
    ]
  }
  ```
  
  @group eco Elements
  @element eco-json-schema-object
  * @demo demo/index.html
  */
  var EcoJsonSchemaObject = /*#__PURE__*/function (_mixinBehaviors) {
    babelHelpers.inherits(EcoJsonSchemaObject, _mixinBehaviors);

    var _super = _createSuper(EcoJsonSchemaObject);

    function EcoJsonSchemaObject() {
      babelHelpers.classCallCheck(this, EcoJsonSchemaObject);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(EcoJsonSchemaObject, [{
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this._clearForm();

        babelHelpers.get(babelHelpers.getPrototypeOf(EcoJsonSchemaObject.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * returns an array of properties for a given schema object
       * @param {object} thisSchema the source schema
       * @returns {array} an array
       */

    }, {
      key: "_buildSchemaProperties",
      value: function _buildSchemaProperties() {
        var _this = this;

        var thisSchema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.schema;
        var ctx = this;
        return Object.keys(thisSchema.properties || []).map(function (key) {
          var schema = thisSchema.properties[key];
          var property = {
            name: key,
            schema: schema,
            label: schema.title || key,
            description: schema.description,
            component: schema.component || {}
          };

          if (!property.component.valueProperty) {
            property.component.valueProperty = "value";
          }

          if (!property.component.slot) {
            property.component.slot = "";
          }

          if (ctx._isSchemaEnum(schema)) {
            property.component.name = property.component.name || "eco-json-schema-enum";

            if (babelHelpers.typeof(schema.value) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              schema.value = "";
            }

            property.value = schema.value;
          } else if (ctx._isSchemaBoolean(schema.type)) {
            property.component.name = property.component.name || "eco-json-schema-boolean";

            if (babelHelpers.typeof(schema.value) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              schema.value = false;
            }

            property.value = schema.value;
          } else if (ctx._isSchemaFile(schema.type)) {
            property.component.name = property.component.name || "eco-json-schema-file";

            if (babelHelpers.typeof(schema.value) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              schema.value = {};
            }

            property.value = schema.value;
          } else if (ctx._isSchemaValue(schema.type)) {
            property.component.name = property.component.name || "eco-json-schema-input";

            if (babelHelpers.typeof(schema.value) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              schema.value = "";
            }

            property.value = schema.value;
          } else if (ctx._isSchemaObject(schema.type)) {
            property.component.name = property.component.name || "eco-json-schema-object";

            if (babelHelpers.typeof(schema.value) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              schema.value = {};
            }

            property.value = schema.value;
          } else if (ctx._isSchemaArray(schema.type)) {
            property.component.name = property.component.name || "eco-json-schema-array";

            _this._buildNestedSchemaProperties(property, schema);
          } else if (ctx._isSchemaFieldset(schema.type)) {
            property.component.name = property.component.name || "eco-json-schema-fieldset";

            _this._buildNestedSchemaProperties(property, schema);
          } else if (ctx._isSchemaTabs(schema.type)) {
            property.component.name = property.component.name || "eco-json-schema-tabs";

            _this._buildNestedSchemaProperties(property, schema);
          } else if (ctx._isSchemaMarkup(schema.type)) {
            property.component.name = property.component.name || "eco-json-schema-markup";

            if (babelHelpers.typeof(schema.value) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              schema.value = "";
            }

            property.value = schema.value;
          } else {
            return console.error("Unknown property type %s", schema.type);
          }

          return property;
        });
      }
      /**
       * adds array of nested sub-properties to a given property based on a given schema
       * @param {object} property the property that will have nested subproperties
       * @param {object} schema the schema that has nested subschemas
       */

    }, {
      key: "_buildNestedSchemaProperties",
      value: function _buildNestedSchemaProperties(property, schema) {
        if (babelHelpers.typeof(schema.value) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) schema.value = schema.type !== "array" ? {} : [];
        property.value = schema.value;

        for (var key in schema.items.properties) {
          schema.items.properties[key].value = schema.value[key];
        }

        property.schema.properties = this._buildSchemaProperties(schema.items, property.property + ".");
      }
      /**
       * updates the value when a schema property (or subproperty) changes
       * @param {event} event the
       * @param {object} detail the event details
       */

    }, {
      key: "_schemaPropertyChanged",
      value: function _schemaPropertyChanged(event, detail) {
        if (detail) {
          if (detail.path && /\.length$/.test(detail.path)) {
            return;
          }

          var ctx = this;
          var property = event.target.schemaProperty;
          var path = ["value"].concat("".concat(event.target.propertyPrefix).concat(event.target.propertyName).split("."));
          var prop = property.property || event.target.propertyName;
          var val = detail && detail.value ? this._deepClone(detail.value) : null;

          if (detail.path && /\.splices$/.test(detail.path)) {
            var parts = detail.path.split(".").slice(1, -1);

            while (parts.length) {
              path.push(parts.shift());

              if (property.keyMap && property.keyMap[path.join(".")]) {
                path = property.keyMap[path.join(".")].split(".");
              }
            }

            if (detail.value.keySplices) {
              if (property.keyMap) {
                detail.value.keySplices.forEach(function (splice) {
                  splice.removed.forEach(function (k) {
                    delete property.keyMap[path.concat([k]).join(".")];
                  });
                });
              }
            }

            if (detail.value) {
              detail.value.indexSplices.forEach(function (splice) {
                var args = [path.join("."), splice.index, splice.removed.length];

                if (splice.addedCount) {
                  for (var i = 0, ii = splice.addedCount; i < ii; i++) {
                    if (splice.addedKeys && splice.addedKeys[i]) {
                      property.keyMap = property.keyMap || {};
                      property.keyMap[path.concat([splice.addedKeys[i]]).join(".")] = path.concat([i + splice.index]).join(".");
                    }

                    args.push(ctx._deepClone(splice.object[i + splice.index]));
                  }
                }

                ctx.splice.apply(ctx, args);
              });
            }
          } else if (detail.path) {
            var parts = detail.path.split(".").slice(1);
            var v = this.value;

            if (!v.hasOwnProperty(property.property)) {
              this.set("value." + property.property, {});
              this.notifyPath("value." + property.property);
            }

            while (parts.length) {
              var k = parts.shift();
              path.push(k);

              if (property.keyMap && property.keyMap[path.join(".")]) {
                path = property.keyMap[path.join(".")].split(".");
              }
            }

            this.set(path.join("."), this._deepClone(detail.value));
            this.notifyPath(path.join("."));
          } else {
            //most of our fields will just set the value this way
            this.set(path.join("."), this._deepClone(detail.value));
            this.notifyPath("value");
          } //fire an event to let array listeners handle changed fields


          event.target.dispatchEvent(new CustomEvent("form-field-changed", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: event.target
          }));
          this.dispatchEvent(new CustomEvent("value-changed", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: this
          }));
        }
      }
      /**
       * sets the value based on a the schema properties (or a subproperties and a path)
       * @param {array} props the schema properties (default) or subproperties
       * @param {string} path the string that indicates the path for subproperties
       */

    }, {
      key: "_setValue",
      value: function _setValue() {
        var _this2 = this;

        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._schemaProperties;
        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
        var setter = path.replace(/\[(\d+)\]/g, ".$1");
        if (setter != "") setter = ".".concat(setter);

        if (props.length > 0) {
          props.forEach(function (property) {
            if (babelHelpers.typeof(property.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              _this2.set("value".concat(setter, ".").concat(property.property), _this2._deepClone(property.value), JSON.stringify(property.value));
            }
          });
          this.notifyPath("value.*");
        }
      }
      /**
       * builds form fields and appends them to an element
       * @param {array} props the schema properties (default) or subproperties
       * @param {object} container optional container element the for the form fields (for subproperties)
       * @param {string} prefix optional field name prefix (for subproperties)
       */

    }, {
      key: "_buildForm",
      value: function _buildForm() {
        var _this3 = this;

        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._schemaProperties;
        var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        var autofocus = this.autofocus;
        props.forEach(function (property) {
          if (property.component.name === "code-editor") {
            // special case, can't come up with a better way to do this but monoco is very special case
            property.schema.component.properties.editorValue = property.schema.value;
            property.schema.component.properties.theme = _this3.codeTheme;
          }

          var propertyPrefix = prefix !== "" ? "".concat(prefix, ".") : "",
              propertyName = property.property || property.name;

          var el = _this3.create(property.component.name, {
            label: property.label,
            schema: property.schema,
            schemaProperty: property,
            propertyPrefix: propertyPrefix,
            propertyName: propertyName,
            language: _this3.language,
            resources: _this3.resources
          });

          if (property.component.name === "paper-input") {
            el.style["background-color"] = "transparent";
            el.style["width"] = "100%";
          }

          el.setAttribute("name", "".concat(propertyPrefix).concat(propertyName));

          if (property.schema.hidden && property.schema.hidden !== undefined) {
            el.setAttribute("hidden", property.schema.hidden);
          } //allows the first form fields to be focused on autopmatically


          if (autofocus) el.setAttribute("autofocus", autofocus); //turns of focus on subsequent form fields

          autofocus = false;
          el.className = "flex start-justified"; // set the element's default value to be what was passed into the schema

          el[property.component.valueProperty] = property.value; // support component attribute overrides

          for (var attr in property.component.attributes) {
            el.setAttribute(attr, property.component.attributes[attr]);
          } // support component property overrides


          for (var prop in property.component.properties) {
            el[prop] = property.component.properties[prop];
          }

          _this3.listen(el, property.component.valueProperty.replace(/([A-Z])/g, "-$1").toLowerCase() + "-changed", "_schemaPropertyChanged");

          _this3.listen(el, "build-fieldset", "_onBuildFieldset");

          if (babelHelpers.typeof(_this3.$) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            container.appendChild(el);

            if (property.description) {
              var id = "tip-" + property.property,
                  tip = document.createElement("div");
              el.setAttribute("aria-describedby", id);
              el.setAttribute("class", "has-tooltip-desc");
              tip.setAttribute("id", id);
              tip.setAttribute("class", "tooltip-desc desc-for-" + property.component.name);
              if (property.schema.hidden === true) tip.setAttribute("hidden", "hidden");
              tip.setAttribute("role", "tooltip");
              tip.innerHTML = property.description;
              container.appendChild(tip);
            }
          } // support for slot injection too!


          if (property.component.slot != "") {
            var temp = document.createElement("div");
            temp.innerHTML = property.component.slot;
            var cloneDiv = temp.cloneNode(true);

            while (cloneDiv.firstChild !== null) {
              el.appendChild(cloneDiv.firstChild);
            }
          }

          _this3.dispatchEvent(new CustomEvent("form-changed", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: _this3
          }));
        });
      }
      /**
       * handles fieldset requests from containers like fieldsets, tabs, or arrays
       * @param {event} event the "build-fieldset" event
       * @param {object} detail the details of the event, as in:```
      {
      prefix: the prefix for the fields 
      properties: []     //an array of schema properties,
      container: <div/>  //the container element,
      }
      ```
       */

    }, {
      key: "_onBuildFieldset",
      value: function _onBuildFieldset(event, detail) {
        if (babelHelpers.typeof(this.get("value.".concat(detail.prefix))) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) this.set("value.".concat(detail.path), this._deepClone(detail.value));

        this._clearForm(detail.container);

        this._buildForm(detail.properties, detail.container, detail.prefix);
      }
      /**
       * removes a field element
       * @param {object} el the element to remove
       * @param {*} parent the container where the field element exists
       */

    }, {
      key: "_removePropertyEl",
      value: function _removePropertyEl(el) {
        var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;

        if (babelHelpers.typeof(el.schemaProperty) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.unlisten(el, el.schemaProperty.component.valueProperty.replace(/([A-Z])/g, "-$1").toLowerCase() + "-changed", "_schemaPropertyChanged");
        }

        el.schemaProperty = null;
        parent.removeChild(el);
      }
      /**
       * clears a form or a fieldset container within a form
       * @param {object} el the element to remove
       * @param {*} parent the container where the field element exists
       */

    }, {
      key: "_clearForm",
      value: function _clearForm() {
        var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

        if (babelHelpers.typeof(this.$) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          var formEl = container;

          while (formEl.firstChild) {
            this._removePropertyEl(formEl.firstChild, container);
          }
        }
      }
      /**
       * updates the form when the schema changes
       * @param {object} newValue the new value for the schema
       * @param {object} oldValue the old value for the schema
       */

    }, {
      key: "_schemaChanged",
      value: function _schemaChanged(newValue, oldValue) {
        if (newValue && newValue !== oldValue) {
          this._clearForm();

          this._schemaProperties = this._buildSchemaProperties();

          this._buildForm();

          this._setValue();
        }
      }
      /**
       * handles errors
       * @todo how do we want to handle errors for nested fields?
       */

    }, {
      key: "_errorChanged",
      value: function _errorChanged() {
        var _this4 = this;

        /*
        console.log(
          "_errorChanged",
          this,
          this.querySelectorAll("[name]"),
          this.error
        );*/
        this.childNodes.forEach(function (el) {
          var name = el.getAttribute("name");

          if (_this4.error && _this4.error[name]) {
            el.error = _this4.error[name];
          } else {
            el.error = null;
          }
        });
      }
      /**
       * clones an object and all its subproperties
       * @param {object} o the object to clone
       * @returns {object} the cloned object
       */

    }, {
      key: "_deepClone",
      value: function _deepClone(o) {
        return JSON.parse(JSON.stringify(o));
      }
    }, {
      key: "_isSchemaValue",
      value: function _isSchemaValue(type) {
        return this._isSchemaBoolean(type) || this._isSchemaNumber(type) || this._isSchemaString(type) || this._isSchemaFile(type);
      }
    }, {
      key: "_isSchemaFile",
      value: function _isSchemaFile(type) {
        if (Array.isArray(type)) {
          return type.indexOf("file") !== -1;
        } else {
          return type === "file";
        }
      }
    }, {
      key: "_isSchemaBoolean",
      value: function _isSchemaBoolean(type) {
        if (Array.isArray(type)) {
          return type.indexOf("boolean") !== -1;
        } else {
          return type === "boolean";
        }
      }
    }, {
      key: "_isSchemaEnum",
      value: function _isSchemaEnum(schema) {
        return !!schema.enum;
      }
    }, {
      key: "_isSchemaNumber",
      value: function _isSchemaNumber(type) {
        if (Array.isArray(type)) {
          return type.indexOf("number") !== -1 || type.indexOf("integer") !== -1;
        } else {
          return type === "number" || type === "integer";
        }
      }
    }, {
      key: "_isSchemaString",
      value: function _isSchemaString(type) {
        if (Array.isArray(type)) {
          return type.indexOf("string") !== -1;
        } else {
          return type === "string";
        }
      }
    }, {
      key: "_isSchemaObject",
      value: function _isSchemaObject(type) {
        return type === "object";
      }
    }, {
      key: "_isSchemaArray",
      value: function _isSchemaArray(type) {
        return type === "array";
      }
    }, {
      key: "_isSchemaFieldset",
      value: function _isSchemaFieldset(type) {
        return type === "fieldset";
      }
    }, {
      key: "_isSchemaTabs",
      value: function _isSchemaTabs(type) {
        return type === "tabs";
      }
    }, {
      key: "_isSchemaMarkup",
      value: function _isSchemaMarkup(type) {
        return type === "markup";
      }
    }, {
      key: "focus",
      value: function focus() {//console.log(this);
      }
    }], [{
      key: "tag",
      get: function get() {
        return "eco-json-schema-object";
      }
    }, {
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_9d42ba90809211edaa2833647dc78c6c || (_templateObject_9d42ba90809211edaa2833647dc78c6c = babelHelpers.taggedTemplateLiteral(["\n      <custom-style>\n        <style is=\"custom-style\" include=\"iron-flex iron-flex-alignment\">\n          :host {\n            --eco-json-field-margin: 0 0 15px;\n            --eco-json-form-border-radius: 2px;\n            --eco-json-form-font-family: var(\n              --paper-font-caption_-_font-family,\n              unset\n            );\n            --eco-json-form-bg: var(--primary-background-color, #fff);\n            --eco-json-form-color: var(--primary-text-color, #222);\n            --eco-json-form-faded-color: #888;\n            --eco-json-form-active-color: var(--primary-color, #000);\n            --eco-json-form-faded-bg: #f0f0f0;\n            --eco-json-form-add-color: #008811;\n            --eco-json-form-add-focus: #007700;\n            --eco-json-form-remove-focus: #cc0000;\n            --eco-json-form-remove-color: #dd0000;\n            --simple-picker-float-label-color: var(--eco-json-form-faded-color);\n            --simple-picker-float-label-active-color: var(\n              --eco-json-form-active-color\n            );\n            --simple-picker-background-color: var(--eco-json-form-bg);\n            --simple-picker-border-color: var(--eco-json-form-faded-color);\n            --simple-picker-focus-border-color: var(\n              --eco-json-form-active-color\n            );\n            --simple-picker-focus-border-width: 2px;\n            --paper-input-container: {\n              padding-top: 0;\n            }\n          }\n          div.layout {\n            height: auto;\n          }\n          #form {\n            display: block;\n            font-family: var(--eco-json-form-font-family);\n            background-color: var(--eco-json-form-bg);\n            color: var(--eco-json-form-color);\n            --simple-tooltip-background: var(--eco-json-form-active-color);\n            --simple-tooltip-text-color: var(--eco-json-form-bg);\n            @apply --eco-json-schema-object-form;\n            @apply --layout-vertical;\n            @apply --layout-wrap;\n          }\n          #form ::slotted(paper-input) {\n            margin-bottom: 15px;\n          }\n          #form ::slotted(*.has-tooltip-desc) {\n            margin-bottom: 0;\n            padding-bottom: 0;\n            --paper-input-container: {\n              margin-bottom: 0;\n              padding-bottom: 0;\n            }\n          }\n          #form ::slotted(div.tooltip-desc) {\n            font-size: 12px;\n            margin: var(--eco-json-field-margin);\n            color: var(--eco-json-form-faded-color);\n          }\n          #form ::slotted(paper-input),\n          #form ::slotted(div.tooltip-desc) {\n            font-family: var(--eco-json-form-font-family);\n          }\n          #form ::slotted(div.desc-for-paper-textarea) {\n            margin-top: -18px;\n            margin-right: 35px;\n          }\n          #form ::slotted(code-editor) {\n            margin: 8px 0;\n            padding: 0;\n            --code-editor-float-label-color: var(--eco-json-form-faded-color);\n            --code-editor-float-label-active-color: var(\n              --eco-json-form-active-color\n            );\n            --code-pen-button-color: var(--eco-json-form-faded-color);\n            --code-editor-code-border: 1px solid\n              var(--eco-json-form-faded-color);\n            --code-editor-code-border-radius: 2px;\n            --code-editor-focus-code-border: 2px solid\n              var(--eco-json-form-active-color);\n          }\n        </style>\n      </custom-style>\n\n      <template is=\"dom-if\" if=\"{{!wizard}}\">\n        <div class=\"header\" hidden$=\"[[!label]]\">[[label]]</div>\n      </template>\n      <div class=\"layout vertical flex start-justified\">\n        <div\n          id=\"form\"\n          class=\"layout horizontal flex start-justified\"\n          aria-live=\"polite\"\n        >\n          <slot></slot>\n        </div>\n      </div>\n    "])));
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          language: {
            value: "en"
          },
          resources: {
            value: function value() {
              return {};
            }
          },
          schema: {
            type: Object,
            notify: true,
            observer: "_schemaChanged"
          },
          label: {
            type: String
          },
          value: {
            type: Object,
            notify: true,
            value: function value() {
              return {};
            }
          },
          error: {
            type: Object,
            observer: "_errorChanged"
          },
          wizard: {
            type: Boolean,
            notify: true
          },

          /**
           * the name of the code-editor theme
           */
          codeTheme: {
            type: String,
            value: "vs-light-2"
          },

          /**
           * automatically set focus on the first field if that field has autofocus
           */
          autofocus: {
            type: Boolean,
            value: false
          }
        };
      }
    }]);
    return EcoJsonSchemaObject;
  }((0, _class.mixinBehaviors)([_appLocalizeBehavior.AppLocalizeBehavior], _polymerElement.PolymerElement));

  _exports.EcoJsonSchemaObject = EcoJsonSchemaObject;
  customElements.define(EcoJsonSchemaObject.tag, EcoJsonSchemaObject);
});