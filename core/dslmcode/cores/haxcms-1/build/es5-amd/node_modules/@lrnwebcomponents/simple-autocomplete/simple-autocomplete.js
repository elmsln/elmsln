define(["exports", "require", "../../lit/index.js", "../simple-filter/simple-filter.js", "../utils/utils.js", "../simple-popover/simple-popover.js"], function (_exports, _require, _index, _simpleFilter, _utils, _simplePopover) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SimpleAutocomplete = void 0;
  _require = _interopRequireWildcard(_require);

  var _templateObject_218a09a0942811ecb1937969798b231a, _templateObject2_218a09a0942811ecb1937969798b231a, _templateObject3_218a09a0942811ecb1937969798b231a, _templateObject4_218a09a0942811ecb1937969798b231a, _templateObject5_218a09a0942811ecb1937969798b231a, _templateObject6_218a09a0942811ecb1937969798b231a, _templateObject7_218a09a0942811ecb1937969798b231a, _templateObject8_218a09a0942811ecb1937969798b231a;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `simple-autocomplete`
   * `auto complete either from an endpoint or local json array`
   * @demo demo/index.html
   * @element simple-autocomplete
   */
  var SimpleAutocomplete = /*#__PURE__*/function (_SimpleFilterMixin) {
    babelHelpers.inherits(SimpleAutocomplete, _SimpleFilterMixin);

    var _super = _createSuper(SimpleAutocomplete);

    /**
     * HTMLElement life cycle
     */
    function SimpleAutocomplete() {
      var _this;

      babelHelpers.classCallCheck(this, SimpleAutocomplete);
      _this = _super.call(this); // default limit of items to show even if there are more results

      _this.itemLimit = 6; // flag to hide input; useful if something else is implementing this tag w/ own input

      _this.hideInput = false;
      _this.selectionPosition = false;
      _this.value = "";
      _this.opened = false; // click trap to ensure we don't close the popover menu by accident of clicking on it

      _this.addEventListener("mousedown", function (e) {
        _this._clicking = true;
      }); // remove the trap


      _this.addEventListener("mouseup", function (e) {
        _this._clicking = false;
      }); // ONLY execute a focusout if we mousedown'ed outside of the scope of this element
      // if mousedown happens inside the element then this doesn't fire
      // if you click away on the screen or tab away from the element then this ensures
      // the popover menu automatically closes and the value is established as the contenteditable


      _this.addEventListener("focusout", function (e) {
        if (!_this._clicking) {
          if (!_this.hideInput) {
            _this.value = _this.$input.innerText;
          }

          _this.opened = false;
        } else {
          _this._clicking = false;
        }
      });

      return _this;
    }
    /**
     * LitElement life cycle for shadowRoot being available
     */


    babelHelpers.createClass(SimpleAutocomplete, [{
      key: "setValue",
      value: function setValue(value) {
        this.processInput(value);

        if (!this.hideInput) {
          this.$input.innerText = value;
        }
      }
      /**
       * Logic for processing input and ensuring list is filtered
       */

    }, {
      key: "processInput",
      value: function processInput(value) {
        this.opened = true;
        this.value = value;
        this.like = this.value;
      }
      /**
       * When input changes as in user types into the contenteditable area
       * Then we need to open the autocomplete menu and start filtering
       */

    }, {
      key: "inputChanged",
      value: function inputChanged(e) {
        this.processInput(this.$input.innerText);
      }
      /**
       * LitElement convention for rendering
       */

    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        return (0, _index.html)(_templateObject_218a09a0942811ecb1937969798b231a || (_templateObject_218a09a0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n      ", "\n      <simple-popover\n        part=\"popover\"\n        auto\n        part=\"simple-popover\"\n        ?hidden=\"", "\"\n        position=\"bottom\"\n        for=\"input\"\n      >\n        ", "\n      </simple-popover>\n    "])), !this.hideInput ? (0, _index.html)(_templateObject2_218a09a0942811ecb1937969798b231a || (_templateObject2_218a09a0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["<span\n            part=\"input\"\n            id=\"input\"\n            name=\"input\"\n            @input=\"", "\"\n            contenteditable\n            @keydown=\"", "\"\n          ></span>"])), this.inputChanged, this.a11yInputKeys) : "", !this.opened || this.filtered.length === 0, this.filtered.length > 0 && this.opened ? (0, _index.html)(_templateObject3_218a09a0942811ecb1937969798b231a || (_templateObject3_218a09a0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral([" <ul\n              part=\"list\"\n              role=\"listbox\"\n              @keydown=\"", "\"\n            >\n              ", "\n            </ul>"])), this.a11yListKeys, this.filtered.map(function (item, i) {
          return (0, _index.html)(_templateObject4_218a09a0942811ecb1937969798b231a || (_templateObject4_218a09a0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["", ""])), i < _this2.itemLimit ? (0, _index.html)(_templateObject5_218a09a0942811ecb1937969798b231a || (_templateObject5_218a09a0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["<li\n                        role=\"option\"\n                        part=\"list-item\"\n                        value=\"", "\"\n                        data-index=\"", "\"\n                      >\n                        <button\n                          part=\"button\"\n                          value=\"", "\"\n                          data-index=\"", "\"\n                          @click=\"", "\"\n                        >\n                          ", "", "\n                        </button>\n                      </li>"])), item.value, i, item.value, i, _this2.itemSelect, item.icon ? (0, _index.html)(_templateObject6_218a09a0942811ecb1937969798b231a || (_templateObject6_218a09a0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["<simple-icon-lite\n                                icon=\"", "\"\n                              ></simple-icon-lite>"])), item.icon) : "", item.label) : "");
        })) : (0, _index.html)(_templateObject7_218a09a0942811ecb1937969798b231a || (_templateObject7_218a09a0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["<div class=\"no-results\" part=\"no-result\">No results</div>"]))));
      }
      /**
       * Accessibility enhancements for key presses while in the list of items
       */

    }, {
      key: "a11yListKeys",
      value: function a11yListKeys(e) {
        if (this.filtered.length > 0 && this.opened) {
          switch (e.key) {
            case "ArrowDown":
              // we are on a button actively and there is a next element (li) which has a button
              if (this.shadowRoot.activeElement.tagName === "BUTTON" && this.shadowRoot.activeElement.parentNode.nextElementSibling && this.shadowRoot.activeElement.parentNode.nextElementSibling.children) {
                this.hardStopEvent(e);
                this.shadowRoot.activeElement.parentNode.nextElementSibling.children[0].focus();
              }

              break;

            case "Escape":
              this.hardStopEvent(e); // close the popover list of items and do focus clean up

              this.resetFocusOnInput();
              break;

            case "ArrowUp":
              // we are actively on a button and there is a previous element (li) which has a button
              if (this.shadowRoot.activeElement.tagName === "BUTTON" && this.shadowRoot.activeElement.parentNode.previousElementSibling && this.shadowRoot.activeElement.parentNode.previousElementSibling.children) {
                this.hardStopEvent(e);
                this.shadowRoot.activeElement.parentNode.previousElementSibling.children[0].focus();
              }

              break;
          }
        }
      }
    }, {
      key: "hardStopEvent",
      value: function hardStopEvent(e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();

        if (e.detail.keyboardEvent) {
          e.detail.keyboardEvent.preventDefault();
          e.detail.keyboardEvent.stopPropagation();
          e.detail.keyboardEvent.stopImmediatePropagation();
        }
      }
      /**
       * Accessibility enhancements when typing in order to move to the autocomplete list easily
       */

    }, {
      key: "a11yInputKeys",
      value: function a11yInputKeys(e) {
        if (this.filtered.length > 0 && this.opened) {
          switch (e.key) {
            case "ArrowDown":
              // down means from the input field, focus on the 1st button
              if (this.shadowRoot.querySelector("button")) {
                this.hardStopEvent(e);
                this.shadowRoot.querySelector("button").focus();
              }

              break;

            case "Escape":
              this.hardStopEvent(e); // close the menu, though it'll reopen when typing more

              this.opened = false;
              break;

            case "ArrowUp":
              // up implies cycling back around so focus on the last button in the list
              if (this.shadowRoot.querySelectorAll("button").length) {
                this.hardStopEvent(e);
                this.shadowRoot.querySelectorAll("button")[this.shadowRoot.querySelectorAll("button").length - 1].focus();
              }

              break;
          }
        }
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        var _this3 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(SimpleAutocomplete.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(SimpleAutocomplete.prototype), "firstUpdated", this).call(this, changedProperties);
        } // store reference to input field as we use it a lot


        if (!this.selectionPosition && this.shadowRoot.querySelector("#input")) {
          this.$input = this.shadowRoot.querySelector("#input"); // set target for popover so it shows up on the input element

          this.shadowRoot.querySelector("simple-popover").target = this.$input; // when focusing the input area ensure we open the popover correctly

          this.$input.addEventListener("focusin", function (e) {
            // ensure when we optimize for a value to fill in the area that we don't accidently open the menu immediately
            if (_this3.value && !_this3._ignoreFocusOpen) {
              _this3.opened = true;

              if (!_this3.hideInput) {
                // this forces the filter to kick in based on what's already there
                _this3.value = _this3.$input.innerText; // "like" is the filtering value to searching against

                _this3.like = _this3.$input.innerText;
              }
            }

            _this3._ignoreFocusOpen = false;
          });
        }
      }
      /**
       * Selection normalizer
       */

    }, {
      key: "getSelection",
      value: function getSelection() {
        // try and obtain the selection from the nearest shadow
        // which would give us the selection object when running native ShadowDOM
        // with fallback support for the entire window which would imply Shady
        if (this.$input) {
          // native API
          if (this.$input.getSelection) {
            return this.$input.getSelection();
          } // ponyfill from google, check that we don't already have a range
          else if (typeof this.$input.endOffset === "undefined" && (0, _utils.getRange)(this.$input)) {
              return (0, _utils.getRange)(this.$input);
            }
        } // missed on both, hope the normal one will work


        return window.getSelection();
      }
      /**
       * Get a normalized range based on current selection
       */

    }, {
      key: "getRange",
      value: function getRange() {
        var sel = this.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          return sel.getRangeAt(0);
        } else if (sel) {
          return sel;
        } else false;
      }
      /**
       * Reset focus back on the input area while closing the popover
       */

    }, {
      key: "resetFocusOnInput",
      value: function resetFocusOnInput() {
        this.opened = false; // trap to ensure we don't open the popover when we mean to close it

        this._ignoreFocusOpen = true; // focus the input, can't on a range though

        if (typeof this.$input.endOffset === "undefined") {
          this.$input.focus();

          if (this.$input.getAttribute("contenteditable") != null) {
            // generate a fake range at the end of the input so that we can place
            // the cursor where the user expects (end of the input area)
            var range = document.createRange();
            var sel = this.getSelection();
            range.setEnd(this.$input.childNodes[0], this.$input.innerText.length);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
          }
        }
      }
      /**
       * handle item selection and reset focus
       */

    }, {
      key: "itemSelect",
      value: function itemSelect(e) {
        // get value from the button selected
        this.value = e.target.parentNode.getAttribute("value"); // inject that value into the contenteditable

        if (!this.hideInput) {
          this.$input.innerText = this.value;
        }

        this.dispatchEvent(new CustomEvent("item-selected", {
          detail: {
            value: this.value
          }
        })); // ensure the _clicking lock is removed as we need to close popover

        this._clicking = false; // correctly focus the input area now w/ the new value set

        this.resetFocusOnInput();
      }
      /**
       * LitElement convention
       */

    }, {
      key: "updated",
      value:
      /**
       * LitElement life cycle - property changed
       */
      function updated(changedProperties) {
        var _this4 = this;

        changedProperties.forEach(function (oldValue, propName) {
          // notify others that our value has changed if they want to use this
          // as an input to feed their tag
          if (propName == "value") {
            _this4.dispatchEvent(new CustomEvent("".concat(propName, "-changed"), {
              detail: {
                value: _this4[propName]
              }
            }));
          } // when we open, force popover to position correctly


          if (propName == "opened" && _this4.opened) {
            _this4.shadowRoot.querySelector("simple-popover").updatePosition();

            setTimeout(function () {
              if (_this4.selectionPosition && _this4.getRange()) {
                _this4.$input = _this4.getRange(); // special support for native inputs

                if (["TEXTAREA", "INPUT"].includes(document.activeElement.tagName)) {
                  _this4.$input = document.activeElement;
                }

                _this4.shadowRoot.querySelector("simple-popover").target = _this4.$input;

                _this4.shadowRoot.querySelector("simple-popover").updatePosition();
              }
            }, 0);
          } // if we have new items do advanced processing of the items


          if (propName == "items" && _this4.items.length > 0 && !_this4._ignore) {
            _this4._ignore = true;

            for (var i = 0; i < _this4.items.length; i++) {
              // oh... your going to enjoy this one..
              // convert ALL objcet keys into a searchable string called title
              if (!_this4.items[i].title) {
                _this4.items[i].title = Object.keys(_this4.items[i]).map(function (key) {
                  return key !== "icon" ? _this4.items[i][key] : false; // skip icon since it is visual
                }).join(" ");
              } // if we have an icon, inject icon loading imports


              if (_this4.items[i].icon) {
                new Promise(function (res, rej) {
                  return _require.default(["../simple-icon/lib/simple-icon-lite.js"], res, rej);
                });
                new Promise(function (res, rej) {
                  return _require.default(["../simple-icon/lib/simple-icons.js"], res, rej);
                });
              }
            }

            _this4._ignore = false;
          }
        });
      }
    }], [{
      key: "styles",
      get:
      /**
       * LitElement convention
       */
      function get() {
        return [(0, _index.css)(_templateObject8_218a09a0942811ecb1937969798b231a || (_templateObject8_218a09a0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: inline-flex;\n        }\n        :host([hidden]) {\n          display: none;\n        }\n        #input {\n          border: none;\n          min-width: 10px;\n          outline: none;\n          padding: 0 2px;\n        }\n        simple-popover {\n          max-width: var(--simple-autocomplete-popover-max-width, 50vw);\n          padding: 0;\n          --simple-popover-padding: 0px;\n          --simple-popover-border: none;\n          --simple-popover-border-color: #eeeeee;\n          --simple-popover-border-radius: 0;\n        }\n        ul {\n          margin: 0;\n          padding: 0;\n          border: var(--simple-autocomplete-ul-border, 1px solid #eeeeee);\n        }\n        li {\n          list-style: none;\n          padding: 0;\n          margin: 0;\n          display: block;\n        }\n        button {\n          font-size: var(--simple-autocomplete-font-size, 14px);\n          line-height: var(--simple-autocomplete-line-height, 1.5);\n          display: block;\n          border: none;\n          border-bottom: var(\n            --simple-autocomplete-border-bottom,\n            1px solid #eeeeee\n          );\n          padding: 6px 12px;\n          font-weight: 500;\n          width: 100%;\n          background-color: transparent;\n          max-height: var(\n            --simple-autocomplete-max-height,\n            54px\n          ); /* font * line-height * 2 + padding */\n          text-overflow: ellipsis;\n          overflow: hidden;\n          text-align: left;\n          color: var(--simple-autocomplete-color, #333333);\n        }\n        ul li:first-child button {\n          border-top: none;\n        }\n        button:hover,\n        button:active,\n        button:focus {\n          background-color: var(\n            --simple-autocomplete-button-hover-background-color,\n            #eeeeee\n          );\n          color: var(--simple-autocomplete-hover-color, #000000);\n          outline: none;\n        }\n        .no-results {\n          font-size: var(--simple-autocomplete-font-size, 16px);\n          padding: 4px 8px;\n        }\n        simple-icon-lite {\n          color: var(--simple-autocomplete-color, #333333);\n          --simple-icon-width: var(--simple-autocomplete-icon-size, 16px);\n          --simple-icon-height: var(--simple-autocomplete-icon-size, 16px);\n          margin-right: 2px;\n          vertical-align: middle;\n        }\n      "])))];
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          opened: {
            type: Boolean,
            reflect: true
          },
          hideInput: {
            type: Boolean,
            attribute: "hide-input"
          },
          selectionPosition: {
            type: Boolean,
            attribute: "selection-position"
          },
          value: {
            type: String
          },
          itemLimit: {
            type: Number,
            attribute: "item-limit"
          }
        };
      }
      /**
       * Convention we use
       */

    }, {
      key: "tag",
      get: function get() {
        return "simple-autocomplete";
      }
    }]);
    return SimpleAutocomplete;
  }((0, _simpleFilter.SimpleFilterMixin)(_index.LitElement));

  _exports.SimpleAutocomplete = SimpleAutocomplete;
  customElements.define(SimpleAutocomplete.tag, SimpleAutocomplete);
});