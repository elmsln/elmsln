define(["exports", "../../../lit/index.js"], function (_exports, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.AbsolutePositionStateManager = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  // register globally so we can make sure there is only one
  window.AbsolutePositionStateManager = window.AbsolutePositionStateManager || {}; // request if this exists. This helps invoke element existing in dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through same modal

  window.AbsolutePositionStateManager.requestAvailability = function () {
    if (!window.AbsolutePositionStateManager.instance) {
      window.AbsolutePositionStateManager.instance = document.createElement("absolute-position-state-manager");
      var instance = window.AbsolutePositionStateManager.instance;
      document.body.appendChild(instance);
    }

    return window.AbsolutePositionStateManager.instance;
  };
  /**
   * `absolute-position-state-manager`
   * manages state of multiple absolute-positioned elements on a page
   *
   * @element absolute-position-state-manager
   */


  var AbsolutePositionStateManager = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(AbsolutePositionStateManager, _LitElement);

    var _super = _createSuper(AbsolutePositionStateManager);

    /**
     * Makes sure there is a utility ready and listening for elements.
     */
    function AbsolutePositionStateManager() {
      var _this;

      babelHelpers.classCallCheck(this, AbsolutePositionStateManager);
      _this = _super.call(this);
      _this.elements = [];
      _this.__timeout = false;
      _this.__observer = new MutationObserver(function (mutations) {
        return _this.checkMutations(mutations);
      });
      return _this;
    }
    /**
     * Loads element into array
     * @param {object} element to be added
     */


    babelHelpers.createClass(AbsolutePositionStateManager, [{
      key: "loadElement",
      value: function loadElement(el) {
        //only have event listeners when there are elements using manager
        if (this.elements.length < 1) {
          this.__observer.observe(document, {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
          });

          this.updateElements();
          document.addEventListener("load", this.updateElements);
          window.addEventListener("resize", this._handleResize);
        }

        if (this.elements.filter(function (element) {
          return element === el;
        }).length < 1) {
          this.elements.push(el);
          el.style.top = 0;
          el.style.left = 0;
        }

        this.positionElement(el);
      }
      /**
       * Unloads element from array
       * @param {object} element to be removed
       */

    }, {
      key: "unloadElement",
      value: function unloadElement(el) {
        this.elements = this.elements.filter(function (element) {
          return element !== el;
        });
        if (this.elements.length < 1) this.removeEventListeners();
      }
      /**
       * handles resize event
       */

    }, {
      key: "_handleScroll",
      value: function _handleScroll() {
        if (this.__timeout2) clearTimeout(this.__timeout2);
        this.__timeout2 = setTimeout(window.AbsolutePositionStateManager.instance.updateStickyElements(), 1000);
      }
      /**
       * handles resize event
       */

    }, {
      key: "_handleResize",
      value: function _handleResize() {
        if (this.__timeout) clearTimeout(this.__timeout);
        this.__timeout = setTimeout(window.AbsolutePositionStateManager.instance.updateElements(), 250);
      }
      /**
       * Checks if there are any changes other than to
       * element's position and update accordioningly.
       * This is needed so that positioning elements
       * doesn't trigger an infinite loop of updates.
       *
       * @param {array} mutation records
       * @return {void}
       */

    }, {
      key: "checkMutations",
      value: function checkMutations(mutations) {
        var _this2 = this;

        var update = false;
        mutations.forEach(function (mutation) {
          if (update) return;
          update = update || !(mutation.type === "attributes" && mutation.attributeName === "style" && _this2.elements.includes(mutation.target));
        });

        if (update) {
          if (this.__timeout) clearTimeout(this.__timeout);
          this.__timeout = setTimeout(window.AbsolutePositionStateManager.instance.updateElements(), 250);
        }
      }
      /**
       * Returns target element that this element is anchored to. It is
       * either element given by `for` attribute, or immediate parent
       * of element.
       *
       * Uses `target` object if specified.
       * If not, queries document for elements with id specified in `for` attribute.
       * If there is more than one element that matches, gets closest matching element.
       *
       * @param {object} element using absolute-position behavior
       * @return {object} target element for positioning
       */

    }, {
      key: "findTarget",
      value: function findTarget(el) {
        var selector = "#" + el.for,
            target = el.target,
            ancestor = el;

        while (!!el.for && !target && !!ancestor && !!ancestor.parentNode && ancestor !== document) {
          ancestor = ancestor.parentNode;
          target = ancestor ? ancestor.querySelector(selector) : undefined;
          if (ancestor.nodeType === 11) ancestor = ancestor.host;
          target = !target && ancestor ? ancestor.querySelector(selector) : target;
        }

        return target;
      }
      /**
       * Removes event listeners
       * @return {void}
       */

    }, {
      key: "removeEventListeners",
      value: function removeEventListeners() {
        if (this.__observer && this.__observer.disconnect) this.__observer.disconnect();
        document.removeEventListener("load", this.updateElements);
        window.removeEventListener("resize", this._handleResize);
        if (this.__watchSticky) window.removeEventListener("scroll", this._handleScroll);
      }
      /**
       * Updates position for all elements on page.
       * @return {void}
       */

    }, {
      key: "updateElements",
      value: function updateElements() {
        var _this3 = this;

        this.elements.forEach(function (element) {
          return _this3.positionElement(element);
        });
        this.loadSticky();
      }
      /**
       * Updates position for all elements on page.
       * @return {void}
       */

    }, {
      key: "updateStickyElements",
      value: function updateStickyElements() {
        var _this4 = this;

        this.elements.forEach(function (element) {
          if (element.sticky) _this4.positionElement(element);
        });
      }
      /**
       * Only listen for scrolling if there is a sticky element
       * @return {void}
       */

    }, {
      key: "loadSticky",
      value: function loadSticky() {
        //only have event listeners when there are elements using manager
        if (!this.__watchSticky && this.elements.filter(function (el) {
          return el.sticky;
        }).length > 0) {
          this.__watchSticky = true;
          window.addEventListener("scroll", this._handleScroll);
        } else if (this.__watchSticky && this.elements.filter(function (el) {
          return el.sticky;
        }).length < 1) {
          window.removeEventListener("scroll", this._handleScroll);
          this.__watchSticky = false;
        }
      }
    }, {
      key: "_getParentNode",
      value: function _getParentNode(node) {
        var parent = node.parentNode;

        if (parent !== undefined && parent !== null && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          parent = parent.host;
        }

        return parent;
      }
      /**
       * Gets an updated position based on target.
       * @param {object} element using absolute-position behavior
       * @return {void}
       */

    }, {
      key: "positionElement",
      value: function positionElement(el) {
        //set up element's default position
        if (!el.position) {
          el.position = "bottom";
        }

        el.style.position = "absolute";
        if (!el.style.top) el.style.top = "0px";
        if (!el.style.left) el.style.left = "0px"; //continue only if there is a target and a parent

        var target = this.findTarget(el);
        var parent = el.offsetParent;
        var t = target && target.getBoundingClientRect ? target.getBoundingClientRect() : {};
        if (!target || !parent) return; //if justify is set, re-adjust element to
        //target width before getting other dimensions

        if (el.justify) el.style.width = "".concat(t.width, "px"); //get body, parent, and element dimensions

        var w = document.body.getBoundingClientRect(),
            p = parent.getBoundingClientRect(),
            e = el.getBoundingClientRect(),
            //optional offset property
        offset = parseFloat(el.offset),
            //converts a value in px to a float
        pxToNum = function pxToNum(px) {
          return parseFloat(px.replace("px", ""));
        },
            //place element before vertically?
        vertical = function vertical() {
          var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : el.position;
          return pos !== "left" && pos !== "right";
        },
            //place element before target?
        before = function before() {
          var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : el.position;
          return pos === "left" || pos === "top";
        },

        /**
         * aligns horizontally if position is vertical
         * or aligns vertically if position is horizontal
         */
        setAlign = function setAlign() {
          var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : vertical(el.position);

          //fits element within parent's boundaries
          var min = v ? pxToNum(el.style.left) - e.left : pxToNum(el.style.top) - e.top,
              startAt = v ? "left" : "top",
              distance = function distance(rect) {
            return v ? rect.width : rect.height;
          },
              max = min + distance(w) - distance(e),
              align = min,
              bounds;

          if (el.positionAlign === "end") {
            align += t[startAt] - distance(e) + distance(t);
          } else if (el.positionAlign === "start") {
            align += t[startAt];
          } else {
            align += t[startAt] - distance(e) / 2 + distance(t) / 2;
          }

          bounds = el.fitToVisibleBounds ? Math.max(min, Math.min(max, align)) : align; //if element size > parent, align where parent begins

          return bounds;
        },
            //gets coordinate for top ot left position
        getCoord = function getCoord() {
          var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : el.position;
          var coord,
              adjust = vertical(pos) ? pxToNum(el.style.top) - e.top : pxToNum(el.style.left) - e.left,
              //determine whether overflowed content should be part of height/width calculations
          eh = !el.allowOverlap && window.getComputedStyle(el, null).overflowY == "visible" ? Math.max(e.height, el.scrollHeight) : e.height,
              ew = !el.allowOverlap && window.getComputedStyle(el, null).overflowX == "visible" ? Math.max(e.width, el.scrollWidth) : e.width; //calculate coordinate based on position property,
          // offset property, and whether overflowed conent should overlap the target

          coord = pos === "top" ? t.top + adjust - eh - offset : pos === "left" ? t.left + adjust - ew - offset : t[pos] + adjust + offset;
          return coord;
        },
            //determines if element fits on screen in the desired position
        isFit = function isFit() {
          var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : el.position;

          //determines if room for element between parent and target
          var distance = function distance(rect) {
            return vertical(pos) ? e.height + offset : e.width + offset;
          };

          return before(pos) ? t[pos] - w[pos] > distance : w[pos] - t[pos] > distance; //if no room, return original position
        },
            //should element's position flip to fit element within bounds
        flip = el.fitToVisibleBounds !== false && !isFit(el.position),
            //if position needs to be flipped, order of preference for new position
        flipData = {
          top: ["bottom", "left", "right"],
          left: ["right", "top", "bottom"],
          bottom: ["top", "right", "left"],
          right: ["left", "bottom", "top"]
        };
        /*
         * fits element according to specified postion,
         * or finds an alternative position that fits
         */


        if (flip && isFit(flipData[el.position][0])) {
          el.position = flipData[el.position][0];
        } else if (flip && isFit(flipData[el.position][1])) {
          el.position = flipData[el.position][1];
        } else if (flip && isFit(flipData[el.position][2])) {
          el.position = flipData[el.position][2];
        } //get top and left positions


        var tt = vertical(el.position) ? getCoord() : setAlign(),
            ll = vertical(el.position) ? setAlign() : getCoord(); //if element is sticky, adjust top posiiton accordingly

        if (el.sticky) {
          var scrollTop = window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop,
              maxH = window.innerHeight,
              eheight = e.height === 0 && el.children && el.children[0] ? el.children[0].offsetHeight : e.height,
              stickyT = t.top - e.height < 0 && t.top + t.height > 20 + eheight,
              stickyB = t.top + t.height + e.height > maxH && t.top < maxH - eheight;
          if (el.position === "top" && stickyT) tt = scrollTop - parent.offsetTop + (eheight - e.height);
          if (el.position === "bottom" && stickyB) tt = scrollTop + maxH - parent.offsetTop - eheight;
        } //set top and left positions


        el.style.top = tt + "px";
        el.style.left = ll + "px"; //provide positions for element and target (in case furthor positioning adjustments are needed)

        el.__positions = {
          self: e,
          parent: p,
          target: t
        };
      }
      /**
       * life cycle, element is removed from DOM
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.removeEventListeners();
        babelHelpers.get(babelHelpers.getPrototypeOf(AbsolutePositionStateManager.prototype), "disconnectedCallback", this).call(this);
      }
    }], [{
      key: "tag",
      get:
      /**
       * Store tag name to make it easier to obtain directly.
       */
      function get() {
        return "absolute-position-state-manager";
      } // properties available to custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Stores an array of all elements using manager.
           */
          elements: {
            type: Array
          },

          /**
           * mutation observer
           */
          __observer: {
            type: Object
          },

          /**
           * resize timeout
           */
          __timeout: {
            type: Object
          },

          /**
           * resize timeout
           */
          __timeout2: {
            type: Object
          }
        };
      }
    }]);
    return AbsolutePositionStateManager;
  }(_index.LitElement);

  _exports.AbsolutePositionStateManager = AbsolutePositionStateManager;
  customElements.define(AbsolutePositionStateManager.tag, AbsolutePositionStateManager);
});