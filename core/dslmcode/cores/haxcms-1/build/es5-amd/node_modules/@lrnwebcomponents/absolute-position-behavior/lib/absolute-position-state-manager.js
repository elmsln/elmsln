define(["exports", "../../../lit-element/lit-element.js"], function (_exports, _litElement) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.AbsolutePositionStateManager = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  // register globally so we can make sure there is only one
  window.AbsolutePositionStateManager = window.AbsolutePositionStateManager || {}; // request if this exists. This helps invoke element existing in dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through same modal

  window.AbsolutePositionStateManager.requestAvailability = function () {
    if (!window.AbsolutePositionStateManager.instance) {
      window.AbsolutePositionStateManager.instance = document.createElement("absolute-position-state-manager");
      var instance = window.AbsolutePositionStateManager.instance;
      document.body.appendChild(instance);
    }

    return window.AbsolutePositionStateManager.instance;
  };
  /**
   * `absolute-position-state-manager`
   * manages state of multiple absolute-positioned elements on a page
   *
   * @element absolute-position-state-manager
   */


  var AbsolutePositionStateManager = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(AbsolutePositionStateManager, _LitElement);

    var _super = _createSuper(AbsolutePositionStateManager);

    babelHelpers.createClass(AbsolutePositionStateManager, null, [{
      key: "tag",

      /**
       * Store tag name to make it easier to obtain directly.
       */
      get: function get() {
        return "absolute-position-state-manager";
      } // properties available to custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Stores an array of all elements using manager.
           */
          elements: {
            type: Array
          },

          /**
           * mutation observer
           */
          __observer: {
            type: Object
          },

          /**
           * resize timeout
           */
          __timeout: {
            type: Object
          }
        };
      }
      /**
       * Makes sure there is a utility ready and listening for elements.
       */

    }]);

    function AbsolutePositionStateManager() {
      var _this;

      babelHelpers.classCallCheck(this, AbsolutePositionStateManager);
      _this = _super.call(this);
      _this.elements = [];
      _this.__timeout = false;
      _this.__observer = new MutationObserver(function (mutations) {
        return _this.checkMutations(mutations);
      });
      return _this;
    }
    /**
     * Loads element into array
     * @param {object} element to be added
     */


    babelHelpers.createClass(AbsolutePositionStateManager, [{
      key: "loadElement",
      value: function loadElement(el) {
        //only have event listeners when there are elements using manager
        if (this.elements.length < 1) {
          this.__observer.observe(document, {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
          });

          this.updateElements();
          document.addEventListener("load", this.updateElements);
          window.addEventListener("resize", this._handleResize);
        }

        this.elements.push(el);
        el.style.top = 0;
        el.style.left = 0;
        this.positionElement(el);
      }
      /**
       * Unloads element from array
       * @param {object} element to be removed
       */

    }, {
      key: "unloadElement",
      value: function unloadElement(el) {
        this.elements.filter(function (element) {
          return element === el;
        });
        if (this.elements.length < 1) this.removeEventListeners();
      }
      /**
       * handles resize event
       */

    }, {
      key: "_handleResize",
      value: function _handleResize() {
        if (this.__timeout) clearTimeout(this.__timeout);
        this.__timeout = setTimeout(window.AbsolutePositionStateManager.instance.updateElements(), 250);
      }
      /**
       * Checks if there are any chances other than to
       * element's position and updates accordioning.
       * This is needed so that positioning elements
       * doesn't trigger an infinite loop of updates.
       *
       * @param {array} mutation records
       * @return {void}
       */

    }, {
      key: "checkMutations",
      value: function checkMutations(mutations) {
        var _this2 = this;

        var update = false;
        mutations.forEach(function (mutation) {
          if (update) return;
          update = update || !(mutation.type === "attributes" && mutation.attributeName === "style" && _this2.elements.includes(mutation.target));
        });
        if (update) this.updateElements();
      }
      /**
       * Returns target element that this element is anchored to. It is
       * either element given by `for` attribute, or immediate parent
       * of element.
       *
       * Uses `target` object if specified.
       * If not, queries document for elements with id specified in `for` attribute.
       * If there is more than one element that matches, gets closest matching element.
       *
       * @param {object} element using absolute-position behavior
       * @return {object} target element for positioning
       */

    }, {
      key: "findTarget",
      value: function findTarget(el) {
        var selector = "#" + el.for,
            target = el.target,
            ancestor = el;

        while (el.for !== undefined && target === null && ancestor !== null && ancestor.parentNode !== null && ancestor !== document) {
          ancestor = ancestor.parentNode;
          if (ancestor.nodeType === 11) ancestor = ancestor.host;
          target = ancestor ? ancestor.querySelector(selector) : null;
        }

        return target;
      }
      /**
       * Removes event listeners
       * @return {void}
       */

    }, {
      key: "removeEventListeners",
      value: function removeEventListeners() {
        if (this.__observer && this.__observer.disconnect) this.__observer.disconnect();
        document.removeEventListener("load", this.updateElements);
        window.removeEventListener("resize", this._handleResize);
      }
      /**
       * Updates position for all elements on page.
       * @return {void}
       */

    }, {
      key: "updateElements",
      value: function updateElements() {
        var _this3 = this;

        this.elements.forEach(function (element) {
          return _this3.positionElement(element);
        });
      }
    }, {
      key: "_getParentNode",
      value: function _getParentNode(node) {
        var parent = node.parentNode;

        if (parent !== undefined && parent !== null && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          parent = parent.host;
        }

        return parent;
      }
      /**
       * Gets an updated position based on target.
       * @param {object} element using absolute-position behavior
       * @return {void}
       */

    }, {
      key: "positionElement",
      value: function positionElement(el) {
        if (!el.position) {
          el.position = "bottom";
        }

        var target = this.findTarget(el),
            parent = el.offsetParent;
        if (!target || !parent) return;

        var offset = parseFloat(el.offset),
            w = document.body.getBoundingClientRect(),
            p = parent.getBoundingClientRect(),
            t = target.getBoundingClientRect(),
            e = el.getBoundingClientRect(),
            //place element before vertically?
        vertical = function vertical() {
          var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : el.position;
          return pos !== "left" && pos !== "right";
        },
            //place element before target?
        before = function before() {
          var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : el.position;
          return pos === "left" || pos === "top";
        },

        /**
         * aligns horizontally if position is vertical
         * or aligns vertically if position is horizontal
         */
        setAlign = function setAlign() {
          var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : vertical(el.position);

          //fits element within parent's boundaries
          var pxToNum = function pxToNum(px) {
            return parseFloat(px.replace("px", ""));
          },
              min = v ? pxToNum(el.style.left) - e.left : pxToNum(el.style.top) - e.top,
              startAt = v ? "left" : "top",
              distance = function distance(rect) {
            return v ? rect.width : rect.height;
          },
              max = min + distance(w) - distance(e),
              align = min;

          if (el.positionAlign === "end") {
            align += t[startAt] - distance(e) + distance(t);
          } else if (el.positionAlign === "start") {
            align += t[startAt];
          } else {
            align += t[startAt] - distance(e) / 2 + distance(t) / 2;
          }

          return el.fitToVisibleBounds ? Math.max(min, Math.min(max, align)) + "px" : align + "px"; //if element size > parent, align where parent begins
        },
            getCoord = function getCoord() {
          var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : el.position;

          var pxToNum = function pxToNum(px) {
            return parseFloat(px.replace("px", ""));
          },
              adjust = vertical(pos) ? pxToNum(el.style.top) - e.top : pxToNum(el.style.left) - e.left;

          return pos === "top" ? t.top + adjust - e.height - offset + "px" : pos === "left" ? t.left + adjust - e.width - offset + "px" : t[pos] + adjust + offset + "px";
        },
            isFit = function isFit() {
          var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : el.position;

          //determines if room for element between parent and target
          var distance = function distance(rect) {
            return vertical(pos) ? e.height + offset : e.width + offset;
          };

          return before(pos) ? t[pos] - w[pos] > distance : w[pos] - t[pos] > distance; //if no room, return original position
        },
            flip = el.fitToVisibleBounds !== false && !isFit(el.position),
            flipData = {
          top: ["bottom", "left", "right"],
          left: ["right", "top", "bottom"],
          bottom: ["top", "right", "left"],
          right: ["left", "bottom", "top"]
        };

        el.style.position = "absolute";
        /*
         * fits element according to specified postion,
         * or finds an alternative position that fits
         */

        if (flip && isFit(flipData[el.position][0])) {
          el.position = flipData[el.position][0];
        } else if (flip && isFit(flipData[el.position][1])) {
          el.position = flipData[el.position][1];
        } else if (flip && isFit(flipData[el.position][2])) {
          el.position = flipData[el.position][2];
        } else {
          el.style.top = vertical(el.position) ? getCoord() : setAlign();
          el.style.left = vertical(el.position) ? setAlign() : getCoord(); //provide positions for element and target (in case furthor positioning adjustments are needed)

          el.__positions = {
            self: e,
            parent: p,
            target: t
          };
        }
      }
      /**
       * life cycle, element is removed from DOM
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.removeEventListeners();
        babelHelpers.get(babelHelpers.getPrototypeOf(AbsolutePositionStateManager.prototype), "disconnectedCallback", this).call(this);
      }
    }]);
    return AbsolutePositionStateManager;
  }(_litElement.LitElement);

  _exports.AbsolutePositionStateManager = AbsolutePositionStateManager;
  window.customElements.define(AbsolutePositionStateManager.tag, AbsolutePositionStateManager);
});