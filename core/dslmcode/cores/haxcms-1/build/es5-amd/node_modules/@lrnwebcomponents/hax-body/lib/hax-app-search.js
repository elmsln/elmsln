define(["exports","require","../../../lit-element/lit-element.js","../../simple-colors/simple-colors.js","../../../@polymer/iron-ajax/iron-ajax.js","../../utils/utils.js"],function(_exports,_require,_litElement,_simpleColors,_ironAjax,_utils){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HaxAppSearch=void 0;_require=babelHelpers.interopRequireWildcard(_require);function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1,source;i<arguments.length;i++){source=null!=arguments[i]?arguments[i]:{};if(i%2){ownKeys(Object(source),!0).forEach(function(key){babelHelpers.defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}function _templateObject3_183ec65072ac11eab01767e8389e9c27(){var data=babelHelpers.taggedTemplateLiteral(["\n            <hax-app-search-result\n              image=\"","\"\n              title=\"","\"\n              details=\"","\"\n              .map=\"","\"\n              type=\"","\"\n            ></hax-app-search-result>\n          "]);_templateObject3_183ec65072ac11eab01767e8389e9c27=function _templateObject3_183ec65072ac11eab01767e8389e9c27(){return data};return data}function _templateObject2_183ec65072ac11eab01767e8389e9c27(){var data=babelHelpers.taggedTemplateLiteral(["\n      <iron-ajax\n        id=\"request\"\n        handle-as=\"json\"\n        @last-response-changed=\"","\"\n        @loading-changed=\"","\"\n        debounce-duration=\"200\"\n      ></iron-ajax>\n      <hax-app-search-inputs\n        id=\"searchinput\"\n        .label=\"","\"\n        .schema=\"","\"\n        @search-values-changed=\"","\"\n      ></hax-app-search-inputs>\n      <hax-app-pagination\n        id=\"pagerbottom\"\n        .request-data=\"","\"\n        .pagination=\"","\"\n      ></hax-app-pagination>\n      <hexagon-loader\n        size=\"medium\"\n        item-count=\"4\"\n        ?loading=\"","\"\n        aria-roledescription=\"Loading\"\n      ></hexagon-loader>\n      <div id=\"itemlist\">\n        ","\n      </div>\n    "]);_templateObject2_183ec65072ac11eab01767e8389e9c27=function _templateObject2_183ec65072ac11eab01767e8389e9c27(){return data};return data}function _templateObject_183ec65072ac11eab01767e8389e9c27(){var data=babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n        }\n        hexagon-loader {\n          display: none;\n          justify-content: center;\n          width: 100%;\n          z-index: 1000;\n          position: absolute;\n          --hexagon-color: var(--hax-color-bg-accent, #0085ba);\n        }\n        hexagon-loader[loading] {\n          display: block;\n          opacity: 0.8;\n        }\n        .card-content {\n          padding: 16px;\n        }\n        .card-content p {\n          padding: 0;\n          margin: 0;\n        }\n        #itemlist {\n          min-height: 172px;\n          border: 1px solid #222222;\n        }\n        hax-app-search-inputs {\n          min-height: 80px;\n          padding: 0 16px;\n        }\n        hax-app-pagination {\n          min-height: 32px;\n          font-size: 12.8px;\n          display: none;\n          justify-content: flex-end;\n          justify-content: center;\n        }\n      "]);_templateObject_183ec65072ac11eab01767e8389e9c27=function _templateObject_183ec65072ac11eab01767e8389e9c27(){return data};return data}/**
 * `hax-app-search`
 * `An element that brokers the visual display of a listing of material from an end point. The goal is to normalize data from some location which is media centric. This expects to get at least enough data in order to form a grid of items which are selectable. It's also generically implemented so that anything can be hooked up as a potential source for input (example: youtube API or custom in-house solution). The goal is to return enough info via fired event so that we can tell hax-body that the user selected a tag, properties, slot combination so that hax-body can turn the selection into a custom element / element injected into the hax-body slot.`
 * @microcopy - the mental model for this element
 * - hax-source - a backend that can supply items for selection by the user
 * - hax-body - the text are ultimately we are trying to insert this item into
 * @element hax-app-search
 */var HaxAppSearch=/*#__PURE__*/function(_winEventsElement){babelHelpers.inherits(HaxAppSearch,_winEventsElement);babelHelpers.createClass(HaxAppSearch,null,[{key:"styles",/**
   * LitElement constructable styles enhancement
   */get:function get(){return[].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(HaxAppSearch),"styles",this)),[(0,_litElement.css)(_templateObject_183ec65072ac11eab01767e8389e9c27())])}}]);function HaxAppSearch(){var _this;babelHelpers.classCallCheck(this,HaxAppSearch);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HaxAppSearch).call(this));// window based events managed in winEventsElement
_this.__winEvents={"hax-store-property-updated":"_haxStorePropertyUpdated"};_this.auto=!1;_this.headers={};_this.method="GET";_this.loading=!1;_this.requestData={};_this.media=[];_this.resultMap={};new Promise(function(res,rej){return _require.default(["../../simple-fields/lib/simple-fields-field.js"],res,rej)});new Promise(function(res,rej){return _require.default(["../../simple-fields/lib/simple-fields-container.js"],res,rej)});new Promise(function(res,rej){return _require.default(["../../hexagon-loader/hexagon-loader.js"],res,rej)});new Promise(function(res,rej){return _require.default(["./hax-app-search-inputs.js"],res,rej)});new Promise(function(res,rej){return _require.default(["./hax-app-search-result.js"],res,rej)});return _this}/**
   * LitElement life cycle - render callback
   */babelHelpers.createClass(HaxAppSearch,[{key:"render",value:function render(){return(0,_litElement.html)(_templateObject2_183ec65072ac11eab01767e8389e9c27(),this.requestDataChanged,this._loadingChanged,this.label,this.searchSchema,this._searchValuesChanged,this.requestData,this.pagination,this.loading,this.media.map(function(resultData){return(0,_litElement.html)(_templateObject3_183ec65072ac11eab01767e8389e9c27(),resultData.image,resultData.title,resultData.details,resultData.map,resultData.type)}))}},{key:"requestDataChanged",value:function requestDataChanged(e){this.requestData=e.detail.value}},{key:"updated",value:function updated(changedProperties){var _this2=this;changedProperties.forEach(function(oldValue,propName){if(["auto","method","headers"].includes(propName)){_this2.shadowRoot.querySelector("#request")[propName]=_this2[propName]}if("requestEndPoint"==propName){_this2.shadowRoot.querySelector("#request").url=_this2[propName]}if("requestParams"==propName){_this2.shadowRoot.querySelector("#request").params=_this2[propName]}if("activeApp"==propName){_this2._resetAppSearch(_this2[propName],oldValue)}if("requestData"==propName){_this2._requestDataChanged(_this2[propName],oldValue)}})}},{key:"_searchValuesChanged",/**
   * Search input was added.
   */value:function _searchValuesChanged(e){var requestParams=this.requestParams;for(var property in e.detail){// dont send empty params in the request
if(""!=e.detail[property]){requestParams[property]=e.detail[property]}}this.requestParams=_objectSpread({},this.requestParams)}/**
   * Active app has changed.
   */},{key:"_resetAppSearch",value:function _resetAppSearch(newValue,oldValue){if(babelHelpers.typeof(newValue)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!==newValue){var app=newValue,requestParams={};this.label=app.details.title;// disable auto for a moment while we switch inputs
this.auto=!1;this.media=[];// see if we have any global settings for connections like api keys
if(babelHelpers.typeof(app.connection.data)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){requestParams=app.connection.data}// see if the browse endpoint has local overrides
if(babelHelpers.typeof(app.connection.operations.browse.data)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){requestParams=Object.assign(requestParams,app.connection.operations.browse.data)}this.method=app.connection.operations.browse.method;this.headers={};if(babelHelpers.typeof(app.connection.headers)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.headers=app.connection.headers}// ensure we overwrite completely
this.requestParams={};this.requestParams=requestParams;// build the request end point
var requestEndPoint=app.connection.protocol+"://"+app.connection.url;// ensure we build a url correctly
if("/"!=requestEndPoint.substr(requestEndPoint.length-1)){requestEndPoint+="/"}// support local end point modification
if(babelHelpers.typeof(app.connection.operations.browse.endPoint)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){requestEndPoint+=app.connection.operations.browse.endPoint}this.requestEndPoint=requestEndPoint;// ensure correct wipe of the search area assuming it has a search
this.searchSchema={};var searchSchema={properties:{}};if(babelHelpers.typeof(app.connection.operations.browse.search)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){searchSchema.properties=app.connection.operations.browse.search;this.searchSchema=searchSchema}this.resultMap=app.connection.operations.browse.resultMap;// map pagination if it has it (it better..)
this.pagination={};if(babelHelpers.typeof(app.connection.operations.browse.pagination)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.pagination=app.connection.operations.browse.pagination}// reset the auto flag
if(babelHelpers.typeof(app.connection.auto)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.auto=app.connection.auto}else{this.auto=!0}}}/**
   * Store updated, sync.
   */},{key:"_haxStorePropertyUpdated",value:function _haxStorePropertyUpdated(e){if(e.detail&&babelHelpers.typeof(e.detail.value)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&e.detail.property){this[e.detail.property]=e.detail.value}}/**
   * Callback for when media has been updated via the end point
   */},{key:"_requestDataChanged",value:function _requestDataChanged(newValue,oldValue){if(this.resultMap&&this.resultMap.items&&{}!=babelHelpers.typeof(newValue)&&babelHelpers.typeof(oldValue)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var media=[],map=this.resultMap,data=[];// look for the items element to draw our data from at its root
if(babelHelpers.typeof(this._resolveObjectPath(map.items,newValue))!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){data=this._resolveObjectPath(map.items,newValue)}else{if(null!=newValue){data=newValue}}if(null!=data){// step through and translate response data into a form we can easily
// understand when stamping out our cards above.
for(var i=0;i<data.length;i++){media[i]={title:this._resolveObjectPath(map.preview.title,data[i]),details:this._resolveObjectPath(map.preview.details,data[i]),type:map.defaultGizmoType,map:{}};// strip HTML from details since it might contain complex content
if(babelHelpers.typeof(media[i].details)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=media[i].details){media[i].details=media[i].details.replace(/(<([^>]+)>)/gi,"")}// allow id to use deeper logic to split it back out
if(map.preview.id.constructor===Object){var tmp=this._resolveObjectPath(map.preview.id.property,data[i]);if("split"===map.preview.id.op){tmp=tmp.split(map.preview.id.delimiter);media[i].id=tmp[map.preview.id.position]}}else{media[i].id=this._resolveObjectPath(map.preview.id,data[i])}// image, while really useful is not required
if(babelHelpers.typeof(map.preview.image)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){media[i].image=this._resolveObjectPath(map.preview.image,data[i])}else if(babelHelpers.typeof(map.image)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){media[i].image=map.image}else{media[i].image=""}for(var prop in map.gizmo){// check for a _url_source modifier... stupid youtube and others.
if("_url_source"===prop){var _id="";if(babelHelpers.typeof(media[i].map.__id)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){_id=media[i].map.__id}else{_id=this._resolveObjectPath(map.gizmo.id,data[i])}media[i].map.source=map.gizmo._url_source.replace("<%= id %>",_id)}else{if(map.gizmo[prop].constructor===Object){var _tmp=this._resolveObjectPath(map.gizmo[prop].property,data[i]);if("split"===map.gizmo[prop].op){_tmp=_tmp.split(map.gizmo[prop].delimiter);media[i].map[prop]=_tmp[map.gizmo[prop].position];if("id"===prop){media[i].map.__id=media[i].map[prop]}}}else{media[i].map[prop]=this._resolveObjectPath(map.gizmo[prop],data[i])}}}// another sanity check, if we don't have a url but have a source bind that too
if(babelHelpers.typeof(media[i].map.url)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(media[i].map.source)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){media[i].map.url=media[i].map.source}// gizmo type is also supported in the mapping element itself
// Think an asset management backend as opposed to a specific
// type of asset like video. If the item coming across can
// effectively check what kind of gizmo is required for it
// to work then we need to support that asset declaring the
// gizmo type needed
if(babelHelpers.typeof(map.gizmo.type)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){media[i].type=this._resolveObjectPath(map.gizmo.type,data[i])}}// this will trigger an aggressive repaint of the items
this.media=[].concat(media)}}}},{key:"_loadingChanged",value:function _loadingChanged(e){this.loading=e.detail.value}/**
   * Helper to take a multi-dimensional object and convert
   * it's reference into the real value. This allows for variable input defined
   * in a string to actually hit the deeper part of an object structure.
   */},{key:"_resolveObjectPath",value:function _resolveObjectPath(path,obj){return path.split(".").reduce(function(prev,curr){return prev?prev[curr]:null},obj||self)}}],[{key:"tag",get:function get(){return"hax-app-search"}},{key:"properties",get:function get(){return{/**
       * Active app globally bound based on previous selection.
       */activeApp:{type:Object},/**
       * Immediatley perform a request.
       */auto:{type:Boolean},/**
       * Search schema for presenting a form of input.
       */searchSchema:{type:Object},/**
       * Custom headers for data binding from the App feed.
       */headers:{type:Object},/**
       * Custom method for requesting data (almost always will be GET)
       */method:{type:String},/**
       * loading
       */loading:{type:Boolean},/**
       * Media request data updated
       */requestData:{type:Object},/**
       * Media object, normalized.
       */media:{type:Array},requestEndPoint:{type:String},requestParams:{type:Object},resultMap:{type:Object}}}}]);return HaxAppSearch}((0,_utils.winEventsElement)(_simpleColors.SimpleColors));_exports.HaxAppSearch=HaxAppSearch;window.customElements.define(HaxAppSearch.tag,HaxAppSearch)});