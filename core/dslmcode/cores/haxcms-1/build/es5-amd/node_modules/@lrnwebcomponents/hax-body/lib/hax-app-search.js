define(["exports", "require", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/iron-ajax/iron-ajax.js", "../../simple-colors/simple-colors.js", "../../../@polymer/iron-list/iron-list.js"], function (_exports, _require, _polymerElement, _ironAjax, _simpleColors, _ironList) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxAppSearch = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_efeabaa0dedc11e9bf5a076df0f16721() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"simple-colors-shared-styles\">\n        :host {\n          display: block;\n        }\n        paper-button.item-wrapper {\n          margin: 0;\n          padding: 0;\n        }\n        paper-card {\n          padding: 0;\n          margin: 8px;\n          width: 240px;\n          font-size: 12px;\n          --paper-card-header: {\n            max-height: 160px;\n          }\n        }\n        @media screen and (min-width: 800px) {\n          paper-card {\n            font-size: 14px;\n          }\n        }\n        hexagon-loader {\n          height: 100%;\n          justify-content: center;\n          margin: 0 auto -200px;\n          z-index: 1000;\n          position: relative;\n          transition: 0.3s linear opacity, 0.3s linear visibility;\n          width: calc(100% - 32px);\n          opacity: 0;\n          visibility: visible;\n        }\n        hexagon-loader[loading] {\n          opacity: 1;\n        }\n        .card-content {\n          padding: 16px;\n        }\n        .card-content p {\n          padding: 0;\n          margin: 0;\n        }\n        #itemlist {\n          min-height: 172px;\n          border: 1px solid #222222;\n        }\n        hax-app-search-inputs {\n          min-height: 150px;\n          padding: 0 16px;\n        }\n        hax-app-pagination {\n          min-height: 32px;\n          font-size: 12.8px;\n          display: none;\n          justify-content: flex-end;\n          justify-content: center;\n        }\n      </style>\n\n      <iron-ajax\n        auto=\"[[auto]]\"\n        id=\"request\"\n        method=\"[[method]]\"\n        url=\"[[requestEndPoint]]\"\n        handle-as=\"json\"\n        headers=\"[[headers]]\"\n        params=\"[[requestParams]]\"\n        last-response=\"{{requestData}}\"\n        hidden=\"\"\n        loading=\"{{loading}}\"\n        debounce-duration=\"300\"\n      ></iron-ajax>\n      <hax-app-search-inputs\n        id=\"searchinput\"\n        label=\"[[label]]\"\n        schema=\"{{searchSchema}}\"\n        values=\"{{searchValues}}\"\n      ></hax-app-search-inputs>\n      <hax-app-pagination\n        id=\"pagerbottom\"\n        request-data=\"[[requestData]]\"\n        pagination=\"[[pagination]]\"\n      ></hax-app-pagination>\n      <hexagon-loader\n        size=\"small\"\n        loading$=\"[[loading]]\"\n        color=\"#0085ba\"\n        aria-roledescription=\"Loading\"\n      ></hexagon-loader>\n      <iron-list\n        grid\n        id=\"itemlist\"\n        items=\"[[media]]\"\n        as=\"resultData\"\n        hidden$=\"[[loading]]\"\n      >\n        <template>\n          <hax-app-search-result\n            result-data=\"[[resultData]]\"\n          ></hax-app-search-result>\n        </template>\n      </iron-list>\n    "]);

    _templateObject_efeabaa0dedc11e9bf5a076df0f16721 = function _templateObject_efeabaa0dedc11e9bf5a076df0f16721() {
      return data;
    };

    return data;
  }

  /**
   * `hax-app-search`
   * `An element that brokers the visual display of a listing of material from an end point. The goal is to normalize data from some location which is media centric. This expects to get at least enough data in order to form a grid of items which are selectable. It's also generically implemented so that anything can be hooked up as a potential source for input (example: youtube API or custom in-house solution). The goal is to return enough info via fired event so that hax-manager can tell hax-body that the user selected a tag, properties, slot combination so that hax-body can turn the selection into a custom element / element injected into the hax-body slot.`
   * @microcopy - the mental model for this element
   * - hax-source - a backend that can supply items for selection by the user
   * - hax-manager - controlling the UI for selection of something
   * - hax-body - the text are ultimately we are trying to insert this item into
   */
  var HaxAppSearch =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(HaxAppSearch, _PolymerElement);

    function HaxAppSearch() {
      var _this;

      babelHelpers.classCallCheck(this, HaxAppSearch);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxAppSearch).call(this));
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-input/paper-input.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-card/paper-card.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-styles/paper-styles.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../hexagon-loader/hexagon-loader.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["./hax-app-search-inputs.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["./hax-app-search-result.js"], res, rej);
      });
      document.body.addEventListener("hax-store-property-updated", _this._haxStorePropertyUpdated.bind(babelHelpers.assertThisInitialized(_this)));
      document.body.addEventListener("hax-app-search-values-changed", _this._searchValuesEvent.bind(babelHelpers.assertThisInitialized(_this)));
      return _this;
    }

    babelHelpers.createClass(HaxAppSearch, [{
      key: "_searchValuesEvent",

      /**
       * Search input was added.
       */
      value: function _searchValuesEvent(e) {
        if (babelHelpers.typeof(e.detail) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          var requestParams = this.requestParams;

          for (var property in e.detail) {
            requestParams[property] = e.detail[property];
          }

          this.set("requestParams", {});
          this.set("requestParams", requestParams);
        }
      }
      /**
       * Active app has changed.
       */

    }, {
      key: "_resetAppSearch",
      value: function _resetAppSearch(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue !== null) {
          var app = newValue;
          var requestParams = {};
          this.label = app.details.title; // disasble auto for a moment while we switch inputs

          this.auto = false;
          this.set("media", []); // see if we have any global settings for connections like api keys

          if (babelHelpers.typeof(app.connection.data) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            requestParams = app.connection.data;
          } // see if the browse endpoint has local overrides


          if (babelHelpers.typeof(app.connection.operations.browse.data) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            requestParams = Object.assign(requestParams, app.connection.operations.browse.data);
          }

          this.set("method", app.connection.operations.browse.method);
          this.set("headers", {});

          if (babelHelpers.typeof(app.connection.headers) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            this.set("headers", app.connection.headers);
          } // ensure we overwrite completely


          this.set("requestParams", {});
          this.set("requestParams", requestParams); // build the request end point

          var requestEndPoint = app.connection.protocol + "://" + app.connection.url; // ensure we build a url correctly

          if (requestEndPoint.substr(requestEndPoint.length - 1) != "/") {
            requestEndPoint += "/";
          } // support local end point modification


          if (babelHelpers.typeof(app.connection.operations.browse.endPoint) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            requestEndPoint += app.connection.operations.browse.endPoint;
          }

          this.set("requestEndPoint", requestEndPoint); // ensure correct wipe of the search area assuming it has a search

          this.set("searchSchema", {});
          var searchSchema = {
            properties: {}
          };

          if (babelHelpers.typeof(app.connection.operations.browse.search) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            searchSchema.properties = app.connection.operations.browse.search;
            this.set("searchSchema", searchSchema);
          }

          this.resultMap = app.connection.operations.browse.resultMap; // map pagination if it has it (it better..)

          this.set("pagination", {});

          if (babelHelpers.typeof(app.connection.operations.browse.pagination) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            this.set("pagination", app.connection.operations.browse.pagination);
          } // reset the auto flag


          if (babelHelpers.typeof(app.connection.auto) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            this.auto = app.connection.auto;
          } else {
            this.auto = true;
          }
        }
      }
      /**
       * Store updated, sync.
       */

    }, {
      key: "_haxStorePropertyUpdated",
      value: function _haxStorePropertyUpdated(e) {
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property) {
          this.set(e.detail.property, e.detail.value);
        }
      }
      /**
       * Callback for when media has been updated via the end point
       */

    }, {
      key: "_requestDataChanged",
      value: function _requestDataChanged(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) != {} && babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          var media = [];
          var map = this.resultMap;
          var data = []; // look for the items element to draw our data from at its root

          if (babelHelpers.typeof(this._resolveObjectPath(map.items, newValue)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            data = this._resolveObjectPath(map.items, newValue);
          } else {
            if (newValue != null) {
              data = newValue;
            }
          }

          if (data != null) {
            // step through and translate response data into a form we can easily
            // understand when stamping out our cards above.
            for (var i = 0; i < data.length; i++) {
              media[i] = {
                title: this._resolveObjectPath(map.preview.title, data[i]),
                details: this._resolveObjectPath(map.preview.details, data[i]),
                type: map.defaultGizmoType,
                map: {}
              }; // strip HTML from details since it might contain complex content

              if (babelHelpers.typeof(media[i].details) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && media[i].details != null) {
                media[i].details = media[i].details.replace(/(<([^>]+)>)/gi, "");
              } // allow id to use deeper logic to split it back out


              if (map.preview.id.constructor === Object) {
                var tmp = this._resolveObjectPath(map.preview.id.property, data[i]);

                if (map.preview.id.op === "split") {
                  tmp = tmp.split(map.preview.id.delimiter);
                  media[i].id = tmp[map.preview.id.position];
                }
              } else {
                media[i].id = this._resolveObjectPath(map.preview.id, data[i]);
              } // image, while really useful is not required


              if (babelHelpers.typeof(map.preview.image) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                media[i].image = this._resolveObjectPath(map.preview.image, data[i]);
              } else if (babelHelpers.typeof(map.image) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                media[i].image = map.image;
              } else {
                media[i].image = "";
              }

              for (var prop in map.gizmo) {
                // check for a _url_source modifier... stupid youtube and others.
                if (prop === "_url_source") {
                  var _id = "";

                  if (babelHelpers.typeof(media[i].map.__id) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    _id = media[i].map.__id;
                  } else {
                    _id = this._resolveObjectPath(map.gizmo.id, data[i]);
                  }

                  media[i].map.source = map.gizmo._url_source.replace("<%= id %>", _id);
                } else {
                  if (map.gizmo[prop].constructor === Object) {
                    var _tmp = this._resolveObjectPath(map.gizmo[prop].property, data[i]);

                    if (map.gizmo[prop].op === "split") {
                      _tmp = _tmp.split(map.gizmo[prop].delimiter);
                      media[i].map[prop] = _tmp[map.gizmo[prop].position];

                      if (prop === "id") {
                        media[i].map.__id = media[i].map[prop];
                      }
                    }
                  } else {
                    media[i].map[prop] = this._resolveObjectPath(map.gizmo[prop], data[i]);
                  }
                }
              } // another sanity check, if we don't have a url but have a source bind that too


              if (babelHelpers.typeof(media[i].map.url) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(media[i].map.source) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                media[i].map.url = media[i].map.source;
              } // gizmo type is also supported in the mapping element itself
              // Think an asset management backend as opposed to a specific
              // type of asset like video. If the item coming across can
              // effectively check what kind of gizmo is required for it
              // to work then we need to support that asset declaring the
              // gizmo type needed


              if (babelHelpers.typeof(map.gizmo.type) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                media[i].type = this._resolveObjectPath(map.gizmo.type, data[i]);
              }
            } // this will trigger an aggressive repaint of the cards


            this.set("media", []);
            this.set("media", media);
          }
        }
      }
    }, {
      key: "_loadingChanged",
      value: function _loadingChanged(newValue, oldValue) {
        var _this2 = this;

        if (newValue) {
          this.set("media", []);
          this.notifyPath("media.*");
          setTimeout(function () {
            _this2.shadowRoot.querySelector("#itemlist").dispatchEvent(new CustomEvent("iron-resize", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: true
            }));
          }, 1000);
        }
      }
      /**
       * Callback for when media has been processed for display
       */

    }, {
      key: "_mediaChanged",
      value: function _mediaChanged(newValue, oldValue) {
        var _this3 = this;

        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          setTimeout(function () {
            _this3.shadowRoot.querySelector("#itemlist").dispatchEvent(new CustomEvent("iron-resize", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: true
            }));
          }, 325);
        }
      }
      /**
       * Helper to take a multi-dimensional object and convert
       * it's reference into the real value. This allows for variable input defined
       * in a string to actually hit the deeper part of an object structure.
       */

    }, {
      key: "_resolveObjectPath",
      value: function _resolveObjectPath(path, obj) {
        return path.split(".").reduce(function (prev, curr) {
          return prev ? prev[curr] : null;
        }, obj || self);
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_efeabaa0dedc11e9bf5a076df0f16721());
      }
    }, {
      key: "tag",
      get: function get() {
        return "hax-app-search";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Active app globally bound based on previous selection.
           */
          activeApp: {
            type: Object,
            observer: "_resetAppSearch"
          },

          /**
           * Immediatley perform a request.
           */
          auto: {
            type: Boolean,
            value: false
          },

          /**
           * Search schema for presenting a form of input.
           */
          searchSchema: {
            type: Object
          },

          /**
           * Search values for data binding between search input
           * and actually rebuilding the search request query
           */
          searchValues: {
            type: Object,
            value: {}
          },

          /**
           * Custom headers for data binding from the App feed.
           */
          headers: {
            type: Object,
            value: {}
          },

          /**
           * Custom method for requesting data (almost always will be GET)
           */
          method: {
            type: String,
            value: "GET"
          },

          /**
           * loading
           */
          loading: {
            type: Boolean,
            value: false,
            observer: "_loadingChanged"
          },

          /**
           * Media request data updated
           */
          requestData: {
            type: Object,
            value: {},
            observer: "_requestDataChanged"
          },

          /**
           * Media object, normalized.
           */
          media: {
            type: Array,
            value: [],
            observer: "_mediaChanged"
          }
        };
      }
    }]);
    return HaxAppSearch;
  }(_polymerElement.PolymerElement);

  _exports.HaxAppSearch = HaxAppSearch;
  window.customElements.define(HaxAppSearch.tag, HaxAppSearch);
});