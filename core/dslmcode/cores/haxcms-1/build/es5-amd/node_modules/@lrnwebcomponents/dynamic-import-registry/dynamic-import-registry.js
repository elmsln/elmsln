define(["exports", "meta", "require"], function (_exports, meta, _require) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.DynamicImportRegistry = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);
  _require = babelHelpers.interopRequireWildcard(_require);

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Copyright 2020 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */
  // register globally so we can make sure there is only one
  window.DynamicImportRegistry = window.DynamicImportRegistry || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same modal

  window.DynamicImportRegistry.requestAvailability = function () {
    if (!window.DynamicImportRegistry.instance) {
      window.DynamicImportRegistry.instance = document.createElement("dynamic-import-registry");
      document.body.appendChild(window.DynamicImportRegistry.instance);
    }

    return window.DynamicImportRegistry.instance;
  };
  /**
   * `dynamic-import-registry`
   * `maintain manage the registration and usage of dynamic imports`
   * @demo demo/index.html
   * @element dynamic-import-registry
   */


  var DynamicImportRegistry = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(DynamicImportRegistry, _HTMLElement);

    var _super = _createSuper(DynamicImportRegistry);

    babelHelpers.createClass(DynamicImportRegistry, null, [{
      key: "tag",
      get: function get() {
        return "dynamic-import-registry";
      }
    }]);

    function DynamicImportRegistry() {
      var _this;

      var delayRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      babelHelpers.classCallCheck(this, DynamicImportRegistry);
      _this = _super.call(this); // object for tracking what the registry is

      _this.list = {};
      _this.__loaded = {};
      _this.basePath = _this.pathFromUrl(decodeURIComponent(meta.url)) + "../../";
      return _this;
    }

    babelHelpers.createClass(DynamicImportRegistry, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        window.addEventListener("dynamic-import-registry--register", this.registerDefinitionEvent.bind(this));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("dynamic-import-registry--register", this.registerDefinitionEvent.bind(this));
      }
    }, {
      key: "register",
      value: function register(item) {
        // validate with basic test
        if (item.tag && item.path) {
          if (!this.list[item.tag]) {
            this.list[item.tag] = item.path;
          }
        } else {
          console.warn("DynamicImportRegistry: registration requires tag and path be set");
        }
      }
      /**
       * This doesn't actually do the import, it just holds the definition
       */

    }, {
      key: "registerDefinitionEvent",
      value: function registerDefinitionEvent(e) {
        // validate with basic test
        if (e.detail.tag && e.detail.path) {
          this.register(e.detail);
        }
      }
      /**
       * This implements the definition with checks to ensure it need not run
       */

    }, {
      key: "loadDefinition",
      value: function () {
        var _loadDefinition = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(tag) {
          var _this2 = this;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  // must be lowercase
                  tag = tag.toLowerCase(); // only import if we already had it

                  if (!(!window.customElements.get(tag) && this.list[tag] && !this.__loaded[tag])) {
                    _context.next = 12;
                    break;
                  }

                  // let's assume it's there cause we got here
                  // this can help things on polyfill environments
                  this.__loaded[tag] = true;
                  _context.prev = 3;
                  _context.next = 6;
                  return new Promise(function (res, rej) {
                    return _require.default(["".concat(_this2.basePath).concat(_this2.list[tag])], res, rej);
                  }).then(function (module) {
                    // dispatch custom event in case anyone cares
                    _this2.dispatchEvent(new CustomEvent("dynamic-import-registry-loaded", {
                      detail: {
                        tag: tag,
                        path: _this2.list[tag],
                        module: module
                      }
                    }));
                  });

                case 6:
                  _context.next = 12;
                  break;

                case 8:
                  _context.prev = 8;
                  _context.t0 = _context["catch"](3);
                  console.warn(_context.t0); // fire on error too

                  this.dispatchEvent(new CustomEvent("dynamic-import-registry-failure", {
                    detail: {
                      tag: tag,
                      path: this.list[tag],
                      module: null
                    }
                  }));

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[3, 8]]);
        }));

        function loadDefinition(_x) {
          return _loadDefinition.apply(this, arguments);
        }

        return loadDefinition;
      }() // simple path from a url modifier

    }, {
      key: "pathFromUrl",
      value: function pathFromUrl(url) {
        return url.substring(0, url.lastIndexOf("/") + 1);
      }
    }]);
    return DynamicImportRegistry;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.DynamicImportRegistry = DynamicImportRegistry;
  window.customElements.define(DynamicImportRegistry.tag, DynamicImportRegistry);
});