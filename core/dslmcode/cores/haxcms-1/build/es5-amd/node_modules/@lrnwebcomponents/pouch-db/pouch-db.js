define(["exports", "require"], function (_exports, _require) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PouchDb = _exports.PouchDBElement = void 0;
  _require = _interopRequireWildcard(_require);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Copyright 2021
   * @license Apache-2.0, see License.md for full text.
   */
  // register globally so we can make sure there is only one
  window.PouchDb = window.PouchDb || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same pouch-db element, making it a singleton.

  window.PouchDb.requestAvailability = function () {
    // if there is no single instance, generate one and append it to end of the document
    if (!window.PouchDb.instance) {
      window.PouchDb.instance = document.createElement("pouch-db");
      document.body.appendChild(window.PouchDb.instance);
    }

    return window.PouchDb.instance;
  };

  var PouchDBElement = window.PouchDb.requestAvailability();
  /**
   * `pouch-db`
   * `read and write localized data elements`
   * @polymer
   * @demo demo/index.html
   * @element pouch-db
   */

  _exports.PouchDBElement = PouchDBElement;

  var PouchDb = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(PouchDb, _HTMLElement);

    var _super = _createSuper(PouchDb);

    function PouchDb() {
      var _this;

      babelHelpers.classCallCheck(this, PouchDb);
      _this = _super.call(this);
      _this.type = "xapi";
      new Promise(function (res, rej) {
        return _require.default(["./lib/pouchdb.min.js"], res, rej);
      }).then(function () {
        _this.db = new PouchDB(_this.type);
      });
      return _this;
    }
    /**
     * Store the tag name to make it easier to obtain directly.
     * @notice function name must be here for tooling to operate correctly
     */


    babelHelpers.createClass(PouchDb, [{
      key: "connectedCallback",
      value:
      /**
       * life cycle, element is afixed to the DOM
       */
      function connectedCallback() {
        window.addEventListener("user-engagement", this.userEngagmentFunction.bind(this));
        window.addEventListener("pouch-db-get-data", this.getDataFunction.bind(this));
      }
      /**
       * life cycle, element is removed from the DOM
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("user-engagement", this.userEngagmentFunction.bind(this));
        window.removeEventListener("pouch-db-get-data", this.getDataFunction.bind(this));
      }
    }, {
      key: "userEngagmentFunction",
      value: function userEngagmentFunction(e) {
        var eventData = e.detail;
        var whatEvent = e.target.tagName;

        switch (whatEvent) {
          case "MULTIPLE-CHOICE":
            var dbType = "xapistatements";
            var activityDisplay = eventData.activityDisplay;
            var activityId = "http://adlnet.gov/expapi/verbs/" + activityDisplay; //this may need to be changed in the future for more verbs

            var objectId = "http://haxcms.psu.edu/haxQuiz";
            var objectName = eventData.objectName;
            var objectDescription = "HAX Quiz"; //hard-coded for now for results, future tracking change to pull data from eventData.x

            var resultScoreScaled = 1;
            var resultScoreMin = 0;
            var resultScoreMax = 100;
            var resultScoreRaw = 100;
            var resultSuccess = eventData.resultSuccess;
            var resultCompletion = true;
            var resultResponse = "sample";
            var resultDuration = "sample"; //hard-coded for now for results, future tracking change to pull data from eventData.x

            break;

          default:
            break;
        }

        var remoteCouch = false; ///var remoteCouch = 'http://35.164.8.64:3000/todos';
        //these need to be updated to pull from global

        var userEmail = "mailto:dave@gmail.com";
        var userName = "Dave Fusco";
        var objectStatement = {
          actor: {
            mbox: userEmail,
            name: userName,
            objectType: "Agent"
          },
          verb: {
            id: activityId,
            display: {
              "en-US": activityDisplay
            }
          },
          object: {
            id: objectId,
            definition: {
              name: {
                "en-US": objectName
              },
              description: {
                "en-US": objectDescription
              }
            },
            objectType: "Activity"
          },
          result: {
            score: {
              scaled: resultScoreScaled,
              min: resultScoreMin,
              max: resultScoreMax,
              raw: resultScoreRaw
            },
            success: resultSuccess,
            completion: resultCompletion,
            response: resultResponse,
            duration: resultDuration
          }
        };
        var xapistatement = {
          _id: new Date().toISOString(),
          title: JSON.stringify(objectStatement),
          completed: false
        };
        console.log(xapistatement);
        this.db.put(xapistatement, function callback(err, result) {
          if (!err) {
            console.log("Successfully posted a statement!");
          }
        });

        if (remoteCouch) {
          var opts = {
            live: true
          };
          this.db.replicate.to(remoteCouch, opts, syncError);
          this.db.replicate.from(remoteCouch, opts, syncError);
        } //display for testing only - move to own elements


        this.db.allDocs({
          include_docs: true,
          descending: true
        }, function (err, doc) {
          console.log(doc.rows);
        }); //display for testing only - move to own elements
      }
    }, {
      key: "getDataFunction",
      value: function getDataFunction(e) {
        var eventData = e.detail;
        var whatEvent = e.target.tagName;

        switch (eventData.queryRequest) {
          case "all-quizzes":
            var dbType = "xapistatements"; //this needs to be changed to be more dynamic in the future

            break;

          case "single-quiz":
            var dbType = "xapistatements"; //this needs to be changed to be more dynamic in the future

            var objectName = eventData.objectName; //"Quiz2"

            break;

          case "future-query":
            var dbType = "xapistatements";
            var activityDisplay = eventData.activityDisplay;
            var objectName = eventData.objectName;
            var resultSuccess = eventData.resultSuccess;
            var resultCompletion = eventData.resultCompletion;
            break;

          default:
            var dbType = "xapistatements";
            break;
        }

        var remoteCouch = false; ///var remoteCouch = 'http://35.164.8.64:3000/todos';
        //ADD SINGLE-QUIZ QUERY

        function processxAPI(statements, callback) {
          var arrayxAPI = [];
          statements.forEach(function (statement) {
            var out = JSON.parse(statement.doc.title); //var jsonStatement = out.verb.display['en-US'];  //verb

            var jsonStatement = out.object.definition.name["en-US"]; //all quizzes; quiz name

            arrayxAPI.push(jsonStatement);
          });
          callback(arrayxAPI);
        }

        function processItems(statements, callback) {
          var map = {};
          statements.forEach(function (statement) {
            map[statement] = (map[statement] || 0) + 1;
          });
          callback(map);
        }

        this.db.allDocs({
          include_docs: true,
          descending: true
        }, function (err, doc) {
          processxAPI(doc.rows, function displayxAPI(mapxAPI) {
            processItems(mapxAPI, function display(backMap) {
              var labelsArray = [];
              var resultsArray = [];

              for (var _i = 0, _Object$keys = Object.keys(backMap); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                labelsArray.push(key);
              }

              for (var _i2 = 0, _Object$values = Object.values(backMap); _i2 < _Object$values.length; _i2++) {
                var value = _Object$values[_i2];
                resultsArray.push(value);
              }

              var queryData = [""];
              queryData = {
                labels: labelsArray,
                series: [resultsArray] //activityDisplay: eventData.resultCompletion,    //FUTURE
                //objectName: eventData.objectName,               //FUTURE
                //resultSuccess: eventData.resultSuccess          //FUTURE
                //resultCompletion: eventData.resultCompletion    //FUTURE

              };
              window.dispatchEvent(new CustomEvent("pouch-db-show-data", {
                bubbles: true,
                composed: true,
                cancelable: false,
                detail: queryData
              }));
            } // end of display function
            ); //end of processItems
          } // end of displayxAPI function
          ); //end of processxAPI
        }); //end of this.db.allDocs
      } // end of getDataFunction

    }], [{
      key: "tag",
      get: function get() {
        return "pouch-db";
      }
    }]);
    return PouchDb;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.PouchDb = PouchDb;
  window.customElements.define(PouchDb.tag, PouchDb);
});