define(["exports", "../../@polymer/polymer/polymer-element.js", "../../@polymer/polymer/lib/utils/flattened-nodes-observer.js", "../../@polymer/iron-form-element-behavior/iron-form-element-behavior.js", "../../@polymer/iron-validatable-behavior/iron-validatable-behavior.js", "../../@polymer/polymer/lib/legacy/class.js"], function (_exports, _polymerElement, _flattenedNodesObserver, _ironFormElementBehavior, _ironValidatableBehavior, _class) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.matchesSelector = _exports.MtzMarkedEditor = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject_05d69980d27811ea974763d9c8343f9b() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          display: block;\n        }\n      </style>\n      <slot name=\"controls\"></slot> <slot name=\"textarea\"></slot>\n      <slot name=\"footer\"></slot>\n    "]);

    _templateObject_05d69980d27811ea974763d9c8343f9b = function _templateObject_05d69980d27811ea974763d9c8343f9b() {
      return data;
    };

    return data;
  }

  /**
   * `mtz-marked-editor`
   * @element mtz-marked-editor
   * `Creates a textarea with common editor logic and can be controlled by UI elements`
   * @demo demo/index.html
   */
  var MtzMarkedEditor =
  /*#__PURE__*/
  function (_mixinBehaviors) {
    babelHelpers.inherits(MtzMarkedEditor, _mixinBehaviors);
    babelHelpers.createClass(MtzMarkedEditor, null, [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_05d69980d27811ea974763d9c8343f9b());
      }
    }, {
      key: "tag",
      get: function get() {
        return "mtz-marked-editor";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(MtzMarkedEditor), "properties", this), {
          autofocus: Boolean,
          readonly: Boolean,
          textareaSelector: {
            type: String,
            value: "textarea"
          },
          __textarea: Object
        });
      }
    }]);

    function MtzMarkedEditor() {
      var _this;

      babelHelpers.classCallCheck(this, MtzMarkedEditor);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(MtzMarkedEditor).call(this));

      _this.addEventListener("register-control", _this.__bindControlToEditor.bind(babelHelpers.assertThisInitialized(_this)));

      return _this;
    }

    babelHelpers.createClass(MtzMarkedEditor, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(MtzMarkedEditor.prototype), "connectedCallback", this).call(this);
        this.__textarea = this.queryDistributedElements('[slot="textarea"]')[0];
      }
      /**
       * Returns a filtered list of flattened child elements for this element based
       * on the given selector.
       *
       * @param {string} selector Selector to filter nodes against
       * @return {!Array<!HTMLElement>} List of flattened child elements
       * @override
       */

    }, {
      key: "queryDistributedElements",
      value: function queryDistributedElements(selector) {
        var c$ = _flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(this);

        var list = [];

        for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
          if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
            list.push(c);
          }
        }

        return list;
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.removeEventListener("register-control", this.__bindControlToEditor);
        babelHelpers.get(babelHelpers.getPrototypeOf(MtzMarkedEditor.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * Returns the instance of textarea
       * @return {HTMLTextAreaElement}
       */

    }, {
      key: "getTextarea",
      value: function getTextarea() {
        return this.__textarea;
      }
      /**
       * Returns the number of lines in the textarea
       * @return {Number}
       */

    }, {
      key: "getLines",
      value: function getLines() {
        return this.getContent().split(/(?=\n|\r\n)$/gm);
      }
      /**
       * Gets the content of the textarea
       * @return {String}
       */

    }, {
      key: "getContent",
      value: function getContent() {
        if (babelHelpers.typeof(this.getTextarea()) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          return this.getTextarea().value;
        }

        return "";
      }
      /**
       * Sets the content of the textarea
       * @param {String} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {
        this.getTextarea().value = content;
      }
      /**
       * Gets the selection information from the textarea and puts it into
       * a useful object.
       * @param {HTMLTextAreaElement} [textarea=this.getTextarea()]
       * @return {Object} Containing selection information, start, end, text, and length.
       */

    }, {
      key: "getSelection",
      value: function getSelection() {
        var textarea = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getTextarea();
        var start = textarea.selectionStart;
        var end = textarea.selectionEnd;
        return {
          start: start,
          end: end,
          length: end - start,
          text: textarea.value.substring(start, end)
        };
      }
      /**
       * Updates the selection of the textarea
       * @param {Number} start - Starting index of selection
       * @param {Number} end - Ending index of selection
       * @param {HTMLTextAreaElement} [textarea=this.getTextarea()]
       */

    }, {
      key: "setSelection",
      value: function setSelection(start, end) {
        var textarea = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getTextarea();
        textarea.selectionStart = start;
        textarea.selectionEnd = end;
      }
      /**
       * Replaces the current selection with the passed in text
       * @param {String} text
       * @param {HTMLTextAreaElement} [textarea=this.getTextarea()]
       * @param {Object} [selection=this.getSelection()]
       */

    }, {
      key: "replaceSelection",
      value: function replaceSelection(text) {
        var textarea = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getTextarea();
        var selection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getSelection();
        var val = textarea.value;
        textarea.value = "".concat(val.substr(0, selection.start)).concat(text).concat(val.substr(selection.end, val.length));
      }
      /**
       * Adds a reference of editor to the control
       * @param {CustomEvent} event
       * @private
       */

    }, {
      key: "__bindControlToEditor",
      value: function __bindControlToEditor(e) {
        e.stopPropagation();
        e.target.__editor = this;
      }
    }]);
    return MtzMarkedEditor;
  }((0, _class.mixinBehaviors)([_ironFormElementBehavior.IronFormElementBehavior, _ironValidatableBehavior.IronValidatableBehavior], _polymerElement.PolymerElement));

  _exports.MtzMarkedEditor = MtzMarkedEditor;
  window.customElements.define(MtzMarkedEditor.tag, MtzMarkedEditor);
  var p = Element.prototype;
  /**
   * @const {function(this:Node, string): boolean}
   */

  var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
  /**
   * Cross-platform `element.matches` shim.
   *
   * @function matchesSelector
   * @param {!Node} node Node to check selector against
   * @param {string} selector Selector to match
   * @return {boolean} True if node matched selector
   */

  var matchesSelector = function matchesSelector(node, selector) {
    return normalizedMatchesSelector.call(node, selector);
  };

  _exports.matchesSelector = matchesSelector;
});