define(["exports", "require", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/utils/render-status.js", "../../../@polymer/polymer/lib/legacy/polymer.dom.js", "../../../@polymer/paper-styles/paper-styles.js", "../../simple-colors/simple-colors.js", "./hax-shared-styles.js", "../../../@polymer/iron-pages/iron-pages.js"], function (_exports, _require, _polymerElement, _renderStatus, _polymerDom, _paperStyles, _simpleColors, _haxSharedStyles, _ironPages) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxManager = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_378e01f0e3b511e9b0d5a5c01151ac03() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"simple-colors-shared-styles hax-shared-styles\">\n        @import url(\"https://fonts.googleapis.com/css?family=Noto+Serif\");\n        :host {\n          display: block;\n          color: var(--hax-color-text);\n        }\n        app-drawer:not(:defined),\n        hax-preview:not(:defined),\n        hax-app-browser:not(:defined),\n        hax-gizmo-browser:not(:defined),\n        iron-icon:not(:defined) {\n          display: none;\n        }\n        #dialog {\n          color: var(--hax-color-text);\n          z-index: 10000;\n          padding: 56px 0;\n          margin-top: 56px;\n          --app-drawer-width: 400px;\n          --app-drawer-content-container: {\n            background-color: #ffffff;\n          }\n        }\n        #closedialog {\n          float: right;\n          top: 124px;\n          right: 0;\n          position: absolute;\n          padding: 8px;\n          margin: 0;\n          background-color: var(--hax-color-menu-heading-bg, #eeeeee);\n          color: var(--hax-color-menu-heading-color, black);\n          background-color: transparent;\n          width: 40px;\n          height: 40px;\n          min-width: unset;\n        }\n        :host([active-page=\"0\"]) #dialog {\n          --app-drawer-width: 300px;\n        }\n        :host([active-page=\"1\"]) #dialog {\n          --app-drawer-width: 60%;\n        }\n        :host([active-page=\"2\"]) #dialog {\n          --app-drawer-width: 60%;\n        }\n        :host([active-step]) #dialog {\n          --app-drawer-width: 60%;\n        }\n        :host([searching]) #dialog {\n          --app-drawer-width: 60%;\n        }\n        @media screen and (max-width: 800px) {\n          :host([active-page=\"0\"]) #dialog {\n            --app-drawer-width: 50%;\n          }\n          :host([active-page=\"1\"]) #dialog,\n          :host([active-page=\"2\"]) #dialog,\n          :host([active-step]) #dialog,\n          :host([searching]) #dialog {\n            --app-drawer-width: 80%;\n          }\n        }\n        .title {\n          position: relative;\n          padding: 16px;\n          outline: 0;\n          font-weight: 600;\n          text-align: left;\n          margin: 0;\n          background-color: var(--hax-color-menu-heading-bg);\n          font-size: 18px;\n          line-height: 18px;\n          font-family: \"Noto Serif\", serif;\n          color: var(--hax-color-menu-heading-color);\n        }\n\n        #preview {\n          height: 100%;\n        }\n        vaadin-upload {\n          --primary-color: var(--hax-color-accent1);\n          --primary-font-color: #ffffff;\n          --dark-primary-color: #ffffff;\n          --light-primary-color: var(--hax-color-accent1);\n          --error-color: darkred;\n          color: #ffffff;\n          display: block;\n          padding: 16px !important;\n          --vaadin-upload-button-add-wrapper: {\n            border: 2px solid #ffffff;\n            background-color: var(--hax-color-accent1);\n            color: #ffffff;\n            display: block;\n          }\n          --vaadin-upload-buttons-primary: {\n            display: block;\n            width: 100%;\n            flex: unset;\n            -webkit-flex: unset;\n          }\n          --vaadin-upload-button-add: {\n            color: #000000;\n            display: block;\n            flex: unset;\n            -webkit-flex: unset;\n            text-align: center;\n          }\n          --vaadin-upload-drop-label: {\n            color: #ffffff;\n            display: block;\n            padding: 8px;\n          }\n          --vaadin-upload-drop-label-dragover: {\n            color: #ffffff;\n          }\n          --vaadin-upload-file-list: {\n            padding: 8px;\n            margin: 0;\n            color: #ffffff;\n          }\n          --vaadin-upload-file: {\n            color: #ffffff;\n          }\n        }\n        vaadin-upload[dragover] {\n          border-color: #396;\n        }\n        vaadin-upload-file {\n          --disabled-text-color: #222222;\n        }\n        .add-area-content-wrapper {\n          padding: 0 16px;\n        }\n        .add-url-area,\n        .add-upload-area {\n          margin: 16px 0;\n        }\n        .url-description {\n          font-size: 18px;\n          color: #000000;\n          line-height: 22px;\n          font-family: sans-serif;\n          letter-spacing: 1px;\n        }\n        #steppages {\n          height: 100%;\n        }\n        #newassetconfigure {\n          width: 100%;\n          margin: 0;\n          padding: 16px;\n          background-color: var(--hax-color-menu-heading-bg, #eeeeee);\n          color: var(--hax-color-menu-heading-color, black);\n        }\n        paper-input {\n          color: var(--hax-color-text);\n        }\n        @media screen and (max-width: 550px) {\n          .hide-on-mobile {\n            opacity: 0;\n            visibility: hidden;\n            position: absolute;\n            left: -9999px;\n          }\n          .page-area.hax-manager {\n            padding: 6px;\n          }\n        }\n      </style>\n      <app-drawer id=\"dialog\" opened=\"{{opened}}\" disable-swipe=\"\">\n        <div\n          class=\"dialog-contents\"\n          id=\"dialogcontent\"\n          style=\"height: 100%; overflow: auto;\"\n        >\n          <iron-pages\n            id=\"steppages\"\n            selected=\"{{activeStep}}\"\n            fallback-selection=\"select\"\n            role=\"main\"\n          >\n            <div data-value=\"select\">\n              <iron-pages\n                id=\"activepage\"\n                selected=\"{{activePage}}\"\n                fallback-selection=\"link\"\n              >\n                <div class=\"page-area add-area\">\n                  <h3 class=\"title\">[[addTitle]]</h3>\n                  <div class=\"add-area-content-wrapper\">\n                    <div class=\"add-url-area\">\n                      <paper-input\n                        id=\"url\"\n                        label=\"URL\"\n                        type=\"url\"\n                        auto-validate=\"\"\n                      ></paper-input>\n                      <div class=\"url-description\">\n                        Add an existing resource / link\n                      </div>\n                    </div>\n                    <div class=\"add-upload-area\">\n                      <vaadin-upload\n                        form-data-name=\"file-upload\"\n                        id=\"fileupload\"\n                        hidden$=\"[[!canSupportUploads]]\"\n                      ></vaadin-upload>\n                    </div>\n                    <paper-button id=\"newassetconfigure\" raised=\"\"\n                      >Configure item</paper-button\n                    >\n                  </div>\n                </div>\n                <div class=\"page-area\">\n                  <hax-app-browser id=\"appbrowser\">\n                    <slot></slot>\n                  </hax-app-browser>\n                </div>\n                <div class=\"page-area\">\n                  <hax-gizmo-browser id=\"gizmobrowser\"></hax-gizmo-browser>\n                </div>\n              </iron-pages>\n            </div>\n            <div style=\"height:100%;\">\n              <hax-preview id=\"preview\"></hax-preview>\n            </div>\n          </iron-pages>\n          <paper-button\n            id=\"closedialog\"\n            on-click=\"cancel\"\n            hidden$=\"[[activeStep]]\"\n          >\n            <iron-icon icon=\"icons:cancel\" title=\"Close dialog\"></iron-icon>\n          </paper-button>\n        </div>\n      </app-drawer>\n    "]);

    _templateObject_378e01f0e3b511e9b0d5a5c01151ac03 = function _templateObject_378e01f0e3b511e9b0d5a5c01151ac03() {
      return data;
    };

    return data;
  }

  /**
   * `hax-manager`
   * `A LRN element for brokering the UI for api endpoints both in querying and uploading of new media to eventually bubble up an event for hax-body to have content inserted into it. This is a wiring closet of sorts to ensure we can talk to any backend that's returning a slew of widgets / media to insert.`
   * @microcopy - the mental model for this element
   * - hax-manager - the modal for selecting a app for getting something added to hax-body. This will bubble an event up to an app which will then invoke the haxInsert function on hax-body in order to get the selected item onto the body area for usage.
   * - hax-body - the body tag that's beening clicked / focused and built; our WYSIWYG replacement.
   * - hax-panel - a panel off to the side that has possible options. Clicking in this panel is most likely what invokes hax-manager to display though this is also managed by a higher app (lrnapp-book in initial development)
   * - app - an API end point for querying and returning possible items for insert. For example, if a youtube is a source then it'll be expected to return data that can be mapped in such a way that it can display a grid of videos. Hitting vimeo we'd expect the same thing; enough data to be able to assemble a grid of videos to select / work with.
   * - endpoints - much of hax-manager is about routing data to and from the current application to backends. So uploads need to go some place, this is managing the UI aspect of that transaction while expecting to be fed an endpoint to handle the backend aspect.
   */
  var HaxManager =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(HaxManager, _PolymerElement);

    function HaxManager() {
      var _this;

      babelHelpers.classCallCheck(this, HaxManager);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxManager).call(this));
      new Promise(function (res, rej) {
        return _require.default(["./hax-manager-deps.js"], res, rej);
      });
      return _this;
    }

    babelHelpers.createClass(HaxManager, [{
      key: "ready",

      /**
       * life cycle
       */
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxManager.prototype), "ready", this).call(this); // send an event that this is the manager

        this.dispatchEvent(new CustomEvent("hax-register-manager", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: this
        }));
        (0, _renderStatus.afterNextRender)(this, function () {
          // add event listeners
          document.body.addEventListener("hax-store-property-updated", this._haxStorePropertyUpdated.bind(this));
          document.body.addEventListener("hax-app-picker-selection", this._haxAppPickerSelection.bind(this)); // specialized support for the place-holder tag
          // and a drag and drop event

          document.body.addEventListener("place-holder-file-drop", this._placeHolderFileDrop.bind(this));
          this.shadowRoot.querySelector("#dialog").addEventListener("iron-overlay-canceled", this.close.bind(this));
          this.shadowRoot.querySelector("#dialog").addEventListener("iron-overlay-closed", this.close.bind(this));
          this.shadowRoot.querySelector("#closedialog").addEventListener("click", this.close.bind(this));
          this.shadowRoot.querySelector("#newassetconfigure").addEventListener("click", this.newAssetConfigure.bind(this));
          this.shadowRoot.querySelector("#fileupload").addEventListener("upload-before", this._fileAboutToUpload.bind(this));
          this.shadowRoot.querySelector("#fileupload").addEventListener("upload-response", this._fileUploadResponse.bind(this));
        });
      }
      /**
       * Toggle panel size
       */

    }, {
      key: "togglePanelSize",
      value: function togglePanelSize(e) {
        this.shadowRoot.querySelector("#dialog").classList.toggle("grow");
        this.updateStyles();
        window.dispatchEvent(new Event("resize"));
      }
      /**
       * compute title for edit mode
       */

    }, {
      key: "_computeEditTitle",
      value: function _computeEditTitle(updateExisting) {
        if (babelHelpers.typeof(this.activeHaxElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && updateExisting) {
          return "Update";
        } else {
          return "Insert";
        }
      }
      /**
       * A file event was detected from a drag and drop in the interface, most likely
       * from a place-holder tag
       */

    }, {
      key: "_placeHolderFileDrop",
      value: function _placeHolderFileDrop(e) {
        // reset the manager back to the first page
        this.resetManager(); // trigger a self open request

        this.open(); // reference the active place holder element since place holders are
        // the only things possible for seeing these

        window.HaxStore.instance.activePlaceHolder = e.detail.placeHolderElement;
        this.editExistingNode = true; // ! I can't believe this actually works. This takes the event
        // ! that was a drop event else where on the page and then repoints
        // ! it to simulate the drop event using the same event structure that
        // ! would have happened if they had used this element in the first place

        this.shadowRoot.querySelector("#fileupload")._onDrop(e.detail);
      }
      /**
       * Respond to uploading a file
       */

    }, {
      key: "_fileAboutToUpload",
      value: function _fileAboutToUpload(e) {
        if (!this.__allowUpload) {
          // cancel the event so we can jump in
          e.preventDefault();
          e.stopPropagation(); // look for a match as to what gizmo types it supports

          var values = {
            source: e.detail.file.name,
            type: e.detail.file.type
          }; // we have no clue what this is.. let's try and guess..

          var type = window.HaxStore.guessGizmoType(values); // find targets that support this type

          var targets = window.HaxStore.getHaxAppStoreTargets(type); // make sure we have targets

          if (targets.length === 1) {
            this._haxAppPickerSelection({
              detail: targets[0]
            });
          } else if (targets.length !== 0) {
            window.HaxStore.instance.haxAppPicker.presentOptions(targets, type, "Where would you like to upload this " + type + "?", "app");
          } else {
            window.HaxStore.toast("Sorry, you don't have a storage location that can handle " + type + " uploads!", 5000);
          }
        } else {
          this.__allowUpload = false;
        }
      }
      /**
       * Event for an app being selected from a picker
       * This happens when multiple upload targets support the given type
       */

    }, {
      key: "_haxAppPickerSelection",
      value: function _haxAppPickerSelection(e) {
        // details for where to upload the file
        var connection = e.detail.connection;
        this.__appUsed = e.detail;
        this.shadowRoot.querySelector("#fileupload").method = connection.operations.add.method;
        var requestEndPoint = connection.protocol + "://" + connection.url; // ensure we build a url correctly

        if (requestEndPoint.substr(requestEndPoint.length - 1) != "/") {
          requestEndPoint += "/";
        } // support local end point modification


        if (babelHelpers.typeof(connection.operations.add.endPoint) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          requestEndPoint += connection.operations.add.endPoint;
        } // support jwt hijacking


        if (window.HaxStore.instance.connectionRewrites.appendUploadEndPoint != null) {
          requestEndPoint += "?" + window.HaxStore.instance.connectionRewrites.appendUploadEndPoint;
        }

        if (window.HaxStore.instance.connectionRewrites.appendJwt != null) {
          requestEndPoint += "&" + window.HaxStore.instance.connectionRewrites.appendJwt + "=" + localStorage.getItem(window.HaxStore.instance.connectionRewrites.appendJwt);
        }

        this.shadowRoot.querySelector("#fileupload").headers = connection.headers;
        this.shadowRoot.querySelector("#fileupload").target = requestEndPoint; // invoke file uploading...

        this.__allowUpload = true;
        this.shadowRoot.querySelector("#fileupload").uploadFiles();
      }
      /**
       * Respond to successful file upload, now inject url into url field and
       * do a gizmo guess from there!
       */

    }, {
      key: "_fileUploadResponse",
      value: function _fileUploadResponse(e) {
        this.editExistingNode = true; // convert response to object

        var response = JSON.parse(e.detail.xhr.response); // access the app that did the upload

        var map = this.__appUsed.connection.operations.add.resultMap;
        var data = {};
        var item = {}; // look for the items element to draw our data from at its root

        if (babelHelpers.typeof(this._resolveObjectPath(map.item, response)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          data = this._resolveObjectPath(map.item, response);
        }

        item.type = map.defaultGizmoType; // pull in prop matches

        for (var prop in map.gizmo) {
          item[prop] = this._resolveObjectPath(map.gizmo[prop], data);
        } // another sanity check, if we don't have a url but have a source bind that too


        if (babelHelpers.typeof(item.url) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(item.source) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          item.url = item.source;
        } // gizmo type is also supported in the mapping element itself
        // Think an asset management backend as opposed to a specific
        // type of asset like video. If the item coming across can
        // effectively check what kind of gizmo is required for it
        // to work then we need to support that asset declaring the
        // gizmo type needed


        if (babelHelpers.typeof(map.gizmo.type) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          item.type = this._resolveObjectPath(map.gizmo.type, data);
        }

        this.shadowRoot.querySelector("#url").value = item.url; // @todo put in logic to support the response actually
        // just outright returning a haxElement. This is rare
        // but if the HAX developer has control over the endpoint
        // then they could get HAX to streamline some workflows
        // or by-pass the gizmo selection step to improve UX
        // for end users even further. Examples could be a media
        // management system that has remote rendering (cms-token)
        // or a highly specific endpoint that we know we can only
        // present in one way effectively Box / Google doc viewer.

        this.newAssetConfigure();
      }
      /**
       * Notice page changed.
       */

    }, {
      key: "_activePageChanged",
      value: function _activePageChanged(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.searching = false;
          this.updateStyles();

          if (newValue === 1 && this.shadowRoot.querySelector("#appbrowser")) {
            this.shadowRoot.querySelector("#appbrowser").resetBrowser();
          } else if (newValue === 2 && this.shadowRoot.querySelector("#gizmobrowser")) {
            this.shadowRoot.querySelector("#gizmobrowser").resetBrowser();
          }
        }
      }
      /**
       * Store updated, sync.
       */

    }, {
      key: "_haxStorePropertyUpdated",
      value: function _haxStorePropertyUpdated(e) {
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property) {
          if (e.detail.property === "appList") {
            this.set(e.detail.property, []);
          }

          if (e.detail.property === "activeHaxElement") {
            this.set(e.detail.property, {});
          }

          this.set(e.detail.property, e.detail.value);
        }
      }
      /**
       * Notice active element changed.
       */

    }, {
      key: "_activeHaxElementChanged",
      value: function _activeHaxElementChanged(newValue, oldValue) {
        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.shadowRoot.querySelector("#preview").advancedForm = false;

          if (newValue && babelHelpers.typeof(newValue.tag) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            this.resetManager();
          } else {
            // reset files so it doesn't bloat up
            this.shadowRoot.querySelector("#fileupload").set("files", []);
            this.shadowRoot.querySelector("#dialog").scrollTop = 0;
            this.selectStep("configure");
          }
        }
      }
      /**
       * Bubble up insert event.
       */

    }, {
      key: "insertHaxElement",
      value: function insertHaxElement(e) {
        // bubble up the inject event / element to the body
        var previewNode = this.shadowRoot.querySelector("#preview").previewNode;
        previewNode.removeAttribute("hax-preview-mode"); // trickery to get it into the DOM but the preview not disappear

        if (previewNode.getAttribute("data-hax-slot") != null) {
          previewNode.setAttribute("slot", previewNode.getAttribute("data-hax-slot"));
          previewNode.removeAttribute("data-hax-slot");
        }

        var element = window.HaxStore.nodeToHaxElement(previewNode);
        element.replace = this.editExistingNode;

        if (babelHelpers.typeof(this.activeHaxElement.__type) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          element.__type = this.activeHaxElement.__type;
        }

        element.replacement = previewNode;
        this.dispatchEvent(new CustomEvent("hax-insert-content", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: element
        }));
        var toast = "New element added!";

        if (this.editExistingNode) {
          toast = "Element updated!";
        }

        window.HaxStore.toast(toast, 2000); // close window

        this.close();
      }
      /**
       * Reset things on the display to their defaults.
       */

    }, {
      key: "resetManager",
      value: function resetManager() {
        var activePage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        this.selectStep("select");
        this.activePage = activePage;
        document.body.style.overflow = null;
        this.appList = window.HaxStore.instance.appList;
        this.searching = false;
        window.HaxStore.write("activeApp", null, this);
        window.dispatchEvent(new Event("resize"));
        this.editExistingNode = false;
        this.shadowRoot.querySelector("#url").value = "";
        this.shadowRoot.querySelector("#fileupload").headers = "";
        this.shadowRoot.querySelector("#fileupload").method = "";
        this.shadowRoot.querySelector("#fileupload").target = "";
        this.shadowRoot.querySelector("#preview").shadowRoot.querySelector("#ppanel1").style.flex = "";
        this.shadowRoot.querySelector("#preview").shadowRoot.querySelector("#ppanel2").style.flex = "";
        this.__allowUpload = false;
      }
      /**
       * Cancel interaction with the modal
       */

    }, {
      key: "cancel",
      value: function cancel(e) {
        // reset and close dialog
        this.close();
      }
      /**
       * Open state change.
       */

    }, {
      key: "_openedChanged",
      value: function _openedChanged(newValue, oldValue) {
        if (oldValue && !newValue) {
          document.body.style.overflow = null;
        } else if (newValue && !oldValue) {
          document.body.style.overflow = "hidden";
        }
      }
      /**
       * Respond to the modal closing
       */

    }, {
      key: "close",
      value: function close(e) {
        var normalizedEvent = (0, _polymerDom.dom)(e);
        var local = normalizedEvent.localTarget;

        if (babelHelpers.typeof(e) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) || local === this.shadowRoot.querySelector("#dialog") || local === this.shadowRoot.querySelector("#closedialog")) {
          // reset the active element which will force this to reset the manager
          window.HaxStore.write("activeHaxElement", {}, this);
          this.opened = false;
          this.resetManager();
        }
      }
      /**
       * Open the dialog
       */

    }, {
      key: "open",
      value: function open(e) {
        this.opened = true;
      }
      /**
       * Configure asset after upload or URL passed in.
       */

    }, {
      key: "newAssetConfigure",
      value: function newAssetConfigure() {
        var values = {
          source: this.shadowRoot.querySelector("#url").value
        }; // we have no clue what this is.. let's try and guess..

        var type = window.HaxStore.guessGizmoType(values);
        var haxElements = window.HaxStore.guessGizmo(type, values); // see if we got anything

        if (haxElements.length > 0) {
          if (haxElements.length === 1) {
            if (babelHelpers.typeof(haxElements[0].tag) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              window.HaxStore.write("activeHaxElement", haxElements[0], this);
            }
          } else {
            // hand off to hax-app-picker to deal with the rest of this
            window.HaxStore.instance.haxAppPicker.presentOptions(haxElements, type, "Pick how to present the " + type, "gizmo");
          }
        } else {
          window.HaxStore.toast("Sorry, HAX doesn't know how to handle that type of link yet.");
        }
      }
      /**
       * Toggle ourselves.
       */

    }, {
      key: "toggleDialog",
      value: function toggleDialog() {
        var toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (this.opened && toggle) {
          this.close();
        } else {
          window.HaxStore.instance.closeAllDrawers(this);
        }
      }
      /**
       * Set step to configure or insert
       */

    }, {
      key: "selectStep",
      value: function selectStep(step) {
        if (step == "configure") {
          this.activeStep = true;
        } else {
          this.activeStep = false;
        }
      }
      /**
       * Notice step changes
       */

    }, {
      key: "_activeStepChanged",
      value: function _activeStepChanged(newValue, oldValue) {
        if (newValue || !newValue) {
          this.updateStyles();
          window.dispatchEvent(new Event("resize"));
        }
      }
      /**
       * Helper to take a multi-dimensional object and convert
       * it's reference into the real value. This allows for variable input defined
       * in a string to actually hit the deeper part of an object structure.
       */

    }, {
      key: "_resolveObjectPath",
      value: function _resolveObjectPath(path, obj) {
        return path.split(".").reduce(function (prev, curr) {
          return prev ? prev[curr] : null;
        }, obj || self);
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_378e01f0e3b511e9b0d5a5c01151ac03());
      }
    }, {
      key: "tag",
      get: function get() {
        return "hax-manager";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Track visibility status.
           */
          opened: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: "_openedChanged"
          },

          /**
           * Title when open.
           */
          editExistingNode: {
            type: Boolean,
            value: false
          },

          /**
           * Title when open.
           */
          editTitle: {
            type: String,
            computed: "_computeEditTitle(editExistingNode)"
          },

          /**
           * Active title
           */
          addTitle: {
            type: String,
            value: "Add content"
          },

          /**
           * Active step currently selected
           */
          activeStep: {
            type: Boolean,
            reflectToAttribute: true,
            value: false,
            observer: "_activeStepChanged"
          },

          /**
           * Searching mode
           */
          searching: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          },

          /**
           * Active page currently selected
           */
          activePage: {
            type: String,
            reflectToAttribute: true,
            value: 0,
            observer: "_activePageChanged"
          },

          /**
           * If this can support uploads or not based on presense of a backend
           * this property is synced down from the store
           */
          canSupportUploads: {
            type: Boolean,
            value: false
          },

          /**
           * Active element
           */
          activeHaxElement: {
            type: Object,
            observer: "_activeHaxElementChanged"
          },

          /**
           * List of apps so they can be added
           */
          appList: {
            type: Array,
            value: []
          },

          /**
           * Helper so we can upload after prompting where to go.
           */
          __allowUpload: {
            type: Boolean,
            value: false
          }
        };
      }
    }]);
    return HaxManager;
  }(_polymerElement.PolymerElement);

  _exports.HaxManager = HaxManager;
  window.customElements.define(HaxManager.tag, HaxManager);
});