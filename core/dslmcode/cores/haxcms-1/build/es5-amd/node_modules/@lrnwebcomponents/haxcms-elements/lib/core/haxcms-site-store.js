define(["exports", "../../../../mobx/dist/mobx.esm.js", "../../../utils/utils.js", "../../../json-outline-schema/json-outline-schema.js"], function (_exports, _mobxEsm, _utils, _jsonOutlineSchema) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSSiteStore = _exports.HAXcmsStore = _exports.store = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  (0, _mobxEsm.configure)({
    enforceActions: false,
    useProxies: "ifavailable"
  }); // strict mode off

  var Store = /*#__PURE__*/function () {
    function Store() {
      babelHelpers.classCallCheck(this, Store);
      this.location = null;
      this.jwt = null;
      this.setupSlots = {};
      this.editMode = false;
      this.manifest = null;
      this.activeItemContent = "";
      this.themeElement = null;
      this.t = {
        close: "Close"
      };
      this.activeId = null;
      this.userData = {};
      this.cmsSiteEditor = {
        instance: null
      };
      this.cmsSiteEditorBackend = {
        instance: null
      };
      this.dashboardOpened = false;
      (0, _mobxEsm.makeObservable)(this, {
        location: _mobxEsm.observable.ref,
        // router location in url
        editMode: _mobxEsm.observable,
        // global editing state
        jwt: _mobxEsm.observable,
        // json web token
        dashboardOpened: _mobxEsm.observable,
        // if haxcms backend settings are open
        userData: _mobxEsm.observable,
        // user data object for logged in users
        manifest: _mobxEsm.observable,
        // JOS / manifest
        activeItemContent: _mobxEsm.observable,
        // active site content, cleaned up
        themeElement: _mobxEsm.observable,
        // theme element
        routerManifest: _mobxEsm.computed,
        // router mixed in manifest w/ routes / paths
        siteTitle: _mobxEsm.computed,
        isLoggedIn: _mobxEsm.computed,
        // simple boolean for state so we can style based on logged in
        themeData: _mobxEsm.computed,
        // get the active theme from manifest + activeId
        homeLink: _mobxEsm.computed,
        activeId: _mobxEsm.observable,
        // this affects all state changes associated to activeItem
        activeItem: _mobxEsm.computed,
        // active item object
        activeItemFields: _mobxEsm.computed,
        // active item field values
        activeManifestIndex: _mobxEsm.computed,
        // active array index, used for pagination
        activeManifestIndexCounter: _mobxEsm.computed,
        // active array index counter, used for pagination
        activeTitle: _mobxEsm.computed,
        // active page title
        parentTitle: _mobxEsm.computed,
        // active page parent title
        ancestorTitle: _mobxEsm.computed // active page ancestor title

      });
    }
    /**
     * Global toast bridge so we don't have to keep writing custom event
     */


    babelHelpers.createClass(Store, [{
      key: "toast",
      value: function toast(message) {
        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
        var classStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "capsule";
        var closeText = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.t.close;
        var eventCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var slot = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        // gets it all the way to the top immediately
        window.dispatchEvent(new CustomEvent("simple-toast-show", {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            text: message,
            duration: duration,
            classStyle: classStyle,
            closeText: closeText,
            eventCallback: eventCallback,
            slot: slot
          }
        }));
      }
      /**
       * Load a manifest / site.json / JSON outline schema
       * and prep it for usage in HAXcms
       */

    }, {
      key: "loadManifest",
      value: function loadManifest(manifest) {
        var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // support a custom target or ensure event fires off window
        if (target == null && window) {
          target = window;
        } // @todo replace this with a schema version mapper
        // once we have versions


        if ((0, _utils.varExists)(manifest, "metadata.siteName")) {
          var git = (0, _utils.varGet)(manifest, "publishing.git", {});
          manifest.metadata.site = {
            name: manifest.metadata.siteName,
            git: git,
            created: manifest.metadata.created,
            updated: manifest.metadata.updated
          };
          manifest.metadata.theme.variables = {
            image: manifest.metadata.image,
            icon: manifest.metadata.icon,
            hexCode: manifest.metadata.hexCode,
            cssVariable: manifest.metadata.cssVariable
          };
          manifest.metadata.node = {
            dynamicElementLoader: manifest.metadata.dynamicElementLoader,
            fields: manifest.metadata.fields
          };
          delete manifest.metadata.publishing;
          delete manifest.metadata.created;
          delete manifest.metadata.updated;
          delete manifest.metadata.siteName;
          delete manifest.metadata.image;
          delete manifest.metadata.icon;
          delete manifest.metadata.hexCode;
          delete manifest.metadata.cssVariable;
          delete manifest.metadata.dynamicElementLoader;
          delete manifest.metadata.fields;
        } // repair slug not being in earlier builds of json schema


        manifest.items.forEach(function (item, index, array) {
          if (!item.slug) {
            array[index].slug = item.location.replace("pages/", "").replace("/index.html", "");
          }
        });
        var site = new _jsonOutlineSchema.JsonOutlineSchema(); // we already have our items, pass them in

        var nodes = site.itemsToNodes(manifest.items); // smash outline into flat to get the correct order

        var correctOrder = site.nodesToItems(nodes);
        var newItems = []; // build a new array in the correct order by pushing the old items around

        for (var key in correctOrder) {
          newItems.push(manifest.items.find(function (element) {
            return element.id === correctOrder[key].id;
          }));
        }

        manifest.items = newItems;
        this.manifest = manifest;
        target.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: manifest
        }));
      }
      /**
       * Ensure there's a copy of the site-editor globally available
       */

    }, {
      key: "cmsSiteEditorAvailability",
      value: function cmsSiteEditorAvailability() {
        if (!this.cmsSiteEditor.instance) {
          this.cmsSiteEditor.instance = document.createElement("haxcms-site-editor");
        }

        return this.cmsSiteEditor.instance;
      }
    }, {
      key: "processedItems",
      get: function get() {}
      /**
       * Compute items leveraging the site query engine
       */

    }, {
      key: "_computeItems",
      value: function _computeItems(start, end, parent, dynamicMethodology, _routerManifest) {
        var _this = this;

        if (_routerManifest) {
          var _ret = function () {
            var items = [];
            var data = [];
            var tmpItem;

            _routerManifest.items.forEach(function (element) {
              // find top level parents
              if (!element.parent) {
                items.push(element);
              }
            });

            switch (dynamicMethodology) {
              case "parent":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // shift up 1 if we found something

                if (tmpItem) {
                  parent = tmpItem.parent;
                }

                break;

              case "ancestor":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // walk back up to the root

                while (tmpItem && tmpItem.parent != null) {
                  // take the parent object of this current item
                  tmpItem = _routerManifest.items.find(function (i) {
                    return i.id == tmpItem.parent;
                  });
                }

                if (tmpItem) {
                  parent = tmpItem.id;
                }

                break;
            }

            items.forEach(function (item, i) {
              _this._spiderChildren(item, data, start, end, parent, false);
            });
            return {
              v: data
            };
          }();

          if (babelHelpers.typeof(_ret) === "object") return _ret.v;
        }
      }
      /**
       * Recursively search through a data to find children
       * of a specified item.
       */

    }, {
      key: "_setChildren",
      value: function _setChildren(item, data) {
        var _this2 = this;

        // find all children
        var children = data.filter(function (d) {
          return item.id === d.parent;
        });
        item.children = children;

        if (item.children.length > 0) {
          item.children.forEach(function (child) {
            // recursively call itself
            _this2._setChildren(child, data);
          });
        }
      }
      /**
       * The manifest but with routing mixed in
       */

    }, {
      key: "routerManifest",
      get: function get() {
        var _this3 = this;

        var manifest = this.manifest;
        document.body.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: manifest
        }));

        if (manifest && typeof manifest.items !== "undefined") {
          var manifestItems = manifest.items.map(function (i) {
            var parentLocation = null;
            var parentSlug = null;
            var parent = manifest.items.find(function (d) {
              return i.parent === d.id;
            });

            if (parent) {
              parentLocation = parent.location;
              parentSlug = parent.slug;
            }

            var metadata = i.metadata;
            var location = i.location;
            var slug = i.slug;
            return Object.assign({}, i, {
              parentLocation: parentLocation,
              parentSlug: parentSlug,
              location: location,
              slug: slug,
              metadata: metadata
            });
          }); // build the children into a hierarchy too

          manifestItems.forEach(function (item, i) {
            _this3._setChildren(item, manifestItems);
          });
          /**
           * Publish Pages Option
           *
           * This option enables the notion of published and unpublished pages.
           * To enable this option set manifest.metadata.site.settings.publishPagesOn = true
           *
           * By default all pages will be published unless "metadata.published" is set to "true" on the
           * item.
           */

          if ((0, _utils.varGet)(manifest, "metadata.site.settings.publishPagesOn", true) === true) {
            var filterHiddenParentsRecursive = function filterHiddenParentsRecursive(item) {
              // if the item is unpublished then remove it.
              if (item.metadata.published === false) {
                return false;
              } // if the item has parents, recursively see if any parent is not published


              var parent = manifestItems.find(function (i) {
                return i.id === item.parent;
              });

              if (parent) {
                return filterHiddenParentsRecursive(parent);
              } // if it got this far then it should be good.


              return true;
            }; // If the user is not logged in then we need to hide unpublished nodes items


            if (!this.isLoggedIn) {
              manifestItems = manifestItems.filter(function (i) {
                return filterHiddenParentsRecursive(i);
              });
            }
          }

          return Object.assign({}, manifest, {
            items: manifestItems
          });
        }
      }
      /**
       * Return the site title
       */

    }, {
      key: "siteTitle",
      get: function get() {
        var manifest = this.manifest;

        if (manifest && manifest.title) {
          return manifest.title;
        }

        return "";
      }
      /**
       * Figure out the home page, lazily the 1st thing in the manifest
       */

    }, {
      key: "homeLink",
      get: function get() {
        // if we are on the homepage then load the first item in the manifest and set it active
        if (this.manifest) {
          var firstItem = this.manifest.items.find(function (i) {
            return typeof i.id !== "undefined";
          });

          if (firstItem) {
            return firstItem.slug;
          }
        }

        return "/";
      }
      /**
       * Get the active Item based on activeId
       */

    }, {
      key: "activeItem",
      get: function get() {
        var item = this.findItem(this.activeId); // ensure we found something, return null for consistency in data

        if (item) {
          return item;
        }

        return null;
      }
      /**
       * Get the fields from the node
       */

    }, {
      key: "activeItemFields",
      get: function get() {
        // need to have metadata to be valid so..
        if (this.activeItem && this.activeItem.metadata) {
          // core "fields" we'd expect
          var fields = {
            title: this.activeItem.title,
            description: this.activeItem.description,
            location: this.activeItem.location,
            slug: this.activeItem.slug,
            created: this.activeItem.metadata.created,
            updated: this.activeItem.metadata.created
          }; // mix in any custom field definitions

          if (this.activeItem.metadata.fields) {
            return Object.assign({}, fields, this.activeItem.metadata.fields);
          }
        }
      }
      /**
       * get theme data from manifest + activeId combo
       */

    }, {
      key: "themeData",
      get: function get() {
        if (this.manifest) {
          var themeData = {}; // this is required so better be...

          if ((0, _utils.varExists)(this.manifest, "metadata.theme")) {
            themeData = this.manifest.metadata.theme;
          } else {
            // fallback juuuuust to be safe...
            themeData = {
              "haxcms-basic-theme": {
                element: "haxcms-basic-theme",
                path: "@lrnwebcomponents/haxcms-elements/lib/core/themes/haxcms-basic-theme.js",
                name: "Basic theme",
                variables: {
                  image: "assets/banner.jpg",
                  icon: "icons:record-voice-over",
                  hexCode: "#da004e",
                  cssVariable: "pink"
                }
              }
            };
          } // ooo you sneaky devil you...


          if (this.activeItem && (0, _utils.varExists)(this.activeItem, "metadata.theme")) {
            return this.activeItem.metadata.theme;
          }

          return themeData;
        }
      }
      /**
       * Get the active manifest index array position
       * -1 if not found
       */

    }, {
      key: "activeManifestIndex",
      get: function get() {
        if (this.manifest && this.manifest.items && this.activeId) {
          for (var index in this.manifest.items) {
            if (this.manifest.items[index].id === this.activeId) {
              return parseInt(index);
            }
          }
        }

        return -1;
      }
    }, {
      key: "activeRouterManifestIndex",
      get: function get() {
        if (this.routerManifest && this.routerManifest.items && this.activeId) {
          for (var index in this.routerManifest.items) {
            if (this.routerManifest.items[index].id === this.activeId) {
              return parseInt(index);
            }
          }
        }

        return -1;
      }
      /**
       * Better for visualizing the counter
       */

    }, {
      key: "activeManifestIndexCounter",
      get: function get() {
        if (this.activeManifestIndex !== null) {
          return 1 + this.activeManifestIndex;
        }

        return 0;
      }
      /**
       * shortcut for active page title
       */

    }, {
      key: "activeTitle",
      get: function get() {
        if (this.activeItem) {
          return this.activeItem.title;
        }

        return "";
      }
      /**
       * shortcut for active page parent title
       */

    }, {
      key: "parentTitle",
      get: function get() {
        var _this4 = this;

        if (this.manifest && this.activeItem) {
          var tmpItem = this.manifest.items.find(function (d) {
            return _this4.activeItem.parent === d.id;
          }); // shift up 1 if we found something

          if (tmpItem) {
            return tmpItem.title;
          }
        }

        return "";
      }
    }, {
      key: "isLoggedIn",
      get: function get() {
        // account for keypair storage issue since its a string bin
        if (this.jwt && this.jwt != "null") {
          return true;
        }

        return false;
      }
      /**
       * shortcut for active page ancestor title
       */

    }, {
      key: "ancestorTitle",
      get: function get() {
        var _this5 = this;

        if (this.manifest && this.activeItem) {
          var _ret2 = function () {
            var tmpItem = _this5.manifest.items.find(function (d) {
              return _this5.activeItem.parent === d.id;
            }); // walk back up to the root


            while (tmpItem && tmpItem.parent != null) {
              // take the parent object of this current item
              tmpItem = _this5.manifest.items.find(function (i) {
                return i.id == tmpItem.parent;
              });
            }

            if (tmpItem) {
              return {
                v: tmpItem.title
              };
            }
          }();

          if (babelHelpers.typeof(_ret2) === "object") return _ret2.v;
        }

        return "";
      }
      /**
       * shortcut to find an item in the manifest based on id
       */

    }, {
      key: "findItem",
      value: function findItem(id) {
        if (this.manifest && id) {
          return this.manifest.items.find(function (item) {
            if (item.id !== id) {
              return false;
            }

            return true;
          });
        }

        return null;
      }
      /**
       * shortcut to find an item in the manifest based on id
       */

    }, {
      key: "findItemAsObject",
      value: function () {
        var _findItemAsObject = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(id) {
          var attrLookup,
              scope,
              tmpItem,
              _args = arguments;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  attrLookup = _args.length > 1 && _args[1] !== undefined ? _args[1] : "id";
                  scope = _args.length > 2 && _args[2] !== undefined ? _args[2] : "item";

                  if (!(this.manifest && id)) {
                    _context.next = 18;
                    break;
                  }

                  _context.t0 = _mobxEsm.toJS;
                  _context.next = 6;
                  return this.manifest.items.find(function (item) {
                    if (item[attrLookup] !== id) {
                      return false;
                    }

                    return true;
                  });

                case 6:
                  _context.t1 = _context.sent;
                  tmpItem = (0, _context.t0)(_context.t1);

                  if (!(scope == "item")) {
                    _context.next = 12;
                    break;
                  }

                  return _context.abrupt("return", tmpItem);

                case 12:
                  if (!(scope == "parent" && tmpItem.parent)) {
                    _context.next = 18;
                    break;
                  }

                  _context.t2 = _mobxEsm.toJS;
                  _context.next = 16;
                  return this.manifest.items.find(function (d) {
                    return tmpItem.parent === d.id;
                  });

                case 16:
                  _context.t3 = _context.sent;
                  return _context.abrupt("return", (0, _context.t2)(_context.t3));

                case 18:
                  return _context.abrupt("return", null);

                case 19:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function findItemAsObject(_x) {
          return _findItemAsObject.apply(this, arguments);
        }

        return findItemAsObject;
      }()
      /**
       * Spider children based on criteria and return what we found
       */

    }, {
      key: "spiderChildren",
      value: function spiderChildren(item, data, start, end, parent, parentFound, noDynamicLevel) {
        var _this6 = this;

        // see if we have the parent... or keep going
        if (item.id === parent || parentFound) {
          // set parent to current so it's gaurenteed to match on next one
          if (!parentFound) {
            parentFound = true; // support sliding scales, meaning that start / end is relative to active

            if (!noDynamicLevel && item.indent >= start) {
              start += item.indent;
              end += item.indent;
            }
          } // only add on what we're between


          if (item.indent >= start && item.indent <= end) {
            data.push(item);
          } // we've found it. Now everyone below here should match


          if (item.children.length > 0) {
            item.children.forEach(function (child) {
              // recursively call itself
              _this6.spiderChildren(child, data, start, end, parent, parentFound, noDynamicLevel);
            });
          }
        } else {
          if (item.children.length > 0) {
            item.children.forEach(function (child) {
              // recursively call itself
              _this6.spiderChildren(child, data, start, end, parent, parentFound, noDynamicLevel);
            });
          }
        }
      }
      /**
       * Compute items leveraging the site query engine
       */

    }, {
      key: "computeItems",
      value: function computeItems(start, end, parent, dynamicMethodology, _routerManifest, noDynamicLevel) {
        if (_routerManifest) {
          var _ret3 = function () {
            var items = [];
            var data = [];
            var tmpItem;

            _routerManifest.items.forEach(function (element) {
              // find top level parents
              if (!element.parent) {
                items.push(element);
              }
            });

            switch (dynamicMethodology) {
              case "parent":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // shift up 1 if we found something

                if (tmpItem) {
                  parent = tmpItem.parent;
                }

                break;

              case "ancestor":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // walk back up to the root

                while (tmpItem && tmpItem.parent != null) {
                  // take the parent object of this current item
                  tmpItem = _routerManifest.items.find(function (i) {
                    return i.id == tmpItem.parent;
                  });
                }

                if (tmpItem) {
                  parent = tmpItem.id;
                }

                break;
            }

            _routerManifest.items.forEach(function (item, i) {
              store.spiderChildren(item, data, start, end, parent, false, noDynamicLevel);
            });

            return {
              v: data
            };
          }();

          if (babelHelpers.typeof(_ret3) === "object") return _ret3.v;
        }
      }
    }]);
    return Store;
  }();
  /**
   * Central store
   */


  var store = new Store(); // register globally so we can make sure there is only one

  _exports.store = store;
  window.HAXCMS = window.HAXCMS || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same modal

  window.HAXCMS.requestAvailability = function () {
    if (!window.HAXCMS.instance) {
      window.HAXCMS.instance = document.createElement("haxcms-site-store");
      document.body.appendChild(window.HAXCMS.instance);
    }

    return window.HAXCMS.instance;
  }; // weird, but self appending


  var HAXcmsStore = window.HAXCMS.requestAvailability();
  /**
   * HTMLElement
   */

  _exports.HAXcmsStore = HAXcmsStore;

  var HAXCMSSiteStore = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(HAXCMSSiteStore, _HTMLElement);

    var _super = _createSuper(HAXCMSSiteStore);

    function HAXCMSSiteStore() {
      var _this7;

      babelHelpers.classCallCheck(this, HAXCMSSiteStore);
      _this7 = _super.call(this); // keep track of the HTML element pieces dedicated to different
      // critical pieces of functionality like theme and editor builders.

      _this7.storePieces = {}; // full on store that does the heavy lifting

      _this7.store = store; // source for reading in the store if different than default site.json

      _this7.source = "";
      /**
       * When location changes update activeItem
       */

      (0, _mobxEsm.autorun)(function () {
        if (store.location && store.location.route && store.location.route.component) {
          // get the id from the router
          var id = store.location.route.name; // make sure that we aren't in edit mode

          var found = store.manifest.items.filter(function (item) {
            if (item.id !== id) {
              return false;
            }

            return true;
          });

          if (found) {
            store.activeId = id;
          }
        }
      });
      /**
       * When Active Item Changes notify json-outline-schema to have the backend
       * change the page.
       */

      (0, _mobxEsm.autorun)(function () {
        var foundItem = (0, _mobxEsm.toJS)(store.findItem(store.activeId));

        if (foundItem) {
          document.body.dispatchEvent(new CustomEvent("json-outline-schema-active-item-changed", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: foundItem
          }));
        }
      });
      /**
       * When editMode changes notify HAXeditor.
       */

      (0, _mobxEsm.autorun)(function () {
        var editMode = (0, _mobxEsm.toJS)(store.editMode); // trap for early setup

        if (window.HaxStore && window.HaxStore.requestAvailability() && window.HaxStore.requestAvailability().write) {
          window.dispatchEvent(new CustomEvent("haxcms-edit-mode-changed", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: editMode
          }));
          window.HaxStore.requestAvailability().editMode = editMode; // @todo hack to keep voice controls active if enabled

          if (window.HaxStore.requestAvailability().globalPreferences.haxVoiceCommands) {
            setTimeout(function () {
              window.HaxStore.requestAvailability().__hal.auto = true;
            }, 10);
          }
        }
      });
      return _this7;
    }
    /**
     * Try to get context of what backend is powering this
     */


    babelHelpers.createClass(HAXCMSSiteStore, [{
      key: "getApplicationContext",
      value: function getApplicationContext() {
        var context = ""; // @todo review if we even need this because newer contexts don't care
        // figure out the context we need to apply for where the editing creds
        // and API might come from
        // beaker is a unique scenario

        if ((typeof DatArchive === "undefined" ? "undefined" : babelHelpers.typeof(DatArchive)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          context = "beaker"; // implies usage of BeakerBrowser, an experimental browser for decentralization
        } else {
          switch (window.HAXCMSContext) {
            case "published": // implies this is to behave as if it is completely static

            case "nodejs": // implies nodejs based backend, tho no diff from

            case "php": // implies php backend

            case "11ty": // implies 11ty static site generator

            case "demo": // demo / local development

            case "desktop": // implies electron

            case "local":
              // implies ability to use local file system
              context = window.HAXCMSContext;
              break;

            default:
              // we don't have one so assume it's php for now
              // @notice change this in the future
              context = "php";
              break;
          }
        }

        return context;
      }
    }, {
      key: "source",
      get: function get() {
        return this.getAttribute("source");
      },
      set: function set(value) {
        this[name] = value;

        if (value) {
          this.setAttribute("source", value);
        }
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, oldVal, newVal) {
        var _this8 = this;

        if (name == "source" && newVal != "") {
          fetch(this[name]).then(function (response) {
            return response.json();
          }).then(function (data) {
            _this8.store.loadManifest(data);
          }).catch(function (err) {
            console.warn(err);
          });
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "haxcms-site-store";
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return ["source"];
      }
    }]);
    return HAXCMSSiteStore;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.HAXCMSSiteStore = HAXCMSSiteStore;
  window.customElements.define(HAXCMSSiteStore.tag, HAXCMSSiteStore);
});