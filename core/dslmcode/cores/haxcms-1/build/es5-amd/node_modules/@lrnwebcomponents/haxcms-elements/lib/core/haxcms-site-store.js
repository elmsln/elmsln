define(["exports", "meta", "../../../../mobx/dist/mobx.esm.js", "../../../utils/utils.js", "../../../json-outline-schema/json-outline-schema.js", "../../../replace-tag/lib/PerformanceDetect.js"], function (_exports, meta, _mobxEsm, _utils, _jsonOutlineSchema, _PerformanceDetect) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.store = _exports.HAXcmsStore = _exports.HAXCMSSiteStore = void 0;
  meta = _interopRequireWildcard(meta);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && babelHelpers.instanceof(outerFn.prototype, Generator) ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == babelHelpers.typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

  (0, _mobxEsm.configure)({
    enforceActions: false,
    useProxies: "ifavailable"
  }); // strict mode off

  var Store = /*#__PURE__*/function () {
    function Store() {
      babelHelpers.classCallCheck(this, Store);
      this.badDevice = false;
      this.evaluatebadDevice();
      this.location = null;
      this.jwt = null;
      this.soundStatus = (0, _utils.localStorageGet)("app-hax-soundStatus", true);
      this.darkMode = !(0, _utils.localStorageGet)("app-hax-darkMode") ? false : (0, _utils.localStorageGet)("app-hax-darkMode");
      this.setupSlots = {
        "haxcms-site-editor-ui-prefix-avatar": [],
        "haxcms-site-editor-ui-prefix-buttons": [],
        "haxcms-site-editor-ui-suffix-buttons": [],
        "haxcms-site-editor-ui-main-menu": [],
        "haxcms-site-editor-ui-topbar-character-button": []
      };
      this.appReady = false;
      this.editMode = false;
      this.manifest = null;
      this.activeItemContent = "";
      this.themeElement = null;
      this.themeStyleElement = document.createElement("style");
      this.themeStyleElement.id = "haxcms-theme-global-style-element";
      this.t = {
        close: "Close"
      };
      this.activeId = null;
      this.userData = {};
      this.cmsSiteEditor = {
        instance: null
      };
      this.cmsSiteEditorBackend = {
        instance: null
      };
      this.dashboardOpened = false;
      (0, _mobxEsm.makeObservable)(this, {
        location: _mobxEsm.observable.ref,
        // router location in url
        editMode: _mobxEsm.observable,
        // global editing state
        jwt: _mobxEsm.observable,
        // json web token
        dashboardOpened: _mobxEsm.observable,
        // if haxcms backend settings are open
        userData: _mobxEsm.observable,
        // user data object for logged in users
        manifest: _mobxEsm.observable,
        // JOS / manifest
        activeItemContent: _mobxEsm.observable,
        // active site content, cleaned up
        themeElement: _mobxEsm.observable,
        // theme element
        routerManifest: _mobxEsm.computed,
        // router mixed in manifest w/ routes / paths
        siteTitle: _mobxEsm.computed,
        isLoggedIn: _mobxEsm.computed,
        // simple boolean for state so we can style based on logged in
        themeData: _mobxEsm.computed,
        // get the active theme from manifest + activeId
        homeLink: _mobxEsm.computed,
        activeId: _mobxEsm.observable,
        // this affects all state changes associated to activeItem
        activeItem: _mobxEsm.computed,
        // active item object
        activeItemFields: _mobxEsm.computed,
        // active item field values
        activeManifestIndex: _mobxEsm.computed,
        // active array index, used for pagination
        activeManifestIndexCounter: _mobxEsm.computed,
        // active array index counter, used for pagination
        activeTitle: _mobxEsm.computed,
        // active page title
        parentTitle: _mobxEsm.computed,
        // active page parent title
        ancestorTitle: _mobxEsm.computed,
        // active page ancestor title
        ancestorItem: _mobxEsm.computed,
        // active page ancestor
        darkMode: _mobxEsm.observable,
        // dark mode pref
        soundStatus: _mobxEsm.observable,
        // toggle sounds on and off
        appReady: _mobxEsm.observable,
        // system is ready via firstUpdated of haxcms-site-builder
        badDevice: _mobxEsm.observable // if we have a low performance device

      });
    }
    /**
     * Get a unique slug name / path based on existing slug, page data and if we are to automatically generate
     * @param {*} slug
     * @param {*} page
     * @param {*} pathAuto
     * @returns
     */


    babelHelpers.createClass(Store, [{
      key: "getUniqueSlugName",
      value: function getUniqueSlugName(slug) {
        var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var pathAuto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var rSlug = slug; // check for pathauto setting and this having a parent

        if (page != null && page.parent != null && page.parent != "" && pathAuto) {
          var item = page;
          var pieces = [slug];

          while (item = this.findItem(item.parent)) {
            var tmp = item.slug.split("/");
            pieces.unshift(tmp.pop());
          }

          slug = pieces.join("/");
          rSlug = slug;
        }

        var loop = 0;
        var ready = false; // while not ready, keep checking

        while (!ready) {
          ready = true; // loop through items

          for (var key in this.manifest.items) {
            var _item = this.manifest.items[key]; // if our slug matches an existing

            if (rSlug == _item.slug) {
              // if we have a page, and it matches that, bail out cause we have it already
              if (page != null && _item.id == page.id) {
                return rSlug;
              } else {
                // increment the number
                loop++; // append to the new slug

                rSlug = slug + "-" + loop; // force a new test

                ready = false;
              }
            }
          }
        }

        return rSlug.toLowerCase().split(" ").join("-").replace(/[^0-9\-\/a-z]/gi, "");
      } // see if this device is poor

    }, {
      key: "evaluatebadDevice",
      value: function () {
        var _evaluatebadDevice = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _PerformanceDetect.DeviceDetails.badDevice();

                case 2:
                  this.badDevice = _context.sent;

                  if (this.badDevice) {
                    this.soundStatus = false;
                  }

                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function evaluatebadDevice() {
          return _evaluatebadDevice.apply(this, arguments);
        }

        return evaluatebadDevice;
      }() // eslint-disable-next-line class-methods-use-this

    }, {
      key: "playSound",
      value: function playSound(sound) {
        if (this.soundStatus && this.appReady) {
          try {
            switch (sound) {
              case "click":
              case "click2":
              case "coin":
              case "coin2":
              case "hit":
              case "success":
                this.audio = new Audio(new URL("../../../app-hax/lib/assets/sounds/".concat(sound, ".mp3"), meta.url).href);
                this.audio.play();
                break;

              default:
                this.audio = new Audio(new URL("../../../app-hax/lib/assets/sounds/hit.mp3", meta.url).href);
                this.audio.play();
                console.warn("".concat(sound, " is not a valid sound file yet"));
                break;
            }
          } catch (e) {
            console.warn(e);
          }
        }
      }
      /**
       * Global toast bridge so we don't have to keep writing custom event
       */

    }, {
      key: "toast",
      value: function toast(message) {
        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
        var extras = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var classStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "capsule";
        var closeText = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.t.close;
        var eventCallback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var slot = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

        if (this.appReady) {
          // gets it all the way to the top immediately
          window.dispatchEvent(new CustomEvent("haxcms-toast-show", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: _objectSpread({
              text: message,
              duration: duration,
              classStyle: classStyle,
              closeText: closeText,
              eventCallback: eventCallback,
              slot: slot
            }, extras)
          }));
        }
      }
      /**
       * Load a manifest / site.json / JSON outline schema
       * and prep it for usage in HAXcms
       */

    }, {
      key: "loadManifest",
      value: function () {
        var _loadManifest = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(manifest) {
          var target,
              git,
              site,
              nodes,
              correctOrder,
              newItems,
              key,
              _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  target = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;

                  // support a custom target or ensure event fires off window
                  if (target == null && window) {
                    target = window;
                  } // @todo replace this with a schema version mapper
                  // once we have versions


                  if ((0, _utils.varExists)(manifest, "metadata.siteName")) {
                    git = (0, _utils.varGet)(manifest, "publishing.git", {});
                    manifest.metadata.site = {
                      name: manifest.metadata.siteName,
                      git: git,
                      created: manifest.metadata.created,
                      updated: manifest.metadata.updated
                    };
                    manifest.metadata.theme.variables = {
                      image: manifest.metadata.image,
                      icon: manifest.metadata.icon,
                      hexCode: manifest.metadata.hexCode,
                      cssVariable: manifest.metadata.cssVariable
                    };
                    manifest.metadata.node = {
                      dynamicElementLoader: manifest.metadata.dynamicElementLoader,
                      fields: manifest.metadata.fields
                    };
                    delete manifest.metadata.publishing;
                    delete manifest.metadata.created;
                    delete manifest.metadata.updated;
                    delete manifest.metadata.siteName;
                    delete manifest.metadata.image;
                    delete manifest.metadata.icon;
                    delete manifest.metadata.hexCode;
                    delete manifest.metadata.cssVariable;
                    delete manifest.metadata.dynamicElementLoader;
                    delete manifest.metadata.fields;
                  } // repair slug not being in earlier builds of json schema


                  _context2.next = 5;
                  return manifest.items.forEach(function (item, index, array) {
                    // if we did not have a slug, generate one off location
                    if (!item.slug) {
                      array[index].slug = item.location.replace("pages/", "").replace("/index.html", "");
                    } // we default published to true if not set
                    // this avoids constantly checking downstream


                    if (!item.metadata.hasOwnProperty("published")) {
                      array[index].metadata.published = true;
                    } // fix order typing


                    array[index].order = Number(array[index].order); // we default locked to false if not set

                    if (!item.metadata.hasOwnProperty("locked")) {
                      array[index].metadata.locked = false;
                    } // we default locked to false if not set


                    if (!item.metadata.hasOwnProperty("status")) {
                      array[index].metadata.status = "";
                    }
                  });

                case 5:
                  site = new _jsonOutlineSchema.JsonOutlineSchema(); // we already have our items, pass them in

                  nodes = site.itemsToNodes(manifest.items); // smash outline into flat to get the correct order

                  correctOrder = site.nodesToItems(nodes);
                  newItems = []; // build a new array in the correct order by pushing the old items around

                  for (key in correctOrder) {
                    newItems.push(manifest.items.find(function (element) {
                      return element.id === correctOrder[key].id;
                    }));
                  } // support for language being defined in the manifest of the site


                  if (document.documentElement && manifest.metadata.site.lang) {
                    document.documentElement.lang = manifest.metadata.site.lang;
                    window.dispatchEvent(new CustomEvent("languagechange", {
                      detail: manifest.metadata.site.lang
                    }));
                  }

                  manifest.items = newItems;
                  this.manifest = manifest;
                  target.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: manifest
                  }));
                  window.dispatchEvent(new CustomEvent("haxcms-item-rebuild", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                case 15:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function loadManifest(_x) {
          return _loadManifest.apply(this, arguments);
        }

        return loadManifest;
      }()
      /**
       * Ensure there's a copy of the site-editor globally available
       */

    }, {
      key: "cmsSiteEditorAvailability",
      value: function cmsSiteEditorAvailability() {
        if (!this.cmsSiteEditor.instance) {
          this.cmsSiteEditor.instance = document.createElement("haxcms-site-editor");
        }

        return this.cmsSiteEditor.instance;
      }
    }, {
      key: "processedItems",
      get: function get() {}
      /**
       * Compute items leveraging the site query engine
       */

    }, {
      key: "_computeItems",
      value: function _computeItems(start, end, parent, dynamicMethodology, _routerManifest) {
        var _this = this;

        if (_routerManifest) {
          var _ret = function () {
            var items = [];
            var data = [];
            var tmpItem;

            _routerManifest.items.forEach(function (element) {
              // find top level parents
              if (!element.parent) {
                items.push(element);
              }
            });

            switch (dynamicMethodology) {
              case "parent":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // shift up 1 if we found something

                if (tmpItem) {
                  parent = tmpItem.parent;
                }

                break;

              case "ancestor":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // walk back up to the root

                while (tmpItem && tmpItem.parent != null) {
                  // take the parent object of this current item
                  tmpItem = _routerManifest.items.find(function (i) {
                    return i.id == tmpItem.parent;
                  });
                }

                if (tmpItem) {
                  parent = tmpItem.id;
                }

                break;
            }

            items.forEach(function (item, i) {
              _this._spiderChildren(item, data, start, end, parent, false);
            });
            return {
              v: data
            };
          }();

          if (babelHelpers.typeof(_ret) === "object") return _ret.v;
        }
      }
      /**
       * Recursively search through a data to find children
       * of a specified item.
       */

    }, {
      key: "_setChildren",
      value: function _setChildren(item, data) {
        var _this2 = this;

        // find all children
        var children = data.filter(function (d) {
          return item.id === d.parent;
        });
        item.children = children;

        if (item.children.length > 0) {
          item.children.forEach(function (child) {
            // recursively call itself
            _this2._setChildren(child, data);
          });
        }
      }
      /**
       * The manifest but with routing mixed in
       */

    }, {
      key: "routerManifest",
      get: function get() {
        var _this3 = this;

        var manifest = this.manifest;
        document.body.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: manifest
        }));

        if (manifest && typeof manifest.items !== "undefined") {
          var manifestItems = manifest.items.map(function (i) {
            var parentLocation = null;
            var parentSlug = null;
            var parent = manifest.items.find(function (d) {
              return i.parent === d.id;
            });

            if (parent) {
              parentLocation = parent.location;
              parentSlug = parent.slug;
            }

            var metadata = i.metadata;
            var location = i.location;
            var slug = i.slug;
            return Object.assign({}, i, {
              parentLocation: parentLocation,
              parentSlug: parentSlug,
              location: location,
              slug: slug,
              metadata: metadata
            });
          }); // build the children into a hierarchy too

          manifestItems.forEach(function (item, i) {
            _this3._setChildren(item, manifestItems);
          });
          /**
           * Publish Pages Option
           *
           * This option enables the notion of published and unpublished pages.
           * To enable this option set manifest.metadata.site.settings.publishPagesOn = true
           *
           * By default all pages will be published unless "metadata.published" is set to "true" on the
           * item.
           */

          if ((0, _utils.varGet)(manifest, "metadata.site.settings.publishPagesOn", true) === true) {
            var filterHiddenParentsRecursive = function filterHiddenParentsRecursive(item) {
              // if the item is unpublished then remove it.
              if (item.metadata.published === false) {
                return false;
              } // if the item has parents, recursively see if any parent is not published


              var parent = manifestItems.find(function (i) {
                return i.id === item.parent;
              });

              if (parent) {
                return filterHiddenParentsRecursive(parent);
              } // if it got this far then it should be good.


              return true;
            }; // If the user is not logged in then we need to hide unpublished nodes items


            if (!this.isLoggedIn) {
              manifestItems = manifestItems.filter(function (i) {
                return filterHiddenParentsRecursive(i);
              });
            }
          }

          return Object.assign({}, manifest, {
            items: manifestItems
          });
        }
      }
      /**
       * Return the site title
       */

    }, {
      key: "siteTitle",
      get: function get() {
        if (this.manifest && this.manifest.title) {
          return this.manifest.title;
        }

        return "";
      }
      /**
       * Figure out the home page, lazily the 1st thing in the manifest
       */

    }, {
      key: "homeLink",
      get: function get() {
        // if we are on the homepage then load the first item in the manifest and set it active
        if (this.manifest) {
          var firstItem = this.manifest.items.find(function (i) {
            return typeof i.id !== "undefined";
          });

          if (firstItem) {
            return firstItem.slug;
          }
        }

        return "/";
      }
      /**
       * Get the active Item based on activeId
       */

    }, {
      key: "activeItem",
      get: function get() {
        var item = this.findItem(this.activeId); // ensure we found something, return null for consistency in data

        if (item) {
          return item;
        }

        return null;
      }
      /**
       * Get the fields from the node
       */

    }, {
      key: "activeItemFields",
      get: function get() {
        // need to have metadata to be valid so..
        if (this.activeItem && this.activeItem.metadata) {
          // core "fields" we'd expect
          var fields = {
            title: this.activeItem.title,
            description: this.activeItem.description,
            location: this.activeItem.location,
            slug: this.activeItem.slug,
            created: this.activeItem.metadata.created,
            updated: this.activeItem.metadata.created
          }; // mix in any custom field definitions

          if (this.activeItem.metadata.fields) {
            return Object.assign({}, fields, this.activeItem.metadata.fields);
          }
        }
      }
      /**
       * get theme data from manifest + activeId combo
       */

    }, {
      key: "themeData",
      get: function get() {
        if (this.manifest) {
          var themeData = {}; // this is required so better be...

          if ((0, _utils.varExists)(this.manifest, "metadata.theme")) {
            themeData = this.manifest.metadata.theme;
          } else {
            // fallback juuuuust to be safe...
            themeData = {
              "haxcms-basic-theme": {
                element: "haxcms-basic-theme",
                path: "@lrnwebcomponents/haxcms-elements/lib/core/themes/haxcms-basic-theme.js",
                name: "Basic theme",
                variables: {
                  image: "assets/banner.jpg",
                  icon: "icons:record-voice-over",
                  hexCode: "#da004e",
                  cssVariable: "pink"
                }
              }
            };
          } // ooo you sneaky devil you...


          if (this.activeItem && (0, _utils.varExists)(this.activeItem, "metadata.theme")) {
            return this.activeItem.metadata.theme;
          }

          return themeData;
        }
      }
      /**
       * Get the active manifest index array position
       * -1 if not found
       */

    }, {
      key: "activeManifestIndex",
      get: function get() {
        if (this.manifest && this.manifest.items && this.activeId) {
          for (var index in this.manifest.items) {
            if (this.manifest.items[index].id === this.activeId) {
              return parseInt(index);
            }
          }
        }

        return -1;
      }
    }, {
      key: "activeRouterManifestIndex",
      get: function get() {
        if (this.routerManifest && this.routerManifest.items && this.activeId) {
          for (var index in this.routerManifest.items) {
            if (this.routerManifest.items[index].id === this.activeId) {
              return parseInt(index);
            }
          }
        }

        return -1;
      }
      /**
       * Better for visualizing the counter
       */

    }, {
      key: "activeManifestIndexCounter",
      get: function get() {
        if (this.activeManifestIndex !== null) {
          return 1 + this.activeManifestIndex;
        }

        return 0;
      }
      /**
       * shortcut for active page title
       */

    }, {
      key: "activeTitle",
      get: function get() {
        if (this.activeItem) {
          return this.activeItem.title;
        }

        return "";
      }
      /**
       * shortcut for active page parent title
       */

    }, {
      key: "parentTitle",
      get: function get() {
        var _this4 = this;

        if (this.manifest && this.activeItem) {
          var tmpItem = this.manifest.items.find(function (d) {
            return _this4.activeItem.parent === d.id;
          }); // shift up 1 if we found something

          if (tmpItem) {
            return tmpItem.title;
          }
        }

        return "";
      }
    }, {
      key: "isLoggedIn",
      get: function get() {
        // account for keypair storage issue since its a string bin
        if (this.jwt && this.jwt != "null") {
          return true;
        }

        return false;
      }
      /**
       * shortcut for active page ancestor title
       */

    }, {
      key: "ancestorTitle",
      get: function get() {
        var _this5 = this;

        if (this.manifest && this.activeItem) {
          var _ret2 = function () {
            var tmpItem = _this5.manifest.items.find(function (d) {
              return _this5.activeItem.parent === d.id;
            }); // walk back up to the root


            while (tmpItem && tmpItem.parent != null) {
              // take the parent object of this current item
              tmpItem = _this5.manifest.items.find(function (i) {
                return i.id == tmpItem.parent;
              });
            }

            if (tmpItem) {
              return {
                v: tmpItem.title
              };
            }
          }();

          if (babelHelpers.typeof(_ret2) === "object") return _ret2.v;
        }

        return "";
      }
      /**
       * shortcut for active page ancestor
       */

    }, {
      key: "ancestorItem",
      get: function get() {
        var _this6 = this;

        if (this.manifest && this.activeItem) {
          var _ret3 = function () {
            var tmpItem = _this6.manifest.items.find(function (d) {
              return _this6.activeItem.parent === d.id;
            }); // walk back up to the root


            while (tmpItem && tmpItem.parent != null) {
              // take the parent object of this current item
              tmpItem = _this6.manifest.items.find(function (i) {
                return i.id == tmpItem.parent;
              });
            }

            if (tmpItem) {
              return {
                v: tmpItem
              };
            }
          }();

          if (babelHelpers.typeof(_ret3) === "object") return _ret3.v;
        }

        return null;
      }
      /**
       * shortcut to find an item in the manifest based on id
       */

    }, {
      key: "findItem",
      value: function findItem(id) {
        if (this.manifest && id) {
          return this.manifest.items.find(function (item) {
            if (item.id !== id) {
              return false;
            }

            return true;
          });
        }

        return null;
      }
      /**
       * shortcut to find an item in the manifest based on id
       */

    }, {
      key: "findItemAsObject",
      value: function () {
        var _findItemAsObject = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id) {
          var attrLookup,
              scope,
              useToJS,
              tmpItem,
              _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  attrLookup = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : "id";
                  scope = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : "item";
                  useToJS = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : true;

                  if (!(this.manifest && id)) {
                    _context3.next = 18;
                    break;
                  }

                  _context3.next = 6;
                  return this.manifest.items.find(function (item) {
                    if (item[attrLookup] !== id) {
                      return false;
                    }

                    return true;
                  });

                case 6:
                  tmpItem = _context3.sent;

                  if (useToJS) {
                    tmpItem = (0, _mobxEsm.toJS)(tmpItem);
                  }

                  if (!(scope == "item")) {
                    _context3.next = 12;
                    break;
                  }

                  return _context3.abrupt("return", tmpItem);

                case 12:
                  if (!(scope == "parent" && tmpItem.parent)) {
                    _context3.next = 18;
                    break;
                  }

                  _context3.t0 = _mobxEsm.toJS;
                  _context3.next = 16;
                  return this.manifest.items.find(function (d) {
                    return tmpItem.parent === d.id;
                  });

                case 16:
                  _context3.t1 = _context3.sent;
                  return _context3.abrupt("return", (0, _context3.t0)(_context3.t1));

                case 18:
                  return _context3.abrupt("return", null);

                case 19:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function findItemAsObject(_x2) {
          return _findItemAsObject.apply(this, arguments);
        }

        return findItemAsObject;
      }()
      /**
       * return a fallback item because we just got a miss.
       * usually to avoid redirect loops
       */

    }, {
      key: "fallbackItemSlug",
      value: function fallbackItemSlug() {
        if (this.manifest && this.activeItem) {
          if (this.activeManifestIndex > 0 && this.manifest.items[this.activeManifestIndex - 1]) {
            return this.manifest.items[this.activeManifestIndex - 1].slug;
          } else if (this.activeManifestIndex < this.manifest.items.length - 1 && this.manifest.items[this.activeManifestIndex + 1]) {
            return this.manifest.items[this.activeManifestIndex + 1].slug;
          }
        }

        return null;
      }
      /**
       * Return a clone of the manifest items list
       */

    }, {
      key: "getManifestItems",
      value: function getManifestItems() {
        var cloneIt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (cloneIt) {
          return (0, _mobxEsm.toJS)(this.manifest.items);
        }

        return this.manifest.items;
      }
      /**
       * Return a clone of the manifest
       */

    }, {
      key: "getManifest",
      value: function getManifest() {
        var cloneIt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (cloneIt) {
          return (0, _mobxEsm.toJS)(this.manifest);
        }

        return this.manifest;
      }
      /**
       * Add an item
       */

    }, {
      key: "addItem",
      value: function () {
        var _addItem = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(item) {
          var schema, newItem, safeItem, nodes, correctOrder, newItems, key;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  schema = new _jsonOutlineSchema.JsonOutlineSchema();
                  newItem = schema.newItem();

                  if (item.id) {
                    newItem.id = item.id;
                  }

                  if (item.indent) {
                    newItem.indent = item.indent;
                  }

                  newItem.location = item.location;
                  newItem.slug = item.slug;
                  newItem.order = item.order;
                  newItem.parent = item.parent;
                  newItem.title = item.title; // metadata can be anything so whatever

                  newItem.metadata = item.metadata; // all items rebuilt

                  schema.items = (0, _mobxEsm.toJS)(this.manifest.items);
                  safeItem = _objectSpread({}, schema.validateItem(newItem));
                  schema.items.push(safeItem); // we already have our items, pass them in

                  nodes = schema.itemsToNodes(schema.items); // smash outline into flat to get the correct order

                  correctOrder = schema.nodesToItems(nodes);
                  newItems = []; // build a new array in the correct order by pushing the old items around

                  for (key in correctOrder) {
                    newItems.push(schema.items.find(function (element) {
                      return element.id === correctOrder[key].id;
                    }));
                  }

                  this.manifest.items.replace(newItems);
                  window.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));
                  window.dispatchEvent(new CustomEvent("haxcms-item-rebuild", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));
                  return _context4.abrupt("return", this.findItem(newItem.id));

                case 21:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function addItem(_x3) {
          return _addItem.apply(this, arguments);
        }

        return addItem;
      }()
      /**
       * Remove an item
       */

    }, {
      key: "removeItem",
      value: function removeItem(id) {
        var item = this.findItem(id); // "new" items have not yet been added

        if (item) {
          if (item.metadata.status === "new") {
            var index = this.manifest.items.indexOf(item);

            if (index > -1) {
              this.manifest.items.splice(index, 1);
            }
          } else {
            // implies it's going to get deleted on next run
            item.metadata.status = "delete";
          }
        }
      }
      /**
       * Spider children based on criteria and return what we found
       */

    }, {
      key: "spiderChildren",
      value: function spiderChildren(item, data, start, end, parent, parentFound, noDynamicLevel) {
        var _this7 = this;

        // see if we have the parent... or keep going
        if (item.id === parent || parentFound) {
          // set parent to current so it's gaurenteed to match on next one
          if (!parentFound) {
            parentFound = true; // support sliding scales, meaning that start / end is relative to active

            if (!noDynamicLevel && item.indent >= start) {
              start += item.indent;
              end += item.indent;
            }
          } // only add on what we're between


          if (item.indent >= start && item.indent <= end) {
            data.push(item);
          } // we've found it. Now everyone below here should match


          if (item.children.length > 0) {
            item.children.forEach(function (child) {
              // recursively call itself
              _this7.spiderChildren(child, data, start, end, parent, parentFound, noDynamicLevel);
            });
          }
        } else {
          if (item.children.length > 0) {
            item.children.forEach(function (child) {
              // recursively call itself
              _this7.spiderChildren(child, data, start, end, parent, parentFound, noDynamicLevel);
            });
          }
        }
      }
      /**
       * Compute items leveraging the site query engine
       */

    }, {
      key: "computeItems",
      value: function computeItems(start, end, parent, dynamicMethodology, _routerManifest, noDynamicLevel) {
        if (_routerManifest) {
          var _ret4 = function () {
            var items = [];
            var data = [];
            var tmpItem;

            _routerManifest.items.forEach(function (element) {
              // find top level parents
              if (!element.parent) {
                items.push(element);
              }
            });

            switch (dynamicMethodology) {
              case "parent":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // shift up 1 if we found something

                if (tmpItem) {
                  parent = tmpItem.parent;
                }

                break;

              case "ancestor":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // walk back up to the root

                while (tmpItem && tmpItem.parent != null) {
                  // take the parent object of this current item
                  tmpItem = _routerManifest.items.find(function (i) {
                    return i.id == tmpItem.parent;
                  });
                }

                if (tmpItem) {
                  parent = tmpItem.id;
                }

                break;
            }

            _routerManifest.items.forEach(function (item, i) {
              store.spiderChildren(item, data, start, end, parent, false, noDynamicLevel);
            });

            return {
              v: data
            };
          }();

          if (babelHelpers.typeof(_ret4) === "object") return _ret4.v;
        }
      }
    }]);
    return Store;
  }();
  /**
   * Central store
   */


  var store = new Store(); // register globally so we can make sure there is only one

  _exports.store = store;
  window.HAXCMS = window.HAXCMS || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same modal

  window.HAXCMS.requestAvailability = function () {
    if (!window.HAXCMS.instance) {
      window.HAXCMS.instance = document.createElement("haxcms-site-store");
      document.body.appendChild(window.HAXCMS.instance);
    }

    return window.HAXCMS.instance;
  }; // weird, but self appending


  var HAXcmsStore = window.HAXCMS.requestAvailability();
  /**
   * HTMLElement
   */

  _exports.HAXcmsStore = HAXcmsStore;

  var HAXCMSSiteStore = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(HAXCMSSiteStore, _HTMLElement);

    var _super = _createSuper(HAXCMSSiteStore);

    function HAXCMSSiteStore() {
      var _this8;

      babelHelpers.classCallCheck(this, HAXCMSSiteStore);
      _this8 = _super.call(this); // keep track of the HTML element pieces dedicated to different
      // critical pieces of functionality like theme and editor builders.

      _this8.storePieces = {}; // full on store that does the heavy lifting

      _this8.store = store; // source for reading in the store if different than default site.json

      _this8.source = "";
      /**
       * When location changes update activeItem
       */

      (0, _mobxEsm.autorun)(function () {
        if (store.location && store.location.route && store.location.route.component) {
          // get the id from the router
          var id = store.location.route.name; // make sure that we aren't in edit mode

          var found = store.manifest.items.filter(function (item) {
            if (item.id !== id) {
              return false;
            }

            return true;
          });

          if (found) {
            store.activeId = id;
          }
        }
      });
      /**
       * When Active Item Changes notify json-outline-schema to have the backend
       * change the page.
       */

      (0, _mobxEsm.autorun)(function () {
        var foundItem = (0, _mobxEsm.toJS)(store.findItem(store.activeId));

        if (foundItem) {
          document.body.dispatchEvent(new CustomEvent("json-outline-schema-active-item-changed", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: foundItem
          })); //change site title when page changes

          document.title = store.activeTitle;
        }
      });
      /**
       * When editMode changes notify HAXeditor.
       */

      (0, _mobxEsm.autorun)(function () {
        var editMode = (0, _mobxEsm.toJS)(store.editMode); // trap for early setup

        if (window.HaxStore && window.HaxStore.requestAvailability() && window.HaxStore.requestAvailability().write) {
          window.dispatchEvent(new CustomEvent("haxcms-edit-mode-changed", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: editMode
          }));
          window.HaxStore.requestAvailability().editMode = editMode;
          window.HaxStore.requestAvailability().toastShowEventName = "haxcms-toast-show"; // @todo hack to keep voice controls active if enabled

          if (window.HaxStore.requestAvailability().globalPreferences.haxVoiceCommands && window.HaxStore.requestAvailability().__hal) {
            setTimeout(function () {
              window.HaxStore.requestAvailability().__hal.auto = true;
            }, 10);
          }
        }
      });
      return _this8;
    }

    babelHelpers.createClass(HAXCMSSiteStore, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        document.body.appendChild(this.store.themeStyleElement);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.store.themeStyleElement.remove();
        this.store.themeStyleElement = document.createElement("style");
      }
      /**
       * Try to get context of what backend is powering this
       */

    }, {
      key: "getApplicationContext",
      value: function getApplicationContext() {
        var context = ""; // @todo review if we even need this because newer contexts don't care
        // figure out the context we need to apply for where the editing creds
        // and API might come from
        // beaker is a unique scenario

        if ((typeof DatArchive === "undefined" ? "undefined" : babelHelpers.typeof(DatArchive)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          context = "beaker"; // implies usage of BeakerBrowser, an experimental browser for decentralization
        } else {
          switch (window.HAXCMSContext) {
            case "published": // implies this is to behave as if it is completely static

            case "nodejs": // implies nodejs based backend, tho no diff from

            case "php": // implies php backend

            case "11ty": // implies 11ty static site generator

            case "demo": // demo / local development

            case "desktop": // implies electron

            case "local":
              // implies ability to use local file system
              context = window.HAXCMSContext;
              break;

            default:
              // we don't have one so assume it's php for now
              // @notice change this in the future
              context = "php";
              break;
          }
        }

        return context;
      }
    }, {
      key: "source",
      get: function get() {
        return this.getAttribute("source");
      },
      set: function set(value) {
        this[name] = value;

        if (value) {
          this.setAttribute("source", value);
        }
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, oldVal, newVal) {
        var _this9 = this;

        if (name == "source" && newVal != "") {
          fetch(this[name]).then(function (response) {
            return response.json();
          }).then(function (data) {
            _this9.store.loadManifest(data);
          }).catch(function (err) {
            console.warn(err);
          });
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "haxcms-site-store";
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return ["source"];
      }
    }]);
    return HAXCMSSiteStore;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.HAXCMSSiteStore = HAXCMSSiteStore;
  customElements.define(HAXCMSSiteStore.tag, HAXCMSSiteStore);
});