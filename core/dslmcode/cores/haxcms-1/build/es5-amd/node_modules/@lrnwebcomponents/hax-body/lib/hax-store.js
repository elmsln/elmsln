define(["exports", "meta", "require", "../../../lit/index.js", "../../simple-popover/lib/simple-tour.js", "../../utils/utils.js", "../../../mobx/dist/mobx.esm.js", "../../hax-body-behaviors/hax-body-behaviors.js", "../../i18n-manager/lib/I18NMixin.js", "../../media-behaviors/media-behaviors.js", "../../simple-toast/simple-toast.js", "./hax-app.js"], function (_exports, meta, _require, _index, _simpleTour, _utils, _mobxEsm, _haxBodyBehaviors, _I18NMixin2, _mediaBehaviors, _simpleToast, _haxApp) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxStore = _exports.HAXStore = void 0;
  meta = _interopRequireWildcard(meta);
  _require = _interopRequireWildcard(_require);

  var _templateObject_648e8ff0942811ecb1937969798b231a;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  (0, _mobxEsm.configure)({
    enforceActions: false,
    useProxies: "ifavailable"
  }); // strict mode off

  var FALLBACK_LANG = "en";

  function localStorageGet(name) {
    try {
      return localStorage.getItem(name);
    } catch (e) {
      return false;
    }
  }

  function localStorageSet(name, newItem) {
    try {
      return localStorage.setItem(name, newItem);
    } catch (e) {
      return false;
    }
  }

  function sessionStorageGet(name) {
    try {
      return sessionStorage.getItem(name);
    } catch (e) {
      return false;
    }
  }

  function sessionStorageSet(name, newItem) {
    try {
      return sessionStorage.setItem(name, newItem);
    } catch (e) {
      return false;
    }
  }

  var DataStyleDecoration = {
    attribute: "data-style-decoration",
    title: "Decoration",
    description: "Some built in styles to offset the material",
    inputMethod: "select",
    //multiple: true,
    options: {
      "": "",
      "highlight red": "Highlight (red)",
      "highlight blue": "Highlight (blue)",
      "highlight green": "Highlight (green)",
      "highlight orange": "Highlight (orange)",
      "highlight purple": "Highlight (purple)"
    }
  };
  /**
   * @element hax-store
   */

  var HaxStore = /*#__PURE__*/function (_I18NMixin) {
    babelHelpers.inherits(HaxStore, _I18NMixin);

    var _super = _createSuper(HaxStore);

    /**
     * Created life-cycle to ensure a single global store.
     */
    function HaxStore() {
      var _this;

      babelHelpers.classCallCheck(this, HaxStore);
      _this = _super.call(this);
      _this.t = {
        close: "Close"
      };
      _this.__dragTarget = null;

      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        namespace: "hax",
        basePath: meta.url + "/../../",
        locales: ["es"]
      });

      _this.method = "GET";
      _this.haxSelectedText = "";
      _this.__winEvents = {
        "hax-register-properties": "_haxStoreRegisterProperties",
        "hax-consent-tap": "_haxConsentTap",
        "hax-context-item-selected": "_haxContextOperation",
        onbeforeunload: "_onBeforeUnload",
        paste: "_onPaste",
        "hax-register-app": "_haxStoreRegisterApp",
        "hax-register-stax": "_haxStoreRegisterStax",
        "hax-store-write": "_writeHaxStore",
        "hax-register-core-piece": "_haxStorePieceRegistrationManager",
        "hax-register-body": "_haxStoreRegisterBody",
        "hax-insert-content": "_haxStoreInsertContent",
        "hax-insert-content-array": "_haxStoreInsertMultiple",
        "hax-add-voice-command": "_addVoiceCommand",
        "hax-refresh-tray-form": "refreshActiveNodeForm"
      }; // prevent leaving if we are in editMode

      window.onbeforeunload = function (e) {
        if (!_this.skipExitTrap && _this.editMode) {
          var saving = "Are you sure you want to leave? Your work will not be saved!";
          e.returnValue = saving;
          return saving;
        }
      }; // establish the tour


      _simpleTour.SimpleTourManager.registerNewTour({
        key: "hax",
        name: "Let's learn HAX",
        style: "\n      simple-popover-manager::part(simple-popover) {\n        max-width: 250px;\n      }\n      simple-popover-manager button {\n        font-size: 12px;\n        margin: 0px 2px;\n      }\n      simple-popover-manager p {\n        --hax-base-styles-p-font-size: 14px;\n        padding: 0;\n        margin: 0;\n        font-size: 14px;\n        line-height: 20px;\n      }\n      simple-popover-manager h3 {\n        --hax-base-styles-h3-font-size: 18px;\n        margin: 8px 2px;\n      }"
      });

      _this.voiceRespondsTo = "(worker)";
      _this.voiceCommands = {};
      _this.skipHAXConfirmation = false;
      _this.storageData = {};
      _this.appStore = {
        url: "",
        params: {}
      };
      _this.activeNode = null;
      _this.activeEditingElement = null;
      _this.haxBodies = [];
      _this.activePlaceHolder = null;
      _this.sessionObject = {};
      _this.editMode = false;
      _this.skipExitTrap = false;
      _this.appStoreLoaded = false;
      _this.elementList = {}; //if hax-tray-elementAlign exists use that other wise left

      _this.elementAlign = localStorageGet("hax-tray-elementAlign");

      if (!_this.elementAlign || _this.elementAlign == null) {
        _this.elementAlign = "right";
      }

      _this.trayStatus = "collapsed";
      _this.trayDetail = "content-edit";
      _this.appList = [];
      _this.gizmoList = [];
      _this.haxAutoloader = null;
      _this.activeHaxBody = null;
      _this.haxTray = null;
      _this.haxCancel = null;
      _this.staxList = [];
      _this.globalPreferences = {};
      _this.activeApp = {};
      _this.connectionRewrites = {}; // change this in order to debug voice commands

      _this.voiceDebug = false; // keyboard shortcuts, implementing haxHook: gizmoRegistration can ovewrite these as needed

      _this.keyboardShortcuts = {
        "#": {
          tag: "h2",
          content: ""
        },
        "##": {
          tag: "h3",
          content: ""
        },
        "###": {
          tag: "h4",
          content: ""
        },
        "####": {
          tag: "h5",
          content: ""
        },
        "#####": {
          tag: "h6",
          content: ""
        },
        "-": {
          tag: "ul",
          content: "<li></li>"
        },
        "1.": {
          tag: "ol",
          content: "<li></li>"
        },
        "---": {
          tag: "hr"
        },
        "```": {
          tag: "code",
          content: ""
        },
        ">": {
          tag: "blockquote",
          content: ""
        }
      };
      _this.validTagList = _this.__validTags();
      _this.validGridTagList = _this.__validGridTags();
      _this.validGizmoTypes = _this.__validGizmoTypes(); // test for sandboxed env

      var test = document.createElement("webview");
      _this._isSandboxed = typeof test.reload === "function";
      window.SimpleToast.requestAvailability();
      document.body.style.setProperty("--hax-ui-headings", "#d4ff77"); // mobx

      (0, _mobxEsm.makeObservable)(babelHelpers.assertThisInitialized(_this), {
        gizmoList: _mobxEsm.observable,
        activeNode: _mobxEsm.observable,
        globalPreferences: _mobxEsm.observable,
        activeGizmo: _mobxEsm.computed,
        activeNodeIndex: _mobxEsm.computed,
        editMode: _mobxEsm.observable,
        elementAlign: _mobxEsm.observable,
        trayStatus: _mobxEsm.observable,
        trayDetail: _mobxEsm.observable,
        appList: _mobxEsm.observable,
        activeApp: _mobxEsm.observable,
        haxSelectedText: _mobxEsm.observable,
        activeEditingElement: _mobxEsm.observable,
        activeHaxBody: _mobxEsm.observable,
        appStoreLoaded: _mobxEsm.observable
      });
      (0, _mobxEsm.autorun)(function () {
        _this._globalPreferencesChanged((0, _mobxEsm.toJS)(_this.globalPreferences));
      });
      (0, _mobxEsm.autorun)(function () {
        _this._editModeChanged((0, _mobxEsm.toJS)(_this.editMode));
      });
      return _this;
    }
    /**
     * Build HAX property definitions for primitives that we support.
     * @note if someone wants to MANUALLY inject definitions similar
     * to how this is doing so they can with this hack from a global
     * application context. This is going to inject a definition
     * at run time that's for a theoretical tag defined with this
     * but that hasn't been used yet.
      window.addEventListener("hax-store-ready", function(e) {
          setTimeout(() => {
            window.HaxStore.requestAvailability().setHaxProperties(window.customElements.get('instruction-card').haxProperties, 'instruction-card');
          }, 1000);
        }); 
      });
     */


    babelHelpers.createClass(HaxStore, [{
      key: "testHook",
      value:
      /**
       * test a hook's existance in a target
       */
      function testHook(el, op) {
        return el && typeof el.haxHooks === "function" && el.haxHooks()[op];
      }
      /**
       * run a hook in a target if it exists
       */

    }, {
      key: "runHook",
      value: function () {
        var _runHook = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(el, op) {
          var data,
              _args = arguments;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  data = _args.length > 2 && _args[2] !== undefined ? _args[2] : [];

                  if (!this.testHook(el, op)) {
                    _context.next = 5;
                    break;
                  }

                  _context.next = 4;
                  return el[el.haxHooks()[op]].apply(el, babelHelpers.toConsumableArray(data));

                case 4:
                  return _context.abrupt("return", _context.sent);

                case 5:
                  return _context.abrupt("return", false);

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function runHook(_x, _x2) {
          return _runHook.apply(this, arguments);
        }

        return runHook;
      }()
      /**
       * Selection normalizer
       */

    }, {
      key: "getSelection",
      value: function getSelection() {
        // try and obtain the selection from the nearest shadow
        // which would give us the selection object when running native ShadowDOM
        // with fallback support for the entire window which would imply Shady
        if (this.activeHaxBody && this.activeHaxBody.parentNode) {
          // native API
          if (this.activeHaxBody.parentNode.getSelection) {
            return this.activeHaxBody.parentNode.getSelection();
          } // this could fail depending on polyfills and stuff


          try {
            // ponyfill from google
            if ((0, _utils.getRange)(this.activeHaxBody.parentNode)) {
              return (0, _utils.getRange)(this.activeHaxBody.parentNode);
            }
          } catch (e) {}
        } // missed on both, hope the normal one will work


        return window.getSelection();
      }
      /**
       * Get a normalized range based on current selection
       */

    }, {
      key: "getRange",
      value: function getRange() {
        var sel = this.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          return sel.getRangeAt(0);
        } else if (sel) {
          return sel;
        } else false;
      }
      /**
       * Try and guess the Gizmo based on what we were just handed
       */

    }, {
      key: "guessGizmo",
      value: function guessGizmo(guess, values) {
        var _this2 = this;

        var skipPropMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var preferExclusive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var matches = [],
            matchedTags = [];

        if (babelHelpers.typeof(guess) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // verify type
          if (this.validGizmoTypes.includes(guess)) {
            // now we can look through them
            // look for a match
            for (var gizmoposition in this.gizmoList) {
              var gizmo = this.gizmoList[gizmoposition],
                  tags = [];
              var props = !!values.innerHTML ? {
                innerHTML: values.innerHTML
              } : {}; // reset match per gizmo

              var match = false; // ensure this gizmo can handle things

              if (gizmo && gizmo.handles) {
                for (var i = 0; i < gizmo.handles.length; i++) {
                  // WHAT!??!?!?!?!
                  if (guess === gizmo.handles[i].type || guess === "*" && !match) {
                    for (var property in gizmo.handles[i]) {
                      // ignore type.. but again.. WHAT?!?!?!
                      if (property !== "type") {
                        // check the values that came across to see if there's a match
                        // of any kind, we only need one but can then bind to multiple
                        if (babelHelpers.typeof(values[property]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                          // but ensure there's either no meta data OR
                          // the meta data needs to NOT say anythinig about hiding
                          if (guess === "inline" || !gizmo.meta || gizmo.meta && !gizmo.meta.inlineOnly && !gizmo.meta.hidden) {
                            match = true;
                            props[gizmo.handles[i][property]] = values[property];
                          }
                        }
                      }
                    } // omg... we just found a match on a property from who knows where!


                    if (match || skipPropMatch) {
                      if (preferExclusive && gizmo.handles[i].type_exclusive) {
                        return [this.haxElementPrototype(gizmo, props, "")];
                      } else {
                        (function () {
                          var keywords = {};
                          babelHelpers.toConsumableArray(gizmo.handles).forEach(function (i) {
                            if (!!i && !!i.type && i.type != "") keywords[i.type.toLowerCase()] = true;
                          });
                          babelHelpers.toConsumableArray(gizmo.groups).forEach(function (i) {
                            if (!!i && i != "") keywords[i.toLowerCase()] = true;
                          });
                          gizmo.keywords = Object.keys(keywords); //prevent duplicates

                          if (!matchedTags.includes(gizmo.tag)) {
                            matches.push(_this2.haxElementPrototype(gizmo, props, ""));
                            matchedTags.push(gizmo.tag);
                          }
                        })();
                      }
                    }
                  }
                }
              }
            }
          }
        }

        return matches;
      }
      /**
       * Simple workflow for logic from inserting based on
       * a series of criteria.
       */

    }, {
      key: "insertLogicFromValues",
      value: function insertLogicFromValues(values, context) {
        var failOnAnything = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var linkOnMultiple = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        // we have no clue what this is.. let's try and guess..
        var type = this.guessGizmoType(values);
        var typeName = type; // we want to simplify insert but if we get wildcard... do whatever

        var preferExclusive = true;

        if (type == "*") {
          // allow for logic to bail completely if we are told to
          if (failOnAnything) {
            return false;
          }

          preferExclusive = false;
          typeName = "link";
        }

        var haxElements = this.guessGizmo(type, values, false, preferExclusive); // see if we got anything

        if (haxElements.length > 0) {
          // if we ONLY have 1 thing or we say "make it a link if multiple"
          // special case for pasting into the page
          if (haxElements.length === 1 || linkOnMultiple) {
            if (haxElements.length === 1 && babelHelpers.typeof(haxElements[0].tag) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              context.dispatchEvent(new CustomEvent("hax-insert-content", {
                bubbles: true,
                cancelable: true,
                composed: true,
                detail: haxElements[0]
              }));
            } else if (linkOnMultiple) {
              context.dispatchEvent(new CustomEvent("hax-insert-content", {
                bubbles: true,
                cancelable: true,
                composed: true,
                detail: haxElements.find(function (item) {
                  return item.tag == "a";
                })
              }));
            }
          } else {
            // hand off to hax-app-picker to deal with the rest of this
            this.haxAppPicker.presentOptions(haxElements, type, "Pick how to present this " + typeName, "gizmo");
          }

          return true;
        } else {
          this.toast("Sorry, HAX doesn't know how to handle that type of link yet.");
          return false;
        }
      }
      /**
       * write to the store and communicate to all pieces
       */

    }, {
      key: "write",
      value: function write(prop, value, obj) {
        if (obj) {
          obj.dispatchEvent(new CustomEvent("hax-store-write", {
            composed: true,
            bubbles: true,
            cancelable: false,
            detail: {
              property: prop,
              value: value,
              owner: obj
            }
          }));
        }
      }
      /**
       * Convert a data mime type to gizmo type for rendering
       */

    }, {
      key: "mimeTypeToGizmoType",
      value: function mimeTypeToGizmoType(mime) {
        var parts = mime.split("/");

        switch (parts[0]) {
          case "audio":
            return "audio";
            break;

          case "image":
            if (parts[1] == "svg+xml") {
              return "svg";
            }

            return "image";
            break;

          case "video":
            return "video";
            break;

          case "text":
            if (["csv", "html", "markdown"].includes(parts[1])) {
              return parts[1];
            }

            return "document";
            break;

          case "application":
            if (parts[1] == "pdf") {
              return "pdf";
            }

            if (["zip", "gzip", "x-tar"].includes(parts[1])) {
              return "archive";
            }

            return "document";
            break;
        }
      }
      /**
       * Guess the type of Gizmo when given some information about what we have.
       */

    }, {
      key: "guessGizmoType",
      value: function guessGizmoType(guess) {
        if (babelHelpers.typeof(guess.source) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          var source = guess.source.toLowerCase();

          if (source.indexOf(".mp3") != -1 || source.indexOf(".midi") != -1 || source.indexOf(".mid") != -1) {
            return "audio";
          } else if (source.indexOf(".png") != -1 || source.indexOf(".jpg") != -1 || source.indexOf(".jpeg") != -1 || source.indexOf(".gif") != -1) {
            return "image";
          } else if (source.indexOf(".pdf") != -1) {
            return "pdf";
          } else if (source.indexOf(".svg") != -1) {
            return "svg";
          } else if (source.indexOf(".csv") != -1) {
            return "csv";
          } else if (source.indexOf(".md") != -1) {
            return "markdown";
          } else if (source.indexOf(".html") != -1 || source.indexOf(".htm") != -1) {
            return "html";
          } else if (source.indexOf(".txt") != -1 || source.indexOf(".doc") != -1 || source.indexOf(".docx") != -1 || source.indexOf(".xls") != -1 || source.indexOf(".xlsx") != -1 || source.indexOf(".vtt") != -1 || source.indexOf(".ppt") != -1) {
            return "document";
          } else if (source.indexOf(".zip") != -1 || source.indexOf(".tar.gz") != -1 || source.indexOf(".tar") != -1) {
            return "archive";
          } // if it's external we can't assume what it actually is
          else if (window.MediaBehaviors.Video.getVideoType(source) != "external") {
              return "video";
            }
        } // we don't know how to handle this so let's just
        // try ANYTHING that matches


        return "*";
      }
      /**
       * LitElement render
       */

    }, {
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_648e8ff0942811ecb1937969798b231a || (_templateObject_648e8ff0942811ecb1937969798b231a = babelHelpers.taggedTemplateLiteral([" <slot></slot> "])));
      }
      /**
       * convention
       */

    }, {
      key: "toast",
      value:
      /**
       * Global toast bridge so we don't have to keep writing custom event
       */
      function toast(message) {
        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
        var classStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "capsule";
        var closeText = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.t.close;
        var eventCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        // gets it all the way to the top immediately
        window.dispatchEvent(new CustomEvent("simple-toast-show", {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            text: message,
            duration: duration,
            classStyle: classStyle,
            closeText: closeText,
            eventCallback: eventCallback
          }
        }));
      }
      /**
       * LitElement / popular convention
       */

    }, {
      key: "_storageDataChanged",
      value:
      /**
       * Local storage data changed; callback to store this data in user storage
       */
      function _storageDataChanged(newValue) {
        if (newValue && this.ready && this.__storageDataProcessed) {
          if (localStorageGet("haxConfirm")) {
            localStorageSet("haxUserData", JSON.stringify(newValue));
          } else if (sessionStorageGet("haxConfirm")) {
            sessionStorageSet("haxUserData", JSON.stringify(newValue));
          }
        }
      }
    }, {
      key: "isSingleSlotElement",
      value: function isSingleSlotElement(node) {
        var slots = Object.keys(this.slotsSchemaFromNode(node));
        return slots.length == 1 && slots[0].length === 0;
      }
      /**
       * If this is a text node or not so we know if the inline context
       * operations are valid.
       */

    }, {
      key: "isTextElement",
      value: function isTextElement(node) {
        var tag; // resolve HAXelements vs nodes

        if (node != null && node.tagName) {
          tag = node.tagName.toLowerCase();
        } else if (node != null && node.tag) {
          tag = node.tag.toLowerCase();
        }

        if (tag && this.validTagList.includes(tag)) {
          if (["p", "ol", "ul", "li", "a", "h1", "h2", "h3", "h4", "h5", "h6", "strike", "u", "b", "sub", "sup", "span", "i", "bold", "em", "strong", "blockquote", "code", "figure"].includes(tag)) {
            return true;
          }
        }

        return false;
      }
      /**
       * test for being a valid grid plate, li is here because
       * nested lists make this really complicated
       */

    }, {
      key: "isGridPlateElement",
      value: function isGridPlateElement(node) {
        var tag; // resolve HAXelements vs nodes

        if (node && node.tagName) {
          tag = node.tagName.toLowerCase();
        } else if (node && node.tag) {
          tag = node.tag.toLowerCase();
        }

        if (tag && this.validGridTagList.includes(tag)) {
          return true;
        }

        return false;
      }
      /**
       * test for being a valid layout based on `type: grid` in HAXProperties
       * @param {object} node custom element
       * @returns {boolean} whether custom element is layout
       */

    }, {
      key: "isLayoutElement",
      value: function isLayoutElement(node) {
        var schema = !!node && !!node.tagName ? this.haxSchemaFromTag(node.tagName) || {} : {};
        return schema.type && schema.type === "grid";
      }
      /**
       * test for being a slot in a valid layout based on `type: grid` in parent's HAXProperties
       * @param {object} node custom element
       * @returns {boolean} whether custom element is slot in a layout
       */

    }, {
      key: "isLayoutSlot",
      value: function isLayoutSlot(node) {
        if (!node || !node.parentNode) return false;
        return this.isLayoutElement(node.parentNode);
      }
      /**
       * test for being thhe original <grid-plate> element
       * @param {object} node custom element
       * @returns {boolean} whether custom element is grid-plate
       */

    }, {
      key: "isOriginalGridPlate",
      value: function isOriginalGridPlate(node) {
        return !!node && node.tagName === "GRID-PLATE";
      }
      /**
       * gets schema for activeNode
       *
       * @returns {object} haxSchema for node
       * @memberof HaxStore
       */

    }, {
      key: "activeSchema",
      value: function activeSchema() {
        return this.activeNode ? this.haxSchemaFromTag(this.activeNode.tagName) : undefined;
      }
      /**
       * gets schema for activeNode's parent
       *
       * @returns {object} haxSchema for parent node
       * @memberof HaxStore
       */

    }, {
      key: "activeParentSchema",
      value: function activeParentSchema() {
        return this.activeNode && this.activeNode.parentNode ? this.haxSchemaFromTag(this.activeNode.parentNode.tagName) : undefined;
      }
      /**
       * provides metadata for slotted content of a given custom element
       *
       * @param {object} node ustom element with slots
       * @returns {object} Ex: {slotId: {...slotsSchemaFromNode, items: [slottedChild, slottedChild, etc.]}}
       * @memberof HaxStore
       */

    }, {
      key: "slottedContentByNode",
      value: function slottedContentByNode(node) {
        var slots = _objectSpread({}, this.slotsSchemaFromNode(node) || {});

        if (!node) return slots;
        babelHelpers.toConsumableArray(node.children || []).forEach(function (child) {
          if (child.slot && child.slot !== "" && slots[child.slot]) {
            slots[child.slot].items = slots[child.slot].items || [];
            slots[child.slot].items.push(child);
          } else if ((!child.slot || child.slot === "") && slots[""]) {
            slots[""].items = slots[""].items || [];
            slots[""].items.push(child);
          }
        });
        return slots;
      }
      /**
       * provides metadata for slotted content of a given custom element
       *
       * @param {object} node custom element with slots
       * @returns {object} Ex: {slotId: {...node's haxSchema for slot, label: slot's title or id, editMode: properties to set slot in editMode, grid: parent node}
       * @memberof HaxStore
       */

    }, {
      key: "slotsSchemaFromNode",
      value: function slotsSchemaFromNode(node) {
        if (!node || !node.tagName) return {};
        var slotsSchema = {},
            schema = this.haxSchemaFromTag(node.tagName || {}),
            slots = this.slotsFromSchema(schema);

        if (this.isOriginalGridPlate(node)) {
          var layout = node.layout || "1-1-1-1";
          layout.split("-").map(function (item, num) {
            slots.push({
              slot: "col-".concat(num + 1),
              title: "Column ".concat(num + 1),
              excludedSlotWrappers: ["grid-plate"]
            });
          });
        }

        slots.forEach(function (slot) {
          //need to empty this
          slot.items = undefined;
          slot.label = slot.title || slot.slot;
          slot.editMode = _objectSpread(_objectSpread({}, schema.editMode), slot.editMode);
          slot.grid = node;
          if (!!slot.slot || slot.slot === "") slotsSchema[slot.slot] = slot;
        });
        return slotsSchema;
      }
      /**
       * gets a single slot's schema
       *
       * @param {object} node custom element with slots
       * @param {string} slotId unique id for slot
       * @returns
       * @memberof HaxStore
       */

    }, {
      key: "schemaBySlotId",
      value: function schemaBySlotId(node, slotId) {
        return (this.slotsSchemaFromNode(node) || {})[slotId];
      }
      /**
       * Notice _appStore changed.
       */

    }, {
      key: "_appStoreChanged",
      value: function _appStoreChanged(newValue, oldValue) {
        // if we have an endpoint defined, pull it
        if (newValue && oldValue) {
          // support having the request or remote loading
          // depending on the integration type
          if (newValue.url && !newValue.apps && this.shadowRoot) {
            this.loadAppStoreFromRemote();
          } else {
            // directly injected json object into the DOM
            this.__appStoreData = newValue;
          }
        }
      }
      /**
       * Load and attach items from the app store.
       */

    }, {
      key: "_loadAppStoreData",
      value: function () {
        var _loadAppStoreData2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(appDataResponse) {
          var items, i, CEname, CEimport, apps, app, staxs, stax;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!(appDataResponse != null)) {
                    _context2.next = 9;
                    break;
                  }

                  items = {}; // autoload elements

                  if (babelHelpers.typeof(appDataResponse.autoloader) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    // ensure the list is in the right order so we can async dynamic imports
                    // regardless of if its an array or object of values in the right format
                    // force this to be an object
                    appDataResponse.autoloader = Object.assign({}, appDataResponse.autoloader);

                    for (i in appDataResponse.autoloader) {
                      CEname = i;
                      CEimport = appDataResponse.autoloader[i]; // helps support array or object based app store spec
                      // array was originally in the standard so this lets us support both

                      if (!isNaN(CEname)) {
                        CEname = appDataResponse.autoloader[i];
                        CEimport = "@lrnwebcomponents/".concat(CEname, "/").concat(CEname, ".js");
                      } // support for element response shipping w/ the UI for the element
                      // this allows backends to define haxSchema at run time!


                      if (typeof CEimport !== "string") {
                        // definition over the wire
                        if (CEimport.haxProperties) {
                          this.setHaxProperties(appDataResponse.autoloader[i].haxProperties, CEname);
                        }

                        CEimport = appDataResponse.autoloader[i].import;
                      } // force this into the valid tag list so early paints will
                      // correctly include the tag without filtering it out incorrectly


                      this.validTagList.push(CEname);
                      items[CEname] = CEimport;
                    }
                  } // load apps automatically


                  if (babelHelpers.typeof(appDataResponse.apps) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    apps = appDataResponse.apps;

                    for (i = 0; i < apps.length; i++) {
                      app = document.createElement("hax-app");
                      app.data = apps[i];
                      this.appendChild(app);
                    }
                  } // load in stax dynamically


                  if (babelHelpers.typeof(appDataResponse.stax) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    staxs = appDataResponse.stax;

                    for (i = 0; i < staxs.length; i++) {
                      stax = document.createElement("hax-stax");
                      stax.data = staxs[i];
                      this.appendChild(stax);
                    }
                  }

                  this.dispatchEvent(new CustomEvent("hax-store-app-store-loaded", {
                    bubbles: true,
                    cancelable: true,
                    composed: true,
                    detail: true
                  })); // now process the dynamic imports

                  _context2.next = 8;
                  return this._handleDynamicImports(items, this.haxAutoloader);

                case 8:
                  this.appStoreLoaded = true;

                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function _loadAppStoreData(_x3) {
          return _loadAppStoreData2.apply(this, arguments);
        }

        return _loadAppStoreData;
      }()
      /**
       * Handle all the dynamic imports of things told to autoload
       * This ensures we get the definitions quickly as far as
       * what is a safe / valid tag above but then we import in a way
       * that allows us to correctly associate the hax schema to where
       * it came from.
       */

    }, {
      key: "_handleDynamicImports",
      value: function () {
        var _handleDynamicImports2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(items, haxAutoloader) {
          var _this3 = this;

          var basePath, i, tmpEl;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  basePath = new URL("./../../../", meta.url).href;

                  if (window.WCGlobalBasePath) {
                    basePath = window.WCGlobalBasePath;
                  }

                  _context4.t0 = regeneratorRuntime.keys(items);

                case 3:
                  if ((_context4.t1 = _context4.t0()).done) {
                    _context4.next = 12;
                    break;
                  }

                  i = _context4.t1.value;

                  if (!window.customElements.get(i)) {
                    _context4.next = 9;
                    break;
                  }

                  if (window.customElements.get(i).haxProperties) {
                    this.setHaxProperties(window.customElements.get(i).haxProperties, i);
                  } else {
                    // edge case of no definition
                    try {
                      tmpEl = document.createElement(i);
                      haxAutoloader.appendChild(tmpEl);
                    } catch (e) {}
                  }

                  _context4.next = 10;
                  break;

                case 9:
                  return _context4.delegateYield( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
                    var importPath;
                    return regeneratorRuntime.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            importPath = "".concat(basePath).concat(items[i]); // account for external app store reference on import

                            if (_this3.isExternalURLImport(items[i])) {
                              importPath = items[i];
                            } // we have to import and then respond to it being imported by checking again


                            _context3.next = 4;
                            return new Promise(function (res, rej) {
                              return _require.default([importPath], res, rej);
                            }).then(function (response) {
                              // see if it imported now
                              if (window.customElements.get(i) && window.customElements.get(i).haxProperties) {
                                _this3.setHaxProperties(window.customElements.get(i).haxProperties, i);
                              } else {
                                // edge case of no definition
                                haxAutoloader.appendChild(document.createElement(i));
                              }
                            }).catch(function (error) {
                              /* Error handling */
                              console.warn(error); // also try putting it in the autoloader and hope for the best

                              // also try putting it in the autoloader and hope for the best
                              haxAutoloader.appendChild(document.createElement(i));
                            });

                          case 4:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  })(), "t2", 10);

                case 10:
                  _context4.next = 3;
                  break;

                case 12:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function _handleDynamicImports(_x4, _x5) {
          return _handleDynamicImports2.apply(this, arguments);
        }

        return _handleDynamicImports;
      }()
    }, {
      key: "isExternalURLImport",
      value: function isExternalURLImport(string) {
        var url;

        try {
          url = new URL(string);
        } catch (_) {
          return false;
        }

        return new URL(url).origin !== location.origin;
      }
    }, {
      key: "_editModeChanged",
      value: function _editModeChanged(newValue) {
        if (this.__hal) {
          if (newValue && this.globalPreferences.haxVoiceCommands) {
            this.__hal.auto = true;
          } else {
            this.__hal.auto = false;
          }
        } // trap for very slow loading environments that might miss on initial setup timing


        if (newValue && !this.appStoreLoaded && this.__appStoreData && this.haxAutoloader) {
          clearTimeout(this.__readyToProcessAppStoreData);

          this._loadAppStoreData(this.__appStoreData);
        }
      }
    }, {
      key: "_globalPreferencesChanged",
      value: function () {
        var _globalPreferencesChanged2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(newValue) {
          var _this4 = this;

          var storageData;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  // regardless of what it is, reflect it globally but only after setup
                  if (this.__storageDataProcessed && newValue && babelHelpers.typeof(newValue.haxVoiceCommands) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && this.ready) {
                    storageData = this.storageData;
                    storageData.globalPreferences = newValue;
                    this.storageData = storageData;

                    this._storageDataChanged(this.storageData); // import voice command stuff in the background if used selects it
                    // this is experimental / aggressive import of tech so defer to
                    // if they activate it


                    if (newValue.haxVoiceCommands && !this.__hal) {
                      // @todo only activate if the setting to use it is in place
                      new Promise(function (res, rej) {
                        return _require.default(["../../hal-9000/hal-9000.js"], res, rej);
                      }).then(function (esModule) {
                        // initialize voice commands
                        _this4._initVoiceCommands(); // inject tag into shadowRoot after we import the definition


                        _this4.__hal = document.createElement("hal-9000");
                        _this4.__hal.respondsTo = _this4.voiceRespondsTo;
                        _this4.__hal.debug = _this4.voiceDebug;
                        _this4.__hal.auto = true;

                        _this4.shadowRoot.appendChild(_this4.__hal); // establish the initial commands, even if they were captured
                        // prior to usage since we held onto them in this variable


                        _this4.__hal.commands = _objectSpread({}, _this4.voiceCommands);
                      });
                    } // only mess w/ hal if enabled


                    if (this.__hal) {
                      if (newValue.haxVoiceCommands && this.editMode) {
                        this.__hal.auto = true;
                      } else {
                        this.__hal.auto = false;
                      }
                    } // only translate if we are ready, and editing, and have a language other than default


                    if (newValue.haxLang && HAXStore.editMode) {
                      clearTimeout(this._debounceLang); // debounce helps prevent flooding based on this variable being updated
                      // we also don't need to instantly update language as it's an aggressive action
                      // so this 100ms delay helps quiet this down

                      this._debounceLang = setTimeout( /*#__PURE__*/babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
                        var i, el;
                        return regeneratorRuntime.wrap(function _callee5$(_context5) {
                          while (1) {
                            switch (_context5.prev = _context5.next) {
                              case 0:
                                _context5.t0 = regeneratorRuntime.keys(_this4.elementList);

                              case 1:
                                if ((_context5.t1 = _context5.t0()).done) {
                                  _context5.next = 10;
                                  break;
                                }

                                i = _context5.t1.value;
                                el = _this4.elementList[i]; // run through translations to see if we have any
                                // apply as nessecary; abstract out the current translation thing to be reused

                                _context5.next = 6;
                                return _this4.attemptGizmoTranslation(i, el);

                              case 6:
                                el = _context5.sent;
                                _this4.elementList[i] = el;
                                _context5.next = 1;
                                break;

                              case 10:
                                _this4.gizmoList.forEach(function (el) {
                                  // if a title / description exists; "translate" it to match what came across
                                  if (_this4.elementList[el.tag].gizmo.title) {
                                    el.title = _this4.elementList[el.tag].gizmo.title;
                                  }

                                  if (_this4.elementList[el.tag].gizmo.description) {
                                    el.description = _this4.elementList[el.tag].gizmo.description;
                                  }
                                });

                              case 11:
                              case "end":
                                return _context5.stop();
                            }
                          }
                        }, _callee5);
                      })), 100);
                    }
                  }

                case 1:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function _globalPreferencesChanged(_x6) {
          return _globalPreferencesChanged2.apply(this, arguments);
        }

        return _globalPreferencesChanged;
      }()
      /**
       * A handful of context operations need to bubble up to the top
       * because we don't know where they originate from
       */

    }, {
      key: "_haxContextOperation",
      value: function _haxContextOperation(e) {
        var _this5 = this;

        var detail = e.detail;

        if (this.activeNode) {
          var changed = false; // support a simple insert event to bubble up or everything else

          switch (detail.eventName) {
            // directional / proportion operations
            case "hax-align-left":
              this.activeNode.style.float = null;
              this.activeNode.style.margin = null;
              this.activeNode.style.display = null;
              changed = true;
              break;

            case "hax-align-center":
              this.activeNode.style.float = null;
              this.activeNode.style.margin = "0 auto";
              this.activeNode.style.display = "block";
              changed = true;
              break;

            case "hax-align-right":
              this.activeNode.style.float = "right";
              this.activeNode.style.margin = "0 auto";
              this.activeNode.style.display = "block";
              changed = true;
              break;

            case "hax-size-change":
              if (detail.value == 100) {
                this.activeNode.style.width = null;
              } else {
                this.activeNode.style.width = detail.value + "%";
              }

              changed = true;
              break;
          }

          if (changed) {
            clearTimeout(this.__repositionMenu);
            this.__repositionMenu = setTimeout(function () {
              _this5.activeHaxBody.positionContextMenus();
            }, 0);
          }
        }
      }
      /**
       * This only send if they consented to storage of data locally
       */

    }, {
      key: "_haxConsentTap",
      value: function _haxConsentTap(e) {
        // store for future local storage usage
        localStorageSet("haxConfirm", true); // most likely nothing but set it anyway

        localStorageSet("haxUserData", JSON.stringify(this.storageData));
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this6 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "appStore" && _this6[propName]) {
            _this6._appStoreChanged(_this6[propName], oldValue);
          } // composite obervation


          if (["ready", "__appStoreData", "haxAutoloader"].includes(propName) && _this6.ready && _this6.__appStoreData && _this6.haxAutoloader) {
            clearTimeout(_this6.__readyToProcessAppStoreData);
            _this6.__readyToProcessAppStoreData = setTimeout(function () {
              _this6._loadAppStoreData(_this6.__appStoreData);
            }, 0);
          }

          if (["haxAutoloader", "haxTray", "haxCancel"].includes(propName)) {
            // allow this to verify if everything is here or not
            clearTimeout(_this6.__storeReady);
            _this6.__storeReady = setTimeout(function () {
              _this6._storePiecesAllHere(_this6.haxAutoloader, _this6.activeHaxBody, _this6.haxTray, _this6.haxCancel);
            }, 0);
          }
        });
      }
    }, {
      key: "_calculateActiveGizmo",
      value: function _calculateActiveGizmo(activeNode) {
        if (activeNode == null || !activeNode.tagName) {
          return null;
        }

        for (var gizmoposition in this.gizmoList) {
          var gizmo = this.gizmoList[gizmoposition];

          if (gizmo.tag === activeNode.tagName.toLowerCase()) {
            return gizmo;
          }
        }
      }
      /**
       * generate appstore query
       */

    }, {
      key: "loadAppStoreFromRemote",
      value: function loadAppStoreFromRemote() {
        var _this7 = this;

        var searchParams = new URLSearchParams(this.appStore.params);
        var url = this.appStore.url;

        if (searchParams) {
          url += "?".concat(searchParams);
        }

        fetch(url, {
          method: this.method
        }).then(function (response) {
          if (response.ok) return response.json();
        }).then(function (json) {
          _this7.__appStoreData = json;
        });
      }
      /**
       * ready life cycle
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        var _this8 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype), "firstUpdated", this).call(this, changedProperties);
        } // see if a global was used to prevent this check
        // this is useful when in trusted environments where the statement
        // has been consented to in the application this is utilized in


        if (this.skipHAXConfirmation) {
          sessionStorageSet("haxConfirm", true);
          localStorageSet("haxConfirm", true);
        } // check for local storage object
        // if not, then store it in sessionStorage so that all our checks
        // and balances are the same. This could allow for storing these
        // settings on a server in theory


        var haxConfirm = sessionStorageGet("haxConfirm") || localStorageGet("haxConfirm");

        if (!haxConfirm) {
          // this way it isn't shown EVERY reload, but if they didn't confirm
          // it will show up in the future
          sessionStorageSet("haxConfirm", true);
          var msg = "\n    The HAX content editor keeps preferences in order to improve your experience.\n    This data is stored in your browser and is never sent anywhere.\n    Click to accept.\n    ";
          this.toast(msg, "-1", "fit-bottom", "I Accept", "hax-consent-tap");
        } else {
          if (sessionStorageGet("haxConfirm") && !localStorageGet("haxConfirm")) {
            // verify there is something there
            try {
              var globalData = sessionStorageGet("haxUserData") ? JSON.parse(sessionStorageGet("haxUserData")) : {};
              this.storageData = globalData;

              this._storageDataChanged(this.storageData);
            } catch (e) {}
          } else {
            try {
              var _globalData = localStorageGet("haxUserData") ? JSON.parse(localStorageGet("haxUserData")) : {};

              this.storageData = _globalData;

              this._storageDataChanged(this.storageData);
            } catch (e) {}
          }
        } // set this global flag so we know it's safe to start trusting data
        // that is written to global preferences / storage bin


        setTimeout(function () {
          _this8.__storageDataProcessed = true;

          if (_this8.storageData.globalPreferences) {
            _this8.write("globalPreferences", _this8.storageData.globalPreferences, _this8);
          }
        }, 0);
      }
    }, {
      key: "_storePiecesAllHere",
      value: function _storePiecesAllHere(haxAutoloader, activeHaxBody, haxTray, haxCancel) {
        if (!this.ready && activeHaxBody && haxAutoloader && haxTray && haxCancel) {
          // send that hax store is ready to go so now we can setup the rest
          this.dispatchEvent(new CustomEvent("hax-store-ready", {
            bubbles: true,
            cancelable: false,
            composed: true,
            detail: true
          })); // these operations can be hidden in CMS environments

          if (haxTray.shadowRoot.querySelector("#haxcancelbutton")) {
            // associate the cancel button in the tray to the dialog
            haxCancel.shadowRoot.querySelector("#dialog").associateEvents(haxTray.shadowRoot.querySelector("#haxcancelbutton"));

            if (!!haxCancel.shadowRoot.querySelector("#dialog")) {
              window.addEventListener("simple-modal-confirmed", this._handleConfirmCancel.bind(this));
            }
          }

          this.ready = true; // register built in primitive definitions

          this._buildPrimitiveDefinitions();
        }
      }
    }, {
      key: "_handleConfirmCancel",
      value: function _handleConfirmCancel(e) {
        if (e.detail.invokedBy === this.haxTray.shadowRoot.querySelector("#haxcancelbutton")) {
          this.editMode = false;
          this.dispatchEvent(new CustomEvent("hax-cancel", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: e.detail
          }));
        }
      }
      /**
       * Build a list of common voice commands
       */

    }, {
      key: "_initVoiceCommands",
      value: function _initVoiceCommands() {
        var _this9 = this;

        this.__voiceInit = true;

        this.voiceCommands["scroll up ".concat(this.voiceRespondsTo)] = function () {
          window.scrollBy({
            top: -(window.innerHeight * 0.5),
            left: 0,
            behavior: "smooth"
          });
        };

        this.voiceCommands["scroll (down) ".concat(this.voiceRespondsTo)] = function () {
          window.scrollBy({
            top: window.innerHeight * 0.5,
            left: 0,
            behavior: "smooth"
          });
        };

        this.voiceCommands["scroll to bottom ".concat(this.voiceRespondsTo)] = function () {
          window.scrollTo(0, document.body.scrollHeight);
        };

        this.voiceCommands["scroll to top ".concat(this.voiceRespondsTo)] = function () {
          window.scrollTo(0, 0);
        };
        /**
         * Support for focusing active content and typing in it
         */


        this.voiceCommands["".concat(this.voiceRespondsTo, " (show)(focus) active (element)(content)")] = function () {
          try {
            _this9._positionCursorInNode(_this9.activeNode);
          } catch (e) {}
        };

        this.voiceCommands["".concat(this.voiceRespondsTo, " (focus) previous (element)(content)")] = function () {
          if (_this9.activeNode.previousElementSibling) {
            _this9.activeNode = _this9.activeNode.previousElementSibling;

            _this9.write("activeNode", _this9.activeNode, _this9);

            _this9._positionCursorInNode(_this9.activeNode);
          } else {
            _this9.speak("You are at the top of the document");
          }
        };

        this.voiceCommands["".concat(this.voiceRespondsTo, " (focus) next (element)(content)")] = function () {
          if (_this9.activeNode.nextElementSibling) {
            _this9.activeNode = _this9.activeNode.nextElementSibling;

            _this9.write("activeNode", _this9.activeNode, _this9);

            _this9._positionCursorInNode(_this9.activeNode);
          } else {
            _this9.speak("You are at the bottom of the document");
          }
        };

        this.voiceCommands["".concat(this.voiceRespondsTo, " type *mycontent")] = function (e) {
          if (_this9.isTextElement(_this9.activeNode)) {
            try {
              var range = _this9._positionCursorInNode(_this9.activeNode);

              var text = document.createTextNode(e);
              range.deleteContents();
              range.insertNode(text);
            } catch (e) {
              _this9.speak("That didn't work");

              console.warn(e);
            }
          } else {
            _this9.speak("I'm sorry but I can only type in text areas. Try saying Insert Paragraph and try again.");
          }
        }; // trolling


        this.voiceCommands["hey ".concat(this.voiceRespondsTo)] = function () {
          _this9.speak("Yeah what do you want");
        }; // trolling


        this.voiceCommands["".concat(this.voiceRespondsTo, " now your name is *splat")] = function (text) {
          var past = _this9.voiceRespondsTo;

          _this9.speak("I used to be named ".concat(past, " but you can call me ").concat(text, " now."));

          _this9.voiceRespondsTo = "(".concat(text, ")"); // @todo this needs to now update the previous commands somehow to match
          // the new activation name
        };
      }
      /**
       * Speak wrapper on hal to present as text too
       */

    }, {
      key: "speak",
      value: function speak(text) {
        if (this.__hal && this.__hal.speak) {
          this.__hal.speak(text);
        } // always show for accessibility


        this.toast("".concat(this.voiceRespondsTo, ": ").concat(text));
      }
      /**
       * allow uniform method of adding voice commands
       */

    }, {
      key: "addVoiceCommand",
      value: function addVoiceCommand(command, context, callback) {
        if (context) {
          command = command.replace(":name:", this.voiceRespondsTo).toLowerCase();
          this.voiceCommands[command] = context[callback].bind(context);

          if (this.__voiceInit) {
            this.__hal.commands = _objectSpread({}, this.voiceCommands);
          }
        }
      }
      /**
       * event driven version
       */

    }, {
      key: "_addVoiceCommand",
      value: function _addVoiceCommand(e) {
        // without context it's almost worthless so try to fallback on where it came from
        var target = e.detail.context;

        if (!target) {
          target = e.target;
        }

        this.addVoiceCommand(e.detail.command, target, e.detail.callback);
      }
      /**
       * Position cursor at the start of the position of the requested node
       */

    }, {
      key: "_positionCursorInNode",
      value: function _positionCursorInNode(node) {
        var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.activeHaxBody.positionContextMenus();
        var range = document.createRange();
        var sel = this.getSelection();
        range.setStart(node, position);
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
        return range;
      }
      /**
       * Before the browser closes / changes paths, ask if they are sure they want to leave
       */

    }, {
      key: "_onBeforeUnload",
      value: function _onBeforeUnload(e) {
        // ensure we don't leave DURING edit mode
        if (!this.skipExitTrap && this.editMode) {
          return "Are you sure you want to leave? Your work will not be saved!";
        }
      }
      /**
       * detect base64 object
       */

    }, {
      key: "isBase64",
      value: function isBase64(str) {
        try {
          return btoa(atob(str)) == str;
        } catch (err) {
          return false;
        }
      }
    }, {
      key: "retrieveImageFromClipboardAsBlob",
      value: function retrieveImageFromClipboardAsBlob(pasteEvent, callback) {
        if (pasteEvent.clipboardData == false) {
          if (typeof callback == "function") {
            return callback(undefined);
          }
        }

        var items = pasteEvent.clipboardData.items;

        if (items == undefined) {
          if (typeof callback == "function") {
            return callback(undefined);
          }
        }

        for (var i = 0; i < items.length; i++) {
          // Skip content if not image
          if (items[i].type.indexOf("image") == -1) continue; // Retrieve image on clipboard as blob

          var blob = items[i].getAsFile();

          if (typeof callback == "function") {
            return callback(blob);
          }
        }
      }
      /**
       * Intercept paste event and clean it up before inserting the contents
       */

    }, {
      key: "_onPaste",
      value: function () {
        var _onPaste2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(e) {
          var _this10 = this;

          var pasteContent, originalContent, p, i, inlinePaste, newContent, haxElements, values, _values, node, range, sel, newNodes, txt, _enterSplit, activeEl, siblingEl;

          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  if (!(this.editMode && document.activeElement.tagName !== "HAX-TRAY" && document.activeElement.tagName !== "BODY" && document.activeElement.tagName !== "SIMPLE-MODAL")) {
                    _context7.next = 85;
                    break;
                  }

                  // only perform this on a text element that is active
                  // otherwise inject a P so we can paste into it
                  if (this.isTextElement(this.activeNode)) {} else {
                    this.activeNode = this.activeHaxBody.haxInsert("p", "", {});
                  }

                  pasteContent = "";
                  originalContent = ""; // intercept paste event

                  if (e.clipboardData || e.originalEvent.clipboardData) {
                    pasteContent = (e.originalEvent || e).clipboardData.getData("text/html"); // if it is purely plain text it could fail to come across as HTML and be empty

                    if (pasteContent == "") {
                      pasteContent = (e.originalEvent || e).clipboardData.getData("text");
                    }
                  } else if (window.clipboardData) {
                    pasteContent = window.clipboardData.getData("Text");
                  }

                  originalContent = pasteContent; // look for base64 like copy and paste of an image from clipboard

                  if (!this.isBase64(originalContent)) {
                    _context7.next = 13;
                    break;
                  }

                  // stop normal paste
                  e.preventDefault();
                  e.stopPropagation();
                  e.stopImmediatePropagation();
                  return _context7.abrupt("return", this.retrieveImageFromClipboardAsBlob(e, function (imageBlob) {
                    // If there's an image, display it in the canvas
                    if (imageBlob) {
                      // Crossbrowser support for URL
                      var URLObj = window.URL || window.webkitURL;
                      var img = document.createElement("img"); // turn blob into a url to visualize locally, this is just temporary

                      // turn blob into a url to visualize locally, this is just temporary
                      img.src = URLObj.createObjectURL(imageBlob);

                      _this10.activeNode.parentNode.insertBefore(img, _this10.activeNode.nextElementSibling);

                      for (var i in e.clipboardData.items) {
                        // generate a file name if one doesn't exist
                        if (!e.clipboardData.items[i].name && e.clipboardData.items[i].type) {
                          e.clipboardData.items[i].name = "image-" + Math.floor(Date.now() / 1000) + e.clipboardData.items[i].type.replace("image/", ".");
                        }
                      } // cannot believe this actually works


                      // cannot believe this actually works
                      e.dataTransfer = e.clipboardData; // refernece of what to replace; this way while uploading, we still see
                      // what we pasted and it's in place. It'll gracefully switch over to the
                      // real file reference once it finishes uploading

                      // refernece of what to replace; this way while uploading, we still see
                      // what we pasted and it's in place. It'll gracefully switch over to the
                      // real file reference once it finishes uploading
                      e.placeHolderElement = img; // fire this specialized event up so things like HAX can intercept

                      // fire this specialized event up so things like HAX can intercept
                      _this10.dispatchEvent(new CustomEvent("place-holder-file-drop", {
                        bubbles: true,
                        cancelable: true,
                        composed: true,
                        detail: e
                      }));

                      return img;
                    }

                    return false;
                  }));

                case 13:
                  // we have a "file" paste
                  if (e.clipboardData.files.length > 0) {
                    // stop normal paste
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation(); // generate a place holder p tag to replace on upload

                    p = this.activeHaxBody.haxInsert("p", "", {}); // cannot believe this actually works

                    e.dataTransfer = e.clipboardData;

                    for (i in e.clipboardData.files) {
                      // generate a file name if one doesn't exist
                      if (!e.clipboardData.files[i].name && e.clipboardData.files[i].type) {
                        e.clipboardData.files[i].name = "image-" + Math.floor(Date.now() / 1000) + e.clipboardData.files[i].type.replace("image/", ".");
                      }
                    } // refernece of what to replace; this way while uploading, we still see
                    // what we pasted and it's in place. It'll gracefully switch over to the
                    // real file reference once it finishes uploading


                    e.placeHolderElement = p; // fire this specialized event up so things like HAX can intercept

                    this.dispatchEvent(new CustomEvent("place-holder-file-drop", {
                      bubbles: true,
                      cancelable: true,
                      composed: true,
                      detail: e
                    }));
                  }

                case 14:
                  // detect word garbage
                  inlinePaste = false; // the string to import as sanitized by hax

                  newContent = ""; // clear empty span tags that can pop up

                  pasteContent = pasteContent.replace(/<span>\s*?<\/span>/g, " "); //remove hax css variables

                  pasteContent = pasteContent.replace(/(?:style="(\S+:\s*[^;"]+;\s*)*)(\S+:\s*var\(--hax[^;"]+(?:[;"]\s*))+/g, ""); // clean up div tags that can come in from contenteditable pastes
                  // p tags make more sense in the content area

                  pasteContent = pasteContent.replace(/<div/g, "<p");
                  pasteContent = pasteContent.replace(/<\/div>/g, "</p>"); // NOW we can safely handle paste from word cases

                  pasteContent = (0, _utils.stripMSWord)(pasteContent); // we force h2 to be highest document level on pasted content

                  pasteContent = pasteContent.replace(/<h1>/g, "<h2>");
                  pasteContent = pasteContent.replace(/<\/h1>/g, "</h2>"); // convert all images to place-holder tags and then reference the internal file system object
                  // this probably means nothing to the user but MIGHT be a real file in some cases that they
                  // could potentially paste / find

                  pasteContent = pasteContent.replace(/<img src=\"file:(.*?)\/>/g, function (placeholder, part) {
                    var s = part.split('"');
                    return "<place-holder type=\"image\" text=\"file:".concat(s[0], "\"></place-holder>");
                  }); // edges that some things preserve empty white space needlessly

                  _context7.next = 26;
                  return this.htmlToHaxElements(pasteContent);

                case 26:
                  haxElements = _context7.sent;

                  if (!(haxElements.length === 1 && !this.__validGridTags().includes(haxElements[0].tag))) {
                    _context7.next = 31;
                    break;
                  }

                  _context7.next = 30;
                  return this.htmlToHaxElements(haxElements[0].content);

                case 30:
                  haxElements = _context7.sent;

                case 31:
                  if (!(haxElements.length === 0 && (0, _utils.validURL)(pasteContent))) {
                    _context7.next = 38;
                    break;
                  }

                  // ONLY use this logic if we're on an empty container
                  if (this.activeNode.innerText.trim() != "") {
                    inlinePaste = true;
                  } // test for a URL since we didn't have HTML / elements of some kind
                  // if it's a URL we might be able to automatically convert it into it's own element


                  values = {
                    source: pasteContent,
                    title: pasteContent
                  }; // if we DID get a match, block default values

                  if (!(!inlinePaste && !this.insertLogicFromValues(values, this, false, true))) {
                    _context7.next = 36;
                    break;
                  }

                  return _context7.abrupt("return", false);

                case 36:
                  _context7.next = 81;
                  break;

                case 38:
                  if (!(haxElements.length === 0)) {
                    _context7.next = 47;
                    break;
                  }

                  inlinePaste = true; // wrap in a paragraph tag if there is any this ensures it correctly imports
                  // as it might not have evaluated above as having elements bc of the scrubber

                  if (!(originalContent != pasteContent)) {
                    _context7.next = 44;
                    break;
                  }

                  newContent = pasteContent;
                  _context7.next = 45;
                  break;

                case 44:
                  return _context7.abrupt("return", false);

                case 45:
                  _context7.next = 81;
                  break;

                case 47:
                  if (!(haxElements.length === 1 && haxElements[0].tag === "p")) {
                    _context7.next = 52;
                    break;
                  }

                  newContent = pasteContent;
                  inlinePaste = true;
                  _context7.next = 81;
                  break;

                case 52:
                  if (!(haxElements.length === 1 && haxElements[0].tag === "a" && haxElements[0].properties.href)) {
                    _context7.next = 63;
                    break;
                  }

                  if (!(this.activeNode.innerText.trim() != "")) {
                    _context7.next = 58;
                    break;
                  }

                  newContent = haxElements[0].properties.href;
                  inlinePaste = true;
                  _context7.next = 61;
                  break;

                case 58:
                  // test for a URL since we didn't have HTML / elements of some kind
                  // if it's a URL we might be able to automatically convert it into it's own element
                  _values = {
                    source: haxElements[0].properties.href,
                    title: haxElements[0].content
                  }; // if we DID get a match, block default values

                  if (this.insertLogicFromValues(_values, this)) {
                    _context7.next = 61;
                    break;
                  }

                  return _context7.abrupt("return", false);

                case 61:
                  _context7.next = 81;
                  break;

                case 63:
                  if (this.isGridPlateElement(haxElements[0])) {
                    _context7.next = 67;
                    break;
                  }

                  return _context7.abrupt("return", false);

                case 67:
                  _context7.t0 = regeneratorRuntime.keys(haxElements);

                case 68:
                  if ((_context7.t1 = _context7.t0()).done) {
                    _context7.next = 81;
                    break;
                  }

                  i = _context7.t1.value;

                  // special support for pasting into a list of items
                  if (haxElements[i].tag == "p" && ["li", "ol", "ul"].includes(this.activeNode.tagName.toLowerCase())) {
                    haxElements[i].tag = "li";
                  } // special traps for word / other styles bleeding through


                  delete haxElements[i].properties.style;
                  delete haxElements[i].properties.start;
                  delete haxElements[i].properties.align; // this is not the right function.

                  node = (0, _utils.haxElementToNode)({
                    tag: haxElements[i].tag,
                    content: haxElements[i].content.replace(/<span>&nbsp;<\/span>/g, " ").trim(),
                    properties: haxElements[i].properties
                  });
                  _context7.t2 = newContent;
                  _context7.next = 78;
                  return this.nodeToContent(node);

                case 78:
                  newContent = _context7.t2 += _context7.sent;
                  _context7.next = 68;
                  break;

                case 81:
                  // if we got here then we have HTML structures to pull together
                  // this ensures that the below works out
                  e.preventDefault();
                  e.stopPropagation();
                  e.stopImmediatePropagation();

                  try {
                    // get the range that's active and selection
                    range = this.getRange();
                    sel = this.getSelection(); // tee up a wrapper so we can walk and put every element in

                    newNodes = document.createElement("div"); // defined so that we can

                    newNodes.innerHTML = newContent;

                    if (range && sel) {
                      for (i in newNodes.children) {
                        // delete nodes that are empty text elements
                        if (newNodes.children[i].tagName && this.isTextElement(newNodes.children[i]) && newNodes.children[i].innerHTML === "") {
                          newNodes.children[i].remove();
                        }
                      }

                      if (inlinePaste) {
                        // we got here via an inline paste trap for a URL or other inline content
                        if (!(0, _utils.validURL)(pasteContent)) {
                          // if there ARE HTML children under here, we need to resolve it as HTML
                          if (newNodes.children && newNodes.children.length > 0) {
                            while (newNodes.childNodes.length > 1) {
                              range.insertNode(Array.from(newNodes.childNodes).pop());
                            } // this should append the HTML elements / textnodes correctly


                            txt = Array.from(newNodes.childNodes).pop();
                          } else {
                            // just make a text node if this is NODE a link
                            txt = document.createTextNode(newNodes.innerHTML);
                          }
                        } else {
                          // make a link because we have something that looks like one
                          // and we passed all above checks
                          txt = document.createElement("a");
                          txt.setAttribute("href", pasteContent);
                          txt.setAttribute("rel", "noopener noreferrer");
                          txt.setAttribute("target", "_blank");
                          txt.innerText = pasteContent;
                        }

                        range.insertNode(txt);
                        setTimeout(function () {
                          _this10._positionCursorInNode(txt, txt.length);
                        }, 0);
                      } else {
                        // only insert a P if we are splitting something
                        if (this.activeNode.innerText.trim() != "" && range.endOffset != this.activeNode.innerText.length) {
                          _enterSplit = true;
                          document.execCommand("insertParagraph");
                        } // sanity check and then insert our new paste node right AFTER the thing we are pasting in the middle of
                        // this hopefully captures complex HTML pastes and inserts them in a logical way


                        if (range.commonAncestorContainer && range.commonAncestorContainer.parentNode) {
                          if (!siblingEl && this.activeNode != range.commonAncestorContainer) {
                            siblingEl = range.commonAncestorContainer.parentNode;

                            if (!siblingEl) {
                              siblingEl = range.commonAncestorContainer;
                            }
                          }
                        }

                        while (newNodes.firstElementChild) {
                          activeEl = newNodes.firstElementChild; // should always be there but just in case there was no range
                          // so we avoid an infinite loop

                          if (siblingEl) {
                            // account for a potential textnode
                            if (siblingEl.getAttribute && siblingEl.getAttribute("slot")) {
                              activeEl.setAttribute("slot", siblingEl.getAttribute("slot"));
                            } // if we split an item at the very front with the enter key
                            // and we are pasting in complex content then we need to
                            // make sure that we move things AHEAD of what will be moved down


                            if (_enterSplit) {
                              this.activeHaxBody.haxReplaceNode(siblingEl.previousElementSibling, activeEl);
                              _enterSplit = false;
                            } else {
                              siblingEl.parentNode.insertBefore(activeEl, siblingEl.nextElementSibling);
                            }
                          } // attempt insert after active
                          else if (this.activeNode) {
                              if (this.activeNode.getAttribute("slot")) {
                                activeEl.setAttribute("slot", this.activeNode.getAttribute("slot"));
                              } // if we have an empty element we are hitting paste on
                              // then leverage it for the 1st item as opposed to making a new line


                              if (this.activeNode.innerText.trim() == "") {
                                this.activeHaxBody.haxReplaceNode(this.activeNode, activeEl);
                              } else {
                                this.activeNode.parentNode.insertBefore(activeEl, this.activeNode.nextElementSibling);
                              }
                            } // shouldn't be possible but just to be safe
                            else {
                                this.activeHaxBody.appendChild(activeEl);
                              }

                          siblingEl = activeEl;
                        }

                        setTimeout(function () {
                          if (activeEl && activeEl.childNodes && activeEl.childNodes[0]) {
                            _this10._positionCursorInNode(activeEl.childNodes[0], activeEl.childNodes[0].length);

                            activeEl = null;
                            siblingEl = null;
                          }
                        }, 0);
                      }
                    }
                  } catch (e) {
                    console.warn(e);
                  }

                case 85:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function _onPaste(_x7) {
          return _onPaste2.apply(this, arguments);
        }

        return _onPaste;
      }() // HTML primatives which are valid grid plate elements

    }, {
      key: "__validGridTags",
      value: function __validGridTags() {
        return ["p", "ol", "ul", "li", "div", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "code", "figure"];
      } // internal list of HTML primatives which are valid

    }, {
      key: "__validTags",
      value: function __validTags() {
        return ["p", "div", "span", "table", "caption", "sup", "sub", "u", "strike", "tr", "th", "td", "ol", "ul", "li", "a", "strong", "kbd", "tt", "em", "i", "b", "hr", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "code", "figure", "figcaption", "img", "iframe", "video", "audio", "section", "template", "webview"];
      }
      /**
       * Types that we deem as valid
       */

    }, {
      key: "__validGizmoTypes",
      value: function __validGizmoTypes() {
        return ["data", "video", "audio", "text", "link", "file", "pdf", "image", "csv", "doc", "archive", "markdown", "html", "content", "text", "inline", "*"];
      }
    }, {
      key: "_buildPrimitiveDefinitions",
      value: function _buildPrimitiveDefinitions() {
        // sandboxes need a webview definition
        // we don't want people making them but we need to
        // know how to edit them if asked
        if (this._isSandboxed) {
          var webview = {
            type: "element",
            editingElement: "core",
            canScale: true,
            canPosition: true,
            canEditSource: true,
            settings: {
              configure: [{
                attribute: "src",
                title: "Source",
                description: "The URL for this video.",
                inputMethod: "textfield",
                icon: "link",
                required: true,
                validationType: "url"
              }],
              advanced: []
            }
          };
          this.setHaxProperties(webview, "webview");
        }

        var iframe = {
          type: "element",
          editingElement: "core",
          canScale: true,
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Basic iframe",
            description: "A basic iframe",
            icon: "icons:fullscreen",
            color: "blue-grey",
            groups: ["Content"],
            handles: [{
              type: "link",
              source: "src",
              height: "height",
              width: "width"
            }, {
              type: "pdf",
              source: "src",
              height: "height",
              width: "width"
            }, {
              type: "document",
              source: "src",
              height: "height",
              width: "width"
            }, {
              type: "html",
              source: "src",
              height: "height",
              width: "width"
            }],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            configure: [{
              attribute: "src",
              title: "Source",
              description: "The URL for this video.",
              inputMethod: "textfield",
              icon: "link",
              required: true,
              validationType: "url"
            }],
            advanced: [{
              attribute: "loading",
              title: "Loading method",
              description: "Whether or not to lazy load this",
              inputMethod: "select",
              options: {
                lazy: "Load when visible",
                auto: "Automatic"
              }
            }]
          },
          demoSchema: [{
            tag: "iframe",
            content: "",
            properties: {
              src: "https://haxtheweb.org/",
              loading: "lazy",
              style: "height:50vh;width:75%;margin: 0px auto; display: block;"
            }
          }]
        };
        this.setHaxProperties(iframe, "iframe");
        var img = {
          canScale: {
            min: 10,
            step: 5
          },
          type: "element",
          editingElement: "core",
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Image",
            description: "A basic img tag",
            icon: "image:image",
            color: "blue-grey",
            groups: ["Image", "Media"],
            handles: [{
              type: "link",
              source: "src"
            }, {
              type: "image",
              type_exclusive: true,
              source: "src",
              height: "height",
              width: "width"
            }],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            configure: [{
              attribute: "src",
              title: "Source",
              description: "The URL for this video.",
              inputMethod: "haxupload",
              icon: "link",
              required: true,
              validationType: "url"
            }, {
              attribute: "alt",
              title: "Alt text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "alt",
              icon: "accessibility"
            }, {
              attribute: "height",
              title: "Height",
              description: "height in pixels of the item. Leave blank to respond to the natural resolution",
              inputMethod: "textfield",
              icon: "icons:swap-vert"
            }],
            advanced: [{
              attribute: "aria-describedby",
              title: "Aria-describedby",
              description: "Space-separated list of IDs for elements that describe the image.",
              inputMethod: "textfield",
              icon: "accessibility"
            }, {
              attribute: "loading",
              title: "Loading method",
              description: "Whether or not to lazy load this",
              inputMethod: "select",
              options: {
                lazy: "Load when visible",
                auto: "Automatic"
              }
            }]
          },
          demoSchema: [{
            tag: "img",
            content: "",
            properties: {
              src: "https://cdn2.thecatapi.com/images/9j5.jpg",
              loading: "lazy"
            }
          }]
        };
        this.setHaxProperties(img, "img");
        var figure = {
          canScale: {
            min: 10,
            step: 5
          },
          type: "grid",
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Figure",
            description: "A basic figure tag",
            icon: "hax:figure",
            color: "blue-grey",
            groups: ["Image", "Media", "Layout"],
            requiresChildren: "figcaption",
            handles: [],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            advanced: [DataStyleDecoration]
          },
          demoSchema: [{
            tag: "figure",
            properties: {},
            content: '<img src="https://dummyimage.com/300x200/000/fff" alt="image other media here">\n<figcaption><p>Image Caption Here</p></figcaption>'
          }]
        };
        this.setHaxProperties(figure, "figure");
        var figcaption = {
          canScale: {
            min: 10,
            step: 5
          },
          type: "grid",
          editingElement: "core",
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Figure caption",
            description: "Used inside of a figure tag",
            icon: "image:image",
            color: "blue-grey",
            groups: ["Image", "Media"],
            handles: [],
            requiresParent: "figure",
            meta: {
              author: "W3C"
            }
          },
          settings: {
            configure: [{
              slot: "",
              title: "Figure Caption",
              description: "Caption for the figure",
              inputMethod: "code-editor"
            }, DataStyleDecoration]
          },
          demoSchema: [{
            tag: "figcaption",
            properties: {},
            content: "Image Caption Here"
          }]
        };
        this.setHaxProperties(figcaption, "figcaption");
        var ahref = {
          type: "element",
          editingElement: "core",
          canScale: false,
          canPosition: false,
          canEditSource: true,
          contentEditable: true,
          gizmo: {
            title: "Basic link",
            description: "A basic a tag",
            icon: "icons:link",
            color: "blue-grey",
            groups: ["Link"],
            handles: [],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            configure: [{
              attribute: "innerText",
              title: "Text",
              description: "Text of the link",
              inputMethod: "textfield",
              required: true
            }, {
              attribute: "href",
              title: "Link",
              description: "The URL for this video.",
              inputMethod: "haxupload",
              required: true,
              validationType: "url"
            }, {
              attribute: "target",
              title: "Target",
              description: "Where to place the link.",
              inputMethod: "select",
              options: {
                "": "Same window",
                _blank: "New window - _blank",
                _top: "Top window - _top",
                _parent: "Parent window - _parent"
              }
            }, {
              attribute: "title",
              title: "Title text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "textfield"
            }, DataStyleDecoration],
            advanced: [{
              attribute: "rel",
              title: "rel",
              description: "Specifies the relationship between this document and the opened document. Change as part of security or SEO policy.",
              inputMethod: "select",
              options: {
                noopener: "noopener",
                "noopener noreferrer": "noopener noreferrer",
                "nofollow ": "nofollow",
                "noopener noreferrer nofollow": "noopener noreferrer nofollow",
                opener: "opener"
              }
            }]
          }
        }; // anything can be presented as a link

        this.validGizmoTypes.forEach(function (val) {
          ahref.gizmo.handles.push({
            type: val,
            source: "href",
            title: "innerText",
            alt: "title"
          });
        });
        this.setHaxProperties(ahref, "a");
        var p = {
          type: "element",
          editingElement: "core",
          // comment back in when ready to keep cleaning up shadowRoot resolution of focus

          /*editingElement: {
            tag: "simple-autocomplete-text-trigger",
            import:
              "@lrnwebcomponents/simple-autocomplete/lib/simple-autocomplete-text-trigger.js",
            callback: this.setupAutocomplete.bind(this),
          },*/
          canScale: false,
          canPosition: false,
          canEditSource: true,
          contentEditable: true,
          gizmo: {
            title: "Paragraph",
            description: "A basic text area",
            icon: "hax:paragraph",
            color: "blue-grey",
            groups: ["Content"],
            handles: [{
              type: "content",
              source: "",
              title: "innerHTML",
              alt: "title"
            }],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            configure: [],
            advanced: [DataStyleDecoration]
          },
          demoSchema: [{
            tag: "p",
            content: "Paragraph",
            properties: {}
          }]
        };
        this.setHaxProperties(p, "p"); // table tag which has a custom editing interface

        var table = {
          type: "element",
          canScale: true,
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Table",
            description: "A table for displaying data",
            icon: "image:grid-on",
            color: "blue-grey",
            groups: ["Content", "Table", "Data"],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            configure: [],
            advanced: []
          },
          demoSchema: [{
            tag: "table",
            content: "<tr><td>-</td><td>-</td><td>-</td></tr><tr><td>-</td><td>-</td><td>-</td></tr><tr><td>-</td><td>-</td><td>-</td></tr>",
            properties: {}
          }]
        }; // @todo bring back when table editor is supported
        //this.setHaxProperties(table, "table");

        var prims = {
          caption: {
            title: "Caption",
            icon: "av:call-to-action"
          },
          video: {
            title: "Video",
            icon: "av:play-circle-filled"
          },
          audio: {
            title: "Audio",
            icon: "image:music-note"
          },
          section: {
            title: "Section",
            icon: "image:crop-landscape"
          },
          ol: {
            title: "Numbered list",
            icon: "editor:format-list-numbered"
          },
          ul: {
            title: "Bulleted list",
            icon: "editor:format-list-bulleted"
          },
          li: {
            title: "List item",
            icon: "editor:format-list-bulleted"
          },
          h1: {
            title: "Heading",
            icon: "hax:h1"
          },
          h2: {
            title: "Heading",
            icon: "hax:h2"
          },
          h3: {
            title: "Heading",
            icon: "hax:h3"
          },
          h4: {
            title: "Heading",
            icon: "hax:h4"
          },
          h5: {
            title: "Heading",
            icon: "hax:h5"
          },
          h6: {
            title: "Heading",
            icon: "hax:h6"
          },
          strike: {
            title: "Cross out",
            icon: "editor:format-strikethrough"
          },
          u: {
            title: "Underline",
            icon: "editor:format-underlined"
          },
          sub: {
            title: "Subscript",
            icon: "mdextra:subscript"
          },
          sup: {
            title: "Superscript",
            icon: "mdextra:superscript"
          },
          div: {
            title: "DIV",
            icon: "image:crop-landscape"
          },
          span: {
            title: "SPAN",
            icon: "editor:short-text",
            handles: [{
              type: "inline",
              text: "text"
            }]
          },
          i: {
            title: "Italic",
            icon: "editor:format-italic"
          },
          em: {
            title: "Emphasis",
            icon: "editor:format-italic"
          },
          strong: {
            title: "Bold",
            icon: "editor:format-bold"
          },
          b: {
            title: "Bold",
            icon: "editor:format-bold"
          },
          blockquote: {
            title: "Block quote",
            icon: "editor:format-quote"
          },
          code: {
            title: "Code",
            icon: "icons:code"
          },
          embed: {
            title: "Embedded object",
            icon: "icons:fullscreen"
          }
        };

        for (var tag in prims) {
          this.setHaxProperties({
            type: "element",
            editingElement: "core",
            canScale: false,
            canPosition: false,
            canEditSource: true,
            contentEditable: true,
            gizmo: babelHelpers.defineProperty({
              title: prims[tag].title,
              icon: prims[tag].icon,
              meta: {
                hidden: tag == "h2" ? false : true
              },
              groups: ["Content"],
              handles: prims[tag].handles || []
            }, "meta", {
              author: "ELMS:LN",
              inlineOnly: true
            }),
            settings: {
              configure: [],
              advanced: [DataStyleDecoration]
            },
            demoSchema: [{
              tag: tag,
              content: tag == "h2" ? "Heading" : "",
              properties: {}
            }]
          }, tag);
        }

        var hr = {
          canScale: {
            min: 25,
            step: 25
          },
          type: "element",
          editingElement: "core",
          canPosition: false,
          canEditSource: false,
          contentEditable: true,
          gizmo: {
            title: "Horizontal line",
            icon: "hax:hr",
            meta: {
              author: "W3C"
            }
          },
          settings: {
            configure: [],
            advanced: [DataStyleDecoration]
          },
          demoSchema: [{
            tag: "hr",
            content: "",
            properties: {
              style: "width:50%;"
            }
          }]
        };
        this.setHaxProperties(hr, "hr");
      }
      /**
       * A standard event for registering the different pieces of HAX that check in
       * at run time. This allows for additional flexibility down the road as well as
       * registering pieces we never thought of for custom environments.
       * This also ensures that there are object references in the central store
       * but that load at an unknown time during spin up.
       *
       * @param {CustomEvent} e an event that has the piece to register and the object
       */

    }, {
      key: "_haxStorePieceRegistrationManager",
      value: function _haxStorePieceRegistrationManager(e) {
        if (e.detail && e.detail.piece && e.detail.object) {
          this[e.detail.piece] = e.detail.object;
        }
      }
      /**
       * set up the autocomplete contextual settings
       */

    }, {
      key: "setupAutocomplete",
      value: function setupAutocomplete(editor) {
        var _this11 = this;

        editor.triggers = {
          "!": function _(el) {
            var triggers = [];

            _this11.gizmoList.forEach(function (item) {
              triggers.push({
                groups: item.groups && item.groups.length ? item.groups.join(" ") : "",
                icon: item.icon,
                label: item.title,
                value: item.tag
              });
            });

            return triggers;
          }
        };
      }
      /**
       * Insert content in the body.
       */

    }, {
      key: "_haxStoreInsertContent",
      value: function () {
        var _haxStoreInsertContent2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(e) {
          var details, prototypeNode, properties, node, _node, _node2;

          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  if (!e.detail) {
                    _context8.next = 13;
                    break;
                  }

                  details = e.detail;

                  if (!window.customElements.get(details.tag)) {
                    _context8.next = 8;
                    break;
                  }

                  prototypeNode = document.createElement(details.tag); // @see haxHooks: preProcessInsertContent

                  if (!this.testHook(prototypeNode, "preProcessInsertContent")) {
                    _context8.next = 8;
                    break;
                  }

                  _context8.next = 7;
                  return this.runHook(prototypeNode, "preProcessInsertContent", [details, this.activeNode]);

                case 7:
                  details = _context8.sent;

                case 8:
                  properties = {}; // support for properties to be set automatically optionally

                  if (babelHelpers.typeof(details.properties) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    properties = details.properties;
                  } // support / clean up properties / attributes that have innerHTML / innerText
                  // these are reserved words but required for certain bindings


                  if (properties.innerHTML) {
                    if (details.content == "") {
                      details.content = properties.innerHTML;
                    }

                    delete properties.innerHTML;
                  }

                  if (properties.innerText) {
                    if (details.content == "") {
                      details.content = properties.innerText;
                    }

                    delete properties.innerText;
                  } // invoke insert or replacement on body, same function so it's easier to trace


                  if (babelHelpers.typeof(details.__type) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && details.__type === "inline") {
                    node = (0, _utils.haxElementToNode)({
                      tag: details.tag,
                      content: details.content,
                      properties: properties
                    }); // replace what WAS the active selection w/ this new node

                    if (this.activePlaceHolder !== null) {
                      this.activePlaceHolder.deleteContents();
                      this.activePlaceHolder.insertNode(node);
                    } // set it to nothing


                    this.activePlaceHolder = null;
                  } else if (details.replace || details.replacement || details.nextToActive) {
                    _node = (0, _utils.haxElementToNode)({
                      tag: details.tag,
                      content: details.content,
                      properties: properties
                    });

                    if (this.activePlaceHolder) {
                      this.activeHaxBody.haxReplaceNode(this.activePlaceHolder, _node);
                      this.activePlaceHolder = null;
                    } else if (details.nextToActive && this.activeNode) {
                      // special support for an active slot
                      if (this.activeHaxBody.__slot && this.activeNode.haxLayoutContainer) {
                        this.activeNode.appendChild(_node);
                      } else {
                        this.activeNode.parentNode.insertBefore(_node, this.activeNode);
                      }
                    } else {
                      this.activeHaxBody.haxReplaceNode(this.activeNode, _node);
                    }
                  } else if (this.activeNode.parentNode && this.activeNode.parentNode.tagName != "HAX-BODY") {
                    _node2 = (0, _utils.haxElementToNode)({
                      tag: details.tag,
                      content: details.content,
                      properties: properties
                    }); // allow for inserting things into things but not grid plate

                    if (this.activeNode.parentNode.haxLayoutContainer) {
                      // support slot if we have one on the activeNode (most likely)
                      if (this.activeNode.getAttribute("slot") != null) {
                        _node2.setAttribute("slot", this.activeNode.getAttribute("slot"));
                      }

                      this.activeHaxBody.haxInsert(details.tag, details.content, properties);
                    } else {
                      this.activeHaxBody.haxInsert(details.tag, details.content, properties);
                    }
                  } else {
                    this.activeHaxBody.haxInsert(details.tag, details.content, properties);
                  }

                case 13:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function _haxStoreInsertContent(_x8) {
          return _haxStoreInsertContent2.apply(this, arguments);
        }

        return _haxStoreInsertContent;
      }()
      /**
       * if given a schema, returns slots as array
       *
       * @param {object} schema
       * @param {boolean} [optionalOnly=false]
       * @returns {array}
       * @memberof HaxStore
       */

    }, {
      key: "slotsFromSchema",
      value: function slotsFromSchema(schema) {
        var optionalOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var settings = schema ? schema.settings : {},
            slotsList = [];
        return Object.keys(_objectSpread({}, settings || {})).map(function (setting) {
          return (settings[setting] || []).filter(function (prop) {
            var show = !optionalOnly || !prop.required;

            if ((!!prop.slot || prop.slot === "") && !slotsList.includes(prop.slot) && show) {
              slotsList.push(prop.slot);
              return true;
            } else {
              return false;
            }
          });
        }).flat();
      }
      /**
       * get the schema from a tag
       */

    }, {
      key: "haxSchemaFromTag",
      value: function haxSchemaFromTag(tag) {
        tag = tag.toLowerCase();

        if (this.elementList && this.elementList[tag]) {
          return this.elementList[tag];
        }

        return {};
      }
      /**
       * Optional send array, to improve performance and event bubbling better
       */

    }, {
      key: "_haxStoreInsertMultiple",
      value: function _haxStoreInsertMultiple(e) {
        if (e.detail) {
          var properties;

          for (var i in e.detail) {
            properties = {}; // support for properties to be set automatically optionally

            if (babelHelpers.typeof(e.detail[i].properties) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              properties = e.detail[i].properties;
            }

            this.activeHaxBody.haxInsert(e.detail[i].tag, e.detail[i].content, properties);
          }
        }
      }
      /**
       * Set the activeHaxBody and add to the list so we know what to insert into.
       */

    }, {
      key: "_haxStoreRegisterBody",
      value: function _haxStoreRegisterBody(e) {
        var _this12 = this;

        if (e.detail) {
          this.haxBodies.push(e.detail); // default active the whatever is last here

          this.activeHaxBody = e.detail; // needed so that higher order things can respond to us having a body

          this.write("activeHaxBody", this.activeHaxBody, this);
          this.write("editMode", this.editMode, this); // allow this to verify if everything is here or not

          clearTimeout(this.__storeReady);
          this.__storeReady = setTimeout(function () {
            _this12._storePiecesAllHere(_this12.haxAutoloader, _this12.activeHaxBody, _this12.haxTray, _this12.haxCancel);
          }, 0);
        }
      }
      /**
       * Feature detect on the bar.
       */

    }, {
      key: "computePolyfillSafe",
      value: function computePolyfillSafe() {
        /**
         * These are our bad actors in polyfill'ed browsers.
         * This means that https://github.com/webcomponents/webcomponentsjs/commit/ce464bb533bf39b544c312906499a6044ee0d30d
         * explains things but basically if shadow-dom is polyfilled
         * then we can't safely execute a DOM manipulating execCommand.
         * This
         */
        if (document.head.createShadowRoot || document.head.attachShadow) {
          return true;
        } else {
          console.warn("Shadow DOM missing, certain operations hidden");
          return false;
        }
      }
      /**
       * Write store event callback.
       */

    }, {
      key: "_writeHaxStore",
      value: function _writeHaxStore(e) {
        // ensure we have a valid store write
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property && e.detail.owner) {
          // only update US if we didn't originate this message
          if (e.detail.owner !== this) {
            if (e.detail.value == null) {
              this[e.detail.property] = null;
            } else if (babelHelpers.typeof(e.detail.value) === "object") {
              this[e.detail.property] = {};
            }

            this[e.detail.property] = e.detail.value;
          } // tell everyone regardless


          this.dispatchEvent(new CustomEvent("hax-store-property-updated", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: {
              property: e.detail.property,
              value: e.detail.value,
              owner: e.detail.owner
            }
          }));
        }
      }
      /**
       * Notice that an app was set in HAX; register it
       */

    }, {
      key: "_haxStoreRegisterApp",
      value: function _haxStoreRegisterApp(e) {
        if (e.detail) {
          e.detail.index = this.appList.length;
          this.appList = [].concat(babelHelpers.toConsumableArray(this.appList), [e.detail]);
          this.write("appList", (0, _mobxEsm.toJS)(this.appList), this); // preconnect apps at registration time

          if (e.detail.connection && e.detail.connection.protocol && e.detail.connection.url) {
            var preconnectlink = document.createElement("link");
            preconnectlink.rel = "preconnect";
            preconnectlink.href = e.detail.connection.protocol + "://" + e.detail.connection.url;
            document.head.appendChild(preconnectlink);
          } // we don't care about this after it's launched


          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-STORE") {
            e.target.parentElement.removeChild(e.target);
          }
        }
      }
      /**
       * Notice that a stax was set in HAX; register it
       */

    }, {
      key: "_haxStoreRegisterStax",
      value: function _haxStoreRegisterStax(e) {
        if (e.detail) {
          e.detail.index = this.staxList.length;
          this.staxList = [].concat(babelHelpers.toConsumableArray(this.staxList), [e.detail]);
          this.write("staxList", this.staxList, this); // we don't care about this after it's launched

          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-STORE") {
            e.target.parentElement.removeChild(e.target);
          }
        }
      }
      /**
       * Helper to convert dash to camel; important when reading attributes.
       */

    }, {
      key: "dashToCamel",
      value: function dashToCamel(str) {
        return str.replace(/-([a-z])/g, function (g) {
          return g[1].toUpperCase();
        });
      }
      /**
       * Convert HTML into HAX Elements
       */

    }, {
      key: "htmlToHaxElements",
      value: function () {
        var _htmlToHaxElements = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(html) {
          var elements, validTags, fragment, children, i;
          return regeneratorRuntime.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  elements = [];
                  validTags = this.validTagList;
                  fragment = document.createElement("div");
                  fragment.innerHTML = html;
                  children = fragment.childNodes; // loop over the new nodes

                  i = 0;

                case 6:
                  if (!(i < children.length)) {
                    _context9.next = 16;
                    break;
                  }

                  if (!(babelHelpers.typeof(children[i].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && validTags.includes(children[i].tagName.toLowerCase()))) {
                    _context9.next = 13;
                    break;
                  }

                  _context9.t0 = elements;
                  _context9.next = 11;
                  return (0, _utils.nodeToHaxElement)(children[i], null);

                case 11:
                  _context9.t1 = _context9.sent;

                  _context9.t0.push.call(_context9.t0, _context9.t1);

                case 13:
                  i++;
                  _context9.next = 6;
                  break;

                case 16:
                  return _context9.abrupt("return", elements);

                case 17:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9, this);
        }));

        function htmlToHaxElements(_x9) {
          return _htmlToHaxElements.apply(this, arguments);
        }

        return htmlToHaxElements;
      }()
      /**
       * Convert a node to the correct content object for saving.
       * This DOES NOT acccept a HAXElement which is similar
       */

    }, {
      key: "nodeToContent",
      value: function () {
        var _nodeToContent = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(node) {
          var tag, content, props, propvals, j, l, nodeName, value, tmpProps, i, delProps, delProp, voidTags, slotnodes, len2;
          return regeneratorRuntime.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  if (!this.testHook(node, "preProcessNodeToContent")) {
                    _context10.next = 4;
                    break;
                  }

                  _context10.next = 3;
                  return this.runHook(node, "preProcessNodeToContent", [node]);

                case 3:
                  node = _context10.sent;

                case 4:
                  tag = node.tagName.toLowerCase(); // support sandboxed environments which
                  // will hate iframe tags but love webview

                  if (this._isSandboxed && tag === "webview") {
                    tag = "iframe";
                  }

                  content = ""; // start to rebuild the same tag we got in a generalized way

                  content += "<" + tag; // account for things that say NOT to save slot values

                  props = this.elementList[tag];
                  propvals = {}; // grab all of the original's attributes, and pass them to the replacement

                  for (j = 0, l = node.attributes.length; j < l; ++j) {
                    nodeName = node.attributes.item(j).nodeName;
                    value = node.attributes.item(j).value; // encode objects and arrays because they are special

                    if (nodeName != "style" && (babelHelpers.typeof(value) === (typeof Object === "undefined" ? "undefined" : babelHelpers.typeof(Object)) || value.constructor === Array)) {
                      propvals[nodeName] = JSON.stringify(value).replace(new RegExp('"', "g"), "&quot;");
                    } // only write things that aren't empty
                    else if (value != null && value != "null") {
                        if (value === true || value === "true") {
                          propvals[nodeName] = true;
                        } else if (value === false) {// do nothing, no reason to record false unless written as text
                          // in which case below will capture it
                        } else {
                          // ensure that value doesn't have " in it unencoded
                          if (typeof value === "string" && value !== "") {
                            value = value.replace(new RegExp('"', "g"), "&quot;");
                            propvals[nodeName] = value;
                          } // special handling for empty string cause it might mean boolean
                          // or it might be a string
                          else if (value === "") {
                              if (value == "" && node.attributes.item(j).value != "") {
                                value = node.attributes.item(j).value;
                              }

                              propvals[nodeName] = value;
                            } else {
                              propvals[nodeName] = value;
                            }
                        }
                      }
                  } // now look through properties


                  // relatively cross library
                  if (customElements.get(tag)) {
                    tmpProps = customElements.get(tag).properties;
                  } // weak fallback


                  if (babelHelpers.typeof(tmpProps) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    tmpProps = node.__data;
                  }

                  if (babelHelpers.typeof(tmpProps) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    for (j in tmpProps) {
                      nodeName = (0, _utils.camelToDash)(j);
                      value = null; // prefer local value over properties object if possible

                      if (babelHelpers.typeof(node[j]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                        value = node[j];
                      } // never allow read only things to recorded as they
                      // are run-time creation 99% of the time
                      // this is very polymer specific but it allows readOnly and computed props
                      // also __ is a popular convention for private values so let's skip them


                      if (!tmpProps[j].readOnly && !tmpProps[j].computed && value !== tmpProps[j].value && !nodeName.startsWith("__")) {
                        // encode objects and arrays because they are special
                        if (value != null && (babelHelpers.typeof(value) === "object" || value.constructor === Array)) {
                          if (value.constructor === Array && value != []) {
                            propvals[nodeName] = JSON.stringify(value).replace(new RegExp('"', "g"), "&quot;");
                          } else if (babelHelpers.typeof(value) === "object" && value != {}) {
                            propvals[nodeName] = JSON.stringify(value).replace(new RegExp('"', "g"), "&quot;");
                          }
                        } // only write things that aren't empty
                        else if (value != null && value != "null") {
                            if (value === true || value === "true") {
                              propvals[nodeName] = true;
                            } else if (value === false) {// do nothing, no reason to record false unless written as text
                              // in which case below will capture it
                            } else {
                              // ensure that value doesn't have " in it unencoded
                              if (typeof value === "string" && value !== "") {
                                value = value.replace(new RegExp('"', "g"), "&quot;");
                                propvals[nodeName] = value;
                              } // special handling for empty string cause it might mean boolean
                              // or it might be a string
                              else if (value === "") {
                                  if (value == "" && tmpProps[j].value != "") {
                                    value = tmpProps[j].value;
                                  } else if (value === "" && tmpProps[j].value == "") {// do nothing, the default value is empty
                                    // so lets record less data
                                  }
                                } else {
                                  propvals[nodeName] = value;
                                }
                            }
                          }
                      }
                    }
                  } // support for tag defining which properties NOT to save
                  // for simplification, everything is an attribute during this
                  // operation


                  if (babelHelpers.typeof(props) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(props.saveOptions.unsetAttributes) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                    for (i in props.saveOptions.unsetAttributes) {
                      delete propvals[props.saveOptions.unsetAttributes[i]];
                    }
                  } // specialized clean up for some that can leak through from above
                  // and are edge case things because #hashtag gotta love HTML attributes
                  // and the webview tag. facepalm.


                  delProps = ["inner-text", "inner-html", "tabindex", "guestinstance"];

                  for (delProp in delProps) {
                    if (babelHelpers.typeof(propvals[delProps[delProp]]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      delete propvals[delProps[delProp]];
                    }
                  } // remove id attribute if it's empty, somehow misses above


                  if (babelHelpers.typeof(propvals.id) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && propvals.id === "") {
                    delete propvals.id;
                  } // drop these known things we never want to save


                  delete propvals.draggable;
                  delete propvals.contenteditable;
                  delete propvals["data-hax-ray"];
                  delete propvals["data-hax-layout"];

                  if (propvals.class == "" || propvals.class == "hax-active") {
                    delete propvals.class;
                  } // run through the rest and print to the dom


                  for (i in propvals) {
                    if (propvals[i] === true) {
                      content += " " + i;
                    } else {
                      content += " " + i + '="' + propvals[i] + '"';
                    }
                  } // set the opening tag, support self-closing void tags


                  voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];

                  if (voidTags.includes(tag)) {
                    content += "/>";
                  } else {
                    content += ">";
                  } // try and work against anything NOT a P tag


                  if (!(babelHelpers.typeof(props) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) || !props.saveOptions.wipeSlot)) {
                    _context10.next = 48;
                    break;
                  }

                  // get content that is in the slots
                  slotnodes = node.childNodes; // ensure there's something inside of this

                  if (!(slotnodes.length > 0)) {
                    _context10.next = 48;
                    break;
                  }

                  j = 0, len2 = slotnodes.length;

                case 30:
                  if (!(j < len2)) {
                    _context10.next = 48;
                    break;
                  }

                  if (!(babelHelpers.typeof(slotnodes[j].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)))) {
                    _context10.next = 44;
                    break;
                  }

                  if (!(!this.HTMLPrimativeTest(slotnodes[j].tagName) && slotnodes[j].tagName !== "TEMPLATE")) {
                    _context10.next = 39;
                    break;
                  }

                  _context10.t0 = content;
                  _context10.next = 36;
                  return this.nodeToContent(slotnodes[j]);

                case 36:
                  content = _context10.t0 += _context10.sent;
                  _context10.next = 42;
                  break;

                case 39:
                  slotnodes[j].removeAttribute("data-hax-ray");
                  slotnodes[j].contentEditable = false;
                  content += slotnodes[j].outerHTML;

                case 42:
                  _context10.next = 45;
                  break;

                case 44:
                  // keep comments with a special case since they need wrapped
                  if (slotnodes[j].nodeType === 8) {
                    content += "<!-- " + slotnodes[j].textContent + " -->";
                  } // keep everything NOT an element at this point, this helps
                  // preserve whitespace because we're crazy about accuracy
                  else if (slotnodes[j].nodeType !== 1 && babelHelpers.typeof(slotnodes[j].textContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && slotnodes[j].textContent !== "undefined") {
                      content += (0, _utils.htmlEntities)(slotnodes[j].textContent);
                    }

                case 45:
                  j++;
                  _context10.next = 30;
                  break;

                case 48:
                  if (!this.testHook(node, "progressiveEnhancement")) {
                    _context10.next = 53;
                    break;
                  }

                  _context10.t1 = content;
                  _context10.next = 52;
                  return this.runHook(node, "progressiveEnhancement", [node]);

                case 52:
                  content = _context10.t1 += _context10.sent;

                case 53:
                  // don't put return for span since it's an inline tag
                  if (tag === "span") {
                    content += "</" + tag + ">";
                  } else if (tag === "hr" || tag === "br" || tag === "img") {} // do nothing for self-closing tags they'll resolve themselves
                  // close the tag, placing a return in output for block elements
                  else {
                      content += "</" + tag + ">" + "\n";
                    } // spacing niceness for output readability


                  content = content.replace(/&nbsp;/gm, " "); // target and remove hax specific things from output if they slipped through

                  content = content.replace(/ data-hax-ray="(\s|.)*?"/gim, "");
                  content = content.replace(/ class=""/gim, "");
                  content = content.replace(/ class="hax-active"/gim, "");
                  content = content.replace(/ contenteditable="(\s|.)*?"/gim, ""); // wipe pure style spans which can pop up on copy paste if we didn't catch it
                  // also ensure that we then remove purely visual chars laying around
                  // this also helps clean up when we did a normal contenteditable paste
                  // as opposed to our multi-element sanitizing option that we support

                  content = content.replace(/<span style="(.*?)">/gim, "<span>");
                  content = content.replace(/<span>\s*?<\/span>/g, " ");
                  content = content.replace(/<span><br\/><\/span>/gm, ""); // account for things taht on normal paste would pick up too many css vars

                  content = content.replace(/<strong style="(.*?)">/gim, "<strong>");
                  content = content.replace(/<b style="(.*?)">/gim, "<b>");
                  content = content.replace(/<strike style="(.*?)">/gim, "<strike>");
                  content = content.replace(/<em style="(.*?)">/gim, "<em>");
                  content = content.replace(/<i style="(.*?)">/gim, "<i>"); // empty with lots of space

                  content = content.replace(/<p>(\s*)<\/p>/gm, "<p></p>"); // empty p / more or less empty

                  content = content.replace(/<p>&nbsp;<\/p>/gm, "<p></p>"); // br somehow getting through here

                  content = content.replace(/<p><br\/><\/p>/gm, "<p></p>");
                  content = content.replace(/<p><br><\/p>/gm, "<p></p>"); // whitespace in reverse of the top case now that we've cleaned it up

                  content = content.replace(/<\/p>(\s*)<p>/gm, "</p><p>");
                  content = content.split("\n\r").join("\n").split("\r").join("\n").split("\n\n").join("\n").split("\n\n").join("\n").split("\n\n").join("\n"); // @see haxHooks: postProcessNodeToContent

                  if (!this.testHook(node, "postProcessNodeToContent")) {
                    _context10.next = 77;
                    break;
                  }

                  _context10.next = 76;
                  return this.runHook(node, "postProcessNodeToContent", [content]);

                case 76:
                  content = _context10.sent;

                case 77:
                  return _context10.abrupt("return", content);

                case 78:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, this);
        }));

        function nodeToContent(_x10) {
          return _nodeToContent.apply(this, arguments);
        }

        return nodeToContent;
      }()
      /**
       * Basic HTML Primitives test
       */

    }, {
      key: "HTMLPrimativeTest",
      value: function HTMLPrimativeTest(node) {
        if (babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.tagName.indexOf("-") == -1) {
          return true;
        }

        return false;
      }
      /**
       * Filter app store apps to those that accept this file source.
       */

    }, {
      key: "getHaxAppStoreTargets",
      value: function getHaxAppStoreTargets(type) {
        var appList = (0, _mobxEsm.toJS)(this.appList);
        var targets = appList.filter(function (app) {
          if (babelHelpers.typeof(app.connection.operations.add) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var add = app.connection.operations.add;

            if (babelHelpers.typeof(add.acceptsGizmoTypes) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && add.acceptsGizmoTypes.includes(type)) {
              return true;
            }
          }

          return false;
        });
        return targets;
      }
      /**
       * refresh / rebuild the form based on active item
       */

    }, {
      key: "refreshActiveNodeForm",
      value: function () {
        var _refreshActiveNodeForm = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
          return regeneratorRuntime.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  _context11.next = 2;
                  return (0, _utils.nodeToHaxElement)(this.haxTray.activeNode, null);

                case 2:
                  this.haxTray.activeHaxElement = _context11.sent;
                  _context11.next = 5;
                  return this.haxTray._setupForm();

                case 5:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, this);
        }));

        function refreshActiveNodeForm() {
          return _refreshActiveNodeForm.apply(this, arguments);
        }

        return refreshActiveNodeForm;
      }()
      /**
       * Generate Hax Element prototype.
       */

    }, {
      key: "haxElementPrototype",
      value: function haxElementPrototype(gizmo, properties) {
        var content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
        return {
          tag: gizmo.tag,
          properties: properties,
          content: content,
          gizmo: gizmo
        };
      }
      /**
       * Slot content w/ support for custom elements in slot.
       */

    }, {
      key: "getHAXSlot",
      value: function () {
        var _getHAXSlot = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(node) {
          var content, slotnodes, j, len2;
          return regeneratorRuntime.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  if (!this.isTextElement(node)) {
                    _context12.next = 2;
                    break;
                  }

                  return _context12.abrupt("return", node.innerHTML);

                case 2:
                  content = "";
                  slotnodes = node.childNodes; // ensure there's something inside of this

                  if (!(slotnodes.length > 0)) {
                    _context12.next = 26;
                    break;
                  }

                  j = 0, len2 = slotnodes.length;

                case 6:
                  if (!(j < len2)) {
                    _context12.next = 26;
                    break;
                  }

                  if (slotnodes[j]) {
                    _context12.next = 9;
                    break;
                  }

                  return _context12.abrupt("return");

                case 9:
                  if (!(babelHelpers.typeof(slotnodes[j].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)))) {
                    _context12.next = 22;
                    break;
                  }

                  if (!(slotnodes[j].tagName.indexOf("-") > 0)) {
                    _context12.next = 19;
                    break;
                  }

                  _context12.t0 = content;
                  _context12.next = 14;
                  return this.nodeToContent(slotnodes[j]);

                case 14:
                  _context12.t1 = _context12.sent;
                  _context12.t2 = "  " + _context12.t1;
                  content = _context12.t0 += _context12.t2 + "\n";
                  _context12.next = 20;
                  break;

                case 19:
                  content += "  " + slotnodes[j].outerHTML + "\n";

                case 20:
                  _context12.next = 23;
                  break;

                case 22:
                  // keep comments with a special case since they need wrapped
                  if (slotnodes[j].nodeType === 8) {
                    content += "<!-- " + slotnodes[j].textContent + " -->";
                  } // keep everything NOT an element at this point, this helps
                  // preserve whitespace because we're crazy about accuracy
                  else if (slotnodes[j].nodeType !== 1 && babelHelpers.typeof(slotnodes[j].textContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && slotnodes[j].textContent !== "undefined") {
                      content += slotnodes[j].textContent;
                    }

                case 23:
                  j++;
                  _context12.next = 6;
                  break;

                case 26:
                  return _context12.abrupt("return", content);

                case 27:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12, this);
        }));

        function getHAXSlot(_x11) {
          return _getHAXSlot.apply(this, arguments);
        }

        return getHAXSlot;
      }()
      /**
       * Notice that a property off an element was set in HAX some place; register it here
       */

    }, {
      key: "_haxStoreRegisterProperties",
      value: function () {
        var _haxStoreRegisterProperties2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(e) {
          var detail, gizmo, gizmos;
          return regeneratorRuntime.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  if (!(e.detail && e.detail.properties && e.detail.tag)) {
                    _context13.next = 15;
                    break;
                  }

                  if (this.elementList[e.detail.tag]) {
                    _context13.next = 14;
                    break;
                  }

                  detail = e.detail;
                  _context13.next = 5;
                  return this.attemptGizmoTranslation(detail.tag, detail.properties);

                case 5:
                  detail.properties = _context13.sent;
                  // look for a gizmo; it's not required, technically.
                  gizmo = detail.properties.gizmo;

                  if (gizmo) {
                    gizmo.tag = detail.tag;
                    gizmos = this.gizmoList;
                    gizmos.push(gizmo);
                    this.gizmoList = babelHelpers.toConsumableArray(gizmos);
                    this.write("gizmoList", gizmos, this);
                  }

                  this.elementList[detail.tag] = detail.properties; // only push new values on if we got something new

                  if (!this.validTagList.find(function (element) {
                    return element === detail.tag;
                  })) {
                    this.validTagList.push(detail.tag);
                  } // push to grid list IF this marks itself as a grid


                  if (detail.properties.type == "grid" && !this.validGridTagList.find(function (element) {
                    return element === detail.tag;
                  })) {
                    this.validGridTagList.push(detail.tag);
                  } // @see haxHook: gizmoRegistration - allow elements to define their own
                  // custom functionality to run when a gizmo is registered
                  //console.warn(e.detail.tag);


                  if (!(window.customElements.get(e.detail.tag) && this.testHook(document.createElement(e.detail.tag), "gizmoRegistration"))) {
                    _context13.next = 14;
                    break;
                  }

                  _context13.next = 14;
                  return this.runHook(document.createElement(e.detail.tag), "gizmoRegistration", [this]);

                case 14:
                  // delete this tag if it was in the autoloader as it has served it's purpose.
                  if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-AUTOLOADER") {
                    this.haxAutoloader.removeChild(e.target);
                  }

                case 15:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13, this);
        }));

        function _haxStoreRegisterProperties(_x12) {
          return _haxStoreRegisterProperties2.apply(this, arguments);
        }

        return _haxStoreRegisterProperties;
      }()
    }, {
      key: "activeGizmo",
      get: function get() {
        var gizmo = (0, _mobxEsm.toJS)(this._calculateActiveGizmo(this.activeNode));
        this.write("activeGizmo", gizmo, this);
        return gizmo;
      } // find node index / order based on

    }, {
      key: "activeNodeIndex",
      get: function get() {
        var _this13 = this;

        var nodeLookup = null;

        if (this.activeNode) {
          Array.from((0, _mobxEsm.toJS)(this.activeHaxBody).children).map(function (el, i) {
            if ((0, _mobxEsm.toJS)(_this13.activeNode) === el || (0, _mobxEsm.toJS)(_this13.activeNode).parentElement === el) {
              nodeLookup = i;
            }
          });
        }

        return nodeLookup;
      }
    }, {
      key: "attemptGizmoTranslation",
      value: function () {
        var _attemptGizmoTranslation = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(tag, properties) {
          var translationMap, i, sTabs, h, j;
          return regeneratorRuntime.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  _context14.next = 2;
                  return _I18NMixin2.I18NManagerStore.loadNamespaceFile(tag + ".haxProperties");

                case 2:
                  translationMap = _context14.sent;

                  if (!(!translationMap && this.globalPreferences.haxLang == FALLBACK_LANG && window.customElements.get(tag) && window.customElements.get(tag).haxProperties)) {
                    _context14.next = 9;
                    break;
                  }

                  translationMap = window.customElements.get(tag).haxProperties; // support

                  if (!(typeof translationMap === "string")) {
                    _context14.next = 9;
                    break;
                  }

                  _context14.next = 8;
                  return fetch(translationMap).then(function (response) {
                    if (response && response.json) return response.json();
                    return false;
                  });

                case 8:
                  translationMap = _context14.sent;

                case 9:
                  if (translationMap) {
                    // gizmo shows user text
                    if (properties.gizmo && translationMap.gizmo) {
                      for (i in translationMap.gizmo) {
                        properties.gizmo[i] = translationMap.gizmo[i];
                      }
                    } // settings pages


                    if (properties.settings && translationMap.settings) {
                      sTabs = {
                        advanced: "advanced",
                        configure: "configure"
                      };

                      for (h in sTabs) {
                        if (properties.settings[h] && translationMap.settings[h]) {
                          for (i in translationMap.settings[h]) {
                            for (j in translationMap.settings[h][i]) {
                              properties.settings[h][i][j] = translationMap.settings[h][i][j];
                            }
                          }
                        }
                      }
                    } // demo schema can be rewritten too


                    if (properties.demoSchema && translationMap.demoSchema) {
                      for (i in translationMap.demoSchema) {
                        if (translationMap.demoSchema[i].properties) {
                          for (j in translationMap.demoSchema[i].properties) {
                            properties.demoSchema[i].properties[j] = translationMap.demoSchema[i].properties[j];
                          }
                        }
                      }
                    }
                  }

                  return _context14.abrupt("return", properties);

                case 11:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14, this);
        }));

        function attemptGizmoTranslation(_x13, _x14) {
          return _attemptGizmoTranslation.apply(this, arguments);
        }

        return attemptGizmoTranslation;
      }()
    }], [{
      key: "tag",
      get: function get() {
        return "hax-store";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore), "properties", this)), {}, {
          voiceDebug: {
            type: Boolean,
            attribute: "voice-debug"
          },
          voiceRespondsTo: {
            type: String,
            attribute: "voice-responses-to"
          },

          /**
           * skipHAXConfirmation
           */
          skipHAXConfirmation: {
            type: Boolean,
            reflect: true,
            attribute: "skip-hax-confirmation"
          },

          /**
           * Local storage bridge
           */
          storageData: {
            type: Object
          },

          /**
           * Hax tray
           */
          haxTray: {
            type: Object
          },

          /**
           * Hax cancel dialog
           */
          haxCancel: {
            type: Object
          },

          /**
           * Hax autoloader element.
           */
          haxAutoloader: {
            type: Object
          },

          /**
           * A list of all haxBodies that exist
           */
          haxBodies: {
            type: Array
          },

          /**
           * An active place holder item reference. This is used
           * for inline drag and drop event detection so that we
           * know what element replace in context.
           */
          activePlaceHolder: {
            type: Object
          },

          /**
           * Possible appStore endpoint for loading in things dynamically.
           */
          appStore: {
            type: Object
          },

          /**
           * Session object bridged in from a session method of some kind
           */
          sessionObject: {
            type: Object
          },

          /**
           * skip the exit trap to prevent losing data
           */
          skipExitTrap: {
            type: Boolean
          },

          /**
           * Available elements keyed by tagName and with
           * their haxProperties centrally registered.
           */
          elementList: {
            type: Object
          },

          /**
           * Available hax stax which are just re-usable templates
           */
          staxList: {
            type: Array
          },

          /**
           * Valid tag list, tag only and including primatives for a baseline.
           */
          validTagList: {
            type: Array
          },

          /**
           * Valid tag list, tag only and including primatives for a baseline.
           */
          validGridTagList: {
            type: Array
          },

          /**
           * Gizmo types which can be used to bridge apps to gizmos.
           */
          validGizmoTypes: {
            type: Array
          },

          /**
           * Sandboxed environment test
           */
          _isSandboxed: {
            type: Boolean
          },

          /**
           * Internal app store data property after request
           */
          __appStoreData: {
            type: Object
          },
          ready: {
            type: Boolean
          },

          /**
           * Support for deploy specific rewriting for things like JWTs
           */
          connectionRewrites: {
            type: Object
          }
        });
      }
    }]);
    return HaxStore;
  }((0, _I18NMixin2.I18NMixin)((0, _utils.winEventsElement)((0, _haxBodyBehaviors.HAXElement)(_index.LitElement))));

  _exports.HaxStore = HaxStore;
  window.customElements.define(HaxStore.tag, HaxStore);
  // window bridge for external projects that want to account for HAX
  // yet don't want to require it as part of an import chain
  window.HaxStore = window.HaxStore || {};

  window.HaxStore.requestAvailability = function () {
    if (!window.HaxStore.instance) {
      window.HaxStore.instance = document.createElement("hax-store");
      document.body.appendChild(window.HaxStore.instance);
    }

    return window.HaxStore.instance;
  }; // export the singleton so everyone can directly reference it


  var HAXStore = window.HaxStore.requestAvailability(); // debugging / developer console shortcuts

  _exports.HAXStore = HAXStore;
  window.Hax = window.Hax || {};

  window.Hax.add = function (tag) {
    if (HAXStore.elementList[tag]) {
      // generate schema from the tag
      var schema = HAXStore.haxSchemaFromTag(tag);
      var target;

      if (schema.gizmo.tag && schema.demoSchema && schema.demoSchema[0]) {
        target = (0, _utils.haxElementToNode)(schema.demoSchema[0]);
      } else {
        target = document.createElement(tag);
      }

      HAXStore.activeHaxBody.haxReplaceNode(HAXStore.activeNode, target);

      HAXStore.activeHaxBody.__focusLogic(target);
    } else {
      // do nothing, we tried to be a pro but failed :(
      HAXStore.toast("".concat(tag, " is not a valid tag"));
    }
  };

  window.Hax.delete = function () {
    if (HAXStore.activeNode != null) {
      HAXStore.activeHaxBody.haxDeleteNode(HAXStore.activeNode);
    }
  };

  window.Hax.duplicate = function () {
    HAXStore.activeHaxBody.haxDuplicateNode(HAXStore.activeNode);
  };

  window.Hax.move = function () {
    var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    if (dir) {
      HAXStore.activeHaxBody.haxMoveGridPlate("up", HAXStore.activeNode);
    } else {
      HAXStore.activeHaxBody.haxMoveGridPlate("down", HAXStore.activeNode);
    }
  };

  window.Hax.grid = function () {
    var op = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    HAXStore.activeHaxBody.haxGridPlateOps(op);
  };

  window.Hax.set = function (key, value) {
    HAXStore.write(key, value, window);
  };

  window.Hax.get = function (key) {
    return HAXStore[key];
  };

  window.Hax.export = /*#__PURE__*/babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
    return regeneratorRuntime.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            _context15.next = 2;
            return HAXStore.activeHaxBody.haxToContent();

          case 2:
            return _context15.abrupt("return", _context15.sent);

          case 3:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15);
  }));

  window.Hax.import = function () {
    var htmlContent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "<p></p>";
    return HAXStore.activeHaxBody.importContent(htmlContent);
  };
});