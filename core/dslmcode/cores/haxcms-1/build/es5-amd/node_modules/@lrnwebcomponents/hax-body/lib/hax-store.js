define(["exports", "meta", "require", "../../../lit-element/lit-element.js", "../../utils/utils.js", "../../hax-body-behaviors/hax-body-behaviors.js", "../../../undoer/undoer.js"], function (_exports, meta, _require, _litElement, _utils, _haxBodyBehaviors, _undoer) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.UndoerElement = _exports.HaxStore = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject2_65e122a07db411ea9f5415731a698a31() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: none;\n        }\n      "]);

    _templateObject2_65e122a07db411ea9f5415731a698a31 = function _templateObject2_65e122a07db411ea9f5415731a698a31() {
      return data;
    };

    return data;
  }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject_65e122a07db411ea9f5415731a698a31() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <slot></slot>\n      <undoer-element></undoer-element>\n      <iron-ajax\n        id=\"appstore\"\n        url=\"", "\"\n        .params=\"", "\"\n        method=\"GET\"\n        content-type=\"application/json\"\n        handle-as=\"json\"\n        @last-response-changed=\"", "\"\n      ></iron-ajax>\n      <hal-9000\n        id=\"hal\"\n        .responds-to=\"", "\"\n        .debug=\"", "\"\n      ></hal-9000>\n    "]);

    _templateObject_65e122a07db411ea9f5415731a698a31 = function _templateObject_65e122a07db411ea9f5415731a698a31() {
      return data;
    };

    return data;
  }

  /**
   * @element hax-store
   */
  var HaxStore =
  /*#__PURE__*/
  function (_winEventsElement) {
    babelHelpers.inherits(HaxStore, _winEventsElement);
    babelHelpers.createClass(HaxStore, [{
      key: "render",

      /**
       * LitElement render
       */
      value: function render() {
        return (0, _litElement.html)(_templateObject_65e122a07db411ea9f5415731a698a31(), this.appStore.url, this.appStore.params, this.__appStoreDataChanged, this.voiceRespondsTo, this.voiceDebug);
      }
    }, {
      key: "__appStoreDataChanged",
      value: function __appStoreDataChanged(e) {
        this.__appStoreData = e.detail.value;
      }
      /**
       * convention
       */

    }, {
      key: "_storageDataChanged",

      /**
       * Local storage data changed; callback to store this data in user storage
       */
      value: function _storageDataChanged(newValue) {
        if (newValue && window.HaxStore.ready && this.__storageDataProcessed) {
          if (window.localStorage.getItem("haxConfirm")) {
            window.localStorage.setItem("haxUserData", JSON.stringify(newValue));
          } else if (window.sessionStorage.getItem("haxConfirm")) {
            window.sessionStorage.setItem("haxUserData", JSON.stringify(newValue));
          }
        }
      }
      /**
       * If this is a text node or not so we know if the inline context
       * operations are valid.
       */

    }, {
      key: "isTextElement",
      value: function isTextElement(node) {
        var tag; // resolve HAXelements vs nodes

        if (node != null && node.tagName) {
          tag = node.tagName.toLowerCase();
        } else if (node != null && node.tag) {
          tag = node.tag.toLowerCase();
        }

        if (tag && this.validTagList.includes(tag)) {
          if (["p", "ol", "ul", "li", "a", "h1", "h2", "h3", "h4", "h5", "h6", "strike", "u", "b", "sub", "sup", "span", "i", "bold", "em", "strong", "blockquote", "code", "figure"].includes(tag)) {
            return true;
          }
        }

        return false;
      }
      /**
       * test for being a valid grid plate, li is here because
       * nested lists make this really complicated
       */

    }, {
      key: "isGridPlateElement",
      value: function isGridPlateElement(node) {
        var tag; // resolve HAXelements vs nodes

        if (node && node.tagName) {
          tag = node.tagName.toLowerCase();
        } else if (node && node.tag) {
          tag = node.tag.toLowerCase();
        }

        if (tag && this.validTagList.includes(tag)) {
          if (["p", "ol", "ul", "li", "div", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "code", "figure", "grid-plate"].includes(tag)) {
            return true;
          }
        }

        return false;
      }
      /**
       * Notice _appStore changed.
       */

    }, {
      key: "_appStoreChanged",
      value: function _appStoreChanged(newValue, oldValue) {
        // if we have an endpoint defined, pull it
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue != null && babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // support having the request or remote loading
          // depending on the integration type
          if (babelHelpers.typeof(newValue.apps) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && this.shadowRoot && this.shadowRoot.querySelector("#appstore") && this.shadowRoot.querySelector("#appstore").generateRequest) {
            this.shadowRoot.querySelector("#appstore").generateRequest();
          } else {
            // directly injected json object into the DOM
            this.__appStoreData = newValue;
          }
        }
      }
      /**
       * Load and attach items from the app store.
       */

    }, {
      key: "_loadAppStoreData",
      value: function _loadAppStoreData(ready, appDataResponse, haxAutoloader) {
        if (ready && babelHelpers.typeof(appDataResponse) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && appDataResponse != null) {
          var items = {}; // autoload elements

          if (babelHelpers.typeof(appDataResponse.autoloader) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            // ensure the list is in the right order so we can async dynamic imports
            // regardless of if its an array or object of values in the right format
            // force this to be an object
            appDataResponse.autoloader = Object.assign({}, appDataResponse.autoloader);

            for (var i in appDataResponse.autoloader) {
              var CEname = i;
              var CEimport = appDataResponse.autoloader[i]; // helps support array or object based app store spec
              // array was originally in the standard so this lets us support both

              if (!isNaN(CEname)) {
                CEname = appDataResponse.autoloader[i];
                CEimport = "@lrnwebcomponents/".concat(CEname, "/").concat(CEname, ".js");
              } // force this into the valid tag list so early paints will
              // correctly include the tag without filtering it out incorrectly


              this.validTagList.push(CEname);
              items[CEname] = CEimport;
            }
          } // load apps automatically


          if (babelHelpers.typeof(appDataResponse.apps) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var apps = appDataResponse.apps;

            for (var i = 0; i < apps.length; i++) {
              var app = document.createElement("hax-app");
              app.data = apps[i];
              window.HaxStore.instance.appendChild(app);
            }
          } // load in stax dynamically


          if (babelHelpers.typeof(appDataResponse.stax) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var staxs = appDataResponse.stax;

            for (var i = 0; i < staxs.length; i++) {
              var stax = document.createElement("hax-stax");
              stax.data = staxs[i];
              window.HaxStore.instance.appendChild(stax);
            }
          } // load in blox dynamically


          if (babelHelpers.typeof(appDataResponse.blox) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var bloxs = appDataResponse.blox;

            for (var i = 0; i < bloxs.length; i++) {
              var blox = document.createElement("hax-blox");
              blox.data = bloxs[i];
              window.HaxStore.instance.appendChild(blox);
            }
          }

          this.dispatchEvent(new CustomEvent("hax-store-app-store-loaded", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: true
          })); // now process the dynamic imports

          this._handleDynamicImports(items, haxAutoloader);
        }
      } // simple path from a url modifier

    }, {
      key: "pathFromUrl",
      value: function pathFromUrl(url) {
        return url.substring(0, url.lastIndexOf("/") + 1);
      }
      /**
       * Handle all the dynamic imports of things told to autoload
       * This ensures we get the definitions very quickly as far as
       * what is a safe / valid tag above but then we import in a way
       * that allows us to correctly associate the hax schema to where
       * it came from.
       */

    }, {
      key: "_handleDynamicImports",
      value: function () {
        var _handleDynamicImports2 = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(items, haxAutoloader) {
          var _this2 = this;

          var basePath, i, CEClass;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  basePath = this.pathFromUrl(decodeURIComponent(meta.url));
                  _context.t0 = regeneratorRuntime.keys(items);

                case 2:
                  if ((_context.t1 = _context.t0()).done) {
                    _context.next = 13;
                    break;
                  }

                  i = _context.t1.value;

                  if (window.customElements.get(i)) {
                    _context.next = 9;
                    break;
                  }

                  _context.next = 7;
                  return new Promise(function (res, rej) {
                    return _require.default(["".concat(basePath, "../../../").concat(items[i])], res, rej);
                  }).then(function (response) {
                    var hasClass = false;

                    for (var cVal in response) {
                      // get the custom element definition we used to add that file
                      var CEClass = response[cVal];

                      if (typeof CEClass.getHaxProperties === "function") {
                        _this2.setHaxProperties(CEClass.getHaxProperties(), i);

                        hasClass = true;
                      } else if (typeof CEClass.HAXWiring === "function") {
                        _this2.setHaxProperties(CEClass.HAXWiring.getHaxProperties(), i);

                        hasClass = true;
                      } else if (CEClass.haxProperties) {
                        _this2.setHaxProperties(CEClass.haxProperties, i);

                        hasClass = true;
                      }
                    } // fallback for things that don't export a class


                    if (!hasClass && window.customElements.get(i) && window.customElements.get(i).haxProperties) {
                      _this2.setHaxProperties(window.customElements.get(i).haxProperties, i);
                    }
                  }).catch(function (error) {
                    /* Error handling */
                    console.warn(error);
                  });

                case 7:
                  _context.next = 11;
                  break;

                case 9:
                  // get the custom element definition we used to add that file
                  CEClass = window.customElements.get(i);

                  if (typeof CEClass.getHaxProperties === "function") {
                    this.setHaxProperties(CEClass.getHaxProperties(), i);
                  } else if (typeof CEClass.HAXWiring === "function") {
                    this.setHaxProperties(CEClass.HAXWiring.getHaxProperties(), i);
                  } else if (CEClass.haxProperties) {
                    this.setHaxProperties(CEClass.haxProperties, i);
                  } else {
                    // this is the less optimized / legacy polymer element method to inlcude
                    // this item. It's a good reason to skip on this though because you'll
                    // have a faster boot up time with newer ES6 methods then previous ones.
                    haxAutoloader.appendChild(document.createElement(i));
                  }

                case 11:
                  _context.next = 2;
                  break;

                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function _handleDynamicImports(_x, _x2) {
          return _handleDynamicImports2.apply(this, arguments);
        }

        return _handleDynamicImports;
      }()
    }, {
      key: "_editModeChanged",
      value: function _editModeChanged(newValue) {
        if (newValue && this.globalPreferences.haxVoiceCommands) {
          this.__hal.auto = true;
        } else {
          this.__hal.auto = false;
        }
      }
    }, {
      key: "_globalPreferencesChanged",
      value: function _globalPreferencesChanged(newValue, oldValue) {
        // regardless of what it is, reflect it globally but only after setup
        if (this.__storageDataProcessed && newValue && babelHelpers.typeof(newValue.haxVoiceCommands) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && window.HaxStore.ready) {
          var storageData = this.storageData;
          storageData.globalPreferences = newValue;
          this.storageData = storageData;

          this._storageDataChanged(this.storageData);

          if (newValue.haxVoiceCommands && this.editMode) {
            this.__hal.auto = true;
          } else {
            this.__hal.auto = false;
          }
        }
      }
      /**
       * A handful of context operations need to bubble up to the top
       * because we don't know where they originate from
       */

    }, {
      key: "_haxContextOperation",
      value: function _haxContextOperation(e) {
        var _this3 = this;

        var detail = e.detail;

        if (this.activeNode) {
          var changed = false; // support a simple insert event to bubble up or everything else

          switch (detail.eventName) {
            // directional / proportion operations
            case "hax-align-left":
              this.activeNode.style.float = null;
              this.activeNode.style.margin = null;
              this.activeNode.style.display = null;
              changed = true;
              break;

            case "hax-align-center":
              this.activeNode.style.float = null;
              this.activeNode.style.margin = "0 auto";
              this.activeNode.style.display = "block";
              changed = true;
              break;

            case "hax-align-right":
              this.activeNode.style.float = "right";
              this.activeNode.style.margin = "0 auto";
              this.activeNode.style.display = "block";
              changed = true;
              break;

            case "hax-size-change":
              if (detail.value == 100) {
                this.activeNode.style.width = null;
              } else {
                this.activeNode.style.width = detail.value + "%";
              }

              changed = true;
              break;
          }

          if (changed) {
            setTimeout(function () {
              _this3.activeHaxBody.positionContextMenus();
            }, 0);
          }
        }
      }
      /**
       * This only send if they consented to storage of data locally
       */

    }, {
      key: "_haxConsentTap",
      value: function _haxConsentTap(e) {
        // store for future local storage usage
        window.localStorage.setItem("haxConfirm", true); // most likely nothing but set it anyway

        window.localStorage.setItem("haxUserData", JSON.stringify(this.storageData));
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this4 = this;

        var loadAppStoreData = false;
        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "openDrawer") {
            _this4.openDrawersCallback(_this4[propName], oldValue);
          }

          if (propName == "appStore") {
            _this4._appStoreChanged(_this4[propName], oldValue);
          }

          if (propName == "globalPreferences") {
            _this4._globalPreferencesChanged(_this4[propName], oldValue);
          }

          if (propName == "editMode") {
            _this4._editModeChanged(_this4[propName], oldValue);
          }

          if (propName == "activeNode") {
            _this4.activeGizmo = _this4._calculateActiveGizmo(_this4[propName]);
            window.HaxStore.write("activeGizmo", _this4.activeGizmo, _this4);
          } // composite obervation


          if (["__ready", "__appStoreData", "haxAutoloader"].includes(propName)) {
            loadAppStoreData = true;
          }

          if (["haxAutoloader", "activeHaxBody", "haxToast", "haxExport", "haxPreferences", "haxAppPicker", "haxTray"].includes(propName)) {
            // allow this to verify if everything is here or not
            _this4._storePiecesAllHere(_this4.haxAutoloader, _this4.activeHaxBody, _this4.haxToast, _this4.haxExport, _this4.haxPreferences, _this4.haxAppPicker, _this4.haxTray);
          }
        });

        if (loadAppStoreData) {
          this._loadAppStoreData(this.__ready, this.__appStoreData, this.haxAutoloader);
        }
      }
    }, {
      key: "_calculateActiveGizmo",
      value: function _calculateActiveGizmo(activeNode) {
        if (activeNode == null) {
          return null;
        }

        for (var gizmoposition in this.gizmoList) {
          var gizmo = this.gizmoList[gizmoposition];

          if (gizmo.tag === activeNode.tagName.toLowerCase()) {
            return gizmo;
          }
        }
      }
      /**
       * ready life cycle
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        var _this5 = this;

        new Promise(function (res, rej) {
          return _require.default(["../../../@polymer/iron-ajax/iron-ajax.js"], res, rej);
        }).then(function (esModule) {
          if (_this5.shadowRoot.querySelector("#appstore")) {
            _this5.shadowRoot.querySelector("#appstore").generateRequest();
          }
        }); // import voice command stuff in the background
        // @todo only activate if the setting to use it is in place

        new Promise(function (res, rej) {
          return _require.default(["../../hal-9000/hal-9000.js"], res, rej);
        }).then(function (esModule) {
          _this5.__hal = _this5.shadowRoot.querySelector("#hal");
        }); // set this global flag so we know it's safe to start trusting data
        // that is written to global preferences / storage bin

        setTimeout(function () {
          _this5.__storageDataProcessed = true;

          if (_this5.storageData.globalPreferences) {
            window.HaxStore.write("globalPreferences", _this5.storageData.globalPreferences, _this5);
          }
        }, 100); // see if a global was used to prevent this check
        // this is useful when in trusted environments where the statement
        // has been consented to in the application this is utilized in

        if (this.skipHAXConfirmation) {
          window.sessionStorage.setItem("haxConfirm", true);
          window.localStorage.setItem("haxConfirm", true);
        } // check for local storage object
        // if not, then store it in sessionStorage so that all our checks
        // and balances are the same. This could allow for storing these
        // settings on a server in theory


        var haxConfirm = window.sessionStorage.getItem("haxConfirm") || window.localStorage.getItem("haxConfirm");

        if (!haxConfirm) {
          // this way it isn't shown EVERY reload, but if they didn't confirm
          // it will show up in the future
          window.sessionStorage.setItem("haxConfirm", true);
          var msg = "\n    The HAX content editor keeps preferences in order to improve your experience.\n    This data is stored in your browser and is never sent anywhere.\n    Click to accept.\n    ";
          window.HaxStore.toast(msg, "-1", "fit-bottom", "I Accept", "hax-consent-tap");
        } else {
          if (window.sessionStorage.getItem("haxConfirm") && !window.localStorage.getItem("haxConfirm")) {
            // verify there is something there
            try {
              var globalData = window.sessionStorage.getItem("haxUserData") ? JSON.parse(window.sessionStorage.getItem("haxUserData")) : {};
              this.storageData = globalData;

              this._storageDataChanged(this.storageData);
            } catch (e) {}
          } else {
            try {
              var _globalData = window.localStorage.getItem("haxUserData") ? JSON.parse(window.localStorage.getItem("haxUserData")) : {};

              this.storageData = _globalData;

              this._storageDataChanged(this.storageData);
            } catch (e) {}
          }
        }
      }
    }, {
      key: "_storePiecesAllHere",
      value: function _storePiecesAllHere(haxAutoloader, activeHaxBody, haxToast, haxExport, haxPreferences, haxAppPicker, haxTray) {
        if (!this.__ready && activeHaxBody && haxAutoloader && haxToast && haxExport && haxPreferences && haxAppPicker && haxTray) {
          // send that hax store is ready to go so now we can setup the rest
          this.dispatchEvent(new CustomEvent("hax-store-ready", {
            bubbles: true,
            cancelable: false,
            composed: true,
            detail: true
          }));
          window.HaxStore.ready = true;
          this.__ready = true; // register built in primitive definitions

          this._buildPrimitiveDefinitions(); // initialize voice commands


          this._initVoiceCommands();

          this.__hal.commands = _objectSpread({}, this.voiceCommands);
        }
      }
      /**
       * Build a list of common voice commands
       */

    }, {
      key: "_initVoiceCommands",
      value: function _initVoiceCommands() {
        var _this6 = this;

        this.__voiceInit = true;

        this.voiceCommands["scroll up ".concat(this.voiceRespondsTo)] = function () {
          window.scrollBy({
            top: -(window.innerHeight * 0.5),
            left: 0,
            behavior: "smooth"
          });
        };

        this.voiceCommands["scroll (down) ".concat(this.voiceRespondsTo)] = function () {
          window.scrollBy({
            top: window.innerHeight * 0.5,
            left: 0,
            behavior: "smooth"
          });
        };

        this.voiceCommands["scroll to bottom ".concat(this.voiceRespondsTo)] = function () {
          window.scrollTo(0, document.body.scrollHeight);
        };

        this.voiceCommands["scroll to top ".concat(this.voiceRespondsTo)] = function () {
          window.scrollTo(0, 0);
        };
        /**
         * Support for focusing active content and typing in it
         */


        this.voiceCommands["".concat(this.voiceRespondsTo, " (show)(focus) active (element)(content)")] = function () {
          try {
            _this6._positionCursorInNode(_this6.activeNode);
          } catch (e) {}
        };

        this.voiceCommands["".concat(this.voiceRespondsTo, " (focus) previous (element)(content)")] = function () {
          if (_this6.activeNode.previousElementSibling) {
            _this6.activeNode = _this6.activeNode.previousElementSibling;
            window.HaxStore.write("activeNode", _this6.activeNode, _this6);
            _this6.activeContainerNode = _this6.activeNode;
            window.HaxStore.write("activeContainerNode", _this6.activeNode, _this6);

            _this6._positionCursorInNode(_this6.activeNode);
          } else {
            _this6.speak("You are at the top of the document");
          }
        };

        this.voiceCommands["".concat(this.voiceRespondsTo, " (focus) next (element)(content)")] = function () {
          if (_this6.activeNode.nextElementSibling) {
            _this6.activeNode = _this6.activeNode.nextElementSibling;
            window.HaxStore.write("activeNode", _this6.activeNode, _this6);
            _this6.activeContainerNode = _this6.activeNode;
            window.HaxStore.write("activeContainerNode", _this6.activeNode, _this6);

            _this6._positionCursorInNode(_this6.activeNode);
          } else {
            _this6.speak("You are at the bottom of the document");
          }
        };

        this.voiceCommands["".concat(this.voiceRespondsTo, " type *mycontent")] = function (e) {
          if (window.HaxStore.instance.isTextElement(_this6.activeNode)) {
            try {
              var range = _this6._positionCursorInNode(_this6.activeNode);

              var text = document.createTextNode(e);
              range.deleteContents();
              range.insertNode(text);
            } catch (e) {
              _this6.speak("That didn't work");

              console.warn(e);
            }
          } else {
            _this6.speak("I'm sorry but I can only type in text areas. Try saying Insert Paragraph and try again.");
          }
        }; // trolling


        this.voiceCommands["hey ".concat(this.voiceRespondsTo)] = function () {
          _this6.speak("Yeah what do you want");
        }; // trolling


        this.voiceCommands["".concat(this.voiceRespondsTo, " now your name is *splat")] = function (text) {
          var past = _this6.voiceRespondsTo;

          _this6.speak("I used to be named ".concat(past, " but you can call me ").concat(text, " now."));

          _this6.voiceRespondsTo = "(".concat(text, ")"); // @todo this needs to now update the previous commands somehow to match
          // the new activation name
        };

        this.voiceCommands["".concat(this.voiceRespondsTo, " close")] = function () {
          window.HaxStore.write("openDrawer", false, _this6);
        };
      }
      /**
       * Speak wrapper on hal to present as text too
       */

    }, {
      key: "speak",
      value: function speak(text) {
        if (this.__hal && this.__hal.speak) {
          this.__hal.speak(text);
        } // always show for accessibility


        window.HaxStore.toast("".concat(this.voiceRespondsTo, ": ").concat(text));
      }
      /**
       * allow uniform method of adding voice commands
       */

    }, {
      key: "addVoiceCommand",
      value: function addVoiceCommand(command, context, callback) {
        if (context) {
          command = command.replace(":name:", this.voiceRespondsTo).toLowerCase();
          this.voiceCommands[command] = context[callback].bind(context);

          if (this.__voiceInit) {
            this.__hal.commands = _objectSpread({}, this.voiceCommands);
          }
        }
      }
      /**
       * event driven version
       */

    }, {
      key: "_addVoiceCommand",
      value: function _addVoiceCommand(e) {
        // without context it's almost worthless so try to fallback on where it came from
        var target = e.detail.context;

        if (!target) {
          target = e.target;
        }

        this.addVoiceCommand(e.detail.command, target, e.detail.callback);
      }
      /**
       * Position cursor at the start of the position of the requested node
       */

    }, {
      key: "_positionCursorInNode",
      value: function _positionCursorInNode(node) {
        var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.activeHaxBody.positionContextMenus();
        var range = document.createRange();
        var sel = window.HaxStore.getSelection();
        range.setStart(node, position);
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
        return range;
      }
      /**
       * Before the browser closes / changes paths, ask if they are sure they want to leave
       */

    }, {
      key: "_onBeforeUnload",
      value: function _onBeforeUnload(e) {
        // ensure we don't leave DURING edit mode
        if (!window.HaxStore.instance.skipExitTrap && window.HaxStore.instance.editMode) {
          return "Are you sure you want to leave? Your work will not be saved!";
        }
      }
      /**
       * Intercept paste event and clean it up before inserting the contents
       */

    }, {
      key: "_onPaste",
      value: function _onPaste(e) {
        // only perform this on a text element that is active
        if (window.HaxStore.instance.isTextElement(window.HaxStore.instance.activeNode)) {
          var pasteContent = ""; // intercept paste event

          if (e.clipboardData || e.originalEvent.clipboardData) {
            pasteContent = (e.originalEvent || e).clipboardData.getData("text/html");
          } else if (window.clipboardData) {
            pasteContent = window.clipboardData.getData("Text");
          } // detect word garbage


          var mswTest = pasteContent.replace(/(class=(")?Mso[a-zA-Z]+(")?)/g, "");
          var wordPaste = false; // the string to import as sanitized by hax

          var newContent = "";
          mswTest = mswTest.replace("mso-style-", "");

          if (pasteContent != mswTest) {
            wordPaste = true;
          } // clear empty span tags that can pop up


          pasteContent = pasteContent.replace(/<span>\s*?<\/span>/g, " "); // clean up div tags that can come in from contenteditable pastes
          // p tags make more sense in the content area

          pasteContent = pasteContent.replace(/<div/g, "<p");
          pasteContent = pasteContent.replace(/<\/div>/g, "</p>"); // NOW we can safely handle paste from word cases

          pasteContent = (0, _utils.stripMSWord)(pasteContent); // edges that some things preserve empty white space needlessly

          var haxElements = window.HaxStore.htmlToHaxElements(pasteContent); // if interpretation as HTML fails then let's ignore this whole thing
          // as we allow normal contenteditable to handle the paste
          // we only worry about HTML structures

          if (haxElements.length === 0) {
            // wrap in a paragraph tag if there is any this ensures it correctly imports
            // as it might not have evaluated above as having elements bc of the scrubber
            if (wordPaste) {
              newContent = pasteContent;
            } else {
              return false;
            }
          } // account for incredibly basic pastes of single groups of characters
          else if (haxElements.length === 1 && haxElements[0].tag === "p") {
              return false;
            } // account for broken pastes in resolution, just let browser handle it
            else if (!this.isGridPlateElement(haxElements[0])) {
                return false;
              } else {
                for (var i in haxElements) {
                  // special traps for word / other styles bleeding through
                  delete haxElements[i].properties.style;
                  delete haxElements[i].properties.start;
                  delete haxElements[i].properties.align; // this is not the right function.

                  var node = window.HaxStore.haxElementToNode(haxElements[i].tag, haxElements[i].content.replace(/<span>&nbsp;<\/span>/g, " ").trim(), haxElements[i].properties);
                  newContent += window.HaxStore.nodeToContent(node);
                }
              } // if we got here then we have HTML structures to pull together
          // this ensures that the below works out


          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();

          try {
            // get the range that's active and selection
            var range = window.HaxStore.getRange();
            var sel = window.HaxStore.getSelection(); // tee up a wrapper so we can walk and put every element in

            var newNodes = document.createElement("div");
            newNodes.innerHTML = newContent;

            if (range && sel && typeof range.deleteContents === "function") {
              range.deleteContents();

              while (newNodes.lastChild) {
                range.insertNode(newNodes.lastChild);
              }
            }
          } catch (e) {
            console.warn(e);
          }
        }
      }
    }, {
      key: "__validTags",
      value: function __validTags() {
        return ["p", "div", "span", "table", "caption", "sup", "sub", "u", "strike", "tr", "th", "td", "ol", "ul", "li", "a", "strong", "kbd", "em", "i", "b", "hr", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "code", "figure", "img", "iframe", "video", "audio", "section", "grid-plate", "template", "webview"];
      }
    }, {
      key: "__validGizmoTypes",
      value: function __validGizmoTypes() {
        return ["data", "video", "audio", "text", "link", "file", "pdf", "image", "csv", "doc", "archive", "markdown", "html", "wikipedia", "content", "text", "inline", "*"];
      }
      /**
       * Created life-cycle to ensure a single global store.
       */

    }], [{
      key: "styles",

      /**
       * LitElement constructable styles enhancement
       */
      get: function get() {
        return [(0, _litElement.css)(_templateObject2_65e122a07db411ea9f5415731a698a31())];
      }
    }, {
      key: "tag",
      get: function get() {
        return "hax-store";
      }
      /**
       * LitElement / popular convention
       */

    }, {
      key: "properties",
      get: function get() {
        return _objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore), "properties", this), {
          openDrawer: {
            type: Object
          },
          voiceDebug: {
            type: Boolean,
            attribute: "voice-debug"
          },
          activeGizmo: {
            type: Object
          },
          voiceRespondsTo: {
            type: String,
            attribute: "voice-responses-to"
          },

          /**
           * skipHAXConfirmation
           */
          skipHAXConfirmation: {
            type: Boolean,
            reflect: true,
            attribute: "skip-hax-confirmation"
          },

          /**
           * Local storage bridge
           */
          storageData: {
            type: Object
          },

          /**
           * Hax tray
           */
          haxTray: {
            type: Object
          },

          /**
           * Hax app picker element.
           */
          haxAppPicker: {
            type: Object
          },

          /**
           * Hax stax picker element.
           */
          haxStaxPicker: {
            type: Object
          },

          /**
           * Hax stax picker element.
           */
          haxBloxPicker: {
            type: Object
          },

          /**
           * Hax autoloader element.
           */
          haxAutoloader: {
            type: Object
          },

          /**
           * A list of all haxBodies that exist
           */
          haxBodies: {
            type: Array
          },

          /**
           * An active place holder item reference. This is used
           * for inline drag and drop event detection so that we
           * know what element replace in context.
           */
          activePlaceHolder: {
            type: Object
          },

          /**
           * The hax-body that is currently active.
           */
          activeHaxBody: {
            type: Object
          },

          /**
           * Possible appStore endpoint for loading in things dynamically.
           */
          appStore: {
            type: Object
          },

          /**
           * HAX Toast message.
           */
          haxToast: {
            type: Object
          },

          /**
           * Hax export dialog element.
           */
          haxExport: {
            type: Object
          },

          /**
           * Hax preferences dialog element.
           */
          haxPreferences: {
            type: Object
          },

          /**
           * Active Node.
           */
          activeNode: {
            type: Object
          },

          /**
           * Active container Node, 2nd highest parent of activeNode.
           */
          activeContainerNode: {
            type: Object
          },

          /**
           * Session object bridged in from a session method of some kind
           */
          sessionObject: {
            type: Object
          },

          /**
           * editMode
           */
          editMode: {
            type: Boolean
          },

          /**
           * skip the exit trap to prevent losing data
           */
          skipExitTrap: {
            type: Boolean
          },

          /**
           * Available gizmos.
           */
          gizmoList: {
            type: Array
          },

          /**
           * Available elements keyed by tagName and with
           * their haxProperties centrally registered.
           */
          elementList: {
            type: Object
          },

          /**
           * Available apps of things supplying media / content.
           */
          appList: {
            type: Array
          },

          /**
           * Available hax stax which are just re-usable templates
           */
          staxList: {
            type: Array
          },

          /**
           * Available hax blox which are grid plate / layout elements
           */
          bloxList: {
            type: Array
          },

          /**
           * Global preferences that HAX can write to and
           * other elements can use to go off of.
           */
          globalPreferences: {
            type: Object
          },

          /**
           * Globally active app, used for brokering communications
           */
          activeApp: {
            type: Object
          },

          /**
           * Valid tag list, tag only and including primatives for a baseline.
           */
          validTagList: {
            type: Array
          },

          /**
           * Gizmo types which can be used to bridge apps to gizmos.
           */
          validGizmoTypes: {
            type: Array
          },

          /**
           * Sandboxed environment test
           */
          _isSandboxed: {
            type: Boolean
          },

          /**
           * Internal app store data property after request
           */
          __appStoreData: {
            type: Object
          },
          __ready: {
            type: Boolean
          },

          /**
           * Support for deploy specific rewriting for things like JWTs
           */
          connectionRewrites: {
            type: Object
          }
        });
      }
    }]);

    function HaxStore() {
      var _this;

      babelHelpers.classCallCheck(this, HaxStore);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxStore).call(this));
      _this.__winEvents = {
        "hax-register-properties": "_haxStoreRegisterProperties",
        "hax-consent-tap": "_haxConsentTap",
        "hax-context-item-selected": "_haxContextOperation",
        onbeforeunload: "_onBeforeUnload",
        paste: "_onPaste",
        "hax-register-app": "_haxStoreRegisterApp",
        "hax-register-stax": "_haxStoreRegisterStax",
        "hax-register-blox": "_haxStoreRegisterBlox",
        "hax-store-write": "_writeHaxStore",
        "hax-register-core-piece": "_haxStorePieceRegistrationManager",
        "hax-register-body": "_haxStoreRegisterBody",
        "hax-insert-content": "_haxStoreInsertContent",
        "hax-insert-content-array": "_haxStoreInsertMultiple",
        "hax-add-voice-command": "_addVoiceCommand"
      };
      _this.voiceRespondsTo = "(worker)";
      _this.voiceCommands = {};
      _this.skipHAXConfirmation = false;
      _this.storageData = {};
      _this.appStore = {
        url: "",
        params: {}
      };
      _this.activeContainerNode = null;
      _this.activeNode = null;
      _this.haxBodies = [];
      _this.activePlaceHolder = null;
      _this.sessionObject = {};
      _this.editMode = false;
      _this.skipExitTrap = false;
      _this.gizmoList = [];
      _this.elementList = {};
      _this.appList = [];
      _this.staxList = [];
      _this.bloxList = [];
      _this.globalPreferences = {};
      _this.activeApp = {};
      _this.connectionRewrites = {}; // change this in order to debug voice commands

      _this.voiceDebug = false;
      _this.validTagList = _this.__validTags();
      _this.validGizmoTypes = _this.__validGizmoTypes(); // test for sandboxed env

      var test = document.createElement("webview");
      _this._isSandboxed = typeof test.reload === "function"; // claim the instance spot. This way we can easily
      // be referenced globally

      if (window.HaxStore.instance == null) {
        window.HaxStore.instance = babelHelpers.assertThisInitialized(_this);
      } // imports app, blox, stax definitions


      new Promise(function (res, rej) {
        return _require.default(["./hax-app.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/polymer/lib/utils/settings.js"], res, rej);
      }).then(function (esModule) {
        esModule.setPassiveTouchGestures(true);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../simple-toast/simple-toast.js"], res, rej);
      }).then(function () {
        _this.haxToast = window.SimpleToast.requestAvailability();
      });
      new Promise(function (res, rej) {
        return _require.default(["../../media-behaviors/media-behaviors.js"], res, rej);
      });
      document.body.style.setProperty("--hax-ui-headings", "#d4ff77");
      return _this;
    }
    /**
     * Build HAX property definitions for primitives that we support.
     */


    babelHelpers.createClass(HaxStore, [{
      key: "_buildPrimitiveDefinitions",
      value: function _buildPrimitiveDefinitions() {
        // sandboxes need a webview definition
        // we don't want people making them but we need to
        // know how to edit them if asked
        if (window.HaxStore.instance._isSandboxed) {
          var webview = {
            canScale: true,
            canPosition: true,
            canEditSource: false,
            settings: {
              quick: [{
                attribute: "src",
                title: "Source",
                description: "The URL for this video.",
                inputMethod: "textfield",
                icon: "link",
                required: true,
                validationType: "url"
              }],
              configure: [{
                attribute: "src",
                title: "Source",
                description: "The URL for this video.",
                inputMethod: "textfield",
                icon: "link",
                required: true,
                validationType: "url"
              }],
              advanced: []
            }
          };
          this.setHaxProperties(webview, "webview");
        }

        var iframe = {
          canScale: true,
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Basic iframe",
            description: "A basic iframe",
            icon: "icons:fullscreen",
            color: "blue-grey",
            groups: ["Content"],
            handles: [{
              type: "link",
              source: "src",
              height: "height",
              width: "width"
            }],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            quick: [{
              attribute: "src",
              title: "Source",
              description: "The URL for this video.",
              inputMethod: "textfield",
              icon: "link",
              required: true,
              validationType: "url"
            }],
            configure: [{
              attribute: "src",
              title: "Source",
              description: "The URL for this video.",
              inputMethod: "textfield",
              icon: "link",
              required: true,
              validationType: "url"
            }],
            advanced: [{
              attribute: "loading",
              title: "Loading method",
              description: "Whether or not to lazy load this",
              inputMethod: "select",
              options: {
                lazy: "Load when visible",
                auto: "Automatic"
              }
            }]
          }
        };
        this.setHaxProperties(iframe, "iframe");
        var img = {
          canScale: {
            min: 10,
            step: 5
          },
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Image",
            description: "A basic img tag",
            icon: "image:image",
            color: "blue-grey",
            groups: ["Image", "Media"],
            handles: [{
              type: "link",
              source: "src"
            }, {
              type: "image",
              type_exclusive: true,
              source: "src",
              height: "height",
              width: "width"
            }],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            quick: [{
              attribute: "alt",
              title: "Alt text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "alt",
              icon: "accessibility"
            }, {
              attribute: "height",
              title: "Height",
              description: "height in pixels of the item. Leave blank to respond to the natural resolution",
              inputMethod: "textfield",
              icon: "icons:swap-vert"
            }],
            configure: [{
              attribute: "src",
              title: "Source",
              description: "The URL for this video.",
              inputMethod: "haxupload",
              icon: "link",
              required: true,
              validationType: "url"
            }, {
              attribute: "alt",
              title: "Alt text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "alt",
              icon: "accessibility"
            }, {
              attribute: "height",
              title: "Height",
              description: "height in pixels of the item. Leave blank to respond to the natural resolution",
              inputMethod: "textfield",
              icon: "icons:swap-vert"
            }],
            advanced: [{
              attribute: "loading",
              title: "Loading method",
              description: "Whether or not to lazy load this",
              inputMethod: "select",
              options: {
                lazy: "Load when visible",
                auto: "Automatic"
              }
            }]
          }
        };
        this.setHaxProperties(img, "img");
        var ahref = {
          canScale: false,
          canPosition: false,
          canEditSource: true,
          gizmo: {
            title: "Basic link",
            description: "A basic a tag",
            icon: "icons:link",
            color: "blue-grey",
            groups: ["Link"],
            handles: [],
            meta: {
              author: "W3C",
              hidden: true
            }
          },
          settings: {
            quick: [{
              attribute: "href",
              title: "Link",
              description: "The URL for this video.",
              inputMethod: "textfield",
              icon: "icons:link",
              required: true,
              validationType: "url"
            }, {
              attribute: "title",
              title: "Title text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "textfield",
              icon: "icons:accessibility"
            }],
            configure: [{
              attribute: "innerText",
              title: "Text",
              description: "Text of the link",
              inputMethod: "textfield",
              required: true
            }, {
              attribute: "href",
              title: "Link",
              description: "The URL for this video.",
              inputMethod: "haxupload",
              icon: "icons:link",
              required: true,
              validationType: "url"
            }, {
              attribute: "title",
              title: "Title text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "textfield",
              icon: "icons:accessibility"
            }, {
              attribute: "target",
              title: "Target",
              description: "Where to place the link.",
              inputMethod: "select",
              icon: "icons:launch",
              options: {
                "": "Same window",
                _blank: "New window",
                _top: "Top window",
                _parent: "Parent window"
              }
            }],
            advanced: []
          }
        }; // anything can be presented as a link

        this.validGizmoTypes.forEach(function (val) {
          ahref.gizmo.handles.push({
            type: val,
            source: "href",
            title: "innerText",
            alt: "title"
          });
        });
        this.setHaxProperties(ahref, "a");
        var p = {
          canScale: false,
          canPosition: false,
          canEditSource: true,
          gizmo: {
            title: "Paragraph",
            description: "A basic text area",
            icon: "hax:paragraph",
            color: "blue-grey",
            groups: ["Text"],
            handles: [{
              type: "content",
              content: ""
            }],
            meta: {
              author: "W3C",
              hidden: true
            }
          },
          settings: {
            quick: [],
            configure: [],
            advanced: []
          }
        };
        this.setHaxProperties(p, "p");
        var table = {
          canScale: true,
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Table",
            description: "A table for displaying data",
            icon: "image:grid-on",
            color: "blue-grey",
            groups: ["Text"],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            quick: [],
            configure: [{
              slot: "",
              title: "Body",
              description: "Tags that make up the table",
              inputMethod: "code-editor",
              slotWrapper: ""
            }],
            advanced: []
          }
        };
        this.setHaxProperties(table, "table");
        var prims = {
          caption: {
            title: "Caption",
            icon: "av:call-to-action"
          },
          video: {
            title: "Video",
            icon: "av:play-circle-filled"
          },
          audio: {
            title: "Audio",
            icon: "image:music-note"
          },
          section: {
            title: "Section",
            icon: "image:crop-landscape"
          },
          ol: {
            title: "Numbered list",
            icon: "editor:format-list-numbered"
          },
          ul: {
            title: "Bulleted list",
            icon: "editor:format-list-bulleted"
          },
          li: {
            title: "List item",
            icon: "editor:format-list-bulleted"
          },
          h1: {
            title: "Heading",
            icon: "hax:h1"
          },
          h2: {
            title: "Heading",
            icon: "hax:h2"
          },
          h3: {
            title: "Heading",
            icon: "hax:h3"
          },
          h4: {
            title: "Heading",
            icon: "hax:h4"
          },
          h5: {
            title: "Heading",
            icon: "hax:h5"
          },
          h6: {
            title: "Heading",
            icon: "hax:h6"
          },
          strike: {
            title: "Cross out",
            icon: "editor:format-strikethrough"
          },
          u: {
            title: "Underline",
            icon: "editor:format-underlined"
          },
          sub: {
            title: "Subscript",
            icon: "mdextra:subscript"
          },
          sup: {
            title: "Superscript",
            icon: "mdextra:superscript"
          },
          div: {
            title: "DIV",
            icon: "image:crop-landscape"
          },
          span: {
            title: "SPAN",
            icon: "editor:short-text"
          },
          i: {
            title: "Italic",
            icon: "editor:format-italic"
          },
          em: {
            title: "Emphasis",
            icon: "editor:format-italic"
          },
          strong: {
            title: "Bold",
            icon: "editor:format-bold"
          },
          b: {
            title: "Bold",
            icon: "editor:format-bold"
          },
          blockquote: {
            title: "Block quote",
            icon: "editor:format-quote"
          },
          code: {
            title: "Code",
            icon: "icons:code"
          },
          figure: {
            title: "Figure",
            icon: "icons:label-outline"
          },
          embed: {
            title: "Embedded object",
            icon: "icons:fullscreen"
          }
        };

        for (var tag in prims) {
          this.setHaxProperties({
            canScale: false,
            canPosition: false,
            canEditSource: true,
            gizmo: {
              title: prims[tag].title,
              icon: prims[tag].icon,
              meta: {
                hidden: true
              }
            },
            settings: {
              quick: [],
              configure: [],
              advanced: []
            }
          }, tag);
        }

        var hr = {
          canScale: {
            min: 25,
            step: 25
          },
          gizmo: {
            title: "Horizontal line",
            icon: "hax:hr",
            meta: {
              hidden: true
            }
          },
          canPosition: false,
          canEditSource: false,
          settings: {
            quick: [],
            configure: [],
            advanced: []
          }
        };
        this.setHaxProperties(hr, "hr");
      }
      /**
       * A standard event for registering the different pieces of HAX that check in
       * at run time. This allows for additional flexibility down the road as well as
       * registering pieces we never thought of for custom environments.
       *
       * @param {CustomEvent} e an event that has the piece to register and the object
       */

    }, {
      key: "_haxStorePieceRegistrationManager",
      value: function _haxStorePieceRegistrationManager(e) {
        if (e.detail && e.detail.piece && e.detail.object) {
          this[e.detail.piece] = e.detail.object;
        }
      }
      /**
       * Close all drawers
       */

    }, {
      key: "openDrawersCallback",
      value: function openDrawersCallback() {
        var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var oldValue = arguments.length > 1 ? arguments[1] : undefined;
        // walk all drawers, close everything
        // except active. This also will allow them
        // to close everything then.
        var drawers = ["haxAppPicker", "haxPreferences", "haxExport"];

        for (var i in drawers) {
          if (active === this[drawers[i]]) {
            active.open();
            setTimeout(function () {
              if (active.querySelector("simple-fields-field,textarea,paper-button,hax-tray-button") != null) {
                active.querySelector("simple-fields-field,textarea,paper-button,hax-tray-button").focus();
              }

              var evt = document.createEvent("UIEvents");
              evt.initUIEvent("resize", true, false, window, 0);
              window.dispatchEvent(evt);
            }, 325);
          } else {
            this[drawers[i]].close();
          }
        }
      }
      /**
       * Insert content in the body.
       */

    }, {
      key: "_haxStoreInsertContent",
      value: function _haxStoreInsertContent(e) {
        var _this7 = this;

        if (e.detail) {
          var details = e.detail;

          if (window.customElements.get(details.tag)) {
            var prototype = Object.getPrototypeOf(document.createElement(details.tag)); // support for deep API call to clean up special elements

            if (babelHelpers.typeof(prototype.preProcessHaxInsertContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              details = prototype.preProcessHaxInsertContent(details);
            }
          }

          var properties = {}; // support for properties to be set automatically optionally

          if (babelHelpers.typeof(details.properties) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            properties = details.properties;
          } // support / clean up properties / attributes that have innerHTML / innerText
          // these are reserved words but required for certain bindings


          if (properties.innerHTML) {
            if (details.content == "") {
              details.content = properties.innerHTML;
            }

            delete properties.innerHTML;
          }

          if (properties.innerText) {
            if (details.content == "") {
              details.content = properties.innerText;
            }

            delete properties.innerText;
          } // ensure better UX for text based operations


          this.activeHaxBody.__activeHover = null; // invoke insert or replacement on body, same function so it's easier to trace

          if (details.replace && details.replacement) {
            var node = window.HaxStore.haxElementToNode(details.tag, details.content, properties);

            if (this.activePlaceHolder) {
              this.activeHaxBody.haxReplaceNode(this.activePlaceHolder, node);
              this.activePlaceHolder = null;
            } else {
              this.activeHaxBody.haxReplaceNode(this.activeNode, node);
            }
          } else if (babelHelpers.typeof(details.__type) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && details.__type === "inline") {
            var _node = window.HaxStore.haxElementToNode(details.tag, details.content, properties); // replace what WAS the active selection w/ this new node


            if (this.activePlaceHolder !== null) {
              this.activePlaceHolder.deleteContents();
              this.activePlaceHolder.insertNode(_node);
            } // set it to nothing


            this.activePlaceHolder = null;
          } else if (this.activeContainerNode != null) {
            var _node2 = window.HaxStore.haxElementToNode(details.tag, details.content, properties); // allow for inserting things into things but not grid plate


            if (this.activeContainerNode && this.activeContainerNode.tagName === "GRID-PLATE") {
              // support slot if we have one on the activeNode (most likely)
              if (this.activeNode.getAttribute("slot") != null) {
                _node2.setAttribute("slot", this.activeNode.getAttribute("slot"));
              }

              this.activeHaxBody.haxInsert(details.tag, details.content, properties, false);
              this.activeHaxBody.shadowRoot.querySelector("#textcontextmenu").highlightOps = false;
            } else {
              this.activeHaxBody.haxInsert(details.tag, details.content, properties, false);
            }
          } else {
            this.activeHaxBody.haxInsert(details.tag, details.content, properties, false);
          } // shift the last used thing to the front of the array
          // that way the list is actually sorted based on usage
          // delay though in the event other things depend on the array
          // as it currently exists


          setTimeout(function () {
            var gizmoList = _this7.gizmoList;

            for (var gizmoposition in gizmoList) {
              var gizmo = gizmoList[gizmoposition]; // find the tag and then move this position to the front of the array

              if (gizmo.tag === details.tag) {
                var tmp = gizmoList[gizmoposition];
                delete gizmoList[gizmoposition];

                _this7.gizmoList.unshift(tmp);
              }
            } // spread for accurate data usage locally, then write store globally


            _this7.gizmoList = babelHelpers.toConsumableArray(gizmoList);
            window.HaxStore.write("gizmoList", gizmoList, _this7);
          }, 10);
        }
      }
      /**
       * Optional send array, to improve performance and event bubbling better
       */

    }, {
      key: "_haxStoreInsertMultiple",
      value: function _haxStoreInsertMultiple(e) {
        if (e.detail) {
          var properties;

          for (var i in e.detail) {
            properties = {}; // support for properties to be set automatically optionally

            if (babelHelpers.typeof(e.detail[i].properties) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              properties = e.detail[i].properties;
            }

            this.activeHaxBody.haxInsert(e.detail[i].tag, e.detail[i].content, properties, false);
          }
        }
      }
      /**
       * Set the activeHaxBody and add to the list so we know what to insert into.
       */

    }, {
      key: "_haxStoreRegisterBody",
      value: function _haxStoreRegisterBody(e) {
        if (e.detail) {
          this.haxBodies.push(e.detail); // default active the whatever is last here

          this.activeHaxBody = e.detail; // needed so that higher order things can respond to us having a body

          window.HaxStore.write("activeHaxBody", this.activeHaxBody, this);
          window.HaxStore.write("editMode", this.editMode, this);
        }
      }
      /**
       * Feature detect on the bar.
       */

    }, {
      key: "computePolyfillSafe",
      value: function computePolyfillSafe() {
        /**
         * These are our bad actors in polyfill'ed browsers.
         * This means that https://github.com/webcomponents/webcomponentsjs/commit/ce464bb533bf39b544c312906499a6044ee0d30d
         * explains things but basically if shadow-dom is polyfilled
         * then we can't safely execute a DOM manipulating execCommand.
         * This
         */
        if (document.head.createShadowRoot || document.head.attachShadow) {
          return true;
        } else {
          console.warn("Shadow DOM missing, certain operations hidden");
          return false;
        }
      }
      /**
       * Write store event callback.
       */

    }, {
      key: "_writeHaxStore",
      value: function _writeHaxStore(e) {
        // ensure we have a valid store write
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property && e.detail.owner) {
          if (e.detail.value == null) {
            this[e.detail.property] = null;
          } else if (babelHelpers.typeof(e.detail.value) === "object") {
            this[e.detail.property] = {};
          }

          this[e.detail.property] = e.detail.value;
          this.dispatchEvent(new CustomEvent("hax-store-property-updated", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: {
              property: e.detail.property,
              value: e.detail.value,
              owner: e.detail.owner
            }
          }));
        }
      }
      /**
       * Notice that an app was set in HAX; register it
       */

    }, {
      key: "_haxStoreRegisterApp",
      value: function _haxStoreRegisterApp(e) {
        if (e.detail) {
          e.detail.index = this.appList.length;
          this.appList = [].concat(babelHelpers.toConsumableArray(this.appList), [e.detail]);
          window.HaxStore.write("appList", this.appList, this); // preconnect apps at registration time

          if (e.detail.connection && e.detail.connection.protocol && e.detail.connection.url) {
            var preconnectlink = document.createElement("link");
            preconnectlink.rel = "preconnect";
            preconnectlink.href = e.detail.connection.protocol + "://" + e.detail.connection.url;
            document.head.appendChild(preconnectlink);
          } // we don't care about this after it's launched


          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-STORE") {
            e.target.parentElement.removeChild(e.target);
          }
        }
      }
      /**
       * Notice that a stax was set in HAX; register it
       */

    }, {
      key: "_haxStoreRegisterStax",
      value: function _haxStoreRegisterStax(e) {
        if (e.detail) {
          e.detail.index = this.staxList.length;
          this.staxList = [].concat(babelHelpers.toConsumableArray(this.staxList), [e.detail]);
          window.HaxStore.write("staxList", this.staxList, this); // we don't care about this after it's launched

          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-STORE") {
            e.target.parentElement.removeChild(e.target);
          }
        }
      }
      /**
       * Notice that a blox was set in HAX; register it
       */

    }, {
      key: "_haxStoreRegisterBlox",
      value: function _haxStoreRegisterBlox(e) {
        if (e.detail) {
          e.detail.index = this.bloxList.length;
          this.bloxList = [].concat(babelHelpers.toConsumableArray(this.bloxList), [e.detail]);
          window.HaxStore.write("bloxList", this.bloxList, this); // we don't care about this after it's launched

          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-STORE") {
            e.target.parentElement.removeChild(e.target);
          }
        }
      }
      /**
       * Notice that a property off an element was set in HAX some place; register it here
       */

    }, {
      key: "_haxStoreRegisterProperties",
      value: function _haxStoreRegisterProperties(e) {
        if (e.detail && e.detail.properties && e.detail.tag) {
          // only register tag if we don't know about it already
          if (babelHelpers.typeof(this.elementList[e.detail.tag]) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            // look for a gizmo; it's not required, technically.
            var gizmo = e.detail.properties.gizmo;

            if (gizmo) {
              gizmo.tag = e.detail.tag;
              var gizmos = this.gizmoList;
              gizmos.push(gizmo);
              window.HaxStore.write("gizmoList", gizmos, this);
            }

            this.elementList[e.detail.tag] = e.detail.properties; // only push new values on if we got something new

            if (!this.validTagList.find(function (element) {
              return element === e.detail.tag;
            })) {
              this.validTagList.push(e.detail.tag);
            }
          } // delete this tag if it was in the autoloader as it has served it's purpose.


          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-AUTOLOADER") {
            this.haxAutoloader.removeChild(e.target);
          }
        }
      }
    }]);
    return HaxStore;
  }((0, _utils.winEventsElement)((0, _haxBodyBehaviors.HAXElement)(_litElement.LitElement)));

  _exports.HaxStore = HaxStore;
  window.customElements.define(HaxStore.tag, HaxStore);
  /**
   * Trick to write the store to the DOM if it wasn't there already.
   * This is not used yet but could be if you wanted to dynamically
   * load the store based on something else calling for it. Like
   * store lazy loading but it isn't tested.
   */

  window.HaxStore = window.HaxStore || {};
  window.HaxStore.instance = null;

  window.HaxStore.requestAvailability = function () {
    if (!window.HaxStore.instance) {
      window.HaxStore.instance = document.createElement("hax-store");
      document.body.appendChild(window.HaxStore.instance);
    }

    return window.HaxStore.instance;
  };
  /**
   * Simple Array smashing function to ensure Object is array.
   */


  window.HaxStore.toArray = function (obj) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    });
  };
  /**
   * Helper to convert camel case to dash; important when setting attributes.
   */


  window.HaxStore.camelToDash = function (str) {
    return str.replace(/\W+/g, "-").replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
  };
  /**
   * Helper to convert dash to camel; important when reading attributes.
   */


  window.HaxStore.dashToCamel = function (str) {
    return str.replace(/-([a-z])/g, function (g) {
      return g[1].toUpperCase();
    });
  };
  /**
   * Convert HTML into HAX Elements
   */


  window.HaxStore.htmlToHaxElements = function (html) {
    var elements = [];
    var validTags = window.HaxStore.instance.validTagList;
    var fragment = document.createElement("div");
    fragment.innerHTML = html;
    var children = fragment.childNodes; // loop over the new nodes

    for (var i = 0; i < children.length; i++) {
      // verify this tag is a valid one
      if (babelHelpers.typeof(children[i].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && validTags.includes(children[i].tagName.toLowerCase())) {
        elements.push(window.HaxStore.nodeToHaxElement(children[i], null));
      }
    }

    return elements;
  };
  /**
   * Convert a node to a HAX element. Hax elements ensure
   * a certain level of sanitization by verifying tags and
   * properties / attributes that have values.
   */


  window.HaxStore.nodeToHaxElement = function (node) {
    var eventName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "insert-element";

    if (!node) {
      return null;
    } // build out the properties to send along


    var props = {}; // support basic styles

    if (babelHelpers.typeof(node.style) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      props.style = node.getAttribute("style");
    } // don't set a null style


    if (props.style === null || props.style === "null") {
      delete props.style;
    } // test if a class exists, not everything scopes


    if (babelHelpers.typeof(node.attributes.class) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      props.class = node.attributes.class.nodeValue.replace("hax-active", "");
    } // test if a id exists as its a special case in attributes... of course


    if (babelHelpers.typeof(node.attributes.id) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      props.id = node.getAttribute("id");
    }

    var tmpProps; // relatively cross library

    if (customElements.get(node.tagName.toLowerCase())) {
      tmpProps = customElements.get(node.tagName.toLowerCase()).properties;
    } // weak fallback


    if (babelHelpers.typeof(tmpProps) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      tmpProps = node.__data;
    } // complex elements need complex support


    if (babelHelpers.typeof(tmpProps) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      // run through attributes, though non-reflected props won't be here
      // run through props, we always defer to property values
      for (var property in tmpProps) {
        // make sure we only set things that have a value
        if (property != "class" && property != "style" && tmpProps.hasOwnProperty(property) && babelHelpers.typeof(node[property]) !== undefined && node[property] != null && node[property] != "") {
          props[property] = node[property];
        } // special support for false boolean
        else if (node[property] === false) {
            props[property] = node[property];
          } else {}
      }

      for (var attribute in node.attributes) {
        // make sure we only set things that have a value
        if (babelHelpers.typeof(node.attributes[attribute].name) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.attributes[attribute].name != "class" && node.attributes[attribute].name != "style" && node.attributes[attribute].name != "id" && node.attributes.hasOwnProperty(attribute) && babelHelpers.typeof(node.attributes[attribute].value) !== undefined && node.attributes[attribute].value != null && node.attributes[attribute].value != "" && !tmpProps.hasOwnProperty(window.HaxStore.dashToCamel(node.attributes[attribute].name))) {
          props[window.HaxStore.dashToCamel(node.attributes[attribute].name)] = node.attributes[attribute].value;
        } else {// note: debug here if experiencing attributes that won't bind
        }
      }
    } else {
      // much easier case, usually just in primatives
      for (var attribute in node.attributes) {
        // make sure we only set things that have a value
        if (babelHelpers.typeof(node.attributes[attribute].name) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.attributes[attribute].name != "class" && node.attributes[attribute].name != "style" && node.attributes[attribute].name != "id" && node.attributes.hasOwnProperty(attribute) && babelHelpers.typeof(node.attributes[attribute].value) !== undefined && node.attributes[attribute].value != null && node.attributes[attribute].value != "") {
          props[window.HaxStore.dashToCamel(node.attributes[attribute].name)] = node.attributes[attribute].value;
        }
      }
    } // support sandboxed environments which
    // will hate iframe tags but love webview


    var tag = node.tagName.toLowerCase();

    if (window.HaxStore.instance._isSandboxed && tag === "iframe") {
      tag = "webview";
    }

    var slotContent = window.HaxStore.getHAXSlot(node); // support fallback on inner text if there were no nodes

    if (slotContent == "") {
      slotContent = node.innerText;
    } // special edge case for slot binding in primatives


    if (tag === "a") {
      props.innerText = slotContent;
    } else if (tag === "p" || tag === "table" || tag === "ol" || tag === "ul" || tag === "div") {
      props.innerHTML = slotContent;
    }

    var element = {
      tag: tag,
      properties: props,
      content: slotContent
    };

    if (eventName !== null) {
      element.eventName = eventName;
    }

    return element;
  };
  /**
   * Convert a haxElement to a DOM node.
   */


  window.HaxStore.haxElementToNode = function (tag, content, properties) {
    // support sandboxed environments which
    // will hate iframe tags but love webview
    if (window.HaxStore.instance._isSandboxed && tag === "iframe") {
      tag = "webview";
    }

    var frag = document.createElement(tag);
    frag.innerHTML = content; // clone the fragment which will force an escalation to full node

    var newNode = frag.cloneNode(true); // support for properties if they exist

    for (var property in properties) {
      var attributeName = window.HaxStore.camelToDash(property);

      if (properties.hasOwnProperty(property)) {
        // special supporting for boolean because html is weird :p
        if (properties[property] === true) {
          newNode.setAttribute(attributeName, properties[property]);
        } else if (properties[property] === false) {
          newNode.removeAttribute(attributeName);
        } else if (properties[property] != null && properties[property].constructor === Array) {
          // do nothing if we have additional data to suggest this is actually readOnly
          // polymer / typed specific thing
          if (frag.properties && frag.properties[property] && frag.properties[property].readOnly) {} else {
            if (newNode.set) {
              newNode.set(attributeName, properties[property]);
            } else {
              newNode[attributeName] = babelHelpers.toConsumableArray(properties[property]);
            }
          }
        } else if (properties[property] != null && properties[property].constructor === Object) {
          // do nothing if we have additional data to suggest this is actually readOnly
          // polymer / typed specific thing
          if (frag.properties && frag.properties[property] && frag.properties[property].readOnly) {} else {
            if (newNode.set) {
              newNode.set(attributeName, properties[property]);
            } else {
              newNode[attributeName] = _objectSpread({}, properties[property]);
            }
          }
        } else {
          newNode.setAttribute(attributeName, properties[property]);
        }
      }
    }

    return newNode;
  };
  /**
   * Convert a node to the correct content object for saving.
   * This DOES NOT acccept a HAXElement which is similar
   */


  window.HaxStore.nodeToContent = function (node) {
    // ensure we have access to all the member functions of the custom element
    var prototype = Object.getPrototypeOf(node); // support for deep API call

    if (babelHelpers.typeof(prototype.preProcessHaxNodeToContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      node = prototype.preProcessHaxNodeToContent(node);
    }

    var tag = node.tagName.toLowerCase(); // support sandboxed environments which
    // will hate iframe tags but love webview

    if (window.HaxStore.instance._isSandboxed && tag === "webview") {
      tag = "iframe";
    }

    var content = ""; // start to rebuild the same tag we got in a generalized way

    content += "<" + tag; // account for things that say NOT to save slot values

    var props = window.HaxStore.instance.elementList[tag];
    var propvals = {}; // grab all of the original's attributes, and pass them to the replacement

    for (var j = 0, l = node.attributes.length; j < l; ++j) {
      var nodeName = node.attributes.item(j).nodeName;
      var value = node.attributes.item(j).value; // encode objects and arrays because they are special

      if (nodeName != "style" && (babelHelpers.typeof(value) === (typeof Object === "undefined" ? "undefined" : babelHelpers.typeof(Object)) || value.constructor === Array)) {
        propvals[nodeName] = JSON.stringify(value).replace(new RegExp('"', "g"), "&quot;");
      } // only write things that aren't empty
      else if (value != null && value != "null") {
          if (value === true || value === "true") {
            propvals[nodeName] = true;
          } else if (value === false) {// do nothing, no reason to record false unless written as text
            // in which case below will capture it
          } else {
            // ensure that value doesn't have " in it unencoded
            if (typeof value === "string" && value !== "") {
              value = value.replace(new RegExp('"', "g"), "&quot;");
              propvals[nodeName] = value;
            } // special handling for empty string cause it might mean boolean
            // or it might be a string
            else if (value === "") {
                if (value == "" && node.attributes.item(j).value != "") {
                  value = node.attributes.item(j).value;
                }

                propvals[nodeName] = value;
              } else {
                propvals[nodeName] = value;
              }
          }
        }
    } // now look through properties


    var tmpProps; // relatively cross library

    if (customElements.get(tag)) {
      tmpProps = customElements.get(tag).properties;
    } // weak fallback


    if (babelHelpers.typeof(tmpProps) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      tmpProps = node.__data;
    }

    if (babelHelpers.typeof(tmpProps) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      for (var j in tmpProps) {
        var nodeName = window.HaxStore.camelToDash(j);
        var value = null; // prefer local value over properties object if possible

        if (babelHelpers.typeof(node[j]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          value = node[j];
        } // never allow read only things to recorded as they
        // are run-time creation 99% of the time
        // this is very polymer specific but it allows readOnly and computed props
        // also __ is a popular convention for private values so let's skip them


        if (!tmpProps[j].readOnly && !tmpProps[j].computed && value !== tmpProps[j].value && !nodeName.startsWith("__")) {
          // encode objects and arrays because they are special
          if (value != null && (babelHelpers.typeof(value) === "object" || value.constructor === Array)) {
            if (value.constructor === Array && value != []) {
              propvals[nodeName] = JSON.stringify(value).replace(new RegExp('"', "g"), "&quot;");
            } else if (babelHelpers.typeof(value) === "object" && value != {}) {
              propvals[nodeName] = JSON.stringify(value).replace(new RegExp('"', "g"), "&quot;");
            }
          } // only write things that aren't empty
          else if (value != null && value != "null") {
              if (value === true || value === "true") {
                propvals[nodeName] = true;
              } else if (value === false) {// do nothing, no reason to record false unless written as text
                // in which case below will capture it
              } else {
                // ensure that value doesn't have " in it unencoded
                if (typeof value === "string" && value !== "") {
                  value = value.replace(new RegExp('"', "g"), "&quot;");
                  propvals[nodeName] = value;
                } // special handling for empty string cause it might mean boolean
                // or it might be a string
                else if (value === "") {
                    if (value == "" && tmpProps[j].value != "") {
                      value = tmpProps[j].value;
                    } else if (value === "" && tmpProps[j].value == "") {// do nothing, the default value is empty
                      // so lets record less data
                    }
                  } else {
                    propvals[nodeName] = value;
                  }
              }
            }
        }
      }
    } // support for tag defining which properties NOT to save
    // for simplification, everything is an attribute during this
    // operation


    if (babelHelpers.typeof(props) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(props.saveOptions.unsetAttributes) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      for (var i in props.saveOptions.unsetAttributes) {
        delete propvals[props.saveOptions.unsetAttributes[i]];
      }
    } // specialized clean up for some that can leak through from above
    // and are edge case things because #hashtag gotta love HTML attributes
    // and the webview tag. facepalm.


    var delProps = ["inner-text", "inner-html", "tabindex", "guestinstance"];

    for (var delProp in delProps) {
      if (babelHelpers.typeof(propvals[delProps[delProp]]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
        delete propvals[delProps[delProp]];
      }
    } // remove id attribute if it's empty, somehow misses above


    if (babelHelpers.typeof(propvals.id) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && propvals.id === "") {
      delete propvals.id;
    } // run through the properties


    for (var i in propvals) {
      if (propvals[i] === true) {
        content += " " + i;
      } else {
        content += " " + i + '="' + propvals[i] + '"';
      }
    } // set the opening tag, support self-closing void tags


    var voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];

    if (voidTags.includes(tag)) {
      content += "/>";
    } else {
      content += ">";
    } // try and work against anything NOT a P tag


    if (babelHelpers.typeof(props) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) || !props.saveOptions.wipeSlot) {
      // get content that is in the slots
      var slotnodes = node.childNodes; // ensure there's something inside of this

      if (slotnodes.length > 0) {
        // loop through everything found in the slotted area and put it back in
        for (var j = 0, len2 = slotnodes.length; j < len2; j++) {
          if (babelHelpers.typeof(slotnodes[j].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            // if we're a custom element, keep digging, otherwise a simple
            // self append is fine unless template tag cause it's a special
            // case for the web in general as it'll register as not a primative
            // even though it is...
            if (!window.HaxStore.HTMLPrimativeTest(slotnodes[j].tagName) && slotnodes[j].tagName !== "TEMPLATE") {
              content += window.HaxStore.nodeToContent(slotnodes[j]);
            } else {
              slotnodes[j].setAttribute("data-editable", false);
              slotnodes[j].removeAttribute("data-hax-ray");
              slotnodes[j].contentEditable = false;
              content += slotnodes[j].outerHTML;
            }
          } // keep comments with a special case since they need wrapped
          else if (slotnodes[j].nodeType === 8) {
              content += "<!-- " + slotnodes[j].textContent + " -->";
            } // keep everything NOT an element at this point, this helps
            // preserve whitespace because we're crazy about accuracy
            else if (slotnodes[j].nodeType !== 1 && babelHelpers.typeof(slotnodes[j].textContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && slotnodes[j].textContent !== "undefined") {
                content += slotnodes[j].textContent;
              }
        }
      }
    } // optional support for intentional progressive enhancement


    if (typeof node.haxProgressiveEnhancement === "function") {
      content += node.haxProgressiveEnhancement();
    } // don't put return for span since it's an inline tag


    if (tag === "span") {
      content += "</" + tag + ">";
    } else if (tag === "hr" || tag === "br" || tag === "img") {} // do nothing for self-closing tags they'll resolve themselves
    // close the tag, placing a return in output for block elements
    else {
        content += "</" + tag + ">" + "\n";
      } // spacing niceness for output readability


    content = content.replace(/&nbsp;/gm, " "); // target and remove hax specific things from output if they slipped through

    content = content.replace(/ data-editable="(\s|.)*?"/gim, "");
    content = content.replace(/ data-hax-ray="(\s|.)*?"/gim, "");
    content = content.replace(/ class=""/gim, "");
    content = content.replace(/ class="hax-active"/gim, "");
    content = content.replace(/ contenteditable="(\s|.)*?"/gim, ""); // wipe pure style spans which can pop up on copy paste if we didn't catch it
    // also ensure that we then remove purely visual chars laying around
    // this also helps clean up when we did a normal contenteditable paste
    // as opposed to our multi-element sanitizing option that we support

    content = content.replace(/<span style="(.*?)">/gim, "<span>");
    content = content.replace(/<span>\s*?<\/span>/g, " ");
    content = content.replace(/<span><br\/><\/span>/gm, ""); // account for things taht on normal paste would pick up too many css vars

    content = content.replace(/<strong style="(.*?)">/gim, "<strong>");
    content = content.replace(/<b style="(.*?)">/gim, "<b>");
    content = content.replace(/<strike style="(.*?)">/gim, "<strike>");
    content = content.replace(/<em style="(.*?)">/gim, "<em>");
    content = content.replace(/<i style="(.*?)">/gim, "<i>"); // empty with lots of space

    content = content.replace(/<p>(\s*)<\/p>/gm, "<p></p>"); // empty p / more or less empty

    content = content.replace(/<p>&nbsp;<\/p>/gm, "<p></p>"); // br somehow getting through here

    content = content.replace(/<p><br\/><\/p>/gm, "<p></p>");
    content = content.replace(/<p><br><\/p>/gm, "<p></p>"); // whitespace in reverse of the top case now that we've cleaned it up

    content = content.replace(/<\/p>(\s*)<p>/gm, "</p><p>");
    content = content.split("\n\r").join("\n").split("\r").join("\n").split("\n\n").join("\n").split("\n\n").join("\n").split("\n\n").join("\n"); // support postProcess text rewriting for the node that's been
    // converted to a string for storage

    if (node.postProcesshaxNodeToContent === "function") {
      content = node.postProcesshaxNodeToContent(content);
    }

    return content;
  };
  /**
   * Basic HTML Primitives test
   */


  window.HaxStore.HTMLPrimativeTest = function (node) {
    if (babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.tagName.indexOf("-") == -1) {
      return true;
    }

    return false;
  };
  /**
   * Slot content w/ support for custom elements in slot.
   */


  window.HaxStore.getHAXSlot = function (node) {
    // we can skip all of this if we have a text element / HTML prim!
    if (window.HaxStore.instance.isTextElement(node)) {
      return node.innerHTML;
    }

    var content = "";
    var slotnodes = node.childNodes; // ensure there's something inside of this

    if (slotnodes.length > 0) {
      // loop through everything found in the slotted area and put it back in
      for (var j = 0, len2 = slotnodes.length; j < len2; j++) {
        if (babelHelpers.typeof(slotnodes[j].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // if we're a custom element, keep digging, otherwise a simple
          // self append is fine.
          if (slotnodes[j].tagName.indexOf("-") > 0) {
            content += "  " + window.HaxStore.nodeToContent(slotnodes[j]) + "\n";
          } else {
            content += "  " + slotnodes[j].outerHTML + "\n";
          }
        } // keep comments with a special case since they need wrapped
        else if (slotnodes[j].nodeType === 8) {
            content += "<!-- " + slotnodes[j].textContent + " -->";
          } // keep everything NOT an element at this point, this helps
          // preserve whitespace because we're crazy about accuracy
          else if (slotnodes[j].nodeType !== 1 && babelHelpers.typeof(slotnodes[j].textContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && slotnodes[j].textContent !== "undefined") {
              content += slotnodes[j].textContent;
            }
      }
    }

    return content;
  };
  /**
   * Shortcut to standardize the write / read process.
   */


  window.HaxStore.write = function (prop, value, obj) {
    if (obj) {
      obj.dispatchEvent(new CustomEvent("hax-store-write", {
        composed: true,
        bubbles: true,
        cancelable: false,
        detail: {
          property: prop,
          value: value,
          owner: obj
        }
      }));
    }
  };
  /**
   * Guess the type of Gizmo when given some information about what we have.
   */


  window.HaxStore.guessGizmoType = function (guess) {
    if (babelHelpers.typeof(guess.source) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      var source = guess.source.toLowerCase();

      if (source.indexOf(".mp3") != -1) {
        return "audio";
      } else if (source.indexOf(".png") != -1 || source.indexOf(".jpg") != -1 || source.indexOf(".jpeg") != -1 || source.indexOf(".gif") != -1) {
        return "image";
      } else if (source.indexOf(".pdf") != -1) {
        return "pdf";
      } else if (source.indexOf(".svg") != -1) {
        return "svg";
      } else if (source.indexOf(".csv") != -1) {
        return "csv";
      } else if (source.indexOf(".md") != -1) {
        return "markdown";
      } else if (source.indexOf(".html") != -1 || source.indexOf(".htm") != -1) {
        return "html";
      } else if (source.indexOf(".txt") != -1 || source.indexOf(".doc") != -1 || source.indexOf(".docx") != -1 || source.indexOf(".xls") != -1 || source.indexOf(".xlsx") != -1 || source.indexOf(".ppt") != -1) {
        return "document";
      } else if (source.indexOf(".zip") != -1 || source.indexOf(".tar.gz") != -1 || source.indexOf(".tar") != -1) {
        return "archive";
      } // if it's external we can't assume what it actually is
      else if (window.MediaBehaviors.Video.getVideoType(source) != "external") {
          return "video";
        } else {
          // we don't know how to handle this so let's just
          // try ANYTHING that matches
          return "*";
        }
    }
  };
  /**
   * Try and guess the Gizmo based on what we were just handed
   */


  window.HaxStore.guessGizmo = function (guess, values) {
    var skipPropMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var preferExclusive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var matches = [];

    if (babelHelpers.typeof(guess) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      var store = window.HaxStore.instance; // verify type

      if (store.validGizmoTypes.includes(guess)) {
        // now we can look through them
        // look for a match
        for (var gizmoposition in store.gizmoList) {
          var gizmo = store.gizmoList[gizmoposition];
          var props = {}; // reset match per gizmo

          var match = false; // ensure this gizmo can handle things

          if (gizmo.handles) {
            for (var i = 0; i < gizmo.handles.length; i++) {
              // WHAT!??!?!?!?!
              if (guess === gizmo.handles[i].type || guess === "*" && !match) {
                for (var property in gizmo.handles[i]) {
                  // ignore type.. but again.. WHAT?!?!?!
                  if (property !== "type") {
                    // check the values that came across to see if there's a match
                    // of any kind, we only need one but can then bind to multiple
                    if (babelHelpers.typeof(values[property]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      // but ensure there's either no meta data OR
                      // the meta data needs to NOT say anythinig about hiding
                      if (guess === "inline" || !gizmo.meta || gizmo.meta && !gizmo.meta.inlineOnly && !gizmo.meta.hidden) {
                        match = true;
                        props[gizmo.handles[i][property]] = values[property];
                      }
                    }
                  }
                } // omg... we just found a match on a property from who knows where!


                if (match || skipPropMatch) {
                  if (preferExclusive && gizmo.handles[i].type_exclusive) {
                    return [window.HaxStore.haxElementPrototype(gizmo, props, "")];
                  } else {
                    matches.push(window.HaxStore.haxElementPrototype(gizmo, props, ""));
                  }
                }
              }
            }
          }
        }
      }
    }

    return matches;
  };
  /**
   * Filter app store apps to those that accept this file source.
   */


  window.HaxStore.getHaxAppStoreTargets = function (type) {
    var targets = window.HaxStore.instance.appList.filter(function (app) {
      if (babelHelpers.typeof(app.connection.operations.add) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
        var add = app.connection.operations.add;

        if (babelHelpers.typeof(add.acceptsGizmoTypes) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && add.acceptsGizmoTypes.includes(type)) {
          return true;
        }
      }

      return false;
    });
    return targets;
  };
  /**
   * Generate Hax Element prototype.
   */


  window.HaxStore.haxElementPrototype = function (gizmo, properties) {
    var content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
    return {
      tag: gizmo.tag,
      properties: properties,
      content: content,
      gizmo: gizmo
    };
  };
  /**
   * Wipe out the slot of an element.
   */


  window.HaxStore.wipeSlot = function (element) {
    var slot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    (0, _utils.wipeSlot)(element, slot);
  };
  /**
   * HTML encapsulation of a string on script and style tags
   */


  window.HaxStore.encapScript = function (html) {
    return (0, _utils.encapScript)(html);
  };
  /**
   * Global toast bridge so we don't have to keep writing custom event
   */


  window.HaxStore.toast = function (message) {
    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4000;
    var classStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "capsule";
    var closeText = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var eventCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var evt = new CustomEvent("simple-toast-show", {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: {
        text: message,
        duration: duration,
        classStyle: classStyle,
        closeText: closeText,
        eventCallback: eventCallback
      }
    });
    window.dispatchEvent(evt);
  };
  /**
   * Selection normalizer
   */


  window.HaxStore.getSelection = function () {
    // try and obtain the selection from the nearest shadow
    // which would give us the selection object when running native ShadowDOM
    // with fallback support for the entire window which would imply Shady
    if (window.HaxStore.instance.activeHaxBody.parentNode) {
      // native API
      if (window.HaxStore.instance.activeHaxBody.parentNode.getSelection) {
        return window.HaxStore.instance.activeHaxBody.parentNode.getSelection();
      } // ponyfill from google
      else if ((0, _utils.getRange)(window.HaxStore.instance.activeHaxBody.parentNode)) {
          return (0, _utils.getRange)(window.HaxStore.instance.activeHaxBody.parentNode);
        }
    } // missed on both, hope the normal one will work


    return window.getSelection();
  };
  /**
   * Get a normalized range based on current selection
   */


  window.HaxStore.getRange = function () {
    var sel = window.HaxStore.getSelection();

    if (sel.getRangeAt && sel.rangeCount) {
      return sel.getRangeAt(0);
    } else if (sel) {
      return sel;
    } else false;
  };

  var UndoerElement =
  /*#__PURE__*/
  function (_HTMLElement) {
    babelHelpers.inherits(UndoerElement, _HTMLElement);
    babelHelpers.createClass(UndoerElement, null, [{
      key: "observedAttributes",
      get: function get() {
        return ["state"];
      }
    }]);

    function UndoerElement() {
      var _this8;

      babelHelpers.classCallCheck(this, UndoerElement);
      _this8 = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(UndoerElement).call(this));
      _this8.openDrawer = false;
      _this8._root = _this8.attachShadow({
        mode: "open"
      }); // hide from the first attributeChangedCallback call

      _this8._selfAttributeChange = true;
      window.setTimeout(function () {
        _this8._selfAttributeChange = false;
      });

      var callback = function callback(data) {
        var value = data.value,
            attr = data.attr;

        _this8._updateAttribute(attr ? value : null); // hooray! tell the client


        _this8.dispatchEvent(new CustomEvent("state", {
          detail: value
        }));
      }; // set up initial zero undo state from attr


      var zero = _this8.getAttribute("state");

      var attr = _this8.hasAttribute("state");

      _this8._undoer = new _undoer.Undoer(callback, {
        value: zero,
        attr: attr
      });
      return _this8;
    }

    babelHelpers.createClass(UndoerElement, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, oldValue, newValue) {
        if (name === "state" && !this._selfAttributeChange) {
          this._internalSet(newValue, true);
        }
      }
    }, {
      key: "_updateAttribute",
      value: function _updateAttribute(value) {
        this._selfAttributeChange = true;

        try {
          if (value) {
            this.setAttribute("state", value);
          } else {
            this.removeAttribute("state");
          }
        } finally {
          this._selfAttributeChange = false;
        }
      }
    }, {
      key: "_internalSet",
      value: function _internalSet(value, attr) {
        this._updateAttribute(attr ? value : null);

        this._undoer.push({
          value: value,
          attr: attr
        }, this._root);
      }
    }, {
      key: "state",
      set: function set(value) {
        if (!this.isConnected) {
          throw new Error("can't push state while disconnected");
        } // render if simple "attribute safe" state


        var attr = typeof value === "string" || typeof value === "number";

        this._internalSet(value, attr);
      },
      get: function get() {
        var value = this._undoer.data.value;
        return value;
      }
    }]);
    return UndoerElement;
  }(babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.UndoerElement = UndoerElement;
  window.customElements.define("undoer-element", UndoerElement);
});