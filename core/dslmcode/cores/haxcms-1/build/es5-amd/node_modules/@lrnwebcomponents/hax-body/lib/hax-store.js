define(["exports", "meta", "require", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/utils/render-status.js", "../../../@polymer/polymer/lib/legacy/polymer.dom.js", "../../../@polymer/polymer/lib/utils/resolve-url.js", "../../../@polymer/polymer/lib/utils/settings.js", "./shadows-safari.js", "./haxutils.js", "../../../@polymer/iron-ajax/iron-ajax.js", "../../simple-toast/simple-toast.js", "../../media-behaviors/media-behaviors.js", "../../hax-body-behaviors/hax-body-behaviors.js", "../../code-sample/code-sample.js"], function (_exports, meta, _require, _polymerElement, _renderStatus, _polymerDom, _resolveUrl, _settings, _shadowsSafari, _haxutils, _ironAjax, _simpleToast, _mediaBehaviors, _haxBodyBehaviors, _codeSample) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxStore = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_f489be30dedc11e9bf5a076df0f16721() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          display: none;\n        }\n      </style>\n      <slot></slot>\n      <iron-ajax\n        id=\"appstore\"\n        url=\"[[appStore.url]]\"\n        params=\"[[appStore.params]]\"\n        method=\"GET\"\n        content-type=\"application/json\"\n        handle-as=\"json\"\n        last-response=\"{{__appStoreData}}\"\n      ></iron-ajax>\n      <hal-9000 id=\"hal\" debug=\"debug\" commands=\"[[voiceCommands]]\"></hal-9000>\n    "]);

    _templateObject_f489be30dedc11e9bf5a076df0f16721 = function _templateObject_f489be30dedc11e9bf5a076df0f16721() {
      return data;
    };

    return data;
  }

  var HaxStore =
  /*#__PURE__*/
  function (_HAXElement) {
    babelHelpers.inherits(HaxStore, _HAXElement);
    babelHelpers.createClass(HaxStore, [{
      key: "_storageDataChanged",

      /**
       * Local storage data changed; callback to store this data in user storage
       */
      value: function _storageDataChanged(newValue) {
        if (newValue && window.HaxStore.ready && this.__storageDataProcessed) {
          if (window.localStorage.getItem("haxConfirm")) {
            window.localStorage.setItem("haxUserData", JSON.stringify(newValue));
          } else if (window.sessionStorage.getItem("haxConfirm")) {
            window.sessionStorage.setItem("haxUserData", JSON.stringify(newValue));
          }
        }
      }
      /**
       * If this is a text node or not so we know if the inline context
       * operations are valid.
       */

    }, {
      key: "isTextElement",
      value: function isTextElement(node) {
        if (node != null && this.validTagList.includes(node.tagName.toLowerCase())) {
          if (["p", "ol", "ul", "li", "a", "h1", "h2", "h3", "h4", "h5", "h6", "strike", "u", "b", "sub", "sup", "span", "i", "bold", "em", "strong", "blockquote", "code", "figure"].includes(node.tagName.toLowerCase())) {
            return true;
          }
        }

        return false;
      }
      /**
       * test for being a valid grid plate, li is here because
       * nested lists make this really complicated
       */

    }, {
      key: "isGridPlateElement",
      value: function isGridPlateElement(node) {
        var tag = node.tagName.toLowerCase();

        if (this.validTagList.includes(tag)) {
          if (["p", "ol", "ul", "li", "div", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "code", "figure", "grid-plate"].includes(tag)) {
            return true;
          }
        }

        return false;
      }
      /**
       * Notice _appStore changed.
       */

    }, {
      key: "_appStoreChanged",
      value: function _appStoreChanged(newValue, oldValue) {
        var _this2 = this;

        // if we have an endpoint defined, pull it
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue != null) {
          // support having the request or remote loading
          // depending on the integration type
          if (babelHelpers.typeof(newValue.apps) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            this.shadowRoot.querySelector("#appstore").generateRequest();
          } else {
            // directly injected json object into the DOM, allow some time to propagate data
            // otherwise we might not have a haxAutoloader object ready in time for the paint
            setTimeout(function () {
              _this2.__appStoreData = newValue;
            }, 500);
          }
        }
      }
      /**
       * Load and attach items from the app store.
       */

    }, {
      key: "_loadAppStoreData",
      value: function _loadAppStoreData(ready, appDataResponse, haxAutoloader) {
        if (ready && babelHelpers.typeof(appDataResponse) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && appDataResponse != null) {
          var items = {}; // autoload elements

          if (babelHelpers.typeof(appDataResponse.autoloader) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            // ensure the list is in the right order so we can async dynamic imports
            // regardless of if its an array or object of values in the right format
            // force this to be an object
            appDataResponse.autoloader = Object.assign({}, appDataResponse.autoloader);

            for (var i in appDataResponse.autoloader) {
              var CEname = i;
              var CEimport = appDataResponse.autoloader[i]; // helps support array or object based appstore
              // array was originally in the standard so this lets us support both

              if (!isNaN(CEname)) {
                CEname = appDataResponse.autoloader[i];
                CEimport = "@lrnwebcomponents/".concat(CEname, "/").concat(CEname, ".js");
              } // force this into the valid tag list so early paints will
              // correctly include the tag without filtering it out incorrectly


              this.push("validTagList", CEname);
              items[CEname] = CEimport;
            }
          } // load apps automatically


          if (babelHelpers.typeof(appDataResponse.apps) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var apps = appDataResponse.apps;

            for (var i = 0; i < apps.length; i++) {
              var app = document.createElement("hax-app");
              app.data = apps[i]; // see if anything coming across claims to be a backend for adding items
              // and then enable the upload button

              if (apps[i].connection.operations.add) {
                window.HaxStore.write("canSupportUploads", true, this);
              }

              window.HaxStore.instance.appendChild(app);
            }
          } // load in stax dynamically


          if (babelHelpers.typeof(appDataResponse.stax) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var staxs = appDataResponse.stax;

            for (var i = 0; i < staxs.length; i++) {
              var stax = document.createElement("hax-stax");
              stax.data = staxs[i];
              window.HaxStore.instance.appendChild(stax);
            }
          } // load in blox dynamically


          if (babelHelpers.typeof(appDataResponse.blox) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var bloxs = appDataResponse.blox;

            for (var i = 0; i < bloxs.length; i++) {
              var blox = document.createElement("hax-blox");
              blox.data = bloxs[i];
              window.HaxStore.instance.appendChild(blox);
            }
          }

          this.dispatchEvent(new CustomEvent("hax-store-app-store-loaded", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: true
          })); // now process the dynamic imports

          this._handleDynamicImports(items, haxAutoloader);
        }
      }
      /**
       * Handle all the dynamic imports of things told to autoload
       * This ensures we get the definitions very quickly as far as
       * what is a safe / valid tag above but then we import in a way
       * that allows us to correctly associate the hax schema to where
       * it came from.
       */

    }, {
      key: "_handleDynamicImports",
      value: function () {
        var _handleDynamicImports2 = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(items, haxAutoloader) {
          var _this3 = this;

          var basePath, i, CEClass;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  basePath = (0, _resolveUrl.pathFromUrl)(decodeURIComponent(meta.url));
                  _context.t0 = regeneratorRuntime.keys(items);

                case 2:
                  if ((_context.t1 = _context.t0()).done) {
                    _context.next = 13;
                    break;
                  }

                  i = _context.t1.value;

                  if (window.customElements.get(i)) {
                    _context.next = 9;
                    break;
                  }

                  _context.next = 7;
                  return new Promise(function (res, rej) {
                    return _require.default(["".concat(basePath, "../../../").concat(items[i])], res, rej);
                  }).then(function (response) {
                    for (var cVal in response) {
                      // get the custom element definition we used to add that file
                      var CEClass = response[cVal];

                      if (typeof CEClass.getHaxProperties === "function") {
                        _this3.setHaxProperties(CEClass.getHaxProperties(), i);
                      } else if (typeof CEClass.HAXWiring === "function") {
                        _this3.setHaxProperties(CEClass.HAXWiring.getHaxProperties(), i);
                      } else if (CEClass.haxProperties) {
                        _this3.setHaxProperties(CEClass.haxProperties, i);
                      } else {
                        // this is the less optimized / legacy polymer element or an element
                        // that did not provide an export
                        (0, _polymerDom.dom)(haxAutoloader).appendChild(document.createElement(i));
                      }
                    }
                  }).catch(function (error) {
                    /* Error handling */
                    console.warn(error);
                  });

                case 7:
                  _context.next = 11;
                  break;

                case 9:
                  // get the custom element definition we used to add that file
                  CEClass = window.customElements.get(i);

                  if (typeof CEClass.getHaxProperties === "function") {
                    this.setHaxProperties(CEClass.getHaxProperties(), i);
                  } else if (typeof CEClass.HAXWiring === "function") {
                    this.setHaxProperties(CEClass.HAXWiring.getHaxProperties(), i);
                  } else if (CEClass.haxProperties) {
                    this.setHaxProperties(CEClass.haxProperties, i);
                  } else {
                    // this is the less optimized / legacy polymer element method to inlcude
                    // this item. It's a good reason to skip on this though because you'll
                    // have a faster boot up time with newer ES6 methods then previous ones.
                    (0, _polymerDom.dom)(haxAutoloader).appendChild(document.createElement(i));
                  }

                case 11:
                  _context.next = 2;
                  break;

                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function _handleDynamicImports(_x, _x2) {
          return _handleDynamicImports2.apply(this, arguments);
        }

        return _handleDynamicImports;
      }()
    }, {
      key: "_editModeChanged",
      value: function _editModeChanged(newValue) {
        if (newValue && this.globalPreferences.haxVoiceCommands) {
          this.shadowRoot.querySelector("#hal").auto = true;
        } else {
          this.shadowRoot.querySelector("#hal").auto = false;
        }
      }
    }, {
      key: "_globalPreferencesChanged",
      value: function _globalPreferencesChanged(newValue, oldValue) {
        // regardless of what it is, reflect it globally but only after setup
        if (this.__storageDataProcessed && newValue && babelHelpers.typeof(newValue.haxVoiceCommands) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && window.HaxStore.ready) {
          var storageData = this.storageData;
          storageData.globalPreferences = newValue;
          this.set("storageData", {});
          this.set("storageData", storageData);

          if (newValue.haxVoiceCommands && this.editMode) {
            this.shadowRoot.querySelector("#hal").auto = true;
          } else {
            this.shadowRoot.querySelector("#hal").auto = false;
          }
        }
      }
      /**
       * Detached life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        // notice hax property definitions coming from anywhere
        window.removeEventListener("hax-register-properties", this._haxStoreRegisterProperties.bind(this)); // app registration can come in automatically from app-stores
        // or through direct definition in the DOM

        document.body.removeEventListener("hax-register-app", this._haxStoreRegisterApp.bind(this)); // register stax which are groupings of haxElements

        document.body.removeEventListener("hax-register-stax", this._haxStoreRegisterStax.bind(this)); // register blox which are grid plate configurations
        // with lots of sane visual defaults

        document.body.removeEventListener("hax-register-blox", this._haxStoreRegisterBlox.bind(this)); // register the pieces of the body of what we call HAX
        // think of this like the core of the system required
        // to do anything like have buttons or state management
        // write data to the store

        document.body.removeEventListener("hax-store-write", this._writeHaxStore.bind(this)); // register the manager panel / modal

        document.body.removeEventListener("hax-register-manager", this._haxStoreRegisterManager.bind(this)); // register the autoloader area for elements

        document.body.removeEventListener("hax-register-autoloader", this._haxStoreRegisterAutoloader.bind(this)); // register a body, kind of a big deal

        document.body.removeEventListener("hax-register-body", this._haxStoreRegisterBody.bind(this)); // register the interaction panel / menu

        document.body.removeEventListener("hax-register-panel", this._haxStoreRegisterPanel.bind(this)); // register the app picker for contextual setting / option

        document.body.removeEventListener("hax-register-app-picker", this._haxStoreRegisterAppPicker.bind(this)); // stax modal

        document.body.removeEventListener("hax-register-stax-picker", this._haxStoreRegisterStaxPicker.bind(this)); // blox modal

        document.body.removeEventListener("hax-register-blox-picker", this._haxStoreRegisterBloxPicker.bind(this)); // preferences modal

        document.body.removeEventListener("hax-register-preferences", this._haxStoreRegisterPreferences.bind(this)); // export modal

        document.body.removeEventListener("hax-register-export", this._haxStoreRegisterExport.bind(this)); // notice content insert and help it along to the body

        document.body.removeEventListener("hax-insert-content", this._haxStoreInsertContent.bind(this)); // grid plate add item event

        document.body.removeEventListener("grid-plate-add-item", this.haxInsertAnything.bind(this));
        document.body.removeEventListener("hax-insert-content-array", this._haxStoreInsertMultiple.bind(this));
        window.removeEventListener("hax-add-voice-command", this._addVoiceCommand.bind(this)); // capture events and intercept them globally

        window.removeEventListener("onbeforeunload", this._onBeforeUnload.bind(this));
        window.removeEventListener("hax-consent-tap", this._haxConsentTap.bind(this));
        window.removeEventListener("paste", this._onPaste.bind(this)); // send that hax store is ready to go so now we can setup the rest

        this.dispatchEvent(new CustomEvent("hax-store-ready", {
          bubbles: true,
          cancelable: false,
          composed: true,
          detail: false
        }));
        window.HaxStore.ready = false;
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * This only send if they consented to storage of data locally
       */

    }, {
      key: "_haxConsentTap",
      value: function _haxConsentTap(e) {
        // store for future local storage usage
        window.localStorage.setItem("haxConfirm", true); // most likely nothing but set it anyway

        window.localStorage.setItem("haxUserData", JSON.stringify(this.storageData));
      }
      /**
       * ready life cycle
       */

    }, {
      key: "ready",
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype), "ready", this).call(this);
        (0, _renderStatus.afterNextRender)(this, function () {
          // see if a global was used to prevent this check
          // this is useful when in trusted environments where the statement
          // has been consented to in the application this is utilized in
          if (this.skipHAXConfirmation) {
            window.sessionStorage.setItem("haxConfirm", true);
            window.localStorage.setItem("haxConfirm", true);
          } // check for local storage object
          // if not, then store it in sessionStorage so that all our checks
          // and balances are the same. This could allow for storing these
          // settings on a server in theory


          var haxConfirm = window.sessionStorage.getItem("haxConfirm") || window.localStorage.getItem("haxConfirm");

          if (!haxConfirm) {
            // this way it isn't shown EVERY reload, but if they didn't confirm
            // it will show up in the future
            window.sessionStorage.setItem("haxConfirm", true);
            var msg = "\n      The HAX content editor keeps preferences in order to improve your experience.\n      This data is stored in your browser and is never sent anywhere.\n      Click to accept.\n      ";
            window.HaxStore.toast(msg, "-1", "fit-bottom", "I Accept", "hax-consent-tap");
          } else {
            if (window.sessionStorage.getItem("haxConfirm") && !window.localStorage.getItem("haxConfirm")) {
              // verify there is something there
              try {
                var globalData = window.sessionStorage.getItem("haxUserData") ? JSON.parse(window.sessionStorage.getItem("haxUserData")) : {};
                this.set("storageData", globalData);
              } catch (e) {}
            } else {
              try {
                var _globalData = window.localStorage.getItem("haxUserData") ? JSON.parse(window.localStorage.getItem("haxUserData")) : {};

                this.set("storageData", _globalData);
              } catch (e) {}
            }
          }
        });
      }
      /**
       * attached.
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype), "connectedCallback", this).call(this);
        (0, _renderStatus.afterNextRender)(this, function () {
          var _this4 = this;

          // capture events and intercept them globally
          window.addEventListener("hax-consent-tap", this._haxConsentTap.bind(this));
          window.addEventListener("onbeforeunload", this._onBeforeUnload.bind(this));
          window.addEventListener("paste", this._onPaste.bind(this)); // import voice command stuff in the background
          // @todo only activate if the setting to use it is in place

          new Promise(function (res, rej) {
            return _require.default(["../../hal-9000/hal-9000.js"], res, rej);
          }); // set this global flag so we know it's safe to start trusting data
          // that is written to global preferences / storage bin

          setTimeout(function () {
            _this4.__storageDataProcessed = true;

            if (_this4.storageData.globalPreferences) {
              window.HaxStore.write("globalPreferences", _this4.storageData.globalPreferences, _this4);
            }
          }, 325);
        });
      }
    }, {
      key: "_storePiecesAllHere",
      value: function _storePiecesAllHere(haxAutoloader, activeHaxBody, haxPanel, haxToast, haxExport, haxPreferences, haxManager, haxStaxPicker, haxAppPicker) {
        if (!this.__ready && activeHaxBody && haxAutoloader && haxPanel && haxToast && haxExport && haxPreferences && haxManager && haxStaxPicker && haxAppPicker) {
          // send that hax store is ready to go so now we can setup the rest
          this.dispatchEvent(new CustomEvent("hax-store-ready", {
            bubbles: true,
            cancelable: false,
            composed: true,
            detail: true
          }));
          window.HaxStore.ready = true;
          this.__ready = true; // register built in primitive definitions

          this._buildPrimitiveDefinitions(); // initialize voice commands


          this.voiceCommands = this._initVoiceCommands();
        }
      }
      /**
       * Build a list of common voice commands
       */

    }, {
      key: "_initVoiceCommands",
      value: function _initVoiceCommands() {
        var _this5 = this;

        var commands = {};

        commands["".concat(this.shadowRoot.querySelector("#hal").respondsTo, " scroll up")] = function () {
          window.scrollBy({
            top: -(window.innerHeight * 0.5),
            left: 0,
            behavior: "smooth"
          });
        };

        commands["".concat(this.shadowRoot.querySelector("#hal").respondsTo, " scroll (down)")] = function () {
          window.scrollBy({
            top: window.innerHeight * 0.5,
            left: 0,
            behavior: "smooth"
          });
        };

        commands["hey ".concat(this.shadowRoot.querySelector("#hal").respondsTo)] = function () {
          _this5.shadowRoot.querySelector("#hal").speak("Yeah what do you want");
        };

        commands["".concat(this.shadowRoot.querySelector("#hal").respondsTo, " find media")] = function () {
          window.HaxStore.write("activeHaxElement", {}, window.HaxStore.instance);
          window.HaxStore.instance.haxManager.resetManager(1);
          window.HaxStore.instance.haxManager.toggleDialog(false);
        };

        return commands;
      }
      /**
       * allow uniform method of adding voice commands
       */

    }, {
      key: "addVoiceCommand",
      value: function addVoiceCommand(command) {
        this.push("voiceCommands", command);
        this.notifyPath("voiceCommands.*");
      }
      /**
       * event driven version
       */

    }, {
      key: "_addVoiceCommand",
      value: function _addVoiceCommand(e) {
        this.addVoiceCommand(e.detail);
      }
      /**
       * Before the browser closes / changes paths, ask if they are sure they want to leave
       */

    }, {
      key: "_onBeforeUnload",
      value: function _onBeforeUnload(e) {
        // ensure we don't leave DURING edit mode
        if (!window.HaxStore.instance.skipExitTrap && window.HaxStore.instance.editMode) {
          return "Are you sure you want to leave? Your work will not be saved!";
        }
      }
      /**
       * Intercept paste event and clean it up before inserting the contents
       */

    }, {
      key: "_onPaste",
      value: function _onPaste(e) {
        // only perform this on a text element that is active
        if (window.HaxStore.instance.isTextElement(window.HaxStore.instance.activeNode) && !window.HaxStore.instance.haxManager.opened) {
          var pasteContent = ""; // intercept paste event

          if (e.clipboardData || e.originalEvent.clipboardData) {
            pasteContent = (e.originalEvent || e).clipboardData.getData("text/html");
          } else if (window.clipboardData) {
            pasteContent = window.clipboardData.getData("Text");
          }

          pasteContent = pasteContent.replace(/<span> <\/span>/g, " ");
          pasteContent = pasteContent.replace(/<span><\/span>/g, "");
          pasteContent = (0, _haxutils.stripMSWord)(pasteContent); // edges that some things preserve empty white space needlessly

          var haxElements = window.HaxStore.htmlToHaxElements(pasteContent); // if interpretation as HTML fails then let's ignore this whole thing
          // as we allow normal contenteditable to handle the paste
          // we only worry about HTML structures

          if (haxElements.length === 0) {
            return false;
          } // if we got here then we have HTML structures to pull together
          // this ensures that the below works out


          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation(); // stupid but we need to reverse these

          haxElements.reverse();
          var newContent = "";

          for (var i in haxElements) {
            // special traps for word / other styles bleeding through
            delete haxElements[i].properties.style;
            delete haxElements[i].properties.start;
            delete haxElements[i].properties.align; // this is not the right function.

            var node = window.HaxStore.haxElementToNode(haxElements[i].tag, haxElements[i].content.replace(/<span>&nbsp;<\/span>/g, " ").trim(), haxElements[i].properties);
            newContent += window.HaxStore.nodeToContent(node);
          }

          try {
            // get the range that's active and selection
            var range = window.HaxStore.getRange();
            var sel = window.HaxStore.getSelection(); // tee up a wrapper so we can walk and put every element in

            var newNodes = document.createElement("div");
            newNodes.innerHTML = newContent;

            if (range && sel && typeof range.deleteContents === "function") {
              range.deleteContents();

              while (newNodes.firstChild) {
                range.insertNode(newNodes.firstChild);
              }
            }
          } catch (e) {
            console.warn(e);
          }
        }
      }
      /**
       * Created life-cycle to ensure a single global store.
       */

    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_f489be30dedc11e9bf5a076df0f16721());
      }
    }, {
      key: "tag",
      get: function get() {
        return "hax-store";
      }
      /**
       * Complex observer composites used for initial timing since this is a skeleton setup
       */

    }, {
      key: "observers",
      get: function get() {
        return ["_loadAppStoreData(__ready, __appStoreData, haxAutoloader)", "_storePiecesAllHere(haxAutoloader,activeHaxBody, haxPanel, haxToast, haxExport, haxPreferences, haxManager, haxStaxPicker, haxAppPicker)"];
      }
    }, {
      key: "properties",
      get: function get() {
        return Object.assign({
          /**
           * skipHAXConfirmation
           */
          skipHAXConfirmation: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },

          /**
           * Local storage bridge
           */
          storageData: {
            type: Object,
            value: {},
            observer: "_storageDataChanged"
          },

          /**
           * Hax app picker element.
           */
          haxAppPicker: {
            type: Object
          },

          /**
           * Hax stax picker element.
           */
          haxStaxPicker: {
            type: Object
          },

          /**
           * Hax manager element.
           */
          haxManager: {
            type: Object
          },

          /**
           * Hax autoloader element.
           */
          haxAutoloader: {
            type: Object
          },

          /**
           * A list of all haxBodies that exist
           */
          haxBodies: {
            type: Array,
            value: []
          },

          /**
           * An active place holder item reference. This is used
           * for inline drag and drop event detection so that we
           * know what element replace in context.
           */
          activePlaceHolder: {
            type: Object,
            value: null
          },

          /**
           * The hax-body that is currently active.
           */
          activeHaxBody: {
            type: Object
          },

          /**
           * Possible appStore endpoint for loading in things dynamically.
           */
          appStore: {
            type: Object,
            observer: "_appStoreChanged"
          },

          /**
           * HAX Toast message.
           */
          haxToast: {
            type: Object
          },

          /**
           * Hax panel element.
           */
          haxPanel: {
            type: Object
          },

          /**
           * Hax export dialog element.
           */
          haxExport: {
            type: Object
          },

          /**
           * Hax preferences dialog element.
           */
          haxPreferences: {
            type: Object
          },

          /**
           * Active HAX Element if we have one we are working on.
           */
          activeHaxElement: {
            type: Object
          },

          /**
           * Active Node.
           */
          activeNode: {
            type: Object
          },

          /**
           * Active container Node, 2nd highest parent of activeNode.
           */
          activeContainerNode: {
            type: Object
          },

          /**
           * Session object bridged in from a session method of some kind
           */
          sessionObject: {
            type: Object,
            value: {}
          },

          /**
           * editMode
           */
          editMode: {
            type: Boolean,
            value: false,
            observer: "_editModeChanged"
          },

          /**
           * Boolean for if this instance has backends that support uploading
           */
          canSupportUploads: {
            type: Boolean,
            value: false
          },

          /**
           * skip the exit trap to prevent losing data
           */
          skipExitTrap: {
            type: Boolean,
            value: false
          },

          /**
           * Default settings that can be overridden as needed
           */
          defaults: {
            type: Object,
            value: {
              image: {
                src: "stock.jpg",
                alt: "A beachfront deep in the heart of Alaska."
              },
              iframe: {
                src: "https://www.wikipedia.org/"
              }
            }
          },

          /**
           * Available gizmos.
           */
          gizmoList: {
            type: Array,
            value: []
          },

          /**
           * Available elements keyed by tagName and with
           * their haxProperties centrally registered.
           */
          elementList: {
            type: Object,
            value: {}
          },

          /**
           * Available apps of things supplying media / content.
           */
          appList: {
            type: Array,
            value: []
          },

          /**
           * Available hax stax which are just re-usable templates
           */
          staxList: {
            type: Array,
            value: []
          },

          /**
           * Available hax blox which are grid plate / layout elements
           */
          bloxList: {
            type: Array,
            value: []
          },

          /**
           * Global preferences that HAX can write to and
           * other elements can use to go off of.
           */
          globalPreferences: {
            type: Object,
            value: {},
            observer: "_globalPreferencesChanged"
          },

          /**
           * Globally active app, used for brokering communications
           */
          activeApp: {
            type: Object,
            value: {}
          },

          /**
           * Valid tag list, tag only and including primatives for a baseline.
           */
          validTagList: {
            type: Array,
            value: ["p", "div", "span", "table", "sup", "sub", "u", "strike", "tr", "td", "ol", "ul", "li", "a", "strong", "kbd", "em", "i", "b", "hr", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "code", "figure", "img", "iframe", "video", "audio", "section", "grid-plate", "template", "webview"]
          },

          /**
           * Gizmo types which can be used to bridge apps to gizmos.
           */
          validGizmoTypes: {
            type: Array,
            value: ["data", "video", "audio", "text", "link", "file", "pdf", "image", "csv", "doc", "content", "text", "inline", "*"]
          },

          /**
           * Sandboxed environment test
           */
          _isSandboxed: {
            type: Boolean,
            value: function value() {
              var test = document.createElement("webview"); // if this function exists it means that our deploy target
              // is in a sandboxed environment and is not able to run iframe
              // content with any real stability. This is beyond edge case but
              // as this is an incredibly useful tag we want to make sure it
              // can mutate to work in chromium and android environments
              // which support such sandboxing

              if (typeof test.reload === "function") {
                return true;
              }

              return false;
            }
          },

          /**
           * Internal app store data property after request
           */
          __appStoreData: {
            type: Object
          },
          __ready: {
            type: Boolean
          },
          voiceCommands: {
            type: Object
          },

          /**
           * Support for deploy specific rewriting for things like JWTs
           */
          connectionRewrites: {
            type: Object,
            value: {}
          }
        }, babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore), "properties", this));
      }
    }]);

    function HaxStore() {
      var _this;

      babelHelpers.classCallCheck(this, HaxStore);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxStore).call(this));
      (0, _settings.setPassiveTouchGestures)(true); // helps promose polyfill for this to be 1 execution chain as opposed to multiple

      new Promise(function (res, rej) {
        return _require.default(["./hax-store-dynamic.js"], res, rej);
      }); // claim the instance spot. This way we can easily
      // be referenced globally

      if (window.HaxStore.instance == null) {
        window.HaxStore.instance = babelHelpers.assertThisInitialized(_this);
      }

      _this.haxToast = window.SimpleToast.requestAvailability(); // notice hax property definitions coming from anywhere

      window.addEventListener("hax-register-properties", _this._haxStoreRegisterProperties.bind(babelHelpers.assertThisInitialized(_this))); // app registration can come in automatically from app-stores
      // or through direct definition in the DOM

      document.body.addEventListener("hax-register-app", _this._haxStoreRegisterApp.bind(babelHelpers.assertThisInitialized(_this))); // register stax which are groupings of haxElements

      document.body.addEventListener("hax-register-stax", _this._haxStoreRegisterStax.bind(babelHelpers.assertThisInitialized(_this))); // register blox which are grid plate configurations
      // with lots of sane visual defaults

      document.body.addEventListener("hax-register-blox", _this._haxStoreRegisterBlox.bind(babelHelpers.assertThisInitialized(_this))); // register the pieces of the body of what we call HAX
      // think of this like the core of the system required
      // to do anything like have buttons or state management
      // write data to the store

      document.body.addEventListener("hax-store-write", _this._writeHaxStore.bind(babelHelpers.assertThisInitialized(_this))); // register the manager panel / modal

      document.body.addEventListener("hax-register-manager", _this._haxStoreRegisterManager.bind(babelHelpers.assertThisInitialized(_this))); // register the autoloader area for elements

      document.body.addEventListener("hax-register-autoloader", _this._haxStoreRegisterAutoloader.bind(babelHelpers.assertThisInitialized(_this))); // register a body, kind of a big deal

      document.body.addEventListener("hax-register-body", _this._haxStoreRegisterBody.bind(babelHelpers.assertThisInitialized(_this))); // register the interaction panel / menu

      document.body.addEventListener("hax-register-panel", _this._haxStoreRegisterPanel.bind(babelHelpers.assertThisInitialized(_this))); // register the app picker for contextual setting / option

      document.body.addEventListener("hax-register-app-picker", _this._haxStoreRegisterAppPicker.bind(babelHelpers.assertThisInitialized(_this))); // stax modal

      document.body.addEventListener("hax-register-stax-picker", _this._haxStoreRegisterStaxPicker.bind(babelHelpers.assertThisInitialized(_this))); // blox modal

      document.body.addEventListener("hax-register-blox-picker", _this._haxStoreRegisterBloxPicker.bind(babelHelpers.assertThisInitialized(_this))); // preferences modal

      document.body.addEventListener("hax-register-preferences", _this._haxStoreRegisterPreferences.bind(babelHelpers.assertThisInitialized(_this))); // export modal

      document.body.addEventListener("hax-register-export", _this._haxStoreRegisterExport.bind(babelHelpers.assertThisInitialized(_this))); // grid plate add item event

      document.body.addEventListener("grid-plate-add-item", _this.haxInsertAnything.bind(babelHelpers.assertThisInitialized(_this))); // notice content insert and help it along to the body

      document.body.addEventListener("hax-insert-content", _this._haxStoreInsertContent.bind(babelHelpers.assertThisInitialized(_this)));
      document.body.addEventListener("hax-insert-content-array", _this._haxStoreInsertMultiple.bind(babelHelpers.assertThisInitialized(_this)));
      window.addEventListener("hax-add-voice-command", _this._addVoiceCommand.bind(babelHelpers.assertThisInitialized(_this)));
      document.body.style.setProperty("--hax-ui-headings", "#d4ff77");
      return _this;
    }
    /**
     * Build HAX property definitions for primitives that we support.
     */


    babelHelpers.createClass(HaxStore, [{
      key: "_buildPrimitiveDefinitions",
      value: function _buildPrimitiveDefinitions() {
        // sandboxes need a webview definition
        // we don't want people making them but we need to
        // know how to edit them if asked
        if (window.HaxStore.instance._isSandboxed) {
          var webview = {
            canScale: true,
            canPosition: true,
            canEditSource: false,
            settings: {
              quick: [{
                attribute: "src",
                title: "Source",
                description: "The URL for this video.",
                inputMethod: "textfield",
                icon: "link",
                required: true,
                validationType: "url"
              }],
              configure: [{
                attribute: "src",
                title: "Source",
                description: "The URL for this video.",
                inputMethod: "textfield",
                icon: "link",
                required: true,
                validationType: "url"
              }],
              advanced: []
            }
          };
          this.setHaxProperties(webview, "webview");
        }

        var iframe = {
          canScale: true,
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "Basic iframe",
            description: "A basic iframe",
            icon: "icons:fullscreen",
            color: "grey",
            groups: ["Content"],
            handles: [{
              type: "link",
              source: "src",
              height: "height",
              width: "width"
            }],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            quick: [{
              attribute: "src",
              title: "Source",
              description: "The URL for this video.",
              inputMethod: "textfield",
              icon: "link",
              required: true,
              validationType: "url"
            }],
            configure: [{
              attribute: "src",
              title: "Source",
              description: "The URL for this video.",
              inputMethod: "textfield",
              icon: "link",
              required: true,
              validationType: "url"
            }],
            advanced: []
          }
        };
        this.setHaxProperties(iframe, "iframe");
        var img = {
          canScale: true,
          canPosition: true,
          canEditSource: false,
          gizmo: {
            title: "Image",
            description: "A basic img tag",
            icon: "image:image",
            color: "grey",
            groups: ["Image", "Media"],
            handles: [{
              type: "link",
              source: "src"
            }, {
              type: "image",
              source: "src",
              height: "height",
              width: "width"
            }],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            quick: [{
              attribute: "src",
              title: "Source",
              description: "The URL for this video.",
              inputMethod: "textfield",
              icon: "link",
              required: true,
              validationType: "url"
            }, {
              attribute: "alt",
              title: "Alt text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "alt",
              icon: "accessibility"
            }, {
              attribute: "height",
              title: "Height",
              description: "height in pixels of the item",
              inputMethod: "textfield",
              icon: "icons:swap-vert"
            }, {
              attribute: "width",
              title: "Width",
              description: "width in pixels of the item",
              inputMethod: "textfield",
              icon: "icons:swap-horiz"
            }],
            configure: [{
              attribute: "src",
              title: "Source",
              description: "The URL for this video.",
              inputMethod: "haxupload",
              icon: "link",
              required: true,
              validationType: "url"
            }, {
              attribute: "alt",
              title: "Alt text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "alt",
              icon: "accessibility"
            }, {
              attribute: "height",
              title: "Height",
              description: "height in pixels of the item",
              inputMethod: "textfield",
              icon: "icons:swap-vert"
            }, {
              attribute: "width",
              title: "Width",
              description: "width in pixels of the item",
              inputMethod: "textfield",
              icon: "icons:swap-horiz"
            }],
            advanced: []
          }
        };
        this.setHaxProperties(img, "img");
        var ahref = {
          canScale: false,
          canPosition: false,
          canEditSource: true,
          gizmo: {
            title: "Basic link",
            description: "A basic a tag",
            icon: "icons:link",
            color: "grey",
            groups: ["Link"],
            handles: [{
              type: "link",
              source: "href",
              title: "innerText",
              alt: "title"
            }],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            quick: [{
              attribute: "href",
              title: "Link",
              description: "The URL for this video.",
              inputMethod: "textfield",
              icon: "icons:link",
              required: true,
              validationType: "url"
            }, {
              attribute: "title",
              title: "Title text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "textfield",
              icon: "icons:accessibility"
            }],
            configure: [{
              attribute: "innerText",
              title: "Text",
              description: "Text of the link",
              inputMethod: "textfield",
              required: true
            }, {
              attribute: "href",
              title: "Link",
              description: "The URL for this video.",
              inputMethod: "haxupload",
              icon: "icons:link",
              required: true,
              validationType: "url"
            }, {
              attribute: "title",
              title: "Title text",
              description: "Useful for screen readers and improved SEO.",
              inputMethod: "textfield",
              icon: "icons:accessibility"
            }, {
              attribute: "target",
              title: "Target",
              description: "Where to place the link.",
              inputMethod: "select",
              icon: "icons:launch",
              options: {
                "": "Same window",
                _blank: "New window",
                _top: "Top window",
                _parent: "Parent window"
              }
            }],
            advanced: []
          }
        };
        this.setHaxProperties(ahref, "a");
        var p = {
          canScale: false,
          canPosition: false,
          canEditSource: true,
          gizmo: {
            title: "Paragraph",
            description: "A basic text area",
            icon: "editor:short-text",
            color: "grey",
            groups: ["Text"],
            handles: [{
              type: "content",
              content: ""
            }],
            meta: {
              author: "W3C"
            }
          },
          settings: {
            quick: [],
            configure: [{
              slot: "",
              title: "Content",
              description: "Internal content",
              inputMethod: "code-editor",
              icon: "icons:code"
            }],
            advanced: []
          }
        };
        this.setHaxProperties(p, "p");
        var hr = {
          canScale: true,
          canPosition: true,
          canEditSource: false,
          settings: {
            quick: [],
            configure: [],
            advanced: []
          }
        };
        this.setHaxProperties(hr, "hr");
        this.setHaxProperties(_codeSample.CodeSample.haxProperties, _codeSample.CodeSample.tag);
      }
      /**
       * Set the haxManager node so we can interface with it.
       * This also allows for using a different manager that supplies
       * the same functions if that would be desired at some point.
       */

    }, {
      key: "_haxStoreRegisterManager",
      value: function _haxStoreRegisterManager(e) {
        if (e.detail && babelHelpers.typeof(this.haxManager) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.haxManager = e.detail;
        }
      }
      /**
       * Register autoloader so we can ship to it from app-store spec
       */

    }, {
      key: "_haxStoreRegisterAutoloader",
      value: function _haxStoreRegisterAutoloader(e) {
        if (e.detail && babelHelpers.typeof(this.haxAutoloader) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.haxAutoloader = e.detail;
        }
      }
      /**
       * Set the appPicker node so we can interface with it.
       * This helps with picking between multiple options when we need the user
       * to decide between a sub-set of options
       */

    }, {
      key: "_haxStoreRegisterAppPicker",
      value: function _haxStoreRegisterAppPicker(e) {
        if (e.detail && babelHelpers.typeof(this.haxAppPicker) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.haxAppPicker = e.detail;
        }
      }
      /**
       * Set the stax picker so that we have an element in charge
       * of the listing of available stax.
       */

    }, {
      key: "_haxStoreRegisterStaxPicker",
      value: function _haxStoreRegisterStaxPicker(e) {
        if (e.detail && babelHelpers.typeof(this.haxStaxPicker) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.haxStaxPicker = e.detail;
        }
      }
      /**
       * Set the blox picker so that we have an element in charge
       * of the listing of available blox.
       */

    }, {
      key: "_haxStoreRegisterBloxPicker",
      value: function _haxStoreRegisterBloxPicker(e) {
        if (e.detail && babelHelpers.typeof(this.haxBloxPicker) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.haxBloxPicker = e.detail;
        }
      }
      /**
       * Close all drawers
       */

    }, {
      key: "closeAllDrawers",
      value: function closeAllDrawers() {
        var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        // walk all drawers, close everything
        // except active. This also will allow them
        // to close everything then.
        var drawers = ["haxManager", "haxBloxPicker", "haxStaxPicker", "haxPreferences", "haxExport"];

        for (var i in drawers) {
          if (active === this[drawers[i]]) {
            active.open();

            if (drawers[i] === "haxManager") {
              setTimeout(function () {
                if (active.querySelector("#activepage .iron-selected paper-input") != null) {
                  active.querySelector("#activepage .iron-selected paper-input").focus();
                }

                var evt = document.createEvent("UIEvents");
                evt.initUIEvent("resize", true, false, window, 0);
                window.dispatchEvent(evt);
              }, 325);
            } else {
              setTimeout(function () {
                if (active.querySelector("paper-checkbox,paper-input,textarea,paper-button") != null) {
                  active.querySelector("paper-checkbox,paper-input,textarea,paper-button").focus();
                }

                var evt = document.createEvent("UIEvents");
                evt.initUIEvent("resize", true, false, window, 0);
                window.dispatchEvent(evt);
              }, 325);
            }
          } else {
            this[drawers[i]].close();
          }
        }
      }
      /**
       * Insert content in the body.
       */

    }, {
      key: "_haxStoreInsertContent",
      value: function _haxStoreInsertContent(e) {
        var _this6 = this;

        if (e.detail) {
          var details = e.detail;

          if (window.customElements.get(details.tag)) {
            var prototype = Object.getPrototypeOf(document.createElement(details.tag)); // support for deep API call to clean up special elements

            if (babelHelpers.typeof(prototype.preProcessHaxInsertContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              details = prototype.preProcessHaxInsertContent(details);
            }
          }

          var properties = {}; // support for properties to be set automatically optionally

          if (babelHelpers.typeof(details.properties) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            properties = details.properties;
          } // support / clean up properties / attributes that have innerHTML / innerText
          // these are reserved words but required for certain bindings


          if (properties.innerHTML) {
            if (details.content == "") {
              details.content = properties.innerHTML;
            }

            delete properties.innerHTML;
          }

          if (properties.innerText) {
            if (details.content == "") {
              details.content = properties.innerText;
            }

            delete properties.innerText;
          } // ensure better UX for text based operations


          this.activeHaxBody.__activeHover = null; // invoke insert or replacement on body, same function so it's easier to trace

          if (details.replace && details.replacement) {
            var node = window.HaxStore.haxElementToNode(details.tag, details.content, properties);

            if (this.activePlaceHolder) {
              this.activeHaxBody.haxReplaceNode(this.activePlaceHolder, node, this.activePlaceHolder.parentNode);
              this.activePlaceHolder = null;
            } else {
              this.activeHaxBody.haxReplaceNode(this.activeNode, node, this.activeNode.parentNode);
            }
          } else if (babelHelpers.typeof(details.__type) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && details.__type === "inline") {
            var _node = window.HaxStore.haxElementToNode(details.tag, details.content, properties); // replace what WAS the active selection w/ this new node


            if (this.activePlaceHolder !== null) {
              this.activePlaceHolder.deleteContents();
              this.activePlaceHolder.insertNode(_node);
            } // set it to nothing


            this.activePlaceHolder = null;
          } else if (this.activeContainerNode != null) {
            var _node2 = window.HaxStore.haxElementToNode(details.tag, details.content, properties); // allow for inserting things into things but not grid plate


            if (this.activeContainerNode && this.activeContainerNode.tagName === "GRID-PLATE") {
              // support slot if we have one on the activeNode (most likely)
              if (this.activeNode.getAttribute("slot") != null) {
                _node2.setAttribute("slot", this.activeNode.getAttribute("slot"));
              }

              (0, _polymerDom.dom)(this.activeContainerNode).appendChild(_node2);
              this.activeHaxBody.$.textcontextmenu.highlightOps = false;
              this.activeHaxBody.__updateLockFocus = _node2; // wait so that the DOM can have the node to then attach to

              setTimeout(function () {
                _this6.activeHaxBody.breakUpdateLock();
              }, 50);
            } else {
              this.activeHaxBody.haxInsert(details.tag, details.content, properties);
            }
          } else {
            this.activeHaxBody.haxInsert(details.tag, details.content, properties);
          }
        }
      }
      /**
       * Present all elements to potentially insert
       */

    }, {
      key: "haxInsertAnything",
      value: function haxInsertAnything(e) {
        var haxElements = [];

        for (var i in window.HaxStore.instance.gizmoList) {
          haxElements.push(window.HaxStore.haxElementPrototype(window.HaxStore.instance.gizmoList[i], e.detail.properties, ""));
        } // hand off to hax-app-picker to deal with the rest of this


        window.HaxStore.instance.haxAppPicker.presentOptions(haxElements, "element", "Add an element", "gizmo");
      }
      /**
       * Optional send array, to improve performance and event bubbling better
       */

    }, {
      key: "_haxStoreInsertMultiple",
      value: function _haxStoreInsertMultiple(e) {
        var _this7 = this;

        if (e.detail) {
          var properties;

          for (var i in e.detail) {
            properties = {}; // support for properties to be set automatically optionally

            if (babelHelpers.typeof(e.detail[i].properties) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              properties = e.detail[i].properties;
            }

            this.activeHaxBody.haxInsert(e.detail[i].tag, e.detail[i].content, properties, false);
          }

          setTimeout(function () {
            _this7.activeHaxBody.breakUpdateLock();
          }, 300);
        }
      }
      /**
       * Set the activeHaxBody and add to the list so we know what to insert into.
       */

    }, {
      key: "_haxStoreRegisterBody",
      value: function _haxStoreRegisterBody(e) {
        if (e.detail) {
          this.haxBodies.push(e.detail); // default active the whatever is last here

          this.activeHaxBody = e.detail; // needed so that higher order things can respond to us having a body

          window.HaxStore.write("activeHaxBody", this.activeHaxBody, this);
          window.HaxStore.write("editMode", this.editMode, this);
        }
      }
      /**
       * Set the haxPanel so we know what to insert into.
       */

    }, {
      key: "_haxStoreRegisterPanel",
      value: function _haxStoreRegisterPanel(e) {
        if (e.detail && babelHelpers.typeof(this.haxPanel) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.haxPanel = e.detail;
        }
      }
      /**
       * Set the haxExport so we know who to call for exporting
       */

    }, {
      key: "_haxStoreRegisterExport",
      value: function _haxStoreRegisterExport(e) {
        if (e.detail && babelHelpers.typeof(this.haxExport) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.haxExport = e.detail;
        }
      }
      /**
       * Set the haxPreferences so we know what has global preferences
       */

    }, {
      key: "_haxStoreRegisterPreferences",
      value: function _haxStoreRegisterPreferences(e) {
        if (e.detail && babelHelpers.typeof(this.haxPreferences) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.haxPreferences = e.detail;
        }
      }
      /**
       * Feature detect on the bar.
       */

    }, {
      key: "computePolyfillSafe",
      value: function computePolyfillSafe() {
        /**
         * These are our bad actors in polyfill'ed browsers.
         * This means that https://github.com/webcomponents/webcomponentsjs/commit/ce464bb533bf39b544c312906499a6044ee0d30d
         * explains things but basically if shadow-dom is polyfilled
         * then we can't safely execute a DOM manipulating execCommand.
         * This
         */
        if (document.head.createShadowRoot || document.head.attachShadow) {
          return true;
        } else {
          console.warn("Shadow DOM missing, certain operations hidden");
          return false;
        }
      }
      /**
       * Write store event callback.
       */

    }, {
      key: "_writeHaxStore",
      value: function _writeHaxStore(e) {
        // ensure we have a valid store write
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property && e.detail.owner) {
          if (e.detail.value == null) {
            this.set(e.detail.property, null);
          } else if (babelHelpers.typeof(e.detail.value) === "object") {
            this.set(e.detail.property, {});
          }

          if (this.globalPreferences && this.globalPreferences.haxDeveloperMode) {
            console.warn(e.detail.property);
          }

          this.set(e.detail.property, e.detail.value);
          this.dispatchEvent(new CustomEvent("hax-store-property-updated", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: {
              property: e.detail.property,
              value: e.detail.value,
              owner: e.detail.owner
            }
          }));
        }
      }
      /**
       * Notice that an app was set in HAX; register it
       */

    }, {
      key: "_haxStoreRegisterApp",
      value: function _haxStoreRegisterApp(e) {
        if (e.detail) {
          e.detail.index = this.appList.length;
          this.push("appList", e.detail);
          window.HaxStore.write("appList", this.appList, this); // preconnect apps at registration time

          if (e.detail.connection && e.detail.connection.protocol && e.detail.connection.url) {
            var preconnectlink = document.createElement("link");
            preconnectlink.rel = "preconnect";
            preconnectlink.href = e.detail.connection.protocol + "://" + e.detail.connection.url;
            document.head.appendChild(preconnectlink);
          } // we don't care about this after it's launched


          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-STORE") {
            (0, _polymerDom.dom)(e.target.parentElement).removeChild(e.target);
          }
        }
      }
      /**
       * Notice that a stax was set in HAX; register it
       */

    }, {
      key: "_haxStoreRegisterStax",
      value: function _haxStoreRegisterStax(e) {
        if (e.detail) {
          e.detail.index = this.staxList.length;
          this.push("staxList", e.detail);
          window.HaxStore.write("staxList", this.staxList, this); // we don't care about this after it's launched

          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-STORE") {
            (0, _polymerDom.dom)(e.target.parentElement).removeChild(e.target);
          }
        }
      }
      /**
       * Notice that a blox was set in HAX; register it
       */

    }, {
      key: "_haxStoreRegisterBlox",
      value: function _haxStoreRegisterBlox(e) {
        if (e.detail) {
          e.detail.index = this.bloxList.length;
          this.push("bloxList", e.detail);
          window.HaxStore.write("bloxList", this.bloxList, this); // we don't care about this after it's launched

          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-STORE") {
            (0, _polymerDom.dom)(e.target.parentElement).removeChild(e.target);
          }
        }
      }
      /**
       * Notice that a property off an element was set in HAX some place; register it here
       */

    }, {
      key: "_haxStoreRegisterProperties",
      value: function _haxStoreRegisterProperties(e) {
        if (e.detail && e.detail.properties && e.detail.tag) {
          // only register tag if we don't know about it already
          if (babelHelpers.typeof(this.elementList[e.detail.tag]) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            // look for a gizmo; it's not required, technically.
            var gizmo = e.detail.properties.gizmo;

            if (gizmo) {
              gizmo.tag = e.detail.tag;
              var gizmos = this.gizmoList;
              gizmos.push(gizmo);
              window.HaxStore.write("gizmoList", gizmos, this);
            }

            this.set("elementList." + e.detail.tag, e.detail.properties); // only push new values on if we got something new

            if (!this.validTagList.find(function (element) {
              return element === e.detail.tag;
            })) {
              this.push("validTagList", e.detail.tag);
            }
          } // delete this tag if it was in the autoloader as it has served it's purpose.


          if (babelHelpers.typeof(e.target.parentElement) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.target.parentElement.tagName === "HAX-AUTOLOADER") {
            (0, _polymerDom.dom)(this.haxAutoloader).removeChild(e.target);
          }
        }
      }
    }]);
    return HaxStore;
  }((0, _haxBodyBehaviors.HAXElement)((0, _mediaBehaviors.MediaBehaviorsVideo)(_polymerElement.PolymerElement)));
  /**
   * Trick to write the store to the DOM if it wasn't there already.
   * This is not used yet but could be if you wanted to dynamically
   * load the store based on something else calling for it. Like
   * store lazy loading but it isn't tested.
   */


  _exports.HaxStore = HaxStore;
  window.HaxStore = window.HaxStore || {};
  window.HaxStore.instance = null;

  window.HaxStore.requestAvailability = function () {
    if (!window.HaxStore.instance) {
      window.HaxStore.instance = document.createElement("hax-store");
      document.body.appendChild(window.HaxStore.instance);
    }

    return window.HaxStore.instance;
  };
  /**
   * Simple Array smashing function to ensure Object is array.
   */


  window.HaxStore.toArray = function (obj) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    });
  };
  /**
   * Helper to convert camel case to dash; important when setting attributes.
   */


  window.HaxStore.camelToDash = function (str) {
    return str.replace(/\W+/g, "-").replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
  };
  /**
   * Helper to convert dash to camel; important when reading attributes.
   */


  window.HaxStore.dashToCamel = function (str) {
    return str.replace(/-([a-z])/g, function (g) {
      return g[1].toUpperCase();
    });
  };
  /**
   * Convert HTML into HAX Elements
   */


  window.HaxStore.htmlToHaxElements = function (html) {
    var elements = [];
    var validTags = window.HaxStore.instance.validTagList;
    var fragment = document.createElement("div");
    fragment.innerHTML = html;
    var children = fragment.childNodes; // loop over the new nodes

    for (var i = 0; i < children.length; i++) {
      // verify this tag is a valid one
      if (babelHelpers.typeof(children[i].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && validTags.includes(children[i].tagName.toLowerCase())) {
        elements.push(window.HaxStore.nodeToHaxElement(children[i], null));
      }
    }

    return elements;
  };
  /**
   * Convert a node to a HAX element. Hax elements ensure
   * a certain level of sanitization by verifying tags and
   * properties / attributes that have values.
   */


  window.HaxStore.nodeToHaxElement = function (node) {
    var eventName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "insert-element";

    if (!node) {
      return null;
    } // build out the properties to send along


    var props = {}; // support basic styles

    if (babelHelpers.typeof(node.style) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      props.style = node.getAttribute("style");
    } // don't set a null style


    if (props.style === null || props.style === "null") {
      delete props.style;
    } // test if a class exists, not everything scopes


    if (babelHelpers.typeof(node.attributes.class) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      props.class = node.attributes.class.nodeValue.replace("hax-active", "");
    } // test if a id exists as its a special case in attributes... of course


    if (babelHelpers.typeof(node.attributes.id) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      props.id = node.getAttribute("id");
    }

    var tmpProps; // relatively cross library

    if (customElements.get(node.tagName.toLowerCase())) {
      tmpProps = customElements.get(node.tagName.toLowerCase()).properties;
    } // weak fallback


    if (babelHelpers.typeof(tmpProps) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      tmpProps = node.__data;
    } // complex elements need complex support


    if (babelHelpers.typeof(tmpProps) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      // run through attributes, though non-reflected props won't be here
      // run through props, we always defer to property values
      for (var property in tmpProps) {
        // make sure we only set things that have a value
        if (property != "class" && property != "style" && tmpProps.hasOwnProperty(property) && babelHelpers.typeof(node[property]) !== undefined && node[property] != null && node[property] != "") {
          props[property] = node[property];
        } // special support for false boolean
        else if (node[property] === false) {
            props[property] = node[property];
          } else {}
      }

      for (var attribute in node.attributes) {
        // make sure we only set things that have a value
        if (babelHelpers.typeof(node.attributes[attribute].name) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.attributes[attribute].name != "class" && node.attributes[attribute].name != "style" && node.attributes[attribute].name != "id" && node.attributes.hasOwnProperty(attribute) && babelHelpers.typeof(node.attributes[attribute].value) !== undefined && node.attributes[attribute].value != null && node.attributes[attribute].value != "" && !tmpProps.hasOwnProperty(window.HaxStore.dashToCamel(node.attributes[attribute].name))) {
          props[window.HaxStore.dashToCamel(node.attributes[attribute].name)] = node.attributes[attribute].value;
        } else {// note: debug here if experiencing attributes that won't bind
        }
      }
    } else {
      // much easier case, usually just in primatives
      for (var attribute in node.attributes) {
        // make sure we only set things that have a value
        if (babelHelpers.typeof(node.attributes[attribute].name) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.attributes[attribute].name != "class" && node.attributes[attribute].name != "style" && node.attributes[attribute].name != "id" && node.attributes.hasOwnProperty(attribute) && babelHelpers.typeof(node.attributes[attribute].value) !== undefined && node.attributes[attribute].value != null && node.attributes[attribute].value != "") {
          props[window.HaxStore.dashToCamel(node.attributes[attribute].name)] = node.attributes[attribute].value;
        }
      }
    } // support sandboxed environments which
    // will hate iframe tags but love webview


    var tag = node.tagName.toLowerCase();

    if (window.HaxStore.instance._isSandboxed && tag === "iframe") {
      tag = "webview";
    }

    var slotContent = window.HaxStore.getHAXSlot(node); // support fallback on inner text if there were no nodes

    if (slotContent == "") {
      slotContent = node.innerText;
    } // special edge case for slot binding in primatives


    if (tag === "a") {
      props.innerText = slotContent;
    } else if (tag === "p" || tag === "ol" || tag === "ul" || tag === "div") {
      props.innerHTML = slotContent;
    }

    var element = {
      tag: tag,
      properties: props,
      content: slotContent
    };

    if (eventName !== null) {
      element.eventName = eventName;
    }

    return element;
  };
  /**
   * Convert a haxElement to a DOM node.
   */


  window.HaxStore.haxElementToNode = function (tag, content, properties) {
    // support sandboxed environments which
    // will hate iframe tags but love webview
    if (window.HaxStore.instance._isSandboxed && tag === "iframe") {
      tag = "webview";
    }

    var frag = document.createElement(tag);
    frag.innerHTML = content; // clone the fragment which will force an escalation to full node

    var newNode = frag.cloneNode(true); // support for properties if they exist

    for (var property in properties) {
      var attributeName = window.HaxStore.camelToDash(property);

      if (properties.hasOwnProperty(property)) {
        // special supporting for boolean because html is weird :p
        if (properties[property] === true) {
          newNode.setAttribute(attributeName, properties[property]);
        } else if (properties[property] === false) {
          newNode.removeAttribute(attributeName);
        } else if (properties[property] != null && properties[property].constructor === Array) {
          // do nothing if we have additional data to suggest this is actually readOnly
          // polymer / typed specific thing
          if (frag.properties && frag.properties[property] && frag.properties[property].readOnly) {} else {
            newNode.set(attributeName, properties[property]);
          }
        } else if (properties[property] != null && properties[property].constructor === Object) {
          // do nothing if we have additional data to suggest this is actually readOnly
          // polymer / typed specific thing
          if (frag.properties && frag.properties[property] && frag.properties[property].readOnly) {} else {
            newNode.set(attributeName, properties[property]);
          }
        } else {
          newNode.setAttribute(attributeName, properties[property]);
        }
      }
    }

    return newNode;
  };
  /**
   * Convert a node to the correct content object for saving.
   * This DOES NOT acccept a HAXElement which is similar
   */


  window.HaxStore.nodeToContent = function (node) {
    if (window.HaxStore.instance.activeHaxBody.globalPreferences.haxDeveloperMode) {
      console.warn(node);
    } // ensure we have access to all the member functions of the custom element


    var prototype = Object.getPrototypeOf(node); // support for deep API call

    if (babelHelpers.typeof(prototype.preProcessHaxNodeToContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      var clone = node.cloneNode(true);
      node = prototype.preProcessHaxNodeToContent(clone);
    }

    var tag = node.tagName.toLowerCase(); // support sandboxed environments which
    // will hate iframe tags but love webview

    if (window.HaxStore.instance._isSandboxed && tag === "webview") {
      tag = "iframe";
    }

    var content = ""; // start to rebuild the same tag we got in a generalized way

    content += "<" + tag; // account for things that say NOT to save slot values

    var props = window.HaxStore.instance.elementList[tag];
    var propvals = {}; // grab all of the original's attributes, and pass them to the replacement

    for (var j = 0, l = node.attributes.length; j < l; ++j) {
      var nodeName = node.attributes.item(j).nodeName;
      var value = node.attributes.item(j).value; // encode objects and arrays because they are special

      if (nodeName != "style" && (babelHelpers.typeof(value) === (typeof Object === "undefined" ? "undefined" : babelHelpers.typeof(Object)) || value.constructor === Array)) {
        propvals[nodeName] = JSON.stringify(value).replace(new RegExp('"', "g"), "&quot;");
      } // only write things that aren't empty
      else if (value != null && value != "null") {
          if (value === true || value === "true") {
            propvals[nodeName] = true;
          } else if (value === false) {// do nothing, no reason to record false unless written as text
            // in which case below will capture it
          } else {
            // ensure that value doesn't have " in it unencoded
            if (typeof value === "string" && value !== "") {
              value = value.replace(new RegExp('"', "g"), "&quot;");
              propvals[nodeName] = value;
            } // special handling for empty string cause it might mean boolean
            // or it might be a string
            else if (value === "") {
                if (value == "" && node.attributes.item(j).value != "") {
                  value = node.attributes.item(j).value;
                }

                propvals[nodeName] = value;
              } else {
                propvals[nodeName] = value;
              }
          }
        }
    } // now look through properties


    var tmpProps; // relatively cross library

    if (customElements.get(tag)) {
      tmpProps = customElements.get(tag).properties;
    } // weak fallback


    if (babelHelpers.typeof(tmpProps) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      tmpProps = node.__data;
    }

    if (babelHelpers.typeof(tmpProps) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      for (var j in tmpProps) {
        var nodeName = window.HaxStore.camelToDash(j);
        var value = null; // prefer local value over properties object if possible

        if (babelHelpers.typeof(node[j]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          value = node[j];
        } // never allow read only things to recorded as they
        // are run-time creation 99% of the time
        // this is very polymer specific but it allows readOnly and computed props


        if (!tmpProps[j].readOnly && !tmpProps[j].computed && value !== tmpProps[j].value) {
          // encode objects and arrays because they are special
          if (value != null && (babelHelpers.typeof(value) === (typeof Object === "undefined" ? "undefined" : babelHelpers.typeof(Object)) || value.constructor === Array)) {
            propvals[nodeName] = JSON.stringify(value).replace(new RegExp('"', "g"), "&quot;");
          } // only write things that aren't empty
          else if (value != null && value != "null") {
              if (value === true || value === "true") {
                propvals[nodeName] = true;
              } else if (value === false) {// do nothing, no reason to record false unless written as text
                // in which case below will capture it
              } else {
                // ensure that value doesn't have " in it unencoded
                if (typeof value === "string" && value !== "") {
                  value = value.replace(new RegExp('"', "g"), "&quot;");
                  propvals[nodeName] = value;
                } // special handling for empty string cause it might mean boolean
                // or it might be a string
                else if (value === "") {
                    if (value == "" && tmpProps[j].value != "") {
                      value = tmpProps[j].value;
                    } else if (value === "" && tmpProps[j].value == "") {// do nothing, the default value is empty
                      // so lets record less data
                    }
                  } else {
                    propvals[nodeName] = value;
                  }
              }
            }
        }
      }
    } // support for tag defining which properties NOT to save
    // for simplification, everything is an attribute during this
    // operation


    if (babelHelpers.typeof(props) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(props.saveOptions.unsetAttributes) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      for (var i in props.saveOptions.unsetAttributes) {
        delete propvals[props.saveOptions.unsetAttributes[i]];
      }
    } // specialized clean up for some that can leak through from above
    // and are edge case things because #hashtag gotta love HTML attributes
    // and the webview tag. facepalm.


    var delProps = ["inner-text", "inner-html", "tabindex", "guestinstance"];

    for (var delProp in delProps) {
      if (babelHelpers.typeof(propvals[delProps[delProp]]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
        delete propvals[delProps[delProp]];
      }
    } // remove id attribute if it's empty, somehow misses above


    if (babelHelpers.typeof(propvals.id) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && propvals.id === "") {
      delete propvals.id;
    } // run through the properties


    for (var i in propvals) {
      if (propvals[i] === true) {
        content += " " + i;
      } else {
        content += " " + i + '="' + propvals[i] + '"';
      }
    } // set the opening tag, support self-closing void tags


    var voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];

    if (voidTags.includes(tag)) {
      content += "/>";
    } else {
      content += ">";
    } // try and work against anything NOT a P tag


    if (babelHelpers.typeof(props) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) || !props.saveOptions.wipeSlot) {
      // get content that is in the slots
      var slotnodes = (0, _polymerDom.dom)(node).getEffectiveChildNodes(); // ensure there's something inside of this

      if (slotnodes.length > 0) {
        // loop through everything found in the slotted area and put it back in
        for (var j = 0, len2 = slotnodes.length; j < len2; j++) {
          if (babelHelpers.typeof(slotnodes[j].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            // if we're a custom element, keep digging, otherwise a simple
            // self append is fine unless template tag cause it's a special
            // case for the web in general as it'll register as not a primative
            // even though it is...
            if (!window.HaxStore.HTMLPrimativeTest(slotnodes[j].tagName) && slotnodes[j].tagName !== "TEMPLATE") {
              content += window.HaxStore.nodeToContent(slotnodes[j]);
            } else {
              slotnodes[j].setAttribute("data-editable", false);
              slotnodes[j].removeAttribute("data-hax-ray");
              slotnodes[j].contentEditable = false;
              content += slotnodes[j].outerHTML;
            }
          } // keep comments with a special case since they need wrapped
          else if (slotnodes[j].nodeType === 8) {
              content += "<!-- " + slotnodes[j].textContent + " -->";
            } // keep everything NOT an element at this point, this helps
            // preserve whitespace because we're crazy about accuracy
            else if (slotnodes[j].nodeType !== 1 && babelHelpers.typeof(slotnodes[j].textContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && slotnodes[j].textContent !== "undefined") {
                content += slotnodes[j].textContent;
              }
        }
      }
    } // don't put return for span since it's an inline tag


    if (tag === "span") {
      content += "</" + tag + ">";
    } else if (tag === "hr" || tag === "br" || tag === "img") {} // do nothing for self-closing tags they'll resolve themselves
    // close the tag, placing a return in output for block elements
    else {
        content += "</" + tag + ">" + "\n";
      }

    if (window.HaxStore.instance.activeHaxBody.globalPreferences.haxDeveloperMode) {
      console.warn(content);
    } // support postProcess text rewriting for the node that's been
    // converted to a string for storage


    if (node.postProcesshaxNodeToContent === "function") {
      content = node.postProcesshaxNodeToContent(content);
    }

    return content;
  };
  /**
   * Basic HTML Primitives test
   */


  window.HaxStore.HTMLPrimativeTest = function (node) {
    if (babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.tagName.indexOf("-") == -1) {
      return true;
    }

    return false;
  };
  /**
   * Slot content w/ support for custom elements in slot.
   */


  window.HaxStore.getHAXSlot = function (node) {
    // we can skip all of this if we have a text element / HTML prim!
    if (window.HaxStore.instance.isTextElement(node)) {
      return node.innerHTML;
    }

    var content = "";
    var slotnodes = (0, _polymerDom.dom)(node).children; // ensure there's something inside of this

    if (slotnodes.length > 0) {
      // loop through everything found in the slotted area and put it back in
      for (var j = 0, len2 = slotnodes.length; j < len2; j++) {
        if (babelHelpers.typeof(slotnodes[j].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // if we're a custom element, keep digging, otherwise a simple
          // self append is fine.
          if (slotnodes[j].tagName.indexOf("-") > 0) {
            content += "  " + window.HaxStore.nodeToContent(slotnodes[j]) + "\n";
          } else {
            content += "  " + slotnodes[j].outerHTML + "\n";
          }
        } // keep comments with a special case since they need wrapped
        else if (slotnodes[j].nodeType === 8) {
            content += "<!-- " + slotnodes[j].textContent + " -->";
          } // keep everything NOT an element at this point, this helps
          // preserve whitespace because we're crazy about accuracy
          else if (slotnodes[j].nodeType !== 1 && babelHelpers.typeof(slotnodes[j].textContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && slotnodes[j].textContent !== "undefined") {
              content += slotnodes[j].textContent;
            }
      }
    }

    return content;
  };
  /**
   * Shortcut to standardize the write / read process.
   */


  window.HaxStore.write = function (prop, value, obj) {
    if (obj) {
      obj.dispatchEvent(new CustomEvent("hax-store-write", {
        composed: true,
        bubbles: true,
        cancelable: false,
        detail: {
          property: prop,
          value: value,
          owner: obj
        }
      }));
    }
  };
  /**
   * Guess the type of Gizmo when given some information about what we have.
   */


  window.HaxStore.guessGizmoType = function (guess) {
    if (babelHelpers.typeof(guess.source) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      if (guess.source.indexOf(".mp3") != -1) {
        return "audio";
      } else if (guess.source.indexOf(".png") != -1 || guess.source.indexOf(".jpg") != -1 || guess.source.indexOf(".jpeg") != -1 || guess.source.indexOf(".gif") != -1) {
        return "image";
      } else if (guess.source.indexOf(".pdf") != -1) {
        return "pdf";
      } else if (guess.source.indexOf(".svg") != -1) {
        return "svg";
      } else if (guess.source.indexOf(".csv") != -1) {
        return "csv";
      } // if it's external we can't assume what it actually is
      else if (window.HaxStore.instance.getVideoType(guess.source) != "external") {
          return "video";
        } else {
          // we don't know how to handle this so let's just
          // try ANYTHING that matches
          return "*";
        }
    }
  };
  /**
   * Try and guess the Gizmo based on what we were just handed
   */


  window.HaxStore.guessGizmo = function (guess, values) {
    var skipPropMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var matches = [];

    if (babelHelpers.typeof(guess) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
      var store = window.HaxStore.instance; // verify type

      if (store.validGizmoTypes.includes(guess)) {
        // now we can look through them
        // look for a match
        for (var gizmoposition in store.gizmoList) {
          var gizmo = store.gizmoList[gizmoposition];
          var props = {}; // reset match per gizmo

          var match = false;

          if (gizmo.handles) {
            for (var i = 0; i < gizmo.handles.length; i++) {
              // WHAT!??!?!?!?!
              if (guess === gizmo.handles[i].type || guess === "*" && !match) {
                for (var property in gizmo.handles[i]) {
                  // ignore type.. but again.. WHAT?!?!?!
                  if (property !== "type") {
                    // check the values that came across to see if there's a match
                    // of any kind, we only need one but can then bind to multiple
                    if (babelHelpers.typeof(values[property]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      match = true;
                      props[gizmo.handles[i][property]] = values[property];
                    }
                  }
                } // omg... we just found a match on a property from who knows where!


                if (match || skipPropMatch) {
                  matches.push(window.HaxStore.haxElementPrototype(gizmo, props, ""));
                }
              }
            }
          }
        }
      }
    }

    return matches;
  };
  /**
   * Filter app store apps to those that accept this file source.
   */


  window.HaxStore.getHaxAppStoreTargets = function (type) {
    var targets = window.HaxStore.instance.appList.filter(function (app) {
      if (babelHelpers.typeof(app.connection.operations.add) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
        var add = app.connection.operations.add;

        if (babelHelpers.typeof(add.acceptsGizmoTypes) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && add.acceptsGizmoTypes.includes(type)) {
          return true;
        }
      }

      return false;
    });
    return targets;
  };
  /**
   * Generate Hax Element prototype.
   */


  window.HaxStore.haxElementPrototype = function (gizmo, properties) {
    var content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
    return {
      tag: gizmo.tag,
      properties: properties,
      content: content,
      gizmo: gizmo
    };
  };
  /**
   * Wipe out the slot of an element.
   */


  window.HaxStore.wipeSlot = function (element) {
    var slot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    (0, _haxutils.wipeSlot)(element, slot);
  };
  /**
   * HTML encapsulation of a string on script and style tags
   */


  window.HaxStore.encapScript = function (html) {
    return (0, _haxutils.encapScript)(html);
  };
  /**
   * Global toast bridge so we don't have to keep writing custom event
   */


  window.HaxStore.toast = function (message) {
    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4000;
    var classStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
    var closeText = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var eventCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var evt = new CustomEvent("simple-toast-show", {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: {
        text: message,
        duration: duration,
        classStyle: classStyle,
        closeText: closeText,
        eventCallback: eventCallback
      }
    });
    window.dispatchEvent(evt);
  };
  /**
   * Selection normalizer
   */


  window.HaxStore.getSelection = function () {
    // try and obtain the selection from the nearest shadow
    // which would give us the selection object when running native ShadowDOM
    // with fallback support for the entire window which would imply Shady
    if (window.HaxStore.instance.activeHaxBody.parentNode) {
      // native API
      if (window.HaxStore.instance.activeHaxBody.parentNode.getSelection) {
        return window.HaxStore.instance.activeHaxBody.parentNode.getSelection();
      } // ponyfill from google
      else if ((0, _shadowsSafari.getRange)(window.HaxStore.instance.activeHaxBody.parentNode)) {
          return (0, _shadowsSafari.getRange)(window.HaxStore.instance.activeHaxBody.parentNode);
        }
    } // missed on both, hope the normal one will work


    return window.getSelection();
  };
  /**
   * Get a normalized range based on current selection
   */


  window.HaxStore.getRange = function () {
    var sel = window.HaxStore.getSelection();

    if (sel.getRangeAt && sel.rangeCount) {
      return sel.getRangeAt(0);
    } else if (sel) {
      return sel;
    } else false;
  };

  window.customElements.define(HaxStore.tag, HaxStore);
});