define(["exports", "meta", "../../lit/index.js", "../es-global-bridge/es-global-bridge.js", "../simple-icon/lib/simple-icon-lite.js", "../simple-icon/lib/simple-icons.js", "./lib/md5.min.js"], function (_exports, meta, _index, _esGlobalBridge, _simpleIconLite, _simpleIcons, md5) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PaperAvatar = void 0;
  meta = _interopRequireWildcard(meta);
  md5 = _interopRequireWildcard(md5);

  var _templateObject_abdee8508e0011ed99ce491205e67b1d, _templateObject2_abdee8508e0011ed99ce491205e67b1d, _templateObject3_abdee8508e0011ed99ce491205e67b1d, _templateObject4_abdee8508e0011ed99ce491205e67b1d, _templateObject5_abdee8508e0011ed99ce491205e67b1d;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
  `paper-avatar`
  User avatar in material style
  
  ### Styling
  Custom property | Description | Default
  ----------------|-------------|----------
  `--paper-avatar-width` | Size (width and height) of the avatar image | 40px
  `--paper-avatar-color` | Background color of the avatar image | `--paper-avatar-calculated-bg`
  `--paper-avatar-text-color` | Text color of the avatar image | #fff
  `--paper-avatar-calculated-bg` | Do NOT use. Thi is an automatically set variable that can be overriden `--paper-avatar-color` | #000
  
  
  * @demo demo/index.html 
  */
  var PaperAvatar = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(PaperAvatar, _LitElement);

    var _super = _createSuper(PaperAvatar);

    /**
     * HTMLElement specification
     */
    function PaperAvatar() {
      var _this;

      babelHelpers.classCallCheck(this, PaperAvatar);
      _this = _super.call(this);
      _this.dark = false;
      _this.label = null;
      _this.src = null;
      _this.jdenticonExists = false;
      _this.twoChars = false;
      _this.jdenticon = false;
      return _this;
    }
    /**
     * LitElement specific property update life cycle
     */


    babelHelpers.createClass(PaperAvatar, [{
      key: "render",
      value:
      /**
       * LitElement render method
       */
      function render() {
        return (0, _index.html)(_templateObject_abdee8508e0011ed99ce491205e67b1d || (_templateObject_abdee8508e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n      <svg id=\"jdenticon\" width=\"40\" height=\"40\"><slot></slot></svg>\n      <div\n        id=\"label\"\n        title=\"", "\"\n        ?hidden=\"", "\"\n      >\n        ", "\n      </div>\n      ", "\n    "])), this.label, this.jdenticonExists && this.jdenticon, this.icon ? (0, _index.html)(_templateObject2_abdee8508e0011ed99ce491205e67b1d || (_templateObject2_abdee8508e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral([" <simple-icon-lite icon=\"", "\"></simple-icon-lite> "])), this.icon) : (0, _index.html)(_templateObject3_abdee8508e0011ed99ce491205e67b1d || (_templateObject3_abdee8508e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n              <span ?two-chars=\"", "\"\n                >", "\n              </span>\n            "])), this.twoChars, this._label(this.label)), this.src ? (0, _index.html)(_templateObject4_abdee8508e0011ed99ce491205e67b1d || (_templateObject4_abdee8508e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n            <img\n              id=\"img\"\n              loading=\"lazy\"\n              .src=\"", "\"\n              @load=\"", "\"\n              @error=\"", "\"\n              aria-hidden=\"true\"\n            />\n          "])), this.src || "", this._onImgLoad, this._onImgError) : "");
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "label") {
            _this2._observerLabel(_this2[propName]);
          }
        });
      }
      /**
       * LitElement / popular library convention
       */

    }, {
      key: "_observerLabel",
      value:
      /**
       * Generate the correct label from change with optional jdenticon md5 hash
       */
      function _observerLabel(label) {
        if (label) {
          if (this.jdenticonExists && this.jdenticon) {
            this.shadowRoot.querySelector("#label").hidden = true;
            window.jdenticon.update(this.shadowRoot.querySelector("#jdenticon"), window.md5(label));
          }

          if (!this.accentColor) this.style.setProperty("--paper-avatar-calculated-bg", this._parseColor(label));
        }
      }
      /**
       * LitElement life cycle - shadowDom / properties mapped
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        var location = new URL("./lib/jdenticon-1.4.0.min.js", meta.url).href;
        window.addEventListener("es-bridge-jdenticon-loaded", this._jdenticonLoaded.bind(this));
        window.ESGlobalBridge.requestAvailability().load("jdenticon", location);
      }
      /**
       * HTMLElement life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("es-bridge-jdenticon-loaded", this._jdenticonLoaded.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(PaperAvatar.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * Callback once we know that the jdenticon library is globally loaded.
       */

    }, {
      key: "_jdenticonLoaded",
      value: function _jdenticonLoaded(e) {
        this.jdenticonExists = true;

        this._observerLabel(this.label);
      }
      /**
       * convert label in context
       */

    }, {
      key: "_label",
      value: function _label(label) {
        if (!label) return "";

        if (this.twoChars) {
          if (this.label.indexOf(" ") > -1) {
            var matches = this.label.match(/\b(\w)/g);
            return matches[0] + matches[1];
          } else {
            return label.substring(0, 2);
          }
        }

        return label.charAt(0);
      }
    }, {
      key: "_onImgLoad",
      value: function _onImgLoad(e) {
        e.currentTarget.hidden = false;
      }
    }, {
      key: "_onImgError",
      value: function _onImgError(e) {
        e.currentTarget.hidden = true;
      }
    }, {
      key: "_parseColor",
      value: function _parseColor(label) {
        var colors = this.colors ? this.colors : ["#F44336", "#E91E63", "#9C27B0", "#673AB7", "#3F51B5", "#2196F3", "#03A9F4", "#00BCD4", "#795548", "#009688", "#4CAF50", "#8BC34A", "#CDDC39", "#FFEB3B", "#FFC107", "#FF9800", "#FF5722", "#9E9E9E", "#607D8B"];
        var hash = 0;

        for (var a = 0; a < label.length; a++) {
          hash += label.charCodeAt(a) << 5;
        }

        if (hash >= colors.length) return colors[hash % colors.length];
        return colors[hash];
      }
    }], [{
      key: "styles",
      get:
      /**
       * LitElement style method
       */
      function get() {
        return [(0, _index.css)(_templateObject5_abdee8508e0011ed99ce491205e67b1d || (_templateObject5_abdee8508e0011ed99ce491205e67b1d = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: inline-block;\n          box-sizing: border-box;\n          position: relative;\n          width: var(--paper-avatar-width, 40px);\n          height: var(--paper-avatar-width, 40px);\n          border-radius: 50%;\n          cursor: default;\n          -webkit-user-select: none;\n          -moz-user-select: none;\n          -ms-user-select: none;\n          user-select: none;\n          color: var(--paper-avatar-text-color, #ffffff);\n          background-color: var(\n            --paper-avatar-color,\n            var(--paper-avatar-calculated-bg, #000)\n          );\n        }\n\n        :host > * {\n          pointer-events: none;\n        }\n        img {\n          width: var(--paper-avatar-width, 40px);\n          height: var(--paper-avatar-width, 40px);\n        }\n        #label,\n        #img,\n        #jdenticon {\n          position: absolute;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          width: 100%;\n          height: 100%;\n          border-radius: 50%;\n        }\n        #label {\n          overflow: hidden;\n          display: -ms-flexbox;\n          display: -webkit-flex;\n          display: flex;\n          -webkit-flex-direction: row;\n          -ms-flex-direction: row;\n          flex-direction: row;\n          -webkit-align-items: center;\n          -ms-flex-align: center;\n          align-items: center;\n          --simple-icon-width: calc(var(--paper-avatar-width, 40px) * 0.9);\n          --simple-icon-height: calc(var(--paper-avatar-width, 40px) * 0.9);\n        }\n        #label[hidden] {\n          display: none;\n        }\n        #label span {\n          display: block;\n          width: 100%;\n          font-weight: 400;\n          color: var(--paper-avatar-text-color, #ffffff);\n          text-transform: capitalize;\n          font-family: \"Roboto\", \"Noto\", sans-serif;\n          -webkit-font-smoothing: antialiased;\n          text-align: center;\n          font-size: calc(var(--paper-avatar-width, 40px) * 0.7);\n          opacity: 0.8;\n        }\n        #label span[two-chars] {\n          font-size: calc(var(--paper-avatar-width, 40px) * 0.5);\n        }\n        #label simple-icon-lite {\n          margin: 0 auto;\n          opacity: 0.8;\n        }\n        #jdenticon {\n          width: var(--paper-avatar-width, 40px);\n          height: var(--paper-avatar-width, 40px);\n        }\n        #jdenticon * {\n          fill: var(--paper-avatar-text-color, #ffffff);\n          opacity: 0.8;\n        }\n        :host #jdenticon ::slotted(*) {\n          fill: var(--paper-avatar-text-color, #ffffff);\n          opacity: 0.8;\n        }\n      "])))];
      }
      /**
       * A convention our team uses
       */

    }, {
      key: "tag",
      get: function get() {
        return "paper-avatar";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Optional simple-icon
           */
          accentColor: {
            type: String,
            attribute: "accent-color"
          },

          /**
           * dark mode
           */
          dark: {
            type: Boolean
          },

          /**
           * Optional simple-icon
           */
          icon: {
            type: String
          },

          /**
           * Image address or base64
           */
          src: {
            type: String
          },

          /**
           *	Label with username
           */
          label: {
            type: String
          },

          /**
           * Ensure we can support jdenticon before invoking it
           */
          jdenticonExists: {
            type: Boolean
          },

          /**
           * Show two chars in avatar
           */
          twoChars: {
            type: Boolean,
            attribute: "two-chars"
          },

          /**
           * Array of colors for avatar background
           */
          colors: {
            type: Array
          },

          /**
           * Set true if you want use a jdenticon avatar
           */
          jdenticon: {
            type: Boolean
          }
        };
      }
    }]);
    return PaperAvatar;
  }(_index.LitElement);

  _exports.PaperAvatar = PaperAvatar;
  customElements.define(PaperAvatar.tag, PaperAvatar);
});